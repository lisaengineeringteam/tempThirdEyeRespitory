"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["src_components_chart_statistics-chart_ts"],{

/***/ "./src/components/chart/statistics-chart.ts":
/*!**************************************************!*\
  !*** ./src/components/chart/statistics-chart.ts ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/decorators */ \"./node_modules/lit/decorators.js\");\n/* harmony import */ var _common_color_colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/color/colors */ \"./src/common/color/colors.ts\");\n/* harmony import */ var _common_config_is_component_loaded__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/config/is_component_loaded */ \"./src/common/config/is_component_loaded.ts\");\n/* harmony import */ var _common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/entity/compute_state_name */ \"./src/common/entity/compute_state_name.ts\");\n/* harmony import */ var _common_number_format_number__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/number/format_number */ \"./src/common/number/format_number.ts\");\n/* harmony import */ var _data_history__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../data/history */ \"./src/data/history.ts\");\n/* harmony import */ var _ha_chart_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ha-chart-base */ \"./src/components/chart/ha-chart-base.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_data_history__WEBPACK_IMPORTED_MODULE_6__]);\n_data_history__WEBPACK_IMPORTED_MODULE_6__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function () { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function (O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function (F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function (receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function (elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function (element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function (element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function (elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function (element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function (elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function (elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function (elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function (elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function (obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function (constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function (obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function (other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\nlet StatisticsChart = _decorate([(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.customElement)(\"statistics-chart\")], function (_initialize, _LitElement) {\n  class StatisticsChart extends _LitElement {\n    constructor(...args) {\n      super(...args);\n\n      _initialize(this);\n    }\n\n  }\n\n  return {\n    F: StatisticsChart,\n    d: [{\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"statisticsData\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        type: Array\n      })],\n      key: \"statisticIds\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)()],\n      key: \"names\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)()],\n      key: \"unit\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"endTime\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        type: Array\n      })],\n      key: \"statTypes\",\n\n      value() {\n        return [\"sum\", \"min\", \"mean\", \"max\"];\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)()],\n      key: \"chartType\",\n\n      value() {\n        return \"line\";\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        type: Boolean\n      })],\n      key: \"isLoadingData\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.state)()],\n      key: \"_chartData\",\n\n      value() {\n        return {\n          datasets: []\n        };\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.state)()],\n      key: \"_chartOptions\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_computedStyle\",\n      value: void 0\n    }, {\n      kind: \"method\",\n      key: \"shouldUpdate\",\n      value: function shouldUpdate(changedProps) {\n        return changedProps.size > 1 || !changedProps.has(\"hass\");\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        if (!this.hasUpdated) {\n          this._createOptions();\n        }\n\n        if (changedProps.has(\"statisticsData\") || changedProps.has(\"statTypes\")) {\n          this._generateData();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"firstUpdated\",\n      value: function firstUpdated() {\n        this._computedStyle = getComputedStyle(this);\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        if (!(0,_common_config_is_component_loaded__WEBPACK_IMPORTED_MODULE_3__.isComponentLoaded)(this.hass, \"history\")) {\n          return lit__WEBPACK_IMPORTED_MODULE_0__.html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.history_disabled\")}\n      </div>`;\n        }\n\n        if (this.isLoadingData && !this.statisticsData) {\n          return lit__WEBPACK_IMPORTED_MODULE_0__.html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.statistics_charts.loading_statistics\")}\n      </div>`;\n        }\n\n        if (!this.statisticsData || !Object.keys(this.statisticsData).length) {\n          return lit__WEBPACK_IMPORTED_MODULE_0__.html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.statistics_charts.no_statistics_found\")}\n      </div>`;\n        }\n\n        return lit__WEBPACK_IMPORTED_MODULE_0__.html`\n      <ha-chart-base\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .chartType=${this.chartType}\n      ></ha-chart-base>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_createOptions\",\n      value: function _createOptions() {\n        this._chartOptions = {\n          parsing: false,\n          animation: false,\n          scales: {\n            x: {\n              type: \"time\",\n              adapters: {\n                date: {\n                  locale: this.hass.locale\n                }\n              },\n              ticks: {\n                maxRotation: 0,\n                sampleSize: 5,\n                autoSkipPadding: 20,\n                major: {\n                  enabled: true\n                },\n                font: context => context.tick && context.tick.major ? {\n                  weight: \"bold\"\n                } : {}\n              },\n              time: {\n                tooltipFormat: \"datetime\"\n              }\n            },\n            y: {\n              beginAtZero: false,\n              ticks: {\n                maxTicksLimit: 7\n              },\n              title: {\n                display: this.unit,\n                text: this.unit\n              }\n            }\n          },\n          plugins: {\n            tooltip: {\n              mode: \"nearest\",\n              callbacks: {\n                label: context => `${context.dataset.label}: ${(0,_common_number_format_number__WEBPACK_IMPORTED_MODULE_5__.formatNumber)(context.parsed.y, this.hass.locale)} ${// @ts-ignore\n                context.dataset.unit || \"\"}`\n              }\n            },\n            filler: {\n              propagate: true\n            },\n            legend: {\n              display: true,\n              labels: {\n                usePointStyle: true\n              }\n            }\n          },\n          hover: {\n            mode: \"nearest\"\n          },\n          elements: {\n            line: {\n              tension: 0.4,\n              borderWidth: 1.5\n            },\n            bar: {\n              borderWidth: 1.5,\n              borderRadius: 4\n            },\n            point: {\n              hitRadius: 5\n            }\n          },\n          // @ts-expect-error\n          locale: (0,_common_number_format_number__WEBPACK_IMPORTED_MODULE_5__.numberFormatToLocale)(this.hass.locale)\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"_getStatisticIds\",\n      value: async function _getStatisticIds() {\n        this.statisticIds = await (0,_data_history__WEBPACK_IMPORTED_MODULE_6__.getStatisticIds)(this.hass);\n      }\n    }, {\n      kind: \"method\",\n      key: \"_generateData\",\n      value: async function _generateData() {\n        if (!this.statisticsData) {\n          return;\n        }\n\n        if (!this.statisticIds) {\n          await this._getStatisticIds();\n        }\n\n        let colorIndex = 0;\n        const statisticsData = Object.values(this.statisticsData);\n        const totalDataSets = [];\n        let endTime;\n\n        if (statisticsData.length === 0) {\n          return;\n        }\n\n        endTime = this.endTime || // Get the highest date from the last date of each statistic\n        new Date(Math.max(...statisticsData.map(stats => new Date(stats[stats.length - 1].start).getTime())));\n\n        if (endTime > new Date()) {\n          endTime = new Date();\n        }\n\n        let unit;\n        const names = this.names || {};\n        statisticsData.forEach(stats => {\n          const firstStat = stats[0];\n          let name = names[firstStat.statistic_id];\n\n          if (!name) {\n            const entityState = this.hass.states[firstStat.statistic_id];\n\n            if (entityState) {\n              name = (0,_common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_4__.computeStateName)(entityState);\n            } else {\n              name = firstStat.statistic_id;\n            }\n          }\n\n          const meta = this.statisticIds.find(stat => stat.statistic_id === firstStat.statistic_id);\n\n          if (!this.unit) {\n            if (unit === undefined) {\n              unit = meta === null || meta === void 0 ? void 0 : meta.unit_of_measurement;\n            } else if (unit !== (meta === null || meta === void 0 ? void 0 : meta.unit_of_measurement)) {\n              unit = null;\n            }\n          } // array containing [value1, value2, etc]\n\n\n          let prevValues = null; // The datasets for the current statistic\n\n          const statDataSets = [];\n\n          const pushData = (timestamp, dataValues) => {\n            if (!dataValues) return;\n\n            if (timestamp > endTime) {\n              // Drop data points that are after the requested endTime. This could happen if\n              // endTime is \"now\" and client time is not in sync with server time.\n              return;\n            }\n\n            statDataSets.forEach((d, i) => {\n              if (dataValues[i] === null && prevValues && prevValues[i] !== null) {\n                // null data values show up as gaps in the chart.\n                // If the current value for the dataset is null and the previous\n                // value of the data set is not null, then add an 'end' point\n                // to the chart for the previous value. Otherwise the gap will\n                // be too big. It will go from the start of the previous data\n                // value until the start of the next data value.\n                d.data.push({\n                  x: timestamp.getTime(),\n                  y: prevValues[i]\n                });\n              }\n\n              d.data.push({\n                x: timestamp.getTime(),\n                y: dataValues[i]\n              });\n            });\n            prevValues = dataValues;\n          };\n\n          const color = (0,_common_color_colors__WEBPACK_IMPORTED_MODULE_2__.getGraphColorByIndex)(colorIndex, this._computedStyle);\n          colorIndex++;\n          const statTypes = [];\n          const drawBands = this.statTypes.includes(\"mean\") && (0,_data_history__WEBPACK_IMPORTED_MODULE_6__.statisticsHaveType)(stats, \"mean\");\n          const sortedTypes = drawBands ? [...this.statTypes].sort((a, b) => {\n            if (a === \"min\" || b === \"max\") {\n              return -1;\n            }\n\n            if (a === \"max\" || b === \"min\") {\n              return +1;\n            }\n\n            return 0;\n          }) : this.statTypes;\n          sortedTypes.forEach(type => {\n            if ((0,_data_history__WEBPACK_IMPORTED_MODULE_6__.statisticsHaveType)(stats, type)) {\n              const band = drawBands && (type === \"min\" || type === \"max\");\n              statTypes.push(type);\n              statDataSets.push({\n                label: `${name} (${this.hass.localize(`ui.components.statistics_charts.statistic_types.${type}`)})\n            `,\n                fill: drawBands ? type === \"min\" ? \"+1\" : type === \"max\" ? \"-1\" : false : false,\n                borderColor: band ? color + \"7F\" : color,\n                backgroundColor: band ? color + \"3F\" : color + \"7F\",\n                pointRadius: 0,\n                data: [],\n                // @ts-ignore\n                unit: meta === null || meta === void 0 ? void 0 : meta.unit_of_measurement,\n                band\n              });\n            }\n          });\n          let prevDate = null; // Process chart data.\n\n          let initVal = null;\n          let prevSum = null;\n          stats.forEach(stat => {\n            const date = new Date(stat.start);\n\n            if (prevDate === date) {\n              return;\n            }\n\n            prevDate = date;\n            const dataValues = [];\n            statTypes.forEach(type => {\n              let val;\n\n              if (type === \"sum\") {\n                if (initVal === null) {\n                  initVal = val = stat.state || 0;\n                  prevSum = stat.sum;\n                } else {\n                  val = initVal + ((stat.sum || 0) - prevSum);\n                }\n              } else {\n                val = stat[type];\n              }\n\n              dataValues.push(val !== null ? Math.round(val * 100) / 100 : null);\n            });\n            pushData(date, dataValues);\n          }); // Add an entry for final values\n\n          pushData(endTime, prevValues); // Concat two arrays\n\n          Array.prototype.push.apply(totalDataSets, statDataSets);\n        });\n\n        if (unit !== null) {\n          this._chartOptions = { ...this._chartOptions,\n            scales: { ...this._chartOptions.scales,\n              y: { ...this._chartOptions.scales.y,\n                title: {\n                  display: unit,\n                  text: unit\n                }\n              }\n            }\n          };\n        }\n\n        this._chartData = {\n          datasets: totalDataSets\n        };\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.css`\n      :host {\n        display: block;\n        min-height: 60px;\n      }\n      .info {\n        text-align: center;\n        line-height: 60px;\n        color: var(--secondary-text-color);\n      }\n    `;\n      }\n    }]\n  };\n}, lit__WEBPACK_IMPORTED_MODULE_0__.LitElement);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jaGFydC9zdGF0aXN0aWNzLWNoYXJ0LnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFRQTs7QUFHQTtBQURBO0FBQ0E7QUFBQTs7QUFBQTtBQUFBOztBQUFBOzs7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7OztBQUVBO0FBQUE7QUFBQTs7Ozs7QUFFQTtBQUFBO0FBQUE7Ozs7O0FBRUE7Ozs7QUFBQTs7Ozs7QUFFQTs7Ozs7QUFFQTtBQUFBO0FBQUE7Ozs7O0FBRUE7QUFBQTtBQUFBOzs7O0FBQUE7Ozs7O0FBT0E7Ozs7QUFBQTs7Ozs7QUFFQTtBQUFBO0FBQUE7Ozs7QUFBQTs7Ozs7QUFFQTs7OztBQUFBO0FBQUE7QUFBQTs7Ozs7QUFFQTs7Ozs7Ozs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUVBO0FBQUE7QUFUQTtBQVlBO0FBQ0E7QUFEQTtBQW5CQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQXhCQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFQQTtBQUZBO0FBYUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBakJBO0FBd0JBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQU5BO0FBVUE7QUFDQTtBQTVFQTtBQThFQTs7OztBQUVBO0FBQ0E7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTs7QUFRQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBR0E7O0FBRUE7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFGQTtBQUZBO0FBRkE7QUFVQTs7QUFFQTtBQUNBO0FBREE7QUFHQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBL1dBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9zcmMvY29tcG9uZW50cy9jaGFydC9zdGF0aXN0aWNzLWNoYXJ0LnRzP2JjZTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBDaGFydERhdGEsXG4gIENoYXJ0RGF0YXNldCxcbiAgQ2hhcnRPcHRpb25zLFxuICBDaGFydFR5cGUsXG59IGZyb20gXCJjaGFydC5qc1wiO1xuaW1wb3J0IHtcbiAgY3NzLFxuICBDU1NSZXN1bHRHcm91cCxcbiAgaHRtbCxcbiAgTGl0RWxlbWVudCxcbiAgUHJvcGVydHlWYWx1ZXMsXG4gIFRlbXBsYXRlUmVzdWx0LFxufSBmcm9tIFwibGl0XCI7XG5pbXBvcnQgeyBjdXN0b21FbGVtZW50LCBwcm9wZXJ0eSwgc3RhdGUgfSBmcm9tIFwibGl0L2RlY29yYXRvcnNcIjtcbmltcG9ydCB7IGdldEdyYXBoQ29sb3JCeUluZGV4IH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9jb2xvci9jb2xvcnNcIjtcbmltcG9ydCB7IGlzQ29tcG9uZW50TG9hZGVkIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9jb25maWcvaXNfY29tcG9uZW50X2xvYWRlZFwiO1xuaW1wb3J0IHsgY29tcHV0ZVN0YXRlTmFtZSB9IGZyb20gXCIuLi8uLi9jb21tb24vZW50aXR5L2NvbXB1dGVfc3RhdGVfbmFtZVwiO1xuaW1wb3J0IHtcbiAgZm9ybWF0TnVtYmVyLFxuICBudW1iZXJGb3JtYXRUb0xvY2FsZSxcbn0gZnJvbSBcIi4uLy4uL2NvbW1vbi9udW1iZXIvZm9ybWF0X251bWJlclwiO1xuaW1wb3J0IHtcbiAgZ2V0U3RhdGlzdGljSWRzLFxuICBTdGF0aXN0aWNzLFxuICBzdGF0aXN0aWNzSGF2ZVR5cGUsXG4gIFN0YXRpc3RpY3NNZXRhRGF0YSxcbiAgU3RhdGlzdGljVHlwZSxcbn0gZnJvbSBcIi4uLy4uL2RhdGEvaGlzdG9yeVwiO1xuaW1wb3J0IHR5cGUgeyBIb21lQXNzaXN0YW50IH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgXCIuL2hhLWNoYXJ0LWJhc2VcIjtcblxuQGN1c3RvbUVsZW1lbnQoXCJzdGF0aXN0aWNzLWNoYXJ0XCIpXG5jbGFzcyBTdGF0aXN0aWNzQ2hhcnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcbiAgQHByb3BlcnR5KHsgYXR0cmlidXRlOiBmYWxzZSB9KSBwdWJsaWMgaGFzcyE6IEhvbWVBc3Npc3RhbnQ7XG5cbiAgQHByb3BlcnR5KHsgYXR0cmlidXRlOiBmYWxzZSB9KSBwdWJsaWMgc3RhdGlzdGljc0RhdGEhOiBTdGF0aXN0aWNzO1xuXG4gIEBwcm9wZXJ0eSh7IHR5cGU6IEFycmF5IH0pIHB1YmxpYyBzdGF0aXN0aWNJZHM/OiBTdGF0aXN0aWNzTWV0YURhdGFbXTtcblxuICBAcHJvcGVydHkoKSBwdWJsaWMgbmFtZXM6IGJvb2xlYW4gfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0gZmFsc2U7XG5cbiAgQHByb3BlcnR5KCkgcHVibGljIHVuaXQ/OiBzdHJpbmc7XG5cbiAgQHByb3BlcnR5KHsgYXR0cmlidXRlOiBmYWxzZSB9KSBwdWJsaWMgZW5kVGltZT86IERhdGU7XG5cbiAgQHByb3BlcnR5KHsgdHlwZTogQXJyYXkgfSkgcHVibGljIHN0YXRUeXBlczogQXJyYXk8U3RhdGlzdGljVHlwZT4gPSBbXG4gICAgXCJzdW1cIixcbiAgICBcIm1pblwiLFxuICAgIFwibWVhblwiLFxuICAgIFwibWF4XCIsXG4gIF07XG5cbiAgQHByb3BlcnR5KCkgcHVibGljIGNoYXJ0VHlwZTogQ2hhcnRUeXBlID0gXCJsaW5lXCI7XG5cbiAgQHByb3BlcnR5KHsgdHlwZTogQm9vbGVhbiB9KSBwdWJsaWMgaXNMb2FkaW5nRGF0YSA9IGZhbHNlO1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX2NoYXJ0RGF0YTogQ2hhcnREYXRhID0geyBkYXRhc2V0czogW10gfTtcblxuICBAc3RhdGUoKSBwcml2YXRlIF9jaGFydE9wdGlvbnM/OiBDaGFydE9wdGlvbnM7XG5cbiAgcHJpdmF0ZSBfY29tcHV0ZWRTdHlsZT86IENTU1N0eWxlRGVjbGFyYXRpb247XG5cbiAgcHJvdGVjdGVkIHNob3VsZFVwZGF0ZShjaGFuZ2VkUHJvcHM6IFByb3BlcnR5VmFsdWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGNoYW5nZWRQcm9wcy5zaXplID4gMSB8fCAhY2hhbmdlZFByb3BzLmhhcyhcImhhc3NcIik7XG4gIH1cblxuICBwdWJsaWMgd2lsbFVwZGF0ZShjaGFuZ2VkUHJvcHM6IFByb3BlcnR5VmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmhhc1VwZGF0ZWQpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZU9wdGlvbnMoKTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZWRQcm9wcy5oYXMoXCJzdGF0aXN0aWNzRGF0YVwiKSB8fCBjaGFuZ2VkUHJvcHMuaGFzKFwic3RhdFR5cGVzXCIpKSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZURhdGEoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZmlyc3RVcGRhdGVkKCkge1xuICAgIHRoaXMuX2NvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlbmRlcigpOiBUZW1wbGF0ZVJlc3VsdCB7XG4gICAgaWYgKCFpc0NvbXBvbmVudExvYWRlZCh0aGlzLmhhc3MsIFwiaGlzdG9yeVwiKSkge1xuICAgICAgcmV0dXJuIGh0bWxgPGRpdiBjbGFzcz1cImluZm9cIj5cbiAgICAgICAgJHt0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jb21wb25lbnRzLmhpc3RvcnlfY2hhcnRzLmhpc3RvcnlfZGlzYWJsZWRcIil9XG4gICAgICA8L2Rpdj5gO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTG9hZGluZ0RhdGEgJiYgIXRoaXMuc3RhdGlzdGljc0RhdGEpIHtcbiAgICAgIHJldHVybiBodG1sYDxkaXYgY2xhc3M9XCJpbmZvXCI+XG4gICAgICAgICR7dGhpcy5oYXNzLmxvY2FsaXplKFxuICAgICAgICAgIFwidWkuY29tcG9uZW50cy5zdGF0aXN0aWNzX2NoYXJ0cy5sb2FkaW5nX3N0YXRpc3RpY3NcIlxuICAgICAgICApfVxuICAgICAgPC9kaXY+YDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3RhdGlzdGljc0RhdGEgfHwgIU9iamVjdC5rZXlzKHRoaXMuc3RhdGlzdGljc0RhdGEpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGh0bWxgPGRpdiBjbGFzcz1cImluZm9cIj5cbiAgICAgICAgJHt0aGlzLmhhc3MubG9jYWxpemUoXG4gICAgICAgICAgXCJ1aS5jb21wb25lbnRzLnN0YXRpc3RpY3NfY2hhcnRzLm5vX3N0YXRpc3RpY3NfZm91bmRcIlxuICAgICAgICApfVxuICAgICAgPC9kaXY+YDtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxoYS1jaGFydC1iYXNlXG4gICAgICAgIC5kYXRhPSR7dGhpcy5fY2hhcnREYXRhfVxuICAgICAgICAub3B0aW9ucz0ke3RoaXMuX2NoYXJ0T3B0aW9uc31cbiAgICAgICAgLmNoYXJ0VHlwZT0ke3RoaXMuY2hhcnRUeXBlfVxuICAgICAgPjwvaGEtY2hhcnQtYmFzZT5cbiAgICBgO1xuICB9XG5cbiAgcHJpdmF0ZSBfY3JlYXRlT3B0aW9ucygpIHtcbiAgICB0aGlzLl9jaGFydE9wdGlvbnMgPSB7XG4gICAgICBwYXJzaW5nOiBmYWxzZSxcbiAgICAgIGFuaW1hdGlvbjogZmFsc2UsXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIHR5cGU6IFwidGltZVwiLFxuICAgICAgICAgIGFkYXB0ZXJzOiB7XG4gICAgICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICAgIGxvY2FsZTogdGhpcy5oYXNzLmxvY2FsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgbWF4Um90YXRpb246IDAsXG4gICAgICAgICAgICBzYW1wbGVTaXplOiA1LFxuICAgICAgICAgICAgYXV0b1NraXBQYWRkaW5nOiAyMCxcbiAgICAgICAgICAgIG1ham9yOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9udDogKGNvbnRleHQpID0+XG4gICAgICAgICAgICAgIGNvbnRleHQudGljayAmJiBjb250ZXh0LnRpY2subWFqb3JcbiAgICAgICAgICAgICAgICA/ICh7IHdlaWdodDogXCJib2xkXCIgfSBhcyBhbnkpXG4gICAgICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpbWU6IHtcbiAgICAgICAgICAgIHRvb2x0aXBGb3JtYXQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgYmVnaW5BdFplcm86IGZhbHNlLFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBtYXhUaWNrc0xpbWl0OiA3LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRoaXMudW5pdCxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudW5pdCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIG1vZGU6IFwibmVhcmVzdFwiLFxuICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgbGFiZWw6IChjb250ZXh0KSA9PlxuICAgICAgICAgICAgICBgJHtjb250ZXh0LmRhdGFzZXQubGFiZWx9OiAke2Zvcm1hdE51bWJlcihcbiAgICAgICAgICAgICAgICBjb250ZXh0LnBhcnNlZC55LFxuICAgICAgICAgICAgICAgIHRoaXMuaGFzcy5sb2NhbGVcbiAgICAgICAgICAgICAgKX0gJHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29udGV4dC5kYXRhc2V0LnVuaXQgfHwgXCJcIlxuICAgICAgICAgICAgICB9YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBmaWxsZXI6IHtcbiAgICAgICAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICB1c2VQb2ludFN0eWxlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgbW9kZTogXCJuZWFyZXN0XCIsXG4gICAgICB9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIHRlbnNpb246IDAuNCxcbiAgICAgICAgICBib3JkZXJXaWR0aDogMS41LFxuICAgICAgICB9LFxuICAgICAgICBiYXI6IHsgYm9yZGVyV2lkdGg6IDEuNSwgYm9yZGVyUmFkaXVzOiA0IH0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgaGl0UmFkaXVzOiA1LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGxvY2FsZTogbnVtYmVyRm9ybWF0VG9Mb2NhbGUodGhpcy5oYXNzLmxvY2FsZSksXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2dldFN0YXRpc3RpY0lkcygpIHtcbiAgICB0aGlzLnN0YXRpc3RpY0lkcyA9IGF3YWl0IGdldFN0YXRpc3RpY0lkcyh0aGlzLmhhc3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZ2VuZXJhdGVEYXRhKCkge1xuICAgIGlmICghdGhpcy5zdGF0aXN0aWNzRGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGF0aXN0aWNJZHMpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2dldFN0YXRpc3RpY0lkcygpO1xuICAgIH1cblxuICAgIGxldCBjb2xvckluZGV4ID0gMDtcbiAgICBjb25zdCBzdGF0aXN0aWNzRGF0YSA9IE9iamVjdC52YWx1ZXModGhpcy5zdGF0aXN0aWNzRGF0YSk7XG4gICAgY29uc3QgdG90YWxEYXRhU2V0czogQ2hhcnREYXRhc2V0PFwibGluZVwiPltdID0gW107XG4gICAgbGV0IGVuZFRpbWU6IERhdGU7XG5cbiAgICBpZiAoc3RhdGlzdGljc0RhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZW5kVGltZSA9XG4gICAgICB0aGlzLmVuZFRpbWUgfHxcbiAgICAgIC8vIEdldCB0aGUgaGlnaGVzdCBkYXRlIGZyb20gdGhlIGxhc3QgZGF0ZSBvZiBlYWNoIHN0YXRpc3RpY1xuICAgICAgbmV3IERhdGUoXG4gICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgIC4uLnN0YXRpc3RpY3NEYXRhLm1hcCgoc3RhdHMpID0+XG4gICAgICAgICAgICBuZXcgRGF0ZShzdGF0c1tzdGF0cy5sZW5ndGggLSAxXS5zdGFydCkuZ2V0VGltZSgpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgaWYgKGVuZFRpbWUgPiBuZXcgRGF0ZSgpKSB7XG4gICAgICBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICB9XG5cbiAgICBsZXQgdW5pdDogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbDtcblxuICAgIGNvbnN0IG5hbWVzID0gdGhpcy5uYW1lcyB8fCB7fTtcbiAgICBzdGF0aXN0aWNzRGF0YS5mb3JFYWNoKChzdGF0cykgPT4ge1xuICAgICAgY29uc3QgZmlyc3RTdGF0ID0gc3RhdHNbMF07XG4gICAgICBsZXQgbmFtZSA9IG5hbWVzW2ZpcnN0U3RhdC5zdGF0aXN0aWNfaWRdO1xuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIGNvbnN0IGVudGl0eVN0YXRlID0gdGhpcy5oYXNzLnN0YXRlc1tmaXJzdFN0YXQuc3RhdGlzdGljX2lkXTtcbiAgICAgICAgaWYgKGVudGl0eVN0YXRlKSB7XG4gICAgICAgICAgbmFtZSA9IGNvbXB1dGVTdGF0ZU5hbWUoZW50aXR5U3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWUgPSBmaXJzdFN0YXQuc3RhdGlzdGljX2lkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLnN0YXRpc3RpY0lkcyEuZmluZChcbiAgICAgICAgKHN0YXQpID0+IHN0YXQuc3RhdGlzdGljX2lkID09PSBmaXJzdFN0YXQuc3RhdGlzdGljX2lkXG4gICAgICApO1xuXG4gICAgICBpZiAoIXRoaXMudW5pdCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdW5pdCA9IG1ldGE/LnVuaXRfb2ZfbWVhc3VyZW1lbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodW5pdCAhPT0gbWV0YT8udW5pdF9vZl9tZWFzdXJlbWVudCkge1xuICAgICAgICAgIHVuaXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFycmF5IGNvbnRhaW5pbmcgW3ZhbHVlMSwgdmFsdWUyLCBldGNdXG4gICAgICBsZXQgcHJldlZhbHVlczogQXJyYXk8bnVtYmVyIHwgbnVsbD4gfCBudWxsID0gbnVsbDtcblxuICAgICAgLy8gVGhlIGRhdGFzZXRzIGZvciB0aGUgY3VycmVudCBzdGF0aXN0aWNcbiAgICAgIGNvbnN0IHN0YXREYXRhU2V0czogQ2hhcnREYXRhc2V0PFwibGluZVwiPltdID0gW107XG5cbiAgICAgIGNvbnN0IHB1c2hEYXRhID0gKFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUsXG4gICAgICAgIGRhdGFWYWx1ZXM6IEFycmF5PG51bWJlciB8IG51bGw+IHwgbnVsbFxuICAgICAgKSA9PiB7XG4gICAgICAgIGlmICghZGF0YVZhbHVlcykgcmV0dXJuO1xuICAgICAgICBpZiAodGltZXN0YW1wID4gZW5kVGltZSkge1xuICAgICAgICAgIC8vIERyb3AgZGF0YSBwb2ludHMgdGhhdCBhcmUgYWZ0ZXIgdGhlIHJlcXVlc3RlZCBlbmRUaW1lLiBUaGlzIGNvdWxkIGhhcHBlbiBpZlxuICAgICAgICAgIC8vIGVuZFRpbWUgaXMgXCJub3dcIiBhbmQgY2xpZW50IHRpbWUgaXMgbm90IGluIHN5bmMgd2l0aCBzZXJ2ZXIgdGltZS5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdERhdGFTZXRzLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgICBpZiAoZGF0YVZhbHVlc1tpXSA9PT0gbnVsbCAmJiBwcmV2VmFsdWVzICYmIHByZXZWYWx1ZXNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG51bGwgZGF0YSB2YWx1ZXMgc2hvdyB1cCBhcyBnYXBzIGluIHRoZSBjaGFydC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHZhbHVlIGZvciB0aGUgZGF0YXNldCBpcyBudWxsIGFuZCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIHZhbHVlIG9mIHRoZSBkYXRhIHNldCBpcyBub3QgbnVsbCwgdGhlbiBhZGQgYW4gJ2VuZCcgcG9pbnRcbiAgICAgICAgICAgIC8vIHRvIHRoZSBjaGFydCBmb3IgdGhlIHByZXZpb3VzIHZhbHVlLiBPdGhlcndpc2UgdGhlIGdhcCB3aWxsXG4gICAgICAgICAgICAvLyBiZSB0b28gYmlnLiBJdCB3aWxsIGdvIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwcmV2aW91cyBkYXRhXG4gICAgICAgICAgICAvLyB2YWx1ZSB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgZGF0YSB2YWx1ZS5cbiAgICAgICAgICAgIGQuZGF0YS5wdXNoKHsgeDogdGltZXN0YW1wLmdldFRpbWUoKSwgeTogcHJldlZhbHVlc1tpXSEgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGQuZGF0YS5wdXNoKHsgeDogdGltZXN0YW1wLmdldFRpbWUoKSwgeTogZGF0YVZhbHVlc1tpXSEgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2VmFsdWVzID0gZGF0YVZhbHVlcztcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0R3JhcGhDb2xvckJ5SW5kZXgoY29sb3JJbmRleCwgdGhpcy5fY29tcHV0ZWRTdHlsZSEpO1xuICAgICAgY29sb3JJbmRleCsrO1xuXG4gICAgICBjb25zdCBzdGF0VHlwZXM6IHRoaXNbXCJzdGF0VHlwZXNcIl0gPSBbXTtcblxuICAgICAgY29uc3QgZHJhd0JhbmRzID1cbiAgICAgICAgdGhpcy5zdGF0VHlwZXMuaW5jbHVkZXMoXCJtZWFuXCIpICYmIHN0YXRpc3RpY3NIYXZlVHlwZShzdGF0cywgXCJtZWFuXCIpO1xuXG4gICAgICBjb25zdCBzb3J0ZWRUeXBlcyA9IGRyYXdCYW5kc1xuICAgICAgICA/IFsuLi50aGlzLnN0YXRUeXBlc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEgPT09IFwibWluXCIgfHwgYiA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYSA9PT0gXCJtYXhcIiB8fCBiID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiArMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0pXG4gICAgICAgIDogdGhpcy5zdGF0VHlwZXM7XG5cbiAgICAgIHNvcnRlZFR5cGVzLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgaWYgKHN0YXRpc3RpY3NIYXZlVHlwZShzdGF0cywgdHlwZSkpIHtcbiAgICAgICAgICBjb25zdCBiYW5kID0gZHJhd0JhbmRzICYmICh0eXBlID09PSBcIm1pblwiIHx8IHR5cGUgPT09IFwibWF4XCIpO1xuICAgICAgICAgIHN0YXRUeXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICAgIHN0YXREYXRhU2V0cy5wdXNoKHtcbiAgICAgICAgICAgIGxhYmVsOiBgJHtuYW1lfSAoJHt0aGlzLmhhc3MubG9jYWxpemUoXG4gICAgICAgICAgICAgIGB1aS5jb21wb25lbnRzLnN0YXRpc3RpY3NfY2hhcnRzLnN0YXRpc3RpY190eXBlcy4ke3R5cGV9YFxuICAgICAgICAgICAgKX0pXG4gICAgICAgICAgICBgLFxuICAgICAgICAgICAgZmlsbDogZHJhd0JhbmRzXG4gICAgICAgICAgICAgID8gdHlwZSA9PT0gXCJtaW5cIlxuICAgICAgICAgICAgICAgID8gXCIrMVwiXG4gICAgICAgICAgICAgICAgOiB0eXBlID09PSBcIm1heFwiXG4gICAgICAgICAgICAgICAgPyBcIi0xXCJcbiAgICAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogYmFuZCA/IGNvbG9yICsgXCI3RlwiIDogY29sb3IsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhbmQgPyBjb2xvciArIFwiM0ZcIiA6IGNvbG9yICsgXCI3RlwiLFxuICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDAsXG4gICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHVuaXQ6IG1ldGE/LnVuaXRfb2ZfbWVhc3VyZW1lbnQsXG4gICAgICAgICAgICBiYW5kLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbGV0IHByZXZEYXRlOiBEYXRlIHwgbnVsbCA9IG51bGw7XG4gICAgICAvLyBQcm9jZXNzIGNoYXJ0IGRhdGEuXG4gICAgICBsZXQgaW5pdFZhbDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICBsZXQgcHJldlN1bTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICBzdGF0cy5mb3JFYWNoKChzdGF0KSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShzdGF0LnN0YXJ0KTtcbiAgICAgICAgaWYgKHByZXZEYXRlID09PSBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByZXZEYXRlID0gZGF0ZTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlczogQXJyYXk8bnVtYmVyIHwgbnVsbD4gPSBbXTtcbiAgICAgICAgc3RhdFR5cGVzLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICBsZXQgdmFsOiBudW1iZXIgfCBudWxsO1xuICAgICAgICAgIGlmICh0eXBlID09PSBcInN1bVwiKSB7XG4gICAgICAgICAgICBpZiAoaW5pdFZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBpbml0VmFsID0gdmFsID0gc3RhdC5zdGF0ZSB8fCAwO1xuICAgICAgICAgICAgICBwcmV2U3VtID0gc3RhdC5zdW07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWwgPSBpbml0VmFsICsgKChzdGF0LnN1bSB8fCAwKSAtIHByZXZTdW0hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gc3RhdFt0eXBlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVZhbHVlcy5wdXNoKHZhbCAhPT0gbnVsbCA/IE1hdGgucm91bmQodmFsICogMTAwKSAvIDEwMCA6IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHVzaERhdGEoZGF0ZSwgZGF0YVZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGFuIGVudHJ5IGZvciBmaW5hbCB2YWx1ZXNcbiAgICAgIHB1c2hEYXRhKGVuZFRpbWUsIHByZXZWYWx1ZXMpO1xuXG4gICAgICAvLyBDb25jYXQgdHdvIGFycmF5c1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodG90YWxEYXRhU2V0cywgc3RhdERhdGFTZXRzKTtcbiAgICB9KTtcblxuICAgIGlmICh1bml0ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9jaGFydE9wdGlvbnMgPSB7XG4gICAgICAgIC4uLnRoaXMuX2NoYXJ0T3B0aW9ucyxcbiAgICAgICAgc2NhbGVzOiB7XG4gICAgICAgICAgLi4udGhpcy5fY2hhcnRPcHRpb25zIS5zY2FsZXMsXG4gICAgICAgICAgeToge1xuICAgICAgICAgICAgLi4uKHRoaXMuX2NoYXJ0T3B0aW9ucyEuc2NhbGVzIS55IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KSxcbiAgICAgICAgICAgIHRpdGxlOiB7IGRpc3BsYXk6IHVuaXQsIHRleHQ6IHVuaXQgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGFydERhdGEgPSB7XG4gICAgICBkYXRhc2V0czogdG90YWxEYXRhU2V0cyxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHlsZXMoKTogQ1NTUmVzdWx0R3JvdXAge1xuICAgIHJldHVybiBjc3NgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBtaW4taGVpZ2h0OiA2MHB4O1xuICAgICAgfVxuICAgICAgLmluZm8ge1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiA2MHB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tc2Vjb25kYXJ5LXRleHQtY29sb3IpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgSFRNTEVsZW1lbnRUYWdOYW1lTWFwIHtcbiAgICBcInN0YXRpc3RpY3MtY2hhcnRcIjogU3RhdGlzdGljc0NoYXJ0O1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/chart/statistics-chart.ts\n");

/***/ })

}]);