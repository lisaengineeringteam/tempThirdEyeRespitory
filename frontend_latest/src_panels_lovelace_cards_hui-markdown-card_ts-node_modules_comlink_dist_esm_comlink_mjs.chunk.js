"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["src_panels_lovelace_cards_hui-markdown-card_ts-node_modules_comlink_dist_esm_comlink_mjs"],{

/***/ "./src/data/ws-templates.ts":
/*!**********************************!*\
  !*** ./src/data/ws-templates.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"subscribeRenderTemplate\": () => (/* binding */ subscribeRenderTemplate)\n/* harmony export */ });\nconst subscribeRenderTemplate = (conn, onChange, params) => conn.subscribeMessage(msg => onChange(msg), {\n  type: \"render_template\",\n  ...params\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGF0YS93cy10ZW1wbGF0ZXMudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQWNBO0FBWUE7QUFDQTtBQUZBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9zcmMvZGF0YS93cy10ZW1wbGF0ZXMudHM/MzRjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25uZWN0aW9uLCBVbnN1YnNjcmliZUZ1bmMgfSBmcm9tIFwiaG9tZS1hc3Npc3RhbnQtanMtd2Vic29ja2V0XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyVGVtcGxhdGVSZXN1bHQge1xuICByZXN1bHQ6IHN0cmluZztcbiAgbGlzdGVuZXJzOiBUZW1wbGF0ZUxpc3RlbmVycztcbn1cblxuaW50ZXJmYWNlIFRlbXBsYXRlTGlzdGVuZXJzIHtcbiAgYWxsOiBib29sZWFuO1xuICBkb21haW5zOiBzdHJpbmdbXTtcbiAgZW50aXRpZXM6IHN0cmluZ1tdO1xuICB0aW1lOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3Qgc3Vic2NyaWJlUmVuZGVyVGVtcGxhdGUgPSAoXG4gIGNvbm46IENvbm5lY3Rpb24sXG4gIG9uQ2hhbmdlOiAocmVzdWx0OiBSZW5kZXJUZW1wbGF0ZVJlc3VsdCkgPT4gdm9pZCxcbiAgcGFyYW1zOiB7XG4gICAgdGVtcGxhdGU6IHN0cmluZztcbiAgICBlbnRpdHlfaWRzPzogc3RyaW5nIHwgc3RyaW5nW107XG4gICAgdmFyaWFibGVzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgdGltZW91dD86IG51bWJlcjtcbiAgICBzdHJpY3Q/OiBib29sZWFuO1xuICB9XG4pOiBQcm9taXNlPFVuc3Vic2NyaWJlRnVuYz4gPT5cbiAgY29ubi5zdWJzY3JpYmVNZXNzYWdlKChtc2c6IFJlbmRlclRlbXBsYXRlUmVzdWx0KSA9PiBvbkNoYW5nZShtc2cpLCB7XG4gICAgdHlwZTogXCJyZW5kZXJfdGVtcGxhdGVcIixcbiAgICAuLi5wYXJhbXMsXG4gIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/data/ws-templates.ts\n");

/***/ }),

/***/ "./src/panels/lovelace/cards/hui-markdown-card.ts":
/*!********************************************************!*\
  !*** ./src/panels/lovelace/cards/hui-markdown-card.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HuiMarkdownCard\": () => (/* binding */ HuiMarkdownCard)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/decorators */ \"./node_modules/lit/decorators.js\");\n/* harmony import */ var lit_directives_class_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/directives/class-map */ \"./node_modules/lit/directives/class-map.js\");\n/* harmony import */ var _common_dom_apply_themes_on_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/dom/apply_themes_on_element */ \"./src/common/dom/apply_themes_on_element.ts\");\n/* harmony import */ var _components_ha_card__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/ha-card */ \"./src/components/ha-card.ts\");\n/* harmony import */ var _components_ha_markdown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/ha-markdown */ \"./src/components/ha-markdown.ts\");\n/* harmony import */ var _data_ws_templates__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../data/ws-templates */ \"./src/data/ws-templates.ts\");\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function () { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function (O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function (F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function (receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function (elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function (element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function (element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function (elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function (element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function (elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function (elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function (elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function (elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function (obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function (constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function (obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function (other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\n\nlet HuiMarkdownCard = _decorate([(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.customElement)(\"hui-markdown-card\")], function (_initialize, _LitElement) {\n  class HuiMarkdownCard extends _LitElement {\n    constructor(...args) {\n      super(...args);\n\n      _initialize(this);\n    }\n\n  }\n\n  return {\n    F: HuiMarkdownCard,\n    d: [{\n      kind: \"method\",\n      static: true,\n      key: \"getConfigElement\",\n      value: async function getConfigElement() {\n        await Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_material_mwc-floating-label_mwc-floating-label-directive_js-node_modules-1dc920\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-textfield_mwc-textfield-base_js-node_modules_material_mwc-t-32f0d5\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-list_mwc-list-item-base_js-node_modules_material_mwc-list_m-ec3d2e\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-list_mwc-list_js\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-select_mwc-select-base_js-node_modules_material_mwc-select_-a6020b\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-menu_mwc-menu-surface_js\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-menu_mwc-menu_js\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-checkbox_mwc-checkbox-base_js-node_modules_material_mwc-che-43cf78\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-radio_mwc-radio-base_js-node_modules_material_mwc-radio_mwc-0c9c9b\"), __webpack_require__.e(\"vendors-node_modules_material_chips_dist_mdc_chips_min_css\"), __webpack_require__.e(\"src_components_ha-textfield_ts\"), __webpack_require__.e(\"src_components_ha-select_ts\"), __webpack_require__.e(\"src_components_ha-checkbox_ts\"), __webpack_require__.e(\"src_components_ha-button-menu_ts\"), __webpack_require__.e(\"src_components_ha-radio_ts\"), __webpack_require__.e(\"src_components_ha-chip_ts\"), __webpack_require__.e(\"src_components_ha-input-helper-text_ts\"), __webpack_require__.e(\"src_components_ha-check-list-item_ts\"), __webpack_require__.e(\"src_components_ha-base-time-input_ts\"), __webpack_require__.e(\"src_components_ha-chip-set_ts\"), __webpack_require__.e(\"src_components_ha-form_ha-form-grid_ts-src_components_ha-form_ha-form_ts\"), __webpack_require__.e(\"node_modules_material_mwc-formfield_mwc-formfield_js-node_modules_material_mwc-list_mwc-check-ee43cd\")]).then(__webpack_require__.bind(__webpack_require__, /*! ../editor/config-elements/hui-markdown-card-editor */ \"./src/panels/lovelace/editor/config-elements/hui-markdown-card-editor.ts\"));\n        return document.createElement(\"hui-markdown-card-editor\");\n      }\n    }, {\n      kind: \"method\",\n      static: true,\n      key: \"getStubConfig\",\n      value: function getStubConfig() {\n        return {\n          type: \"markdown\",\n          content: \"The **Markdown** card allows you to write any text. You can style it **bold**, *italicized*, ~strikethrough~ etc. You can do images, links, and more.\\n\\nFor more information see the [Markdown Cheatsheet](https://commonmark.org/help).\"\n        };\n      }\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.state)()],\n      key: \"_config\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.state)()],\n      key: \"_templateResult\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.state)()],\n      key: \"_unsubRenderTemplate\",\n      value: void 0\n    }, {\n      kind: \"method\",\n      key: \"getCardSize\",\n      value: function getCardSize() {\n        return this._config === undefined ? 3 : this._config.card_size === undefined ? Math.round(this._config.content.split(\"\\n\").length / 2) + (this._config.title ? 1 : 0) : this._config.card_size;\n      }\n    }, {\n      kind: \"method\",\n      key: \"setConfig\",\n      value: function setConfig(config) {\n        var _this$_config;\n\n        if (!config.content) {\n          throw new Error(\"Content required\");\n        }\n\n        if (((_this$_config = this._config) === null || _this$_config === void 0 ? void 0 : _this$_config.content) !== config.content) {\n          this._tryDisconnect();\n        }\n\n        this._config = config;\n      }\n    }, {\n      kind: \"method\",\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(HuiMarkdownCard.prototype), \"connectedCallback\", this).call(this);\n\n        this._tryConnect();\n      }\n    }, {\n      kind: \"method\",\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        this._tryDisconnect();\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        var _this$_templateResult;\n\n        if (!this._config) {\n          return lit__WEBPACK_IMPORTED_MODULE_0__.html``;\n        }\n\n        return lit__WEBPACK_IMPORTED_MODULE_0__.html`\n      <ha-card .header=${this._config.title}>\n        <ha-markdown\n          breaks\n          class=${(0,lit_directives_class_map__WEBPACK_IMPORTED_MODULE_2__.classMap)({\n          \"no-header\": !this._config.title\n        })}\n          .content=${(_this$_templateResult = this._templateResult) === null || _this$_templateResult === void 0 ? void 0 : _this$_templateResult.result}\n        ></ha-markdown>\n      </ha-card>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"updated\",\n      value: function updated(changedProps) {\n        _get(_getPrototypeOf(HuiMarkdownCard.prototype), \"updated\", this).call(this, changedProps);\n\n        if (!this._config || !this.hass) {\n          return;\n        }\n\n        this._tryConnect();\n\n        const oldHass = changedProps.get(\"hass\");\n        const oldConfig = changedProps.get(\"_config\");\n\n        if (!oldHass || !oldConfig || oldHass.themes !== this.hass.themes || oldConfig.theme !== this._config.theme) {\n          (0,_common_dom_apply_themes_on_element__WEBPACK_IMPORTED_MODULE_3__.applyThemesOnElement)(this, this.hass.themes, this._config.theme);\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_tryConnect\",\n      value: async function _tryConnect() {\n        if (this._unsubRenderTemplate !== undefined || !this.hass || !this._config) {\n          return;\n        }\n\n        try {\n          this._unsubRenderTemplate = (0,_data_ws_templates__WEBPACK_IMPORTED_MODULE_6__.subscribeRenderTemplate)(this.hass.connection, result => {\n            this._templateResult = result;\n          }, {\n            template: this._config.content,\n            entity_ids: this._config.entity_id,\n            variables: {\n              config: this._config,\n              user: this.hass.user.name\n            },\n            strict: true\n          });\n        } catch (_err) {\n          this._templateResult = {\n            result: this._config.content,\n            listeners: {\n              all: false,\n              domains: [],\n              entities: [],\n              time: false\n            }\n          };\n          this._unsubRenderTemplate = undefined;\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_tryDisconnect\",\n      value: async function _tryDisconnect() {\n        if (!this._unsubRenderTemplate) {\n          return;\n        }\n\n        try {\n          const unsub = await this._unsubRenderTemplate;\n          unsub();\n          this._unsubRenderTemplate = undefined;\n        } catch (err) {\n          if (err.code === \"not_found\") {// If we get here, the connection was probably already closed. Ignore.\n          } else {\n            throw err;\n          }\n        }\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.css`\n      ha-card {\n        height: 100%;\n      }\n      ha-markdown {\n        padding: 0 16px 16px;\n        word-wrap: break-word;\n      }\n      ha-markdown.no-header {\n        padding-top: 16px;\n      }\n    `;\n      }\n    }]\n  };\n}, lit__WEBPACK_IMPORTED_MODULE_0__.LitElement);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFuZWxzL2xvdmVsYWNlL2NhcmRzL2h1aS1tYXJrZG93bi1jYXJkLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBREE7QUFDQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQVpBO0FBQUE7QUFBQTtBQWNBO0FBQUE7QUFkQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF1QkE7QUFNQTtBQTdCQTtBQUFBO0FBQUE7QUFBQTtBQStCQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUF4Q0E7QUFBQTtBQUFBO0FBQUE7QUEyQ0E7O0FBQ0E7QUFDQTtBQTdDQTtBQUFBO0FBQUE7QUFBQTtBQWdEQTtBQUNBO0FBakRBO0FBQUE7QUFBQTtBQUFBO0FBbURBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuRUE7QUFBQTtBQUFBO0FBQUE7QUFzRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBSUE7QUFNQTtBQUNBO0FBQ0E7QUExRkE7QUFBQTtBQUFBO0FBQUE7QUE2RkE7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFQQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBNUhBO0FBQUE7QUFBQTtBQUFBO0FBK0hBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFpSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE3SkE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9zcmMvcGFuZWxzL2xvdmVsYWNlL2NhcmRzL2h1aS1tYXJrZG93bi1jYXJkLnRzP2U5NmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVW5zdWJzY3JpYmVGdW5jIH0gZnJvbSBcImhvbWUtYXNzaXN0YW50LWpzLXdlYnNvY2tldFwiO1xuaW1wb3J0IHtcbiAgY3NzLFxuICBDU1NSZXN1bHRHcm91cCxcbiAgaHRtbCxcbiAgTGl0RWxlbWVudCxcbiAgUHJvcGVydHlWYWx1ZXMsXG4gIFRlbXBsYXRlUmVzdWx0LFxufSBmcm9tIFwibGl0XCI7XG5pbXBvcnQgeyBjdXN0b21FbGVtZW50LCBwcm9wZXJ0eSwgc3RhdGUgfSBmcm9tIFwibGl0L2RlY29yYXRvcnNcIjtcbmltcG9ydCB7IGNsYXNzTWFwIH0gZnJvbSBcImxpdC9kaXJlY3RpdmVzL2NsYXNzLW1hcFwiO1xuaW1wb3J0IHsgYXBwbHlUaGVtZXNPbkVsZW1lbnQgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2RvbS9hcHBseV90aGVtZXNfb25fZWxlbWVudFwiO1xuaW1wb3J0IFwiLi4vLi4vLi4vY29tcG9uZW50cy9oYS1jYXJkXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9jb21wb25lbnRzL2hhLW1hcmtkb3duXCI7XG5pbXBvcnQge1xuICBSZW5kZXJUZW1wbGF0ZVJlc3VsdCxcbiAgc3Vic2NyaWJlUmVuZGVyVGVtcGxhdGUsXG59IGZyb20gXCIuLi8uLi8uLi9kYXRhL3dzLXRlbXBsYXRlc1wiO1xuaW1wb3J0IHR5cGUgeyBIb21lQXNzaXN0YW50IH0gZnJvbSBcIi4uLy4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgdHlwZSB7IExvdmVsYWNlQ2FyZCwgTG92ZWxhY2VDYXJkRWRpdG9yIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgdHlwZSB7IE1hcmtkb3duQ2FyZENvbmZpZyB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbkBjdXN0b21FbGVtZW50KFwiaHVpLW1hcmtkb3duLWNhcmRcIilcbmV4cG9ydCBjbGFzcyBIdWlNYXJrZG93bkNhcmQgZXh0ZW5kcyBMaXRFbGVtZW50IGltcGxlbWVudHMgTG92ZWxhY2VDYXJkIHtcbiAgcHVibGljIHN0YXRpYyBhc3luYyBnZXRDb25maWdFbGVtZW50KCk6IFByb21pc2U8TG92ZWxhY2VDYXJkRWRpdG9yPiB7XG4gICAgYXdhaXQgaW1wb3J0KFwiLi4vZWRpdG9yL2NvbmZpZy1lbGVtZW50cy9odWktbWFya2Rvd24tY2FyZC1lZGl0b3JcIik7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJodWktbWFya2Rvd24tY2FyZC1lZGl0b3JcIik7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGdldFN0dWJDb25maWcoKTogTWFya2Rvd25DYXJkQ29uZmlnIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtYXJrZG93blwiLFxuICAgICAgY29udGVudDpcbiAgICAgICAgXCJUaGUgKipNYXJrZG93bioqIGNhcmQgYWxsb3dzIHlvdSB0byB3cml0ZSBhbnkgdGV4dC4gWW91IGNhbiBzdHlsZSBpdCAqKmJvbGQqKiwgKml0YWxpY2l6ZWQqLCB+c3RyaWtldGhyb3VnaH4gZXRjLiBZb3UgY2FuIGRvIGltYWdlcywgbGlua3MsIGFuZCBtb3JlLlxcblxcbkZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSB0aGUgW01hcmtkb3duIENoZWF0c2hlZXRdKGh0dHBzOi8vY29tbW9ubWFyay5vcmcvaGVscCkuXCIsXG4gICAgfTtcbiAgfVxuXG4gIEBwcm9wZXJ0eSh7IGF0dHJpYnV0ZTogZmFsc2UgfSkgcHVibGljIGhhc3M/OiBIb21lQXNzaXN0YW50O1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX2NvbmZpZz86IE1hcmtkb3duQ2FyZENvbmZpZztcblxuICBAc3RhdGUoKSBwcml2YXRlIF90ZW1wbGF0ZVJlc3VsdD86IFJlbmRlclRlbXBsYXRlUmVzdWx0O1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX3Vuc3ViUmVuZGVyVGVtcGxhdGU/OiBQcm9taXNlPFVuc3Vic2NyaWJlRnVuYz47XG5cbiAgcHVibGljIGdldENhcmRTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZyA9PT0gdW5kZWZpbmVkXG4gICAgICA/IDNcbiAgICAgIDogdGhpcy5fY29uZmlnLmNhcmRfc2l6ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IE1hdGgucm91bmQodGhpcy5fY29uZmlnLmNvbnRlbnQuc3BsaXQoXCJcXG5cIikubGVuZ3RoIC8gMikgK1xuICAgICAgICAodGhpcy5fY29uZmlnLnRpdGxlID8gMSA6IDApXG4gICAgICA6IHRoaXMuX2NvbmZpZy5jYXJkX3NpemU7XG4gIH1cblxuICBwdWJsaWMgc2V0Q29uZmlnKGNvbmZpZzogTWFya2Rvd25DYXJkQ29uZmlnKTogdm9pZCB7XG4gICAgaWYgKCFjb25maWcuY29udGVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGVudCByZXF1aXJlZFwiKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29uZmlnPy5jb250ZW50ICE9PSBjb25maWcuY29udGVudCkge1xuICAgICAgdGhpcy5fdHJ5RGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gIH1cblxuICBwdWJsaWMgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB0aGlzLl90cnlDb25uZWN0KCk7XG4gIH1cblxuICBwdWJsaWMgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fdHJ5RGlzY29ubmVjdCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlbmRlcigpOiBUZW1wbGF0ZVJlc3VsdCB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcpIHtcbiAgICAgIHJldHVybiBodG1sYGA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8aGEtY2FyZCAuaGVhZGVyPSR7dGhpcy5fY29uZmlnLnRpdGxlfT5cbiAgICAgICAgPGhhLW1hcmtkb3duXG4gICAgICAgICAgYnJlYWtzXG4gICAgICAgICAgY2xhc3M9JHtjbGFzc01hcCh7XG4gICAgICAgICAgICBcIm5vLWhlYWRlclwiOiAhdGhpcy5fY29uZmlnLnRpdGxlLFxuICAgICAgICAgIH0pfVxuICAgICAgICAgIC5jb250ZW50PSR7dGhpcy5fdGVtcGxhdGVSZXN1bHQ/LnJlc3VsdH1cbiAgICAgICAgPjwvaGEtbWFya2Rvd24+XG4gICAgICA8L2hhLWNhcmQ+XG4gICAgYDtcbiAgfVxuXG4gIHByb3RlY3RlZCB1cGRhdGVkKGNoYW5nZWRQcm9wczogUHJvcGVydHlWYWx1ZXMpOiB2b2lkIHtcbiAgICBzdXBlci51cGRhdGVkKGNoYW5nZWRQcm9wcyk7XG4gICAgaWYgKCF0aGlzLl9jb25maWcgfHwgIXRoaXMuaGFzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3RyeUNvbm5lY3QoKTtcblxuICAgIGNvbnN0IG9sZEhhc3MgPSBjaGFuZ2VkUHJvcHMuZ2V0KFwiaGFzc1wiKSBhcyBIb21lQXNzaXN0YW50IHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9sZENvbmZpZyA9IGNoYW5nZWRQcm9wcy5nZXQoXCJfY29uZmlnXCIpIGFzXG4gICAgICB8IE1hcmtkb3duQ2FyZENvbmZpZ1xuICAgICAgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoXG4gICAgICAhb2xkSGFzcyB8fFxuICAgICAgIW9sZENvbmZpZyB8fFxuICAgICAgb2xkSGFzcy50aGVtZXMgIT09IHRoaXMuaGFzcy50aGVtZXMgfHxcbiAgICAgIG9sZENvbmZpZy50aGVtZSAhPT0gdGhpcy5fY29uZmlnLnRoZW1lXG4gICAgKSB7XG4gICAgICBhcHBseVRoZW1lc09uRWxlbWVudCh0aGlzLCB0aGlzLmhhc3MudGhlbWVzLCB0aGlzLl9jb25maWcudGhlbWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3RyeUNvbm5lY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5fdW5zdWJSZW5kZXJUZW1wbGF0ZSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAhdGhpcy5oYXNzIHx8XG4gICAgICAhdGhpcy5fY29uZmlnXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3Vuc3ViUmVuZGVyVGVtcGxhdGUgPSBzdWJzY3JpYmVSZW5kZXJUZW1wbGF0ZShcbiAgICAgICAgdGhpcy5oYXNzLmNvbm5lY3Rpb24sXG4gICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICB0aGlzLl90ZW1wbGF0ZVJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHRlbXBsYXRlOiB0aGlzLl9jb25maWcuY29udGVudCxcbiAgICAgICAgICBlbnRpdHlfaWRzOiB0aGlzLl9jb25maWcuZW50aXR5X2lkLFxuICAgICAgICAgIHZhcmlhYmxlczoge1xuICAgICAgICAgICAgY29uZmlnOiB0aGlzLl9jb25maWcsXG4gICAgICAgICAgICB1c2VyOiB0aGlzLmhhc3MudXNlciEubmFtZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZVJlc3VsdCA9IHtcbiAgICAgICAgcmVzdWx0OiB0aGlzLl9jb25maWchLmNvbnRlbnQsXG4gICAgICAgIGxpc3RlbmVyczogeyBhbGw6IGZhbHNlLCBkb21haW5zOiBbXSwgZW50aXRpZXM6IFtdLCB0aW1lOiBmYWxzZSB9LFxuICAgICAgfTtcbiAgICAgIHRoaXMuX3Vuc3ViUmVuZGVyVGVtcGxhdGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfdHJ5RGlzY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuX3Vuc3ViUmVuZGVyVGVtcGxhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdW5zdWIgPSBhd2FpdCB0aGlzLl91bnN1YlJlbmRlclRlbXBsYXRlO1xuICAgICAgdW5zdWIoKTtcbiAgICAgIHRoaXMuX3Vuc3ViUmVuZGVyVGVtcGxhdGUgPSB1bmRlZmluZWQ7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gXCJub3RfZm91bmRcIikge1xuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgdGhlIGNvbm5lY3Rpb24gd2FzIHByb2JhYmx5IGFscmVhZHkgY2xvc2VkLiBJZ25vcmUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBzdHlsZXMoKTogQ1NTUmVzdWx0R3JvdXAge1xuICAgIHJldHVybiBjc3NgXG4gICAgICBoYS1jYXJkIHtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgfVxuICAgICAgaGEtbWFya2Rvd24ge1xuICAgICAgICBwYWRkaW5nOiAwIDE2cHggMTZweDtcbiAgICAgICAgd29yZC13cmFwOiBicmVhay13b3JkO1xuICAgICAgfVxuICAgICAgaGEtbWFya2Rvd24ubm8taGVhZGVyIHtcbiAgICAgICAgcGFkZGluZy10b3A6IDE2cHg7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBIVE1MRWxlbWVudFRhZ05hbWVNYXAge1xuICAgIFwiaHVpLW1hcmtkb3duLWNhcmRcIjogSHVpTWFya2Rvd25DYXJkO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/panels/lovelace/cards/hui-markdown-card.ts\n");

/***/ }),

/***/ "./node_modules/comlink/dist/esm/comlink.mjs":
/*!***************************************************!*\
  !*** ./node_modules/comlink/dist/esm/comlink.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createEndpoint\": () => (/* binding */ createEndpoint),\n/* harmony export */   \"expose\": () => (/* binding */ expose),\n/* harmony export */   \"proxy\": () => (/* binding */ proxy),\n/* harmony export */   \"proxyMarker\": () => (/* binding */ proxyMarker),\n/* harmony export */   \"releaseProxy\": () => (/* binding */ releaseProxy),\n/* harmony export */   \"transfer\": () => (/* binding */ transfer),\n/* harmony export */   \"transferHandlers\": () => (/* binding */ transferHandlers),\n/* harmony export */   \"windowEndpoint\": () => (/* binding */ windowEndpoint),\n/* harmony export */   \"wrap\": () => (/* binding */ wrap)\n/* harmony export */ });\n/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\nconst isObject = val => typeof val === \"object\" && val !== null || typeof val === \"function\";\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\n\n\nconst proxyTransferHandler = {\n  canHandle: val => isObject(val) && val[proxyMarker],\n\n  serialize(obj) {\n    const {\n      port1,\n      port2\n    } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  }\n\n};\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\n\nconst throwTransferHandler = {\n  canHandle: value => isObject(value) && throwMarker in value,\n\n  serialize({\n    value\n  }) {\n    let serialized;\n\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack\n        }\n      };\n    } else {\n      serialized = {\n        isError: false,\n        value\n      };\n    }\n\n    return [serialized, []];\n  },\n\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(new Error(serialized.value.message), serialized.value);\n    }\n\n    throw serialized.value;\n  }\n\n};\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\n\nconst transferHandlers = new Map([[\"proxy\", proxyTransferHandler], [\"throw\", throwTransferHandler]]);\n\nfunction expose(obj, ep = self) {\n  ep.addEventListener(\"message\", function callback(ev) {\n    if (!ev || !ev.data) {\n      return;\n    }\n\n    const {\n      id,\n      type,\n      path\n    } = Object.assign({\n      path: []\n    }, ev.data);\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n\n      switch (type) {\n        case \"GET\"\n        /* GET */\n        :\n          {\n            returnValue = rawValue;\n          }\n          break;\n\n        case \"SET\"\n        /* SET */\n        :\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n\n        case \"APPLY\"\n        /* APPLY */\n        :\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n\n        case \"CONSTRUCT\"\n        /* CONSTRUCT */\n        :\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n\n        case \"ENDPOINT\"\n        /* ENDPOINT */\n        :\n          {\n            const {\n              port1,\n              port2\n            } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n\n        case \"RELEASE\"\n        /* RELEASE */\n        :\n          {\n            returnValue = undefined;\n          }\n          break;\n\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = {\n        value,\n        [throwMarker]: 0\n      };\n    }\n\n    Promise.resolve(returnValue).catch(value => {\n      return {\n        value,\n        [throwMarker]: 0\n      };\n    }).then(returnValue => {\n      const [wireValue, transferables] = toWireValue(returnValue);\n      ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n        id\n      }), transferables);\n\n      if (type === \"RELEASE\"\n      /* RELEASE */\n      ) {\n        // detach and deactive after sending release response above.\n        ep.removeEventListener(\"message\", callback);\n        closeEndPoint(ep);\n      }\n    });\n  });\n\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint) {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nfunction wrap(ep, target) {\n  return createProxy(ep, [], target);\n}\n\nfunction throwIfProxyReleased(isReleased) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy(ep, path = [], target = function () {}) {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: \"RELEASE\"\n            /* RELEASE */\n            ,\n            path: path.map(p => p.toString())\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return {\n            then: () => proxy\n          };\n        }\n\n        const r = requestResponseMessage(ep, {\n          type: \"GET\"\n          /* GET */\n          ,\n          path: path.map(p => p.toString())\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n\n      return createProxy(ep, [...path, prop]);\n    },\n\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased); // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(ep, {\n        type: \"SET\"\n        /* SET */\n        ,\n        path: [...path, prop].map(p => p.toString()),\n        value\n      }, transferables).then(fromWireValue);\n    },\n\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n\n      if (last === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: \"ENDPOINT\"\n          /* ENDPOINT */\n\n        }).then(fromWireValue);\n      } // We just pretend that `bind()` didn’t happen.\n\n\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(ep, {\n        type: \"APPLY\"\n        /* APPLY */\n        ,\n        path: path.map(p => p.toString()),\n        argumentList\n      }, transferables).then(fromWireValue);\n    },\n\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(ep, {\n        type: \"CONSTRUCT\"\n        /* CONSTRUCT */\n        ,\n        path: path.map(p => p.toString()),\n        argumentList\n      }, transferables).then(fromWireValue);\n    }\n\n  });\n  return proxy;\n}\n\nfunction myFlat(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList) {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map(v => v[0]), myFlat(processed.map(v => v[1]))];\n}\n\nconst transferCache = new WeakMap();\n\nfunction transfer(obj, transfers) {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nfunction proxy(obj) {\n  return Object.assign(obj, {\n    [proxyMarker]: true\n  });\n}\n\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\n  return {\n    postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context)\n  };\n}\n\nfunction toWireValue(value) {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [{\n        type: \"HANDLER\"\n        /* HANDLER */\n        ,\n        name,\n        value: serializedValue\n      }, transferables];\n    }\n  }\n\n  return [{\n    type: \"RAW\"\n    /* RAW */\n    ,\n    value\n  }, transferCache.get(value) || []];\n}\n\nfunction fromWireValue(value) {\n  switch (value.type) {\n    case \"HANDLER\"\n    /* HANDLER */\n    :\n      return transferHandlers.get(value.name).deserialize(value.value);\n\n    case \"RAW\"\n    /* RAW */\n    :\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(ep, msg, transfers) {\n  return new Promise(resolve => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n\n      ep.removeEventListener(\"message\", l);\n      resolve(ev.data);\n    });\n\n    if (ep.start) {\n      ep.start();\n    }\n\n    ep.postMessage(Object.assign({\n      id\n    }, msg), transfers);\n  });\n}\n\nfunction generateUUID() {\n  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join(\"-\");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tbGluay9kaXN0L2VzbS9jb21saW5rLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7O0FBd0JBO0FBQ0E7QUFDQTtBQUVBOztBQXVKQTtBQWdDQTs7Ozs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWEE7QUFzQkE7Ozs7QUFHQTtBQUlBOztBQUVBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFGQTtBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUNBO0FBQ0E7O0FBM0JBO0FBOEJBOzs7O0FBR0E7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBcENBO0FBc0NBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBRUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQURBO0FBRUE7QUFGQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBR0E7QUFBQTtBQURBO0FBRUE7QUFDQTtBQUhBO0FBT0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQURBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQURBO0FBRUE7QUFDQTtBQUhBO0FBT0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBREE7QUFFQTtBQUNBO0FBSEE7QUFPQTs7QUE1RUE7QUE4RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQURBO0FBRUE7QUFDQTtBQUhBO0FBT0E7QUFDQTs7QUFDQTtBQUVBO0FBQUE7QUFEQTtBQUVBO0FBRkE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFKQTtBQU1BOztBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBSUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9zcmMvY29tbGluay50cz8yNGI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgRW5kcG9pbnQsXG4gIEV2ZW50U291cmNlLFxuICBNZXNzYWdlLFxuICBNZXNzYWdlVHlwZSxcbiAgUG9zdE1lc3NhZ2VXaXRoT3JpZ2luLFxuICBXaXJlVmFsdWUsXG4gIFdpcmVWYWx1ZVR5cGUsXG59IGZyb20gXCIuL3Byb3RvY29sXCI7XG5leHBvcnQgeyBFbmRwb2ludCB9O1xuXG5leHBvcnQgY29uc3QgcHJveHlNYXJrZXIgPSBTeW1ib2woXCJDb21saW5rLnByb3h5XCIpO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVuZHBvaW50ID0gU3ltYm9sKFwiQ29tbGluay5lbmRwb2ludFwiKTtcbmV4cG9ydCBjb25zdCByZWxlYXNlUHJveHkgPSBTeW1ib2woXCJDb21saW5rLnJlbGVhc2VQcm94eVwiKTtcblxuY29uc3QgdGhyb3dNYXJrZXIgPSBTeW1ib2woXCJDb21saW5rLnRocm93blwiKTtcblxuLyoqXG4gKiBJbnRlcmZhY2Ugb2YgdmFsdWVzIHRoYXQgd2VyZSBtYXJrZWQgdG8gYmUgcHJveGllZCB3aXRoIGBjb21saW5rLnByb3h5KClgLlxuICogQ2FuIGFsc28gYmUgaW1wbGVtZW50ZWQgYnkgY2xhc3Nlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm94eU1hcmtlZCB7XG4gIFtwcm94eU1hcmtlcl06IHRydWU7XG59XG5cbi8qKlxuICogVGFrZXMgYSB0eXBlIGFuZCB3cmFwcyBpdCBpbiBhIFByb21pc2UsIGlmIGl0IG5vdCBhbHJlYWR5IGlzIG9uZS5cbiAqIFRoaXMgaXMgdG8gYXZvaWQgYFByb21pc2U8UHJvbWlzZTxUPj5gLlxuICpcbiAqIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgYFVucHJvbWlzaWZ5PFQ+YC5cbiAqL1xudHlwZSBQcm9taXNpZnk8VD4gPSBUIGV4dGVuZHMgUHJvbWlzZTx1bmtub3duPiA/IFQgOiBQcm9taXNlPFQ+O1xuLyoqXG4gKiBUYWtlcyBhIHR5cGUgdGhhdCBtYXkgYmUgUHJvbWlzZSBhbmQgdW53cmFwcyB0aGUgUHJvbWlzZSB0eXBlLlxuICogSWYgYFBgIGlzIG5vdCBhIFByb21pc2UsIGl0IHJldHVybnMgYFBgLlxuICpcbiAqIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgYFByb21pc2lmeTxUPmAuXG4gKi9cbnR5cGUgVW5wcm9taXNpZnk8UD4gPSBQIGV4dGVuZHMgUHJvbWlzZTxpbmZlciBUPiA/IFQgOiBQO1xuXG4vKipcbiAqIFRha2VzIHRoZSByYXcgdHlwZSBvZiBhIHJlbW90ZSBwcm9wZXJ0eSBhbmQgcmV0dXJucyB0aGUgdHlwZSB0aGF0IGlzIHZpc2libGUgdG8gdGhlIGxvY2FsIHRocmVhZCBvbiB0aGUgcHJveHkuXG4gKlxuICogTm90ZTogVGhpcyBuZWVkcyB0byBiZSBpdHMgb3duIHR5cGUgYWxpYXMsIG90aGVyd2lzZSBpdCB3aWxsIG5vdCBkaXN0cmlidXRlIG92ZXIgdW5pb25zLlxuICogU2VlIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2FkdmFuY2VkLXR5cGVzLmh0bWwjZGlzdHJpYnV0aXZlLWNvbmRpdGlvbmFsLXR5cGVzXG4gKi9cbnR5cGUgUmVtb3RlUHJvcGVydHk8VD4gPVxuICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBtZXRob2QsIGNvbWxpbmsgd2lsbCBwcm94eSBpdCBhdXRvbWF0aWNhbGx5LlxuICAvLyBPYmplY3RzIGFyZSBvbmx5IHByb3hpZWQgaWYgdGhleSBhcmUgbWFya2VkIHRvIGJlIHByb3hpZWQuXG4gIC8vIE90aGVyd2lzZSwgdGhlIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0aGUgY2xvbmVkIHZhbHVlLlxuICBUIGV4dGVuZHMgRnVuY3Rpb24gfCBQcm94eU1hcmtlZCA/IFJlbW90ZTxUPiA6IFByb21pc2lmeTxUPjtcblxuLyoqXG4gKiBUYWtlcyB0aGUgcmF3IHR5cGUgb2YgYSBwcm9wZXJ0eSBhcyBhIHJlbW90ZSB0aHJlYWQgd291bGQgc2VlIGl0IHRocm91Z2ggYSBwcm94eSAoZS5nLiB3aGVuIHBhc3NlZCBpbiBhcyBhIGZ1bmN0aW9uXG4gKiBhcmd1bWVudCkgYW5kIHJldHVybnMgdGhlIHR5cGUgdGhhdCB0aGUgbG9jYWwgdGhyZWFkIGhhcyB0byBzdXBwbHkuXG4gKlxuICogVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBgUmVtb3RlUHJvcGVydHk8VD5gLlxuICpcbiAqIE5vdGU6IFRoaXMgbmVlZHMgdG8gYmUgaXRzIG93biB0eXBlIGFsaWFzLCBvdGhlcndpc2UgaXQgd2lsbCBub3QgZGlzdHJpYnV0ZSBvdmVyIHVuaW9ucy4gU2VlXG4gKiBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9hZHZhbmNlZC10eXBlcy5odG1sI2Rpc3RyaWJ1dGl2ZS1jb25kaXRpb25hbC10eXBlc1xuICovXG50eXBlIExvY2FsUHJvcGVydHk8VD4gPSBUIGV4dGVuZHMgRnVuY3Rpb24gfCBQcm94eU1hcmtlZFxuICA/IExvY2FsPFQ+XG4gIDogVW5wcm9taXNpZnk8VD47XG5cbi8qKlxuICogUHJveGllcyBgVGAgaWYgaXQgaXMgYSBgUHJveHlNYXJrZWRgLCBjbG9uZXMgaXQgb3RoZXJ3aXNlIChhcyBoYW5kbGVkIGJ5IHN0cnVjdHVyZWQgY2xvbmluZyBhbmQgdHJhbnNmZXIgaGFuZGxlcnMpLlxuICovXG5leHBvcnQgdHlwZSBQcm94eU9yQ2xvbmU8VD4gPSBUIGV4dGVuZHMgUHJveHlNYXJrZWQgPyBSZW1vdGU8VD4gOiBUO1xuLyoqXG4gKiBJbnZlcnNlIG9mIGBQcm94eU9yQ2xvbmU8VD5gLlxuICovXG5leHBvcnQgdHlwZSBVbnByb3h5T3JDbG9uZTxUPiA9IFQgZXh0ZW5kcyBSZW1vdGVPYmplY3Q8UHJveHlNYXJrZWQ+XG4gID8gTG9jYWw8VD5cbiAgOiBUO1xuXG4vKipcbiAqIFRha2VzIHRoZSByYXcgdHlwZSBvZiBhIHJlbW90ZSBvYmplY3QgaW4gdGhlIG90aGVyIHRocmVhZCBhbmQgcmV0dXJucyB0aGUgdHlwZSBhcyBpdCBpcyB2aXNpYmxlIHRvIHRoZSBsb2NhbCB0aHJlYWRcbiAqIHdoZW4gcHJveGllZCB3aXRoIGBDb21saW5rLnByb3h5KClgLlxuICpcbiAqIFRoaXMgZG9lcyBub3QgaGFuZGxlIGNhbGwgc2lnbmF0dXJlcywgd2hpY2ggaXMgaGFuZGxlZCBieSB0aGUgbW9yZSBnZW5lcmFsIGBSZW1vdGU8VD5gIHR5cGUuXG4gKlxuICogQHRlbXBsYXRlIFQgVGhlIHJhdyB0eXBlIG9mIGEgcmVtb3RlIG9iamVjdCBhcyBzZWVuIGluIHRoZSBvdGhlciB0aHJlYWQuXG4gKi9cbmV4cG9ydCB0eXBlIFJlbW90ZU9iamVjdDxUPiA9IHsgW1AgaW4ga2V5b2YgVF06IFJlbW90ZVByb3BlcnR5PFRbUF0+IH07XG4vKipcbiAqIFRha2VzIHRoZSB0eXBlIG9mIGFuIG9iamVjdCBhcyBhIHJlbW90ZSB0aHJlYWQgd291bGQgc2VlIGl0IHRocm91Z2ggYSBwcm94eSAoZS5nLiB3aGVuIHBhc3NlZCBpbiBhcyBhIGZ1bmN0aW9uXG4gKiBhcmd1bWVudCkgYW5kIHJldHVybnMgdGhlIHR5cGUgdGhhdCB0aGUgbG9jYWwgdGhyZWFkIGhhcyB0byBzdXBwbHkuXG4gKlxuICogVGhpcyBkb2VzIG5vdCBoYW5kbGUgY2FsbCBzaWduYXR1cmVzLCB3aGljaCBpcyBoYW5kbGVkIGJ5IHRoZSBtb3JlIGdlbmVyYWwgYExvY2FsPFQ+YCB0eXBlLlxuICpcbiAqIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgYFJlbW90ZU9iamVjdDxUPmAuXG4gKlxuICogQHRlbXBsYXRlIFQgVGhlIHR5cGUgb2YgYSBwcm94aWVkIG9iamVjdC5cbiAqL1xuZXhwb3J0IHR5cGUgTG9jYWxPYmplY3Q8VD4gPSB7IFtQIGluIGtleW9mIFRdOiBMb2NhbFByb3BlcnR5PFRbUF0+IH07XG5cbi8qKlxuICogQWRkaXRpb25hbCBzcGVjaWFsIGNvbWxpbmsgbWV0aG9kcyBhdmFpbGFibGUgb24gZWFjaCBwcm94eSByZXR1cm5lZCBieSBgQ29tbGluay53cmFwKClgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb3h5TWV0aG9kcyB7XG4gIFtjcmVhdGVFbmRwb2ludF06ICgpID0+IFByb21pc2U8TWVzc2FnZVBvcnQ+O1xuICBbcmVsZWFzZVByb3h5XTogKCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBUYWtlcyB0aGUgcmF3IHR5cGUgb2YgYSByZW1vdGUgb2JqZWN0LCBmdW5jdGlvbiBvciBjbGFzcyBpbiB0aGUgb3RoZXIgdGhyZWFkIGFuZCByZXR1cm5zIHRoZSB0eXBlIGFzIGl0IGlzIHZpc2libGUgdG9cbiAqIHRoZSBsb2NhbCB0aHJlYWQgZnJvbSB0aGUgcHJveHkgcmV0dXJuIHZhbHVlIG9mIGBDb21saW5rLndyYXAoKWAgb3IgYENvbWxpbmsucHJveHkoKWAuXG4gKi9cbmV4cG9ydCB0eXBlIFJlbW90ZTxUPiA9XG4gIC8vIEhhbmRsZSBwcm9wZXJ0aWVzXG4gIFJlbW90ZU9iamVjdDxUPiAmXG4gICAgLy8gSGFuZGxlIGNhbGwgc2lnbmF0dXJlIChpZiBwcmVzZW50KVxuICAgIChUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFRBcmd1bWVudHMpID0+IGluZmVyIFRSZXR1cm5cbiAgICAgID8gKFxuICAgICAgICAgIC4uLmFyZ3M6IHsgW0kgaW4ga2V5b2YgVEFyZ3VtZW50c106IFVucHJveHlPckNsb25lPFRBcmd1bWVudHNbSV0+IH1cbiAgICAgICAgKSA9PiBQcm9taXNpZnk8UHJveHlPckNsb25lPFVucHJvbWlzaWZ5PFRSZXR1cm4+Pj5cbiAgICAgIDogdW5rbm93bikgJlxuICAgIC8vIEhhbmRsZSBjb25zdHJ1Y3Qgc2lnbmF0dXJlIChpZiBwcmVzZW50KVxuICAgIC8vIFRoZSByZXR1cm4gb2YgY29uc3RydWN0IHNpZ25hdHVyZXMgaXMgYWx3YXlzIHByb3hpZWQgKHdoZXRoZXIgbWFya2VkIG9yIG5vdClcbiAgICAoVCBleHRlbmRzIHsgbmV3ICguLi5hcmdzOiBpbmZlciBUQXJndW1lbnRzKTogaW5mZXIgVEluc3RhbmNlIH1cbiAgICAgID8ge1xuICAgICAgICAgIG5ldyAoXG4gICAgICAgICAgICAuLi5hcmdzOiB7XG4gICAgICAgICAgICAgIFtJIGluIGtleW9mIFRBcmd1bWVudHNdOiBVbnByb3h5T3JDbG9uZTxUQXJndW1lbnRzW0ldPjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApOiBQcm9taXNpZnk8UmVtb3RlPFRJbnN0YW5jZT4+O1xuICAgICAgICB9XG4gICAgICA6IHVua25vd24pICZcbiAgICAvLyBJbmNsdWRlIGFkZGl0aW9uYWwgc3BlY2lhbCBjb21saW5rIG1ldGhvZHMgYXZhaWxhYmxlIG9uIHRoZSBwcm94eS5cbiAgICBQcm94eU1ldGhvZHM7XG5cbi8qKlxuICogRXhwcmVzc2VzIHRoYXQgYSB0eXBlIGNhbiBiZSBlaXRoZXIgYSBzeW5jIG9yIGFzeW5jLlxuICovXG50eXBlIE1heWJlUHJvbWlzZTxUPiA9IFByb21pc2U8VD4gfCBUO1xuXG4vKipcbiAqIFRha2VzIHRoZSByYXcgdHlwZSBvZiBhIHJlbW90ZSBvYmplY3QsIGZ1bmN0aW9uIG9yIGNsYXNzIGFzIGEgcmVtb3RlIHRocmVhZCB3b3VsZCBzZWUgaXQgdGhyb3VnaCBhIHByb3h5IChlLmcuIHdoZW5cbiAqIHBhc3NlZCBpbiBhcyBhIGZ1bmN0aW9uIGFyZ3VtZW50KSBhbmQgcmV0dXJucyB0aGUgdHlwZSB0aGUgbG9jYWwgdGhyZWFkIGhhcyB0byBzdXBwbHkuXG4gKlxuICogVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBgUmVtb3RlPFQ+YC4gSXQgdGFrZXMgYSBgUmVtb3RlPFQ+YCBhbmQgcmV0dXJucyBpdHMgb3JpZ2luYWwgaW5wdXQgYFRgLlxuICovXG5leHBvcnQgdHlwZSBMb2NhbDxUPiA9XG4gIC8vIE9taXQgdGhlIHNwZWNpYWwgcHJveHkgbWV0aG9kcyAodGhleSBkb24ndCBuZWVkIHRvIGJlIHN1cHBsaWVkLCBjb21saW5rIGFkZHMgdGhlbSlcbiAgT21pdDxMb2NhbE9iamVjdDxUPiwga2V5b2YgUHJveHlNZXRob2RzPiAmXG4gICAgLy8gSGFuZGxlIGNhbGwgc2lnbmF0dXJlcyAoaWYgcHJlc2VudClcbiAgICAoVCBleHRlbmRzICguLi5hcmdzOiBpbmZlciBUQXJndW1lbnRzKSA9PiBpbmZlciBUUmV0dXJuXG4gICAgICA/IChcbiAgICAgICAgICAuLi5hcmdzOiB7IFtJIGluIGtleW9mIFRBcmd1bWVudHNdOiBQcm94eU9yQ2xvbmU8VEFyZ3VtZW50c1tJXT4gfVxuICAgICAgICApID0+IC8vIFRoZSByYXcgZnVuY3Rpb24gY291bGQgZWl0aGVyIGJlIHN5bmMgb3IgYXN5bmMsIGJ1dCBpcyBhbHdheXMgcHJveGllZCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIE1heWJlUHJvbWlzZTxVbnByb3h5T3JDbG9uZTxVbnByb21pc2lmeTxUUmV0dXJuPj4+XG4gICAgICA6IHVua25vd24pICZcbiAgICAvLyBIYW5kbGUgY29uc3RydWN0IHNpZ25hdHVyZSAoaWYgcHJlc2VudClcbiAgICAvLyBUaGUgcmV0dXJuIG9mIGNvbnN0cnVjdCBzaWduYXR1cmVzIGlzIGFsd2F5cyBwcm94aWVkICh3aGV0aGVyIG1hcmtlZCBvciBub3QpXG4gICAgKFQgZXh0ZW5kcyB7IG5ldyAoLi4uYXJnczogaW5mZXIgVEFyZ3VtZW50cyk6IGluZmVyIFRJbnN0YW5jZSB9XG4gICAgICA/IHtcbiAgICAgICAgICBuZXcgKFxuICAgICAgICAgICAgLi4uYXJnczoge1xuICAgICAgICAgICAgICBbSSBpbiBrZXlvZiBUQXJndW1lbnRzXTogUHJveHlPckNsb25lPFRBcmd1bWVudHNbSV0+O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk6IC8vIFRoZSByYXcgY29uc3RydWN0b3IgY291bGQgZWl0aGVyIGJlIHN5bmMgb3IgYXN5bmMsIGJ1dCBpcyBhbHdheXMgcHJveGllZCBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgTWF5YmVQcm9taXNlPExvY2FsPFVucHJvbWlzaWZ5PFRJbnN0YW5jZT4+PjtcbiAgICAgICAgfVxuICAgICAgOiB1bmtub3duKTtcblxuY29uc3QgaXNPYmplY3QgPSAodmFsOiB1bmtub3duKTogdmFsIGlzIG9iamVjdCA9PlxuICAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiB2YWwgIT09IG51bGwpIHx8IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcblxuLyoqXG4gKiBDdXN0b21pemVzIHRoZSBzZXJpYWxpemF0aW9uIG9mIGNlcnRhaW4gdmFsdWVzIGFzIGRldGVybWluZWQgYnkgYGNhbkhhbmRsZSgpYC5cbiAqXG4gKiBAdGVtcGxhdGUgVCBUaGUgaW5wdXQgdHlwZSBiZWluZyBoYW5kbGVkIGJ5IHRoaXMgdHJhbnNmZXIgaGFuZGxlci5cbiAqIEB0ZW1wbGF0ZSBTIFRoZSBzZXJpYWxpemVkIHR5cGUgc2VudCBvdmVyIHRoZSB3aXJlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZmVySGFuZGxlcjxULCBTPiB7XG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBmb3IgZXZlcnkgdmFsdWUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyB0cmFuc2ZlciBoYW5kbGVyXG4gICAqIHNob3VsZCBzZXJpYWxpemUgdGhlIHZhbHVlLCB3aGljaCBpbmNsdWRlcyBjaGVja2luZyB0aGF0IGl0IGlzIG9mIHRoZSByaWdodFxuICAgKiB0eXBlIChidXQgY2FuIHBlcmZvcm0gY2hlY2tzIGJleW9uZCB0aGF0IGFzIHdlbGwpLlxuICAgKi9cbiAgY2FuSGFuZGxlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgVDtcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgaWYgYGNhbkhhbmRsZSgpYCByZXR1cm5lZCBgdHJ1ZWAgdG8gcHJvZHVjZSBhXG4gICAqIHZhbHVlIHRoYXQgY2FuIGJlIHNlbnQgaW4gYSBtZXNzYWdlLCBjb25zaXN0aW5nIG9mIHN0cnVjdHVyZWQtY2xvbmVhYmxlXG4gICAqIHZhbHVlcyBhbmQvb3IgdHJhbnNmZXJyYWJsZSBvYmplY3RzLlxuICAgKi9cbiAgc2VyaWFsaXplKHZhbHVlOiBUKTogW1MsIFRyYW5zZmVyYWJsZVtdXTtcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgdG8gZGVzZXJpYWxpemUgYW4gaW5jb21pbmcgdmFsdWUgdGhhdCB3YXMgc2VyaWFsaXplZCBpbiB0aGVcbiAgICogb3RoZXIgdGhyZWFkIHdpdGggdGhpcyB0cmFuc2ZlciBoYW5kbGVyIChrbm93biB0aHJvdWdoIHRoZSBuYW1lIGl0IHdhc1xuICAgKiByZWdpc3RlcmVkIHVuZGVyKS5cbiAgICovXG4gIGRlc2VyaWFsaXplKHZhbHVlOiBTKTogVDtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCB0cmFuc2ZlciBoYW5kbGUgdG8gaGFuZGxlIG9iamVjdHMgbWFya2VkIHRvIHByb3h5LlxuICovXG5jb25zdCBwcm94eVRyYW5zZmVySGFuZGxlcjogVHJhbnNmZXJIYW5kbGVyPG9iamVjdCwgTWVzc2FnZVBvcnQ+ID0ge1xuICBjYW5IYW5kbGU6ICh2YWwpOiB2YWwgaXMgUHJveHlNYXJrZWQgPT5cbiAgICBpc09iamVjdCh2YWwpICYmICh2YWwgYXMgUHJveHlNYXJrZWQpW3Byb3h5TWFya2VyXSxcbiAgc2VyaWFsaXplKG9iaikge1xuICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBleHBvc2Uob2JqLCBwb3J0MSk7XG4gICAgcmV0dXJuIFtwb3J0MiwgW3BvcnQyXV07XG4gIH0sXG4gIGRlc2VyaWFsaXplKHBvcnQpIHtcbiAgICBwb3J0LnN0YXJ0KCk7XG4gICAgcmV0dXJuIHdyYXAocG9ydCk7XG4gIH0sXG59O1xuXG5pbnRlcmZhY2UgVGhyb3duVmFsdWUge1xuICBbdGhyb3dNYXJrZXJdOiB1bmtub3duOyAvLyBqdXN0IG5lZWRzIHRvIGJlIHByZXNlbnRcbiAgdmFsdWU6IHVua25vd247XG59XG50eXBlIFNlcmlhbGl6ZWRUaHJvd25WYWx1ZSA9XG4gIHwgeyBpc0Vycm9yOiB0cnVlOyB2YWx1ZTogRXJyb3IgfVxuICB8IHsgaXNFcnJvcjogZmFsc2U7IHZhbHVlOiB1bmtub3duIH07XG5cbi8qKlxuICogSW50ZXJuYWwgdHJhbnNmZXIgaGFuZGxlciB0byBoYW5kbGUgdGhyb3duIGV4Y2VwdGlvbnMuXG4gKi9cbmNvbnN0IHRocm93VHJhbnNmZXJIYW5kbGVyOiBUcmFuc2ZlckhhbmRsZXI8XG4gIFRocm93blZhbHVlLFxuICBTZXJpYWxpemVkVGhyb3duVmFsdWVcbj4gPSB7XG4gIGNhbkhhbmRsZTogKHZhbHVlKTogdmFsdWUgaXMgVGhyb3duVmFsdWUgPT5cbiAgICBpc09iamVjdCh2YWx1ZSkgJiYgdGhyb3dNYXJrZXIgaW4gdmFsdWUsXG4gIHNlcmlhbGl6ZSh7IHZhbHVlIH0pIHtcbiAgICBsZXQgc2VyaWFsaXplZDogU2VyaWFsaXplZFRocm93blZhbHVlO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBzZXJpYWxpemVkID0ge1xuICAgICAgICBpc0Vycm9yOiB0cnVlLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsXG4gICAgICAgICAgbmFtZTogdmFsdWUubmFtZSxcbiAgICAgICAgICBzdGFjazogdmFsdWUuc3RhY2ssXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkID0geyBpc0Vycm9yOiBmYWxzZSwgdmFsdWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIFtzZXJpYWxpemVkLCBbXV07XG4gIH0sXG4gIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHtcbiAgICBpZiAoc2VyaWFsaXplZC5pc0Vycm9yKSB7XG4gICAgICB0aHJvdyBPYmplY3QuYXNzaWduKFxuICAgICAgICBuZXcgRXJyb3Ioc2VyaWFsaXplZC52YWx1ZS5tZXNzYWdlKSxcbiAgICAgICAgc2VyaWFsaXplZC52YWx1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgc2VyaWFsaXplZC52YWx1ZTtcbiAgfSxcbn07XG5cbi8qKlxuICogQWxsb3dzIGN1c3RvbWl6aW5nIHRoZSBzZXJpYWxpemF0aW9uIG9mIGNlcnRhaW4gdmFsdWVzLlxuICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJIYW5kbGVycyA9IG5ldyBNYXA8XG4gIHN0cmluZyxcbiAgVHJhbnNmZXJIYW5kbGVyPHVua25vd24sIHVua25vd24+XG4+KFtcbiAgW1wicHJveHlcIiwgcHJveHlUcmFuc2ZlckhhbmRsZXJdLFxuICBbXCJ0aHJvd1wiLCB0aHJvd1RyYW5zZmVySGFuZGxlcl0sXG5dKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9zZShvYmo6IGFueSwgZXA6IEVuZHBvaW50ID0gc2VsZiBhcyBhbnkpIHtcbiAgZXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gY2FsbGJhY2soZXY6IE1lc3NhZ2VFdmVudCkge1xuICAgIGlmICghZXYgfHwgIWV2LmRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgdHlwZSwgcGF0aCB9ID0ge1xuICAgICAgcGF0aDogW10gYXMgc3RyaW5nW10sXG4gICAgICAuLi4oZXYuZGF0YSBhcyBNZXNzYWdlKSxcbiAgICB9O1xuICAgIGNvbnN0IGFyZ3VtZW50TGlzdCA9IChldi5kYXRhLmFyZ3VtZW50TGlzdCB8fCBbXSkubWFwKGZyb21XaXJlVmFsdWUpO1xuICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5zbGljZSgwLCAtMSkucmVkdWNlKChvYmosIHByb3ApID0+IG9ialtwcm9wXSwgb2JqKTtcbiAgICAgIGNvbnN0IHJhd1ZhbHVlID0gcGF0aC5yZWR1Y2UoKG9iaiwgcHJvcCkgPT4gb2JqW3Byb3BdLCBvYmopO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuR0VUOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmF3VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlNFVDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwYXJlbnRbcGF0aC5zbGljZSgtMSlbMF1dID0gZnJvbVdpcmVWYWx1ZShldi5kYXRhLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQVBQTFk6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSByYXdWYWx1ZS5hcHBseShwYXJlbnQsIGFyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNPTlNUUlVDVDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyByYXdWYWx1ZSguLi5hcmd1bWVudExpc3QpO1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBwcm94eSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkVORFBPSU5UOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgICAgIGV4cG9zZShvYmosIHBvcnQyKTtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJhbnNmZXIocG9ydDEsIFtwb3J0MV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5SRUxFQVNFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAodmFsdWUpIHtcbiAgICAgIHJldHVyblZhbHVlID0geyB2YWx1ZSwgW3Rocm93TWFya2VyXTogMCB9O1xuICAgIH1cbiAgICBQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWUpXG4gICAgICAuY2F0Y2goKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07XG4gICAgICB9KVxuICAgICAgLnRoZW4oKHJldHVyblZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IFt3aXJlVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmV0dXJuVmFsdWUpO1xuICAgICAgICBlcC5wb3N0TWVzc2FnZSh7IC4uLndpcmVWYWx1ZSwgaWQgfSwgdHJhbnNmZXJhYmxlcyk7XG4gICAgICAgIGlmICh0eXBlID09PSBNZXNzYWdlVHlwZS5SRUxFQVNFKSB7XG4gICAgICAgICAgLy8gZGV0YWNoIGFuZCBkZWFjdGl2ZSBhZnRlciBzZW5kaW5nIHJlbGVhc2UgcmVzcG9uc2UgYWJvdmUuXG4gICAgICAgICAgZXAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgY2FsbGJhY2sgYXMgYW55KTtcbiAgICAgICAgICBjbG9zZUVuZFBvaW50KGVwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0gYXMgYW55KTtcbiAgaWYgKGVwLnN0YXJ0KSB7XG4gICAgZXAuc3RhcnQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc01lc3NhZ2VQb3J0KGVuZHBvaW50OiBFbmRwb2ludCk6IGVuZHBvaW50IGlzIE1lc3NhZ2VQb3J0IHtcbiAgcmV0dXJuIGVuZHBvaW50LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiTWVzc2FnZVBvcnRcIjtcbn1cblxuZnVuY3Rpb24gY2xvc2VFbmRQb2ludChlbmRwb2ludDogRW5kcG9pbnQpIHtcbiAgaWYgKGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpKSBlbmRwb2ludC5jbG9zZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcDxUPihlcDogRW5kcG9pbnQsIHRhcmdldD86IGFueSk6IFJlbW90ZTxUPiB7XG4gIHJldHVybiBjcmVhdGVQcm94eTxUPihlcCwgW10sIHRhcmdldCkgYXMgYW55O1xufVxuXG5mdW5jdGlvbiB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1JlbGVhc2VkOiBib29sZWFuKSB7XG4gIGlmIChpc1JlbGVhc2VkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJveHkgaGFzIGJlZW4gcmVsZWFzZWQgYW5kIGlzIG5vdCB1c2VhYmxlXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5PFQ+KFxuICBlcDogRW5kcG9pbnQsXG4gIHBhdGg6IChzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpW10gPSBbXSxcbiAgdGFyZ2V0OiBvYmplY3QgPSBmdW5jdGlvbiAoKSB7fVxuKTogUmVtb3RlPFQ+IHtcbiAgbGV0IGlzUHJveHlSZWxlYXNlZCA9IGZhbHNlO1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIHtcbiAgICBnZXQoX3RhcmdldCwgcHJvcCkge1xuICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgIGlmIChwcm9wID09PSByZWxlYXNlUHJveHkpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwge1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuUkVMRUFTRSxcbiAgICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY2xvc2VFbmRQb2ludChlcCk7XG4gICAgICAgICAgICBpc1Byb3h5UmVsZWFzZWQgPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHByb3AgPT09IFwidGhlblwiKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB7IHRoZW46ICgpID0+IHByb3h5IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHtcbiAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5HRVQsXG4gICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgIH0pLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIHJldHVybiByLnRoZW4uYmluZChyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgWy4uLnBhdGgsIHByb3BdKTtcbiAgICB9LFxuICAgIHNldChfdGFyZ2V0LCBwcm9wLCByYXdWYWx1ZSkge1xuICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgIC8vIEZJWE1FOiBFUzYgUHJveHkgSGFuZGxlciBgc2V0YCBtZXRob2RzIGFyZSBzdXBwb3NlZCB0byByZXR1cm4gYVxuICAgICAgLy8gYm9vbGVhbi4gVG8gc2hvdyBnb29kIHdpbGwsIHdlIHJldHVybiB0cnVlIGFzeW5jaHJvbm91c2x5IMKvXFxfKOODhClfL8KvXG4gICAgICBjb25zdCBbdmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoXG4gICAgICAgIGVwLFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VULFxuICAgICAgICAgIHBhdGg6IFsuLi5wYXRoLCBwcm9wXS5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZmVyYWJsZXNcbiAgICAgICkudGhlbihmcm9tV2lyZVZhbHVlKSBhcyBhbnk7XG4gICAgfSxcbiAgICBhcHBseShfdGFyZ2V0LCBfdGhpc0FyZywgcmF3QXJndW1lbnRMaXN0KSB7XG4gICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgY29uc3QgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIGlmICgobGFzdCBhcyBhbnkpID09PSBjcmVhdGVFbmRwb2ludCkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwge1xuICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkVORFBPSU5ULFxuICAgICAgICB9KS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gV2UganVzdCBwcmV0ZW5kIHRoYXQgYGJpbmQoKWAgZGlkbuKAmXQgaGFwcGVuLlxuICAgICAgaWYgKGxhc3QgPT09IFwiYmluZFwiKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7XG4gICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShcbiAgICAgICAgZXAsXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5BUFBMWSxcbiAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICBhcmd1bWVudExpc3QsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZmVyYWJsZXNcbiAgICAgICkudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICB9LFxuICAgIGNvbnN0cnVjdChfdGFyZ2V0LCByYXdBcmd1bWVudExpc3QpIHtcbiAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICBjb25zdCBbYXJndW1lbnRMaXN0LCB0cmFuc2ZlcmFibGVzXSA9IHByb2Nlc3NBcmd1bWVudHMocmF3QXJndW1lbnRMaXN0KTtcbiAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKFxuICAgICAgICBlcCxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkNPTlNUUlVDVCxcbiAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICBhcmd1bWVudExpc3QsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZmVyYWJsZXNcbiAgICAgICkudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICB9LFxuICB9KTtcbiAgcmV0dXJuIHByb3h5IGFzIGFueTtcbn1cblxuZnVuY3Rpb24gbXlGbGF0PFQ+KGFycjogKFQgfCBUW10pW10pOiBUW10ge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0FyZ3VtZW50cyhhcmd1bWVudExpc3Q6IGFueVtdKTogW1dpcmVWYWx1ZVtdLCBUcmFuc2ZlcmFibGVbXV0ge1xuICBjb25zdCBwcm9jZXNzZWQgPSBhcmd1bWVudExpc3QubWFwKHRvV2lyZVZhbHVlKTtcbiAgcmV0dXJuIFtwcm9jZXNzZWQubWFwKCh2KSA9PiB2WzBdKSwgbXlGbGF0KHByb2Nlc3NlZC5tYXAoKHYpID0+IHZbMV0pKV07XG59XG5cbmNvbnN0IHRyYW5zZmVyQ2FjaGUgPSBuZXcgV2Vha01hcDxhbnksIFRyYW5zZmVyYWJsZVtdPigpO1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZmVyPFQ+KG9iajogVCwgdHJhbnNmZXJzOiBUcmFuc2ZlcmFibGVbXSk6IFQge1xuICB0cmFuc2ZlckNhY2hlLnNldChvYmosIHRyYW5zZmVycyk7XG4gIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm94eTxUPihvYmo6IFQpOiBUICYgUHJveHlNYXJrZWQge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIHsgW3Byb3h5TWFya2VyXTogdHJ1ZSB9KSBhcyBhbnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aW5kb3dFbmRwb2ludChcbiAgdzogUG9zdE1lc3NhZ2VXaXRoT3JpZ2luLFxuICBjb250ZXh0OiBFdmVudFNvdXJjZSA9IHNlbGYsXG4gIHRhcmdldE9yaWdpbiA9IFwiKlwiXG4pOiBFbmRwb2ludCB7XG4gIHJldHVybiB7XG4gICAgcG9zdE1lc3NhZ2U6IChtc2c6IGFueSwgdHJhbnNmZXJhYmxlczogVHJhbnNmZXJhYmxlW10pID0+XG4gICAgICB3LnBvc3RNZXNzYWdlKG1zZywgdGFyZ2V0T3JpZ2luLCB0cmFuc2ZlcmFibGVzKSxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIuYmluZChjb250ZXh0KSxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBjb250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZChjb250ZXh0KSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9XaXJlVmFsdWUodmFsdWU6IGFueSk6IFtXaXJlVmFsdWUsIFRyYW5zZmVyYWJsZVtdXSB7XG4gIGZvciAoY29uc3QgW25hbWUsIGhhbmRsZXJdIG9mIHRyYW5zZmVySGFuZGxlcnMpIHtcbiAgICBpZiAoaGFuZGxlci5jYW5IYW5kbGUodmFsdWUpKSB7XG4gICAgICBjb25zdCBbc2VyaWFsaXplZFZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IGhhbmRsZXIuc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBXaXJlVmFsdWVUeXBlLkhBTkRMRVIsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFZhbHVlLFxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlcmFibGVzLFxuICAgICAgXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB0eXBlOiBXaXJlVmFsdWVUeXBlLlJBVyxcbiAgICAgIHZhbHVlLFxuICAgIH0sXG4gICAgdHJhbnNmZXJDYWNoZS5nZXQodmFsdWUpIHx8IFtdLFxuICBdO1xufVxuXG5mdW5jdGlvbiBmcm9tV2lyZVZhbHVlKHZhbHVlOiBXaXJlVmFsdWUpOiBhbnkge1xuICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICBjYXNlIFdpcmVWYWx1ZVR5cGUuSEFORExFUjpcbiAgICAgIHJldHVybiB0cmFuc2ZlckhhbmRsZXJzLmdldCh2YWx1ZS5uYW1lKSEuZGVzZXJpYWxpemUodmFsdWUudmFsdWUpO1xuICAgIGNhc2UgV2lyZVZhbHVlVHlwZS5SQVc6XG4gICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShcbiAgZXA6IEVuZHBvaW50LFxuICBtc2c6IE1lc3NhZ2UsXG4gIHRyYW5zZmVycz86IFRyYW5zZmVyYWJsZVtdXG4pOiBQcm9taXNlPFdpcmVWYWx1ZT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBpZCA9IGdlbmVyYXRlVVVJRCgpO1xuICAgIGVwLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIGwoZXY6IE1lc3NhZ2VFdmVudCkge1xuICAgICAgaWYgKCFldi5kYXRhIHx8ICFldi5kYXRhLmlkIHx8IGV2LmRhdGEuaWQgIT09IGlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGwgYXMgYW55KTtcbiAgICAgIHJlc29sdmUoZXYuZGF0YSk7XG4gICAgfSBhcyBhbnkpO1xuICAgIGlmIChlcC5zdGFydCkge1xuICAgICAgZXAuc3RhcnQoKTtcbiAgICB9XG4gICAgZXAucG9zdE1lc3NhZ2UoeyBpZCwgLi4ubXNnIH0sIHRyYW5zZmVycyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKTogc3RyaW5nIHtcbiAgcmV0dXJuIG5ldyBBcnJheSg0KVxuICAgIC5maWxsKDApXG4gICAgLm1hcCgoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikudG9TdHJpbmcoMTYpKVxuICAgIC5qb2luKFwiLVwiKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/comlink/dist/esm/comlink.mjs\n");

/***/ })

}]);