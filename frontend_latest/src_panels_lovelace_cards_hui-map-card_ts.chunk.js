"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["src_panels_lovelace_cards_hui-map-card_ts"],{

/***/ "./src/common/util/parse-aspect-ratio.ts":
/*!***********************************************!*\
  !*** ./src/common/util/parse-aspect-ratio.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ parseAspectRatio)\n/* harmony export */ });\n// Handle 16x9, 16:9, 1.78x1, 1.78:1, 1.78\n// Ignore everything else\nconst parseOrThrow = num => {\n  const parsed = parseFloat(num);\n\n  if (isNaN(parsed)) {\n    throw new Error(`${num} is not a number`);\n  }\n\n  return parsed;\n};\n\nfunction parseAspectRatio(input) {\n  if (!input) {\n    return null;\n  }\n\n  try {\n    if (input.endsWith(\"%\")) {\n      return {\n        w: 100,\n        h: parseOrThrow(input.substr(0, input.length - 1))\n      };\n    }\n\n    const arr = input.replace(\":\", \"x\").split(\"x\");\n\n    if (arr.length === 0) {\n      return null;\n    }\n\n    return arr.length === 1 ? {\n      w: parseOrThrow(arr[0]),\n      h: 1\n    } : {\n      w: parseOrThrow(arr[0]),\n      h: parseOrThrow(arr[1])\n    };\n  } catch (err) {// Ignore the error\n  }\n\n  return null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL3V0aWwvcGFyc2UtYXNwZWN0LXJhdGlvLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBOztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL3NyYy9jb21tb24vdXRpbC9wYXJzZS1hc3BlY3QtcmF0aW8udHM/ODdlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIYW5kbGUgMTZ4OSwgMTY6OSwgMS43OHgxLCAxLjc4OjEsIDEuNzhcbi8vIElnbm9yZSBldmVyeXRoaW5nIGVsc2VcbmNvbnN0IHBhcnNlT3JUaHJvdyA9IChudW0pID0+IHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2VGbG9hdChudW0pO1xuICBpZiAoaXNOYU4ocGFyc2VkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtudW19IGlzIG5vdCBhIG51bWJlcmApO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZUFzcGVjdFJhdGlvKGlucHV0OiBzdHJpbmcpIHtcbiAgaWYgKCFpbnB1dCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKGlucHV0LmVuZHNXaXRoKFwiJVwiKSkge1xuICAgICAgcmV0dXJuIHsgdzogMTAwLCBoOiBwYXJzZU9yVGhyb3coaW5wdXQuc3Vic3RyKDAsIGlucHV0Lmxlbmd0aCAtIDEpKSB9O1xuICAgIH1cblxuICAgIGNvbnN0IGFyciA9IGlucHV0LnJlcGxhY2UoXCI6XCIsIFwieFwiKS5zcGxpdChcInhcIik7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIubGVuZ3RoID09PSAxXG4gICAgICA/IHsgdzogcGFyc2VPclRocm93KGFyclswXSksIGg6IDEgfVxuICAgICAgOiB7IHc6IHBhcnNlT3JUaHJvdyhhcnJbMF0pLCBoOiBwYXJzZU9yVGhyb3coYXJyWzFdKSB9O1xuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIC8vIElnbm9yZSB0aGUgZXJyb3JcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/common/util/parse-aspect-ratio.ts\n");

/***/ }),

/***/ "./src/data/history.ts":
/*!*****************************!*\
  !*** ./src/data/history.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"entityIdHistoryNeedsAttributes\": () => (/* binding */ entityIdHistoryNeedsAttributes),\n/* harmony export */   \"fetchRecent\": () => (/* binding */ fetchRecent),\n/* harmony export */   \"fetchRecentWS\": () => (/* binding */ fetchRecentWS),\n/* harmony export */   \"fetchDate\": () => (/* binding */ fetchDate),\n/* harmony export */   \"fetchDateWS\": () => (/* binding */ fetchDateWS),\n/* harmony export */   \"computeHistory\": () => (/* binding */ computeHistory),\n/* harmony export */   \"getStatisticIds\": () => (/* binding */ getStatisticIds),\n/* harmony export */   \"getStatisticMetadata\": () => (/* binding */ getStatisticMetadata),\n/* harmony export */   \"fetchStatistics\": () => (/* binding */ fetchStatistics),\n/* harmony export */   \"validateStatistics\": () => (/* binding */ validateStatistics),\n/* harmony export */   \"updateStatisticsMetadata\": () => (/* binding */ updateStatisticsMetadata),\n/* harmony export */   \"clearStatistics\": () => (/* binding */ clearStatistics),\n/* harmony export */   \"calculateStatisticSumGrowth\": () => (/* binding */ calculateStatisticSumGrowth),\n/* harmony export */   \"calculateStatisticsSumGrowth\": () => (/* binding */ calculateStatisticsSumGrowth),\n/* harmony export */   \"statisticsHaveType\": () => (/* binding */ statisticsHaveType),\n/* harmony export */   \"adjustStatisticsSum\": () => (/* binding */ adjustStatisticsSum),\n/* harmony export */   \"getStatisticLabel\": () => (/* binding */ getStatisticLabel)\n/* harmony export */ });\n/* harmony import */ var _common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/entity/compute_domain */ \"./src/common/entity/compute_domain.ts\");\n/* harmony import */ var _common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/entity/compute_state_display */ \"./src/common/entity/compute_state_display.ts\");\n/* harmony import */ var _common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/entity/compute_state_name */ \"./src/common/entity/compute_state_name.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__]);\n_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\n\n\n\nconst DOMAINS_USE_LAST_UPDATED = [\"climate\", \"humidifier\", \"water_heater\"];\nconst NEED_ATTRIBUTE_DOMAINS = [\"climate\", \"humidifier\", \"input_datetime\", \"thermostat\", \"water_heater\"];\nconst LINE_ATTRIBUTES_TO_KEEP = [\"temperature\", \"current_temperature\", \"target_temp_low\", \"target_temp_high\", \"hvac_action\", \"humidity\", \"mode\"];\nconst entityIdHistoryNeedsAttributes = (hass, entityId) => !hass.states[entityId] || NEED_ATTRIBUTE_DOMAINS.includes((0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__.computeDomain)(entityId));\nconst fetchRecent = (hass, entityId, startTime, endTime, skipInitialState = false, significantChangesOnly, minimalResponse = true, noAttributes) => {\n  let url = \"history/period\";\n\n  if (startTime) {\n    url += \"/\" + startTime.toISOString();\n  }\n\n  url += \"?filter_entity_id=\" + entityId;\n\n  if (endTime) {\n    url += \"&end_time=\" + endTime.toISOString();\n  }\n\n  if (skipInitialState) {\n    url += \"&skip_initial_state\";\n  }\n\n  if (significantChangesOnly !== undefined) {\n    url += `&significant_changes_only=${Number(significantChangesOnly)}`;\n  }\n\n  if (minimalResponse) {\n    url += \"&minimal_response\";\n  }\n\n  if (noAttributes) {\n    url += \"&no_attributes\";\n  }\n\n  return hass.callApi(\"GET\", url);\n};\nconst fetchRecentWS = (hass, entityId, startTime, endTime, skipInitialState = false, significantChangesOnly, minimalResponse = true, noAttributes) => hass.callWS({\n  type: \"history/history_during_period\",\n  start_time: startTime.toISOString(),\n  end_time: endTime.toISOString(),\n  significant_changes_only: significantChangesOnly || false,\n  include_start_time_state: !skipInitialState,\n  minimal_response: minimalResponse,\n  no_attributes: noAttributes || false,\n  entity_ids: entityId.split(\",\")\n});\nconst fetchDate = (hass, startTime, endTime, entityIds) => hass.callApi(\"GET\", `history/period/${startTime.toISOString()}?end_time=${endTime.toISOString()}&minimal_response${entityIds ? `&filter_entity_id=${entityIds.join(\",\")}` : ``}`);\nconst fetchDateWS = (hass, startTime, endTime, entityIds) => {\n  const params = {\n    type: \"history/history_during_period\",\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.map(entityId => entityIdHistoryNeedsAttributes(hass, entityId)).reduce((cur, next) => cur || next, false)\n  };\n\n  if (entityIds.length !== 0) {\n    return hass.callWS({ ...params,\n      entity_ids: entityIds\n    });\n  }\n\n  return hass.callWS(params);\n};\n\nconst equalState = (obj1, obj2) => obj1.state === obj2.state && (!obj1.attributes || !obj2.attributes || LINE_ATTRIBUTES_TO_KEEP.every(attr => obj1.attributes[attr] === obj2.attributes[attr]));\n\nconst processTimelineEntity = (localize, language, entityId, states) => {\n  const data = [];\n  const first = states[0];\n\n  for (const state of states) {\n    if (data.length > 0 && state.s === data[data.length - 1].state) {\n      continue;\n    }\n\n    data.push({\n      state_localize: (0,_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__.computeStateDisplayFromEntityAttributes)(localize, language, entityId, state.a || first.a, state.s),\n      state: state.s,\n      // lc (last_changed) may be omitted if its the same\n      // as lu (last_updated).\n      last_changed: (state.lc ? state.lc : state.lu) * 1000\n    });\n  }\n\n  return {\n    name: (0,_common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__.computeStateNameFromEntityAttributes)(entityId, states[0].a),\n    entity_id: entityId,\n    data\n  };\n};\n\nconst processLineChartEntities = (unit, entities) => {\n  const data = [];\n  Object.keys(entities).forEach(entityId => {\n    const states = entities[entityId];\n    const first = states[0];\n    const domain = (0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__.computeDomain)(entityId);\n    const processedStates = [];\n\n    for (const state of states) {\n      let processedState;\n\n      if (DOMAINS_USE_LAST_UPDATED.includes(domain)) {\n        processedState = {\n          state: state.s,\n          last_changed: state.lu * 1000,\n          attributes: {}\n        };\n\n        for (const attr of LINE_ATTRIBUTES_TO_KEEP) {\n          if (attr in state.a) {\n            processedState.attributes[attr] = state.a[attr];\n          }\n        }\n      } else {\n        processedState = {\n          state: state.s,\n          // lc (last_changed) may be omitted if its the same\n          // as lu (last_updated).\n          last_changed: (state.lc ? state.lc : state.lu) * 1000,\n          attributes: {}\n        };\n      }\n\n      if (processedStates.length > 1 && equalState(processedState, processedStates[processedStates.length - 1]) && equalState(processedState, processedStates[processedStates.length - 2])) {\n        continue;\n      }\n\n      processedStates.push(processedState);\n    }\n\n    data.push({\n      domain,\n      name: (0,_common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__.computeStateNameFromEntityAttributes)(entityId, first.a),\n      entity_id: entityId,\n      states: processedStates\n    });\n  });\n  return {\n    unit,\n    identifier: Object.keys(entities).join(\"\"),\n    data\n  };\n};\n\nconst stateUsesUnits = state => attributesHaveUnits(state.attributes);\n\nconst attributesHaveUnits = attributes => \"unit_of_measurement\" in attributes || \"state_class\" in attributes;\n\nconst computeHistory = (hass, stateHistory, localize) => {\n  const lineChartDevices = {};\n  const timelineDevices = [];\n\n  if (!stateHistory) {\n    return {\n      line: [],\n      timeline: []\n    };\n  }\n\n  Object.keys(stateHistory).forEach(entityId => {\n    const stateInfo = stateHistory[entityId];\n\n    if (stateInfo.length === 0) {\n      return;\n    }\n\n    const currentState = entityId in hass.states ? hass.states[entityId] : undefined;\n    const stateWithUnitorStateClass = !currentState && stateInfo.find(state => state.a && attributesHaveUnits(state.a));\n    let unit;\n\n    if (currentState && stateUsesUnits(currentState)) {\n      unit = currentState.attributes.unit_of_measurement || \" \";\n    } else if (stateWithUnitorStateClass) {\n      unit = stateWithUnitorStateClass.a.unit_of_measurement || \" \";\n    } else {\n      unit = {\n        climate: hass.config.unit_system.temperature,\n        counter: \"#\",\n        humidifier: \"%\",\n        input_number: \"#\",\n        number: \"#\",\n        water_heater: hass.config.unit_system.temperature\n      }[(0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__.computeDomain)(entityId)];\n    }\n\n    if (!unit) {\n      timelineDevices.push(processTimelineEntity(localize, hass.locale, entityId, stateInfo));\n    } else if (unit in lineChartDevices && entityId in lineChartDevices[unit]) {\n      lineChartDevices[unit][entityId].push(...stateInfo);\n    } else {\n      if (!(unit in lineChartDevices)) {\n        lineChartDevices[unit] = {};\n      }\n\n      lineChartDevices[unit][entityId] = stateInfo;\n    }\n  });\n  const unitStates = Object.keys(lineChartDevices).map(unit => processLineChartEntities(unit, lineChartDevices[unit]));\n  return {\n    line: unitStates,\n    timeline: timelineDevices\n  };\n}; // Statistics\n\nconst getStatisticIds = (hass, statistic_type) => hass.callWS({\n  type: \"history/list_statistic_ids\",\n  statistic_type\n});\nconst getStatisticMetadata = (hass, statistic_ids) => hass.callWS({\n  type: \"recorder/get_statistics_metadata\",\n  statistic_ids\n});\nconst fetchStatistics = (hass, startTime, endTime, statistic_ids, period = \"hour\") => hass.callWS({\n  type: \"history/statistics_during_period\",\n  start_time: startTime.toISOString(),\n  end_time: endTime === null || endTime === void 0 ? void 0 : endTime.toISOString(),\n  statistic_ids,\n  period\n});\nconst validateStatistics = hass => hass.callWS({\n  type: \"recorder/validate_statistics\"\n});\nconst updateStatisticsMetadata = (hass, statistic_id, unit_of_measurement) => hass.callWS({\n  type: \"recorder/update_statistics_metadata\",\n  statistic_id,\n  unit_of_measurement\n});\nconst clearStatistics = (hass, statistic_ids) => hass.callWS({\n  type: \"recorder/clear_statistics\",\n  statistic_ids\n});\nconst calculateStatisticSumGrowth = values => {\n  if (!values || values.length < 2) {\n    return null;\n  }\n\n  const endSum = values[values.length - 1].sum;\n\n  if (endSum === null) {\n    return null;\n  }\n\n  const startSum = values[0].sum;\n\n  if (startSum === null) {\n    return endSum;\n  }\n\n  return endSum - startSum;\n};\nconst calculateStatisticsSumGrowth = (data, stats) => {\n  let totalGrowth = null;\n\n  for (const stat of stats) {\n    if (!(stat in data)) {\n      continue;\n    }\n\n    const statGrowth = calculateStatisticSumGrowth(data[stat]);\n\n    if (statGrowth === null) {\n      continue;\n    }\n\n    if (totalGrowth === null) {\n      totalGrowth = statGrowth;\n    } else {\n      totalGrowth += statGrowth;\n    }\n  }\n\n  return totalGrowth;\n};\nconst statisticsHaveType = (stats, type) => stats.some(stat => stat[type] !== null);\nconst adjustStatisticsSum = (hass, statistic_id, start_time, adjustment) => hass.callWS({\n  type: \"recorder/adjust_sum_statistics\",\n  statistic_id,\n  start_time,\n  adjustment\n});\nconst getStatisticLabel = (hass, statisticsId, statisticsMetaData) => {\n  const entity = hass.states[statisticsId];\n\n  if (entity) {\n    return (0,_common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__.computeStateName)(entity);\n  }\n\n  const statisticMetaData = statisticsMetaData[statisticsId];\n  return (statisticMetaData === null || statisticMetaData === void 0 ? void 0 : statisticMetaData.name) || statisticsId;\n};\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGF0YS9oaXN0b3J5LnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQU9BO0FBNklBO0FBT0E7QUFVQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFXQTtBQWFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7O0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBOztBQVdBO0FBTUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFFQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BOztBQUVBO0FBUUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUVBOztBQUdBOztBQUdBO0FBS0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7O0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBSUE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUtBO0FBQ0E7QUFGQTtBQUtBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFFQTtBQURBO0FBSUE7QUFNQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUtBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBS0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vc3JjL2RhdGEvaGlzdG9yeS50cz80YTUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhc3NFbnRpdHkgfSBmcm9tIFwiaG9tZS1hc3Npc3RhbnQtanMtd2Vic29ja2V0XCI7XG5pbXBvcnQgeyBjb21wdXRlRG9tYWluIH0gZnJvbSBcIi4uL2NvbW1vbi9lbnRpdHkvY29tcHV0ZV9kb21haW5cIjtcbmltcG9ydCB7IGNvbXB1dGVTdGF0ZURpc3BsYXlGcm9tRW50aXR5QXR0cmlidXRlcyB9IGZyb20gXCIuLi9jb21tb24vZW50aXR5L2NvbXB1dGVfc3RhdGVfZGlzcGxheVwiO1xuaW1wb3J0IHtcbiAgY29tcHV0ZVN0YXRlTmFtZSxcbiAgY29tcHV0ZVN0YXRlTmFtZUZyb21FbnRpdHlBdHRyaWJ1dGVzLFxufSBmcm9tIFwiLi4vY29tbW9uL2VudGl0eS9jb21wdXRlX3N0YXRlX25hbWVcIjtcbmltcG9ydCB7IExvY2FsaXplRnVuYyB9IGZyb20gXCIuLi9jb21tb24vdHJhbnNsYXRpb25zL2xvY2FsaXplXCI7XG5pbXBvcnQgeyBIb21lQXNzaXN0YW50IH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBGcm9udGVuZExvY2FsZURhdGEgfSBmcm9tIFwiLi90cmFuc2xhdGlvblwiO1xuXG5jb25zdCBET01BSU5TX1VTRV9MQVNUX1VQREFURUQgPSBbXCJjbGltYXRlXCIsIFwiaHVtaWRpZmllclwiLCBcIndhdGVyX2hlYXRlclwiXTtcbmNvbnN0IE5FRURfQVRUUklCVVRFX0RPTUFJTlMgPSBbXG4gIFwiY2xpbWF0ZVwiLFxuICBcImh1bWlkaWZpZXJcIixcbiAgXCJpbnB1dF9kYXRldGltZVwiLFxuICBcInRoZXJtb3N0YXRcIixcbiAgXCJ3YXRlcl9oZWF0ZXJcIixcbl07XG5jb25zdCBMSU5FX0FUVFJJQlVURVNfVE9fS0VFUCA9IFtcbiAgXCJ0ZW1wZXJhdHVyZVwiLFxuICBcImN1cnJlbnRfdGVtcGVyYXR1cmVcIixcbiAgXCJ0YXJnZXRfdGVtcF9sb3dcIixcbiAgXCJ0YXJnZXRfdGVtcF9oaWdoXCIsXG4gIFwiaHZhY19hY3Rpb25cIixcbiAgXCJodW1pZGl0eVwiLFxuICBcIm1vZGVcIixcbl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGluZUNoYXJ0U3RhdGUge1xuICBzdGF0ZTogc3RyaW5nO1xuICBsYXN0X2NoYW5nZWQ6IG51bWJlcjtcbiAgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGluZUNoYXJ0RW50aXR5IHtcbiAgZG9tYWluOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZW50aXR5X2lkOiBzdHJpbmc7XG4gIHN0YXRlczogTGluZUNoYXJ0U3RhdGVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaW5lQ2hhcnRVbml0IHtcbiAgdW5pdDogc3RyaW5nO1xuICBpZGVudGlmaWVyOiBzdHJpbmc7XG4gIGRhdGE6IExpbmVDaGFydEVudGl0eVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVsaW5lU3RhdGUge1xuICBzdGF0ZV9sb2NhbGl6ZTogc3RyaW5nO1xuICBzdGF0ZTogc3RyaW5nO1xuICBsYXN0X2NoYW5nZWQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaW1lbGluZUVudGl0eSB7XG4gIG5hbWU6IHN0cmluZztcbiAgZW50aXR5X2lkOiBzdHJpbmc7XG4gIGRhdGE6IFRpbWVsaW5lU3RhdGVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5UmVzdWx0IHtcbiAgbGluZTogTGluZUNoYXJ0VW5pdFtdO1xuICB0aW1lbGluZTogVGltZWxpbmVFbnRpdHlbXTtcbn1cblxuZXhwb3J0IHR5cGUgU3RhdGlzdGljVHlwZSA9IFwic3VtXCIgfCBcIm1pblwiIHwgXCJtYXhcIiB8IFwibWVhblwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpc3RpY3Mge1xuICBbc3RhdGlzdGljSWQ6IHN0cmluZ106IFN0YXRpc3RpY1ZhbHVlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGlzdGljVmFsdWUge1xuICBzdGF0aXN0aWNfaWQ6IHN0cmluZztcbiAgc3RhcnQ6IHN0cmluZztcbiAgZW5kOiBzdHJpbmc7XG4gIGxhc3RfcmVzZXQ6IHN0cmluZyB8IG51bGw7XG4gIG1heDogbnVtYmVyIHwgbnVsbDtcbiAgbWVhbjogbnVtYmVyIHwgbnVsbDtcbiAgbWluOiBudW1iZXIgfCBudWxsO1xuICBzdW06IG51bWJlciB8IG51bGw7XG4gIHN0YXRlOiBudW1iZXIgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpc3RpY3NNZXRhRGF0YSB7XG4gIHVuaXRfb2ZfbWVhc3VyZW1lbnQ6IHN0cmluZztcbiAgc3RhdGlzdGljX2lkOiBzdHJpbmc7XG4gIHNvdXJjZTogc3RyaW5nO1xuICBuYW1lPzogc3RyaW5nIHwgbnVsbDtcbiAgaGFzX3N1bTogYm9vbGVhbjtcbiAgaGFzX21lYW46IGJvb2xlYW47XG59XG5cbmV4cG9ydCB0eXBlIFN0YXRpc3RpY3NWYWxpZGF0aW9uUmVzdWx0ID1cbiAgfCBTdGF0aXN0aWNzVmFsaWRhdGlvblJlc3VsdE5vU3RhdGVcbiAgfCBTdGF0aXN0aWNzVmFsaWRhdGlvblJlc3VsdEVudGl0eU5vdFJlY29yZGVkXG4gIHwgU3RhdGlzdGljc1ZhbGlkYXRpb25SZXN1bHRFbnRpdHlOb0xvbmdlclJlY29yZGVkXG4gIHwgU3RhdGlzdGljc1ZhbGlkYXRpb25SZXN1bHRVbnN1cHBvcnRlZFN0YXRlQ2xhc3NcbiAgfCBTdGF0aXN0aWNzVmFsaWRhdGlvblJlc3VsdFVuaXRzQ2hhbmdlZFxuICB8IFN0YXRpc3RpY3NWYWxpZGF0aW9uUmVzdWx0VW5zdXBwb3J0ZWRVbml0TWV0YWRhdGFcbiAgfCBTdGF0aXN0aWNzVmFsaWRhdGlvblJlc3VsdFVuc3VwcG9ydGVkVW5pdFN0YXRlO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpc3RpY3NWYWxpZGF0aW9uUmVzdWx0Tm9TdGF0ZSB7XG4gIHR5cGU6IFwibm9fc3RhdGVcIjtcbiAgZGF0YTogeyBzdGF0aXN0aWNfaWQ6IHN0cmluZyB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpc3RpY3NWYWxpZGF0aW9uUmVzdWx0RW50aXR5Tm9Mb25nZXJSZWNvcmRlZCB7XG4gIHR5cGU6IFwiZW50aXR5X25vX2xvbmdlcl9yZWNvcmRlZFwiO1xuICBkYXRhOiB7IHN0YXRpc3RpY19pZDogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGlzdGljc1ZhbGlkYXRpb25SZXN1bHRFbnRpdHlOb3RSZWNvcmRlZCB7XG4gIHR5cGU6IFwiZW50aXR5X25vdF9yZWNvcmRlZFwiO1xuICBkYXRhOiB7IHN0YXRpc3RpY19pZDogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGlzdGljc1ZhbGlkYXRpb25SZXN1bHRVbnN1cHBvcnRlZFN0YXRlQ2xhc3Mge1xuICB0eXBlOiBcInVuc3VwcG9ydGVkX3N0YXRlX2NsYXNzXCI7XG4gIGRhdGE6IHsgc3RhdGlzdGljX2lkOiBzdHJpbmc7IHN0YXRlX2NsYXNzOiBzdHJpbmcgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aXN0aWNzVmFsaWRhdGlvblJlc3VsdFVuaXRzQ2hhbmdlZCB7XG4gIHR5cGU6IFwidW5pdHNfY2hhbmdlZFwiO1xuICBkYXRhOiB7IHN0YXRpc3RpY19pZDogc3RyaW5nOyBzdGF0ZV91bml0OiBzdHJpbmc7IG1ldGFkYXRhX3VuaXQ6IHN0cmluZyB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpc3RpY3NWYWxpZGF0aW9uUmVzdWx0VW5zdXBwb3J0ZWRVbml0TWV0YWRhdGEge1xuICB0eXBlOiBcInVuc3VwcG9ydGVkX3VuaXRfbWV0YWRhdGFcIjtcbiAgZGF0YToge1xuICAgIHN0YXRpc3RpY19pZDogc3RyaW5nO1xuICAgIGRldmljZV9jbGFzczogc3RyaW5nO1xuICAgIG1ldGFkYXRhX3VuaXQ6IHN0cmluZztcbiAgICBzdXBwb3J0ZWRfdW5pdDogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpc3RpY3NWYWxpZGF0aW9uUmVzdWx0VW5zdXBwb3J0ZWRVbml0U3RhdGUge1xuICB0eXBlOiBcInVuc3VwcG9ydGVkX3VuaXRfc3RhdGVcIjtcbiAgZGF0YTogeyBzdGF0aXN0aWNfaWQ6IHN0cmluZzsgZGV2aWNlX2NsYXNzOiBzdHJpbmc7IG1ldGFkYXRhX3VuaXQ6IHN0cmluZyB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpc3RpY3NWYWxpZGF0aW9uUmVzdWx0cyB7XG4gIFtzdGF0aXN0aWNJZDogc3RyaW5nXTogU3RhdGlzdGljc1ZhbGlkYXRpb25SZXN1bHRbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5U3RhdGVzIHtcbiAgW2VudGl0eUlkOiBzdHJpbmddOiBFbnRpdHlIaXN0b3J5U3RhdGVbXTtcbn1cblxuaW50ZXJmYWNlIEVudGl0eUhpc3RvcnlTdGF0ZSB7XG4gIC8qKiBzdGF0ZSAqL1xuICBzOiBzdHJpbmc7XG4gIC8qKiBhdHRyaWJ1dGVzICovXG4gIGE6IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIC8qKiBsYXN0X2NoYW5nZWQ7IGlmIHNldCwgYWxzbyBhcHBsaWVzIHRvIGx1ICovXG4gIGxjOiBudW1iZXI7XG4gIC8qKiBsYXN0X3VwZGF0ZWQgKi9cbiAgbHU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGVudGl0eUlkSGlzdG9yeU5lZWRzQXR0cmlidXRlcyA9IChcbiAgaGFzczogSG9tZUFzc2lzdGFudCxcbiAgZW50aXR5SWQ6IHN0cmluZ1xuKSA9PlxuICAhaGFzcy5zdGF0ZXNbZW50aXR5SWRdIHx8XG4gIE5FRURfQVRUUklCVVRFX0RPTUFJTlMuaW5jbHVkZXMoY29tcHV0ZURvbWFpbihlbnRpdHlJZCkpO1xuXG5leHBvcnQgY29uc3QgZmV0Y2hSZWNlbnQgPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIGVudGl0eUlkOiBzdHJpbmcsXG4gIHN0YXJ0VGltZTogRGF0ZSxcbiAgZW5kVGltZTogRGF0ZSxcbiAgc2tpcEluaXRpYWxTdGF0ZSA9IGZhbHNlLFxuICBzaWduaWZpY2FudENoYW5nZXNPbmx5PzogYm9vbGVhbixcbiAgbWluaW1hbFJlc3BvbnNlID0gdHJ1ZSxcbiAgbm9BdHRyaWJ1dGVzPzogYm9vbGVhblxuKTogUHJvbWlzZTxIYXNzRW50aXR5W11bXT4gPT4ge1xuICBsZXQgdXJsID0gXCJoaXN0b3J5L3BlcmlvZFwiO1xuICBpZiAoc3RhcnRUaW1lKSB7XG4gICAgdXJsICs9IFwiL1wiICsgc3RhcnRUaW1lLnRvSVNPU3RyaW5nKCk7XG4gIH1cbiAgdXJsICs9IFwiP2ZpbHRlcl9lbnRpdHlfaWQ9XCIgKyBlbnRpdHlJZDtcbiAgaWYgKGVuZFRpbWUpIHtcbiAgICB1cmwgKz0gXCImZW5kX3RpbWU9XCIgKyBlbmRUaW1lLnRvSVNPU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHNraXBJbml0aWFsU3RhdGUpIHtcbiAgICB1cmwgKz0gXCImc2tpcF9pbml0aWFsX3N0YXRlXCI7XG4gIH1cbiAgaWYgKHNpZ25pZmljYW50Q2hhbmdlc09ubHkgIT09IHVuZGVmaW5lZCkge1xuICAgIHVybCArPSBgJnNpZ25pZmljYW50X2NoYW5nZXNfb25seT0ke051bWJlcihzaWduaWZpY2FudENoYW5nZXNPbmx5KX1gO1xuICB9XG4gIGlmIChtaW5pbWFsUmVzcG9uc2UpIHtcbiAgICB1cmwgKz0gXCImbWluaW1hbF9yZXNwb25zZVwiO1xuICB9XG4gIGlmIChub0F0dHJpYnV0ZXMpIHtcbiAgICB1cmwgKz0gXCImbm9fYXR0cmlidXRlc1wiO1xuICB9XG4gIHJldHVybiBoYXNzLmNhbGxBcGkoXCJHRVRcIiwgdXJsKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmZXRjaFJlY2VudFdTID0gKFxuICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICBlbnRpdHlJZDogc3RyaW5nLCAvLyBUaGlzIG1heSBiZSBDU1ZcbiAgc3RhcnRUaW1lOiBEYXRlLFxuICBlbmRUaW1lOiBEYXRlLFxuICBza2lwSW5pdGlhbFN0YXRlID0gZmFsc2UsXG4gIHNpZ25pZmljYW50Q2hhbmdlc09ubHk/OiBib29sZWFuLFxuICBtaW5pbWFsUmVzcG9uc2UgPSB0cnVlLFxuICBub0F0dHJpYnV0ZXM/OiBib29sZWFuXG4pID0+XG4gIGhhc3MuY2FsbFdTPEhpc3RvcnlTdGF0ZXM+KHtcbiAgICB0eXBlOiBcImhpc3RvcnkvaGlzdG9yeV9kdXJpbmdfcGVyaW9kXCIsXG4gICAgc3RhcnRfdGltZTogc3RhcnRUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgZW5kX3RpbWU6IGVuZFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICBzaWduaWZpY2FudF9jaGFuZ2VzX29ubHk6IHNpZ25pZmljYW50Q2hhbmdlc09ubHkgfHwgZmFsc2UsXG4gICAgaW5jbHVkZV9zdGFydF90aW1lX3N0YXRlOiAhc2tpcEluaXRpYWxTdGF0ZSxcbiAgICBtaW5pbWFsX3Jlc3BvbnNlOiBtaW5pbWFsUmVzcG9uc2UsXG4gICAgbm9fYXR0cmlidXRlczogbm9BdHRyaWJ1dGVzIHx8IGZhbHNlLFxuICAgIGVudGl0eV9pZHM6IGVudGl0eUlkLnNwbGl0KFwiLFwiKSxcbiAgfSk7XG5cbmV4cG9ydCBjb25zdCBmZXRjaERhdGUgPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIHN0YXJ0VGltZTogRGF0ZSxcbiAgZW5kVGltZTogRGF0ZSxcbiAgZW50aXR5SWRzOiBzdHJpbmdbXVxuKTogUHJvbWlzZTxIYXNzRW50aXR5W11bXT4gPT5cbiAgaGFzcy5jYWxsQXBpKFxuICAgIFwiR0VUXCIsXG4gICAgYGhpc3RvcnkvcGVyaW9kLyR7c3RhcnRUaW1lLnRvSVNPU3RyaW5nKCl9P2VuZF90aW1lPSR7ZW5kVGltZS50b0lTT1N0cmluZygpfSZtaW5pbWFsX3Jlc3BvbnNlJHtcbiAgICAgIGVudGl0eUlkcyA/IGAmZmlsdGVyX2VudGl0eV9pZD0ke2VudGl0eUlkcy5qb2luKFwiLFwiKX1gIDogYGBcbiAgICB9YFxuICApO1xuXG5leHBvcnQgY29uc3QgZmV0Y2hEYXRlV1MgPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIHN0YXJ0VGltZTogRGF0ZSxcbiAgZW5kVGltZTogRGF0ZSxcbiAgZW50aXR5SWRzOiBzdHJpbmdbXVxuKSA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICB0eXBlOiBcImhpc3RvcnkvaGlzdG9yeV9kdXJpbmdfcGVyaW9kXCIsXG4gICAgc3RhcnRfdGltZTogc3RhcnRUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgZW5kX3RpbWU6IGVuZFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICBtaW5pbWFsX3Jlc3BvbnNlOiB0cnVlLFxuICAgIG5vX2F0dHJpYnV0ZXM6ICFlbnRpdHlJZHNcbiAgICAgIC5tYXAoKGVudGl0eUlkKSA9PiBlbnRpdHlJZEhpc3RvcnlOZWVkc0F0dHJpYnV0ZXMoaGFzcywgZW50aXR5SWQpKVxuICAgICAgLnJlZHVjZSgoY3VyLCBuZXh0KSA9PiBjdXIgfHwgbmV4dCwgZmFsc2UpLFxuICB9O1xuICBpZiAoZW50aXR5SWRzLmxlbmd0aCAhPT0gMCkge1xuICAgIHJldHVybiBoYXNzLmNhbGxXUzxIaXN0b3J5U3RhdGVzPih7IC4uLnBhcmFtcywgZW50aXR5X2lkczogZW50aXR5SWRzIH0pO1xuICB9XG4gIHJldHVybiBoYXNzLmNhbGxXUzxIaXN0b3J5U3RhdGVzPihwYXJhbXMpO1xufTtcblxuY29uc3QgZXF1YWxTdGF0ZSA9IChvYmoxOiBMaW5lQ2hhcnRTdGF0ZSwgb2JqMjogTGluZUNoYXJ0U3RhdGUpID0+XG4gIG9iajEuc3RhdGUgPT09IG9iajIuc3RhdGUgJiZcbiAgLy8gT25seSBjb21wYXJlIGF0dHJpYnV0ZXMgaWYgYm90aCBzdGF0ZXMgaGF2ZSBhbiBhdHRyaWJ1dGVzIG9iamVjdC5cbiAgLy8gV2hlbiBgbWluaW1hbF9yZXNwb25zZWAgaXMgc2VudCwgb25seSB0aGUgZmlyc3QgYW5kIGxhc3Qgc3RhdGVcbiAgLy8gd2lsbCBoYXZlIGF0dHJpYnV0ZXMgZXhjZXB0IGZvciBkb21haW5zIGluIERPTUFJTlNfVVNFX0xBU1RfVVBEQVRFRC5cbiAgKCFvYmoxLmF0dHJpYnV0ZXMgfHxcbiAgICAhb2JqMi5hdHRyaWJ1dGVzIHx8XG4gICAgTElORV9BVFRSSUJVVEVTX1RPX0tFRVAuZXZlcnkoXG4gICAgICAoYXR0cikgPT4gb2JqMS5hdHRyaWJ1dGVzIVthdHRyXSA9PT0gb2JqMi5hdHRyaWJ1dGVzIVthdHRyXVxuICAgICkpO1xuXG5jb25zdCBwcm9jZXNzVGltZWxpbmVFbnRpdHkgPSAoXG4gIGxvY2FsaXplOiBMb2NhbGl6ZUZ1bmMsXG4gIGxhbmd1YWdlOiBGcm9udGVuZExvY2FsZURhdGEsXG4gIGVudGl0eUlkOiBzdHJpbmcsXG4gIHN0YXRlczogRW50aXR5SGlzdG9yeVN0YXRlW11cbik6IFRpbWVsaW5lRW50aXR5ID0+IHtcbiAgY29uc3QgZGF0YTogVGltZWxpbmVTdGF0ZVtdID0gW107XG4gIGNvbnN0IGZpcnN0OiBFbnRpdHlIaXN0b3J5U3RhdGUgPSBzdGF0ZXNbMF07XG4gIGZvciAoY29uc3Qgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCAmJiBzdGF0ZS5zID09PSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc3RhdGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBkYXRhLnB1c2goe1xuICAgICAgc3RhdGVfbG9jYWxpemU6IGNvbXB1dGVTdGF0ZURpc3BsYXlGcm9tRW50aXR5QXR0cmlidXRlcyhcbiAgICAgICAgbG9jYWxpemUsXG4gICAgICAgIGxhbmd1YWdlLFxuICAgICAgICBlbnRpdHlJZCxcbiAgICAgICAgc3RhdGUuYSB8fCBmaXJzdC5hLFxuICAgICAgICBzdGF0ZS5zXG4gICAgICApLFxuICAgICAgc3RhdGU6IHN0YXRlLnMsXG4gICAgICAvLyBsYyAobGFzdF9jaGFuZ2VkKSBtYXkgYmUgb21pdHRlZCBpZiBpdHMgdGhlIHNhbWVcbiAgICAgIC8vIGFzIGx1IChsYXN0X3VwZGF0ZWQpLlxuICAgICAgbGFzdF9jaGFuZ2VkOiAoc3RhdGUubGMgPyBzdGF0ZS5sYyA6IHN0YXRlLmx1KSAqIDEwMDAsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IGNvbXB1dGVTdGF0ZU5hbWVGcm9tRW50aXR5QXR0cmlidXRlcyhlbnRpdHlJZCwgc3RhdGVzWzBdLmEpLFxuICAgIGVudGl0eV9pZDogZW50aXR5SWQsXG4gICAgZGF0YSxcbiAgfTtcbn07XG5cbmNvbnN0IHByb2Nlc3NMaW5lQ2hhcnRFbnRpdGllcyA9IChcbiAgdW5pdCxcbiAgZW50aXRpZXM6IEhpc3RvcnlTdGF0ZXNcbik6IExpbmVDaGFydFVuaXQgPT4ge1xuICBjb25zdCBkYXRhOiBMaW5lQ2hhcnRFbnRpdHlbXSA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKGVudGl0aWVzKS5mb3JFYWNoKChlbnRpdHlJZCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlcyA9IGVudGl0aWVzW2VudGl0eUlkXTtcbiAgICBjb25zdCBmaXJzdDogRW50aXR5SGlzdG9yeVN0YXRlID0gc3RhdGVzWzBdO1xuICAgIGNvbnN0IGRvbWFpbiA9IGNvbXB1dGVEb21haW4oZW50aXR5SWQpO1xuICAgIGNvbnN0IHByb2Nlc3NlZFN0YXRlczogTGluZUNoYXJ0U3RhdGVbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBzdGF0ZSBvZiBzdGF0ZXMpIHtcbiAgICAgIGxldCBwcm9jZXNzZWRTdGF0ZTogTGluZUNoYXJ0U3RhdGU7XG5cbiAgICAgIGlmIChET01BSU5TX1VTRV9MQVNUX1VQREFURUQuaW5jbHVkZXMoZG9tYWluKSkge1xuICAgICAgICBwcm9jZXNzZWRTdGF0ZSA9IHtcbiAgICAgICAgICBzdGF0ZTogc3RhdGUucyxcbiAgICAgICAgICBsYXN0X2NoYW5nZWQ6IHN0YXRlLmx1ICogMTAwMCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgTElORV9BVFRSSUJVVEVTX1RPX0tFRVApIHtcbiAgICAgICAgICBpZiAoYXR0ciBpbiBzdGF0ZS5hKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRTdGF0ZS5hdHRyaWJ1dGVzIVthdHRyXSA9IHN0YXRlLmFbYXR0cl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzZWRTdGF0ZSA9IHtcbiAgICAgICAgICBzdGF0ZTogc3RhdGUucyxcbiAgICAgICAgICAvLyBsYyAobGFzdF9jaGFuZ2VkKSBtYXkgYmUgb21pdHRlZCBpZiBpdHMgdGhlIHNhbWVcbiAgICAgICAgICAvLyBhcyBsdSAobGFzdF91cGRhdGVkKS5cbiAgICAgICAgICBsYXN0X2NoYW5nZWQ6IChzdGF0ZS5sYyA/IHN0YXRlLmxjIDogc3RhdGUubHUpICogMTAwMCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBwcm9jZXNzZWRTdGF0ZXMubGVuZ3RoID4gMSAmJlxuICAgICAgICBlcXVhbFN0YXRlKFxuICAgICAgICAgIHByb2Nlc3NlZFN0YXRlLFxuICAgICAgICAgIHByb2Nlc3NlZFN0YXRlc1twcm9jZXNzZWRTdGF0ZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgKSAmJlxuICAgICAgICBlcXVhbFN0YXRlKHByb2Nlc3NlZFN0YXRlLCBwcm9jZXNzZWRTdGF0ZXNbcHJvY2Vzc2VkU3RhdGVzLmxlbmd0aCAtIDJdKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzZWRTdGF0ZXMucHVzaChwcm9jZXNzZWRTdGF0ZSk7XG4gICAgfVxuXG4gICAgZGF0YS5wdXNoKHtcbiAgICAgIGRvbWFpbixcbiAgICAgIG5hbWU6IGNvbXB1dGVTdGF0ZU5hbWVGcm9tRW50aXR5QXR0cmlidXRlcyhlbnRpdHlJZCwgZmlyc3QuYSksXG4gICAgICBlbnRpdHlfaWQ6IGVudGl0eUlkLFxuICAgICAgc3RhdGVzOiBwcm9jZXNzZWRTdGF0ZXMsXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgdW5pdCxcbiAgICBpZGVudGlmaWVyOiBPYmplY3Qua2V5cyhlbnRpdGllcykuam9pbihcIlwiKSxcbiAgICBkYXRhLFxuICB9O1xufTtcblxuY29uc3Qgc3RhdGVVc2VzVW5pdHMgPSAoc3RhdGU6IEhhc3NFbnRpdHkpID0+XG4gIGF0dHJpYnV0ZXNIYXZlVW5pdHMoc3RhdGUuYXR0cmlidXRlcyk7XG5cbmNvbnN0IGF0dHJpYnV0ZXNIYXZlVW5pdHMgPSAoYXR0cmlidXRlczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSkgPT5cbiAgXCJ1bml0X29mX21lYXN1cmVtZW50XCIgaW4gYXR0cmlidXRlcyB8fCBcInN0YXRlX2NsYXNzXCIgaW4gYXR0cmlidXRlcztcblxuZXhwb3J0IGNvbnN0IGNvbXB1dGVIaXN0b3J5ID0gKFxuICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICBzdGF0ZUhpc3Rvcnk6IEhpc3RvcnlTdGF0ZXMsXG4gIGxvY2FsaXplOiBMb2NhbGl6ZUZ1bmNcbik6IEhpc3RvcnlSZXN1bHQgPT4ge1xuICBjb25zdCBsaW5lQ2hhcnREZXZpY2VzOiB7IFt1bml0OiBzdHJpbmddOiBIaXN0b3J5U3RhdGVzIH0gPSB7fTtcbiAgY29uc3QgdGltZWxpbmVEZXZpY2VzOiBUaW1lbGluZUVudGl0eVtdID0gW107XG4gIGlmICghc3RhdGVIaXN0b3J5KSB7XG4gICAgcmV0dXJuIHsgbGluZTogW10sIHRpbWVsaW5lOiBbXSB9O1xuICB9XG4gIE9iamVjdC5rZXlzKHN0YXRlSGlzdG9yeSkuZm9yRWFjaCgoZW50aXR5SWQpID0+IHtcbiAgICBjb25zdCBzdGF0ZUluZm8gPSBzdGF0ZUhpc3RvcnlbZW50aXR5SWRdO1xuICAgIGlmIChzdGF0ZUluZm8ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFN0YXRlID1cbiAgICAgIGVudGl0eUlkIGluIGhhc3Muc3RhdGVzID8gaGFzcy5zdGF0ZXNbZW50aXR5SWRdIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHN0YXRlV2l0aFVuaXRvclN0YXRlQ2xhc3MgPVxuICAgICAgIWN1cnJlbnRTdGF0ZSAmJlxuICAgICAgc3RhdGVJbmZvLmZpbmQoKHN0YXRlKSA9PiBzdGF0ZS5hICYmIGF0dHJpYnV0ZXNIYXZlVW5pdHMoc3RhdGUuYSkpO1xuXG4gICAgbGV0IHVuaXQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgIGlmIChjdXJyZW50U3RhdGUgJiYgc3RhdGVVc2VzVW5pdHMoY3VycmVudFN0YXRlKSkge1xuICAgICAgdW5pdCA9IGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVzLnVuaXRfb2ZfbWVhc3VyZW1lbnQgfHwgXCIgXCI7XG4gICAgfSBlbHNlIGlmIChzdGF0ZVdpdGhVbml0b3JTdGF0ZUNsYXNzKSB7XG4gICAgICB1bml0ID0gc3RhdGVXaXRoVW5pdG9yU3RhdGVDbGFzcy5hLnVuaXRfb2ZfbWVhc3VyZW1lbnQgfHwgXCIgXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXQgPSB7XG4gICAgICAgIGNsaW1hdGU6IGhhc3MuY29uZmlnLnVuaXRfc3lzdGVtLnRlbXBlcmF0dXJlLFxuICAgICAgICBjb3VudGVyOiBcIiNcIixcbiAgICAgICAgaHVtaWRpZmllcjogXCIlXCIsXG4gICAgICAgIGlucHV0X251bWJlcjogXCIjXCIsXG4gICAgICAgIG51bWJlcjogXCIjXCIsXG4gICAgICAgIHdhdGVyX2hlYXRlcjogaGFzcy5jb25maWcudW5pdF9zeXN0ZW0udGVtcGVyYXR1cmUsXG4gICAgICB9W2NvbXB1dGVEb21haW4oZW50aXR5SWQpXTtcbiAgICB9XG5cbiAgICBpZiAoIXVuaXQpIHtcbiAgICAgIHRpbWVsaW5lRGV2aWNlcy5wdXNoKFxuICAgICAgICBwcm9jZXNzVGltZWxpbmVFbnRpdHkobG9jYWxpemUsIGhhc3MubG9jYWxlLCBlbnRpdHlJZCwgc3RhdGVJbmZvKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHVuaXQgaW4gbGluZUNoYXJ0RGV2aWNlcyAmJiBlbnRpdHlJZCBpbiBsaW5lQ2hhcnREZXZpY2VzW3VuaXRdKSB7XG4gICAgICBsaW5lQ2hhcnREZXZpY2VzW3VuaXRdW2VudGl0eUlkXS5wdXNoKC4uLnN0YXRlSW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHVuaXQgaW4gbGluZUNoYXJ0RGV2aWNlcykpIHtcbiAgICAgICAgbGluZUNoYXJ0RGV2aWNlc1t1bml0XSA9IHt9O1xuICAgICAgfVxuICAgICAgbGluZUNoYXJ0RGV2aWNlc1t1bml0XVtlbnRpdHlJZF0gPSBzdGF0ZUluZm87XG4gICAgfVxuICB9KTtcblxuICBjb25zdCB1bml0U3RhdGVzID0gT2JqZWN0LmtleXMobGluZUNoYXJ0RGV2aWNlcykubWFwKCh1bml0KSA9PlxuICAgIHByb2Nlc3NMaW5lQ2hhcnRFbnRpdGllcyh1bml0LCBsaW5lQ2hhcnREZXZpY2VzW3VuaXRdKVxuICApO1xuXG4gIHJldHVybiB7IGxpbmU6IHVuaXRTdGF0ZXMsIHRpbWVsaW5lOiB0aW1lbGluZURldmljZXMgfTtcbn07XG5cbi8vIFN0YXRpc3RpY3NcblxuZXhwb3J0IGNvbnN0IGdldFN0YXRpc3RpY0lkcyA9IChcbiAgaGFzczogSG9tZUFzc2lzdGFudCxcbiAgc3RhdGlzdGljX3R5cGU/OiBcIm1lYW5cIiB8IFwic3VtXCJcbikgPT5cbiAgaGFzcy5jYWxsV1M8U3RhdGlzdGljc01ldGFEYXRhW10+KHtcbiAgICB0eXBlOiBcImhpc3RvcnkvbGlzdF9zdGF0aXN0aWNfaWRzXCIsXG4gICAgc3RhdGlzdGljX3R5cGUsXG4gIH0pO1xuXG5leHBvcnQgY29uc3QgZ2V0U3RhdGlzdGljTWV0YWRhdGEgPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIHN0YXRpc3RpY19pZHM/OiBzdHJpbmdbXVxuKSA9PlxuICBoYXNzLmNhbGxXUzxTdGF0aXN0aWNzTWV0YURhdGFbXT4oe1xuICAgIHR5cGU6IFwicmVjb3JkZXIvZ2V0X3N0YXRpc3RpY3NfbWV0YWRhdGFcIixcbiAgICBzdGF0aXN0aWNfaWRzLFxuICB9KTtcblxuZXhwb3J0IGNvbnN0IGZldGNoU3RhdGlzdGljcyA9IChcbiAgaGFzczogSG9tZUFzc2lzdGFudCxcbiAgc3RhcnRUaW1lOiBEYXRlLFxuICBlbmRUaW1lPzogRGF0ZSxcbiAgc3RhdGlzdGljX2lkcz86IHN0cmluZ1tdLFxuICBwZXJpb2Q6IFwiNW1pbnV0ZVwiIHwgXCJob3VyXCIgfCBcImRheVwiIHwgXCJtb250aFwiID0gXCJob3VyXCJcbikgPT5cbiAgaGFzcy5jYWxsV1M8U3RhdGlzdGljcz4oe1xuICAgIHR5cGU6IFwiaGlzdG9yeS9zdGF0aXN0aWNzX2R1cmluZ19wZXJpb2RcIixcbiAgICBzdGFydF90aW1lOiBzdGFydFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICBlbmRfdGltZTogZW5kVGltZT8udG9JU09TdHJpbmcoKSxcbiAgICBzdGF0aXN0aWNfaWRzLFxuICAgIHBlcmlvZCxcbiAgfSk7XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVN0YXRpc3RpY3MgPSAoaGFzczogSG9tZUFzc2lzdGFudCkgPT5cbiAgaGFzcy5jYWxsV1M8U3RhdGlzdGljc1ZhbGlkYXRpb25SZXN1bHRzPih7XG4gICAgdHlwZTogXCJyZWNvcmRlci92YWxpZGF0ZV9zdGF0aXN0aWNzXCIsXG4gIH0pO1xuXG5leHBvcnQgY29uc3QgdXBkYXRlU3RhdGlzdGljc01ldGFkYXRhID0gKFxuICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICBzdGF0aXN0aWNfaWQ6IHN0cmluZyxcbiAgdW5pdF9vZl9tZWFzdXJlbWVudDogc3RyaW5nIHwgbnVsbFxuKSA9PlxuICBoYXNzLmNhbGxXUzx2b2lkPih7XG4gICAgdHlwZTogXCJyZWNvcmRlci91cGRhdGVfc3RhdGlzdGljc19tZXRhZGF0YVwiLFxuICAgIHN0YXRpc3RpY19pZCxcbiAgICB1bml0X29mX21lYXN1cmVtZW50LFxuICB9KTtcblxuZXhwb3J0IGNvbnN0IGNsZWFyU3RhdGlzdGljcyA9IChoYXNzOiBIb21lQXNzaXN0YW50LCBzdGF0aXN0aWNfaWRzOiBzdHJpbmdbXSkgPT5cbiAgaGFzcy5jYWxsV1M8dm9pZD4oe1xuICAgIHR5cGU6IFwicmVjb3JkZXIvY2xlYXJfc3RhdGlzdGljc1wiLFxuICAgIHN0YXRpc3RpY19pZHMsXG4gIH0pO1xuXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlU3RhdGlzdGljU3VtR3Jvd3RoID0gKFxuICB2YWx1ZXM6IFN0YXRpc3RpY1ZhbHVlW11cbik6IG51bWJlciB8IG51bGwgPT4ge1xuICBpZiAoIXZhbHVlcyB8fCB2YWx1ZXMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGVuZFN1bSA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0uc3VtO1xuICBpZiAoZW5kU3VtID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc3RhcnRTdW0gPSB2YWx1ZXNbMF0uc3VtO1xuICBpZiAoc3RhcnRTdW0gPT09IG51bGwpIHtcbiAgICByZXR1cm4gZW5kU3VtO1xuICB9XG4gIHJldHVybiBlbmRTdW0gLSBzdGFydFN1bTtcbn07XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVTdGF0aXN0aWNzU3VtR3Jvd3RoID0gKFxuICBkYXRhOiBTdGF0aXN0aWNzLFxuICBzdGF0czogc3RyaW5nW11cbik6IG51bWJlciB8IG51bGwgPT4ge1xuICBsZXQgdG90YWxHcm93dGg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIGZvciAoY29uc3Qgc3RhdCBvZiBzdGF0cykge1xuICAgIGlmICghKHN0YXQgaW4gZGF0YSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBzdGF0R3Jvd3RoID0gY2FsY3VsYXRlU3RhdGlzdGljU3VtR3Jvd3RoKGRhdGFbc3RhdF0pO1xuXG4gICAgaWYgKHN0YXRHcm93dGggPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodG90YWxHcm93dGggPT09IG51bGwpIHtcbiAgICAgIHRvdGFsR3Jvd3RoID0gc3RhdEdyb3d0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG90YWxHcm93dGggKz0gc3RhdEdyb3d0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG90YWxHcm93dGg7XG59O1xuXG5leHBvcnQgY29uc3Qgc3RhdGlzdGljc0hhdmVUeXBlID0gKFxuICBzdGF0czogU3RhdGlzdGljVmFsdWVbXSxcbiAgdHlwZTogU3RhdGlzdGljVHlwZVxuKSA9PiBzdGF0cy5zb21lKChzdGF0KSA9PiBzdGF0W3R5cGVdICE9PSBudWxsKTtcblxuZXhwb3J0IGNvbnN0IGFkanVzdFN0YXRpc3RpY3NTdW0gPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIHN0YXRpc3RpY19pZDogc3RyaW5nLFxuICBzdGFydF90aW1lOiBzdHJpbmcsXG4gIGFkanVzdG1lbnQ6IG51bWJlclxuKTogUHJvbWlzZTx2b2lkPiA9PlxuICBoYXNzLmNhbGxXUyh7XG4gICAgdHlwZTogXCJyZWNvcmRlci9hZGp1c3Rfc3VtX3N0YXRpc3RpY3NcIixcbiAgICBzdGF0aXN0aWNfaWQsXG4gICAgc3RhcnRfdGltZSxcbiAgICBhZGp1c3RtZW50LFxuICB9KTtcblxuZXhwb3J0IGNvbnN0IGdldFN0YXRpc3RpY0xhYmVsID0gKFxuICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICBzdGF0aXN0aWNzSWQ6IHN0cmluZyxcbiAgc3RhdGlzdGljc01ldGFEYXRhOiBSZWNvcmQ8c3RyaW5nLCBTdGF0aXN0aWNzTWV0YURhdGE+XG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBlbnRpdHkgPSBoYXNzLnN0YXRlc1tzdGF0aXN0aWNzSWRdO1xuICBpZiAoZW50aXR5KSB7XG4gICAgcmV0dXJuIGNvbXB1dGVTdGF0ZU5hbWUoZW50aXR5KTtcbiAgfVxuICBjb25zdCBzdGF0aXN0aWNNZXRhRGF0YSA9IHN0YXRpc3RpY3NNZXRhRGF0YVtzdGF0aXN0aWNzSWRdO1xuICByZXR1cm4gc3RhdGlzdGljTWV0YURhdGE/Lm5hbWUgfHwgc3RhdGlzdGljc0lkO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/data/history.ts\n");

/***/ }),

/***/ "./src/panels/lovelace/cards/hui-map-card.ts":
/*!***************************************************!*\
  !*** ./src/panels/lovelace/cards/hui-map-card.ts ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/decorators */ \"./node_modules/lit/decorators.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! memoize-one */ \"./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var _common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/entity/compute_domain */ \"./src/common/entity/compute_domain.ts\");\n/* harmony import */ var _common_util_parse_aspect_ratio__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/util/parse-aspect-ratio */ \"./src/common/util/parse-aspect-ratio.ts\");\n/* harmony import */ var _components_ha_card__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/ha-card */ \"./src/components/ha-card.ts\");\n/* harmony import */ var _components_ha_icon_button__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/ha-icon-button */ \"./src/components/ha-icon-button.ts\");\n/* harmony import */ var _data_history__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../data/history */ \"./src/data/history.ts\");\n/* harmony import */ var _common_find_entities__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/find-entities */ \"./src/panels/lovelace/common/find-entities.ts\");\n/* harmony import */ var _common_process_config_entities__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/process-config-entities */ \"./src/panels/lovelace/common/process-config-entities.ts\");\n/* harmony import */ var _components_map_ha_map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../components/map/ha-map */ \"./src/components/map/ha-map.ts\");\n/* harmony import */ var _common_color_colors__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../common/color/colors */ \"./src/common/color/colors.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_data_history__WEBPACK_IMPORTED_MODULE_6__]);\n_data_history__WEBPACK_IMPORTED_MODULE_6__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function () { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function (O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function (F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function (receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function (elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function (element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function (element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function (elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function (element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function (elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function (elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function (elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function (elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function (obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function (constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function (obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function (other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nconst mdiImageFilterCenterFocus = \"M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M19,19H15V21H19A2,2 0 0,0 21,19V15H19M19,3H15V5H19V9H21V5A2,2 0 0,0 19,3M5,5H9V3H5A2,2 0 0,0 3,5V9H5M5,15H3V19A2,2 0 0,0 5,21H9V19H5V15Z\";\n\n\n\n\n\n\n\n\n\n\nconst MINUTE = 60000;\n\nlet HuiMapCard = _decorate([(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.customElement)(\"hui-map-card\")], function (_initialize, _LitElement) {\n  class HuiMapCard extends _LitElement {\n    constructor(...args) {\n      super(...args);\n\n      _initialize(this);\n    }\n\n  }\n\n  return {\n    F: HuiMapCard,\n    d: [{\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        type: Boolean,\n        reflect: true\n      })],\n      key: \"isPanel\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.state)()],\n      key: \"_history\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.state)()],\n      key: \"_config\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.query)(\"ha-map\")],\n      key: \"_map\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_date\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_configEntities\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_colorDict\",\n\n      value() {\n        return {};\n      }\n\n    }, {\n      kind: \"field\",\n      key: \"_colorIndex\",\n\n      value() {\n        return 0;\n      }\n\n    }, {\n      kind: \"method\",\n      key: \"setConfig\",\n      value: function setConfig(config) {\n        var _config$entities;\n\n        if (!config) {\n          throw new Error(\"Error in card configuration.\");\n        }\n\n        if (!((_config$entities = config.entities) !== null && _config$entities !== void 0 && _config$entities.length) && !config.geo_location_sources) {\n          throw new Error(\"Either entities or geo_location_sources must be specified\");\n        }\n\n        if (config.entities && !Array.isArray(config.entities)) {\n          throw new Error(\"Entities need to be an array\");\n        }\n\n        if (config.geo_location_sources && !Array.isArray(config.geo_location_sources)) {\n          throw new Error(\"Geo_location_sources needs to be an array\");\n        }\n\n        this._config = config;\n        this._configEntities = (config.entities ? (0,_common_process_config_entities__WEBPACK_IMPORTED_MODULE_8__.processConfigEntities)(config.entities) : []).map(entity => entity.entity);\n\n        this._cleanupHistory();\n      }\n    }, {\n      kind: \"method\",\n      key: \"getCardSize\",\n      value: function getCardSize() {\n        var _this$_config;\n\n        if (!((_this$_config = this._config) !== null && _this$_config !== void 0 && _this$_config.aspect_ratio)) {\n          return 7;\n        }\n\n        const ratio = (0,_common_util_parse_aspect_ratio__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this._config.aspect_ratio);\n        const ar = ratio && ratio.w > 0 && ratio.h > 0 ? `${(100 * ratio.h / ratio.w).toFixed(2)}` : \"100\";\n        return 1 + Math.floor(Number(ar) / 25) || 3;\n      }\n    }, {\n      kind: \"method\",\n      static: true,\n      key: \"getConfigElement\",\n      value: async function getConfigElement() {\n        await Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_material_mwc-floating-label_mwc-floating-label-directive_js-node_modules-1dc920\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-textfield_mwc-textfield-base_js-node_modules_material_mwc-t-32f0d5\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-list_mwc-list-item-base_js-node_modules_material_mwc-list_m-ec3d2e\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-list_mwc-list_js\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-select_mwc-select-base_js-node_modules_material_mwc-select_-a6020b\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-menu_mwc-menu-surface_js\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-menu_mwc-menu_js\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-checkbox_mwc-checkbox-base_js-node_modules_material_mwc-che-43cf78\"), __webpack_require__.e(\"vendors-node_modules_material_mwc-radio_mwc-radio-base_js-node_modules_material_mwc-radio_mwc-0c9c9b\"), __webpack_require__.e(\"vendors-node_modules_material_chips_dist_mdc_chips_min_css\"), __webpack_require__.e(\"vendors-node_modules_vaadin_combo-box_theme_material_vaadin-combo-box-light_js-node_modules_v-9b68f1\"), __webpack_require__.e(\"src_components_ha-textfield_ts\"), __webpack_require__.e(\"src_components_ha-select_ts\"), __webpack_require__.e(\"src_components_ha-checkbox_ts\"), __webpack_require__.e(\"src_components_ha-button-menu_ts\"), __webpack_require__.e(\"src_components_ha-radio_ts\"), __webpack_require__.e(\"src_components_ha-chip_ts\"), __webpack_require__.e(\"src_components_ha-input-helper-text_ts\"), __webpack_require__.e(\"src_components_ha-check-list-item_ts\"), __webpack_require__.e(\"src_components_ha-base-time-input_ts\"), __webpack_require__.e(\"src_components_ha-chip-set_ts\"), __webpack_require__.e(\"src_components_ha-form_ha-form-grid_ts-src_components_ha-form_ha-form_ts\"), __webpack_require__.e(\"src_components_ha-combo-box_ts-node_modules_vaadin_vaadin-material-styles_font-icons_js-node_-76e992\"), __webpack_require__.e(\"src_components_entity_ha-entity-picker_ts\"), __webpack_require__.e(\"src_panels_lovelace_components_hui-entity-editor_ts-src_panels_lovelace_editor_process-editor-5e3479\"), __webpack_require__.e(\"node_modules_material_mwc-formfield_mwc-formfield_js-node_modules_material_mwc-list_mwc-check-f7de93\")]).then(__webpack_require__.bind(__webpack_require__, /*! ../editor/config-elements/hui-map-card-editor */ \"./src/panels/lovelace/editor/config-elements/hui-map-card-editor.ts\"));\n        return document.createElement(\"hui-map-card-editor\");\n      }\n    }, {\n      kind: \"method\",\n      static: true,\n      key: \"getStubConfig\",\n      value: function getStubConfig(hass, entities, entitiesFallback) {\n        const includeDomains = [\"device_tracker\"];\n        const maxEntities = 2;\n        const foundEntities = (0,_common_find_entities__WEBPACK_IMPORTED_MODULE_7__.findEntities)(hass, maxEntities, entities, entitiesFallback, includeDomains);\n        return {\n          type: \"map\",\n          entities: foundEntities\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        var _this$_config$default;\n\n        if (!this._config) {\n          return lit__WEBPACK_IMPORTED_MODULE_0__.html``;\n        }\n\n        return lit__WEBPACK_IMPORTED_MODULE_0__.html`\n      <ha-card id=\"card\" .header=${this._config.title}>\n        <div id=\"root\">\n          <ha-map\n            .hass=${this.hass}\n            .entities=${this._getEntities(this.hass.states, this._config, this._configEntities)}\n            .zoom=${(_this$_config$default = this._config.default_zoom) !== null && _this$_config$default !== void 0 ? _this$_config$default : 14}\n            .paths=${this._getHistoryPaths(this._config, this._history)}\n            .darkMode=${this._config.dark_mode}\n          ></ha-map>\n          <ha-icon-button\n            .label=${this.hass.localize(\"ui.panel.lovelace.cards.map.reset_focus\")}\n            .path=${mdiImageFilterCenterFocus}\n            @click=${this._fitMap}\n            tabindex=\"0\"\n          ></ha-icon-button>\n        </div>\n      </ha-card>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"shouldUpdate\",\n      value: function shouldUpdate(changedProps) {\n        if (!changedProps.has(\"hass\") || changedProps.size > 1) {\n          return true;\n        }\n\n        const oldHass = changedProps.get(\"hass\");\n\n        if (!oldHass || !this._configEntities) {\n          return true;\n        }\n\n        if (oldHass.themes.darkMode !== this.hass.themes.darkMode) {\n          return true;\n        } // Check if any state has changed\n\n\n        for (const entity of this._configEntities) {\n          if (oldHass.states[entity] !== this.hass.states[entity]) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    }, {\n      kind: \"method\",\n      key: \"firstUpdated\",\n      value: function firstUpdated(changedProps) {\n        _get(_getPrototypeOf(HuiMapCard.prototype), \"firstUpdated\", this).call(this, changedProps);\n\n        const root = this.shadowRoot.getElementById(\"root\");\n\n        if (!this._config || this.isPanel || !root) {\n          return;\n        }\n\n        if (!this._config.aspect_ratio) {\n          root.style.paddingBottom = \"100%\";\n          return;\n        }\n\n        const ratio = (0,_common_util_parse_aspect_ratio__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this._config.aspect_ratio);\n        root.style.paddingBottom = ratio && ratio.w > 0 && ratio.h > 0 ? `${(100 * ratio.h / ratio.w).toFixed(2)}%` : root.style.paddingBottom = \"100%\";\n      }\n    }, {\n      kind: \"method\",\n      key: \"updated\",\n      value: function updated(changedProps) {\n        var _this$_config2, _this$_configEntities;\n\n        if ((_this$_config2 = this._config) !== null && _this$_config2 !== void 0 && _this$_config2.hours_to_show && (_this$_configEntities = this._configEntities) !== null && _this$_configEntities !== void 0 && _this$_configEntities.length) {\n          if (changedProps.has(\"_config\")) {\n            this._getHistory();\n          } else if (Date.now() - this._date.getTime() >= MINUTE) {\n            this._getHistory();\n          }\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_fitMap\",\n      value: function _fitMap() {\n        var _this$_map;\n\n        (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.fitMap();\n      }\n    }, {\n      kind: \"method\",\n      key: \"_getColor\",\n      value: function _getColor(entityId) {\n        let color = this._colorDict[entityId];\n\n        if (color) {\n          return color;\n        }\n\n        color = (0,_common_color_colors__WEBPACK_IMPORTED_MODULE_10__.getColorByIndex)(this._colorIndex);\n        this._colorIndex++;\n        this._colorDict[entityId] = color;\n        return color;\n      }\n    }, {\n      kind: \"field\",\n      key: \"_getEntities\",\n\n      value() {\n        return (0,memoize_one__WEBPACK_IMPORTED_MODULE_11__[\"default\"])((states, config, configEntities) => {\n          if (!states || !config) {\n            return undefined;\n          }\n\n          let entities = configEntities || [];\n\n          if (config.geo_location_sources) {\n            const geoEntities = []; // Calculate visible geo location sources\n\n            const includesAll = config.geo_location_sources.includes(\"all\");\n\n            for (const stateObj of Object.values(states)) {\n              if ((0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_2__.computeDomain)(stateObj.entity_id) === \"geo_location\" && (includesAll || config.geo_location_sources.includes(stateObj.attributes.source))) {\n                geoEntities.push(stateObj.entity_id);\n              }\n            }\n\n            entities = [...entities, ...geoEntities];\n          }\n\n          return entities.map(entity => ({\n            entity_id: entity,\n            color: this._getColor(entity)\n          }));\n        });\n      }\n\n    }, {\n      kind: \"field\",\n      key: \"_getHistoryPaths\",\n\n      value() {\n        return (0,memoize_one__WEBPACK_IMPORTED_MODULE_11__[\"default\"])((config, history) => {\n          if (!config.hours_to_show || !history) {\n            return undefined;\n          }\n\n          const paths = [];\n\n          for (const entityStates of history) {\n            if ((entityStates === null || entityStates === void 0 ? void 0 : entityStates.length) <= 1) {\n              continue;\n            } // filter location data from states and remove all invalid locations\n\n\n            const points = entityStates.reduce((accumulator, entityState) => {\n              const latitude = entityState.attributes.latitude;\n              const longitude = entityState.attributes.longitude;\n\n              if (latitude && longitude) {\n                accumulator.push([latitude, longitude]);\n              }\n\n              return accumulator;\n            }, []);\n            paths.push({\n              points,\n              color: this._getColor(entityStates[0].entity_id),\n              gradualOpacity: 0.8\n            });\n          }\n\n          return paths;\n        });\n      }\n\n    }, {\n      kind: \"method\",\n      key: \"_getHistory\",\n      value: async function _getHistory() {\n        this._date = new Date();\n\n        if (!this._configEntities) {\n          return;\n        }\n\n        const entityIds = this._configEntities.join(\",\");\n\n        const endTime = new Date();\n        const startTime = new Date();\n        startTime.setHours(endTime.getHours() - this._config.hours_to_show);\n        const skipInitialState = false;\n        const significantChangesOnly = false;\n        const minimalResponse = false;\n        const stateHistory = await (0,_data_history__WEBPACK_IMPORTED_MODULE_6__.fetchRecent)(this.hass, entityIds, startTime, endTime, skipInitialState, significantChangesOnly, minimalResponse);\n\n        if (stateHistory.length < 1) {\n          return;\n        }\n\n        this._history = stateHistory;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_cleanupHistory\",\n      value: function _cleanupHistory() {\n        if (!this._history) {\n          return;\n        }\n\n        if (this._config.hours_to_show <= 0) {\n          this._history = undefined;\n        } else {\n          // remove unused entities\n          this._history = this._history.reduce((accumulator, entityStates) => {\n            var _this$_configEntities2;\n\n            const entityId = entityStates[0].entity_id;\n\n            if ((_this$_configEntities2 = this._configEntities) !== null && _this$_configEntities2 !== void 0 && _this$_configEntities2.includes(entityId)) {\n              accumulator.push(entityStates);\n            }\n\n            return accumulator;\n          }, []);\n        }\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.css`\n      ha-card {\n        overflow: hidden;\n        width: 100%;\n        height: 100%;\n      }\n\n      ha-map {\n        z-index: 0;\n        border: none;\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background: inherit;\n      }\n\n      ha-icon-button {\n        position: absolute;\n        top: 75px;\n        left: 3px;\n        outline: none;\n      }\n\n      #root {\n        position: relative;\n      }\n\n      :host([ispanel]) #root {\n        height: 100%;\n      }\n    `;\n      }\n    }]\n  };\n}, lit__WEBPACK_IMPORTED_MODULE_0__.LitElement);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFuZWxzL2xvdmVsYWNlL2NhcmRzL2h1aS1tYXAtY2FyZC50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTtBQVFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBRUE7O0FBR0E7QUFEQTtBQUNBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7O0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7Ozs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7OztBQUNBOzs7OztBQUVBOzs7OztBQUdBOzs7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7O0FBT0E7Ozs7Ozs7O0FBRUE7Ozs7OztBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBTUE7QUFDQTs7OztBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUNBOzs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUVBO0FBS0E7QUFDQTtBQUNBO0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7OztBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFFQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBSUE7Ozs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7Ozs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQU1BO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7OztBQUdBO0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBVUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQS9WQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vc3JjL3BhbmVscy9sb3ZlbGFjZS9jYXJkcy9odWktbWFwLWNhcmQudHM/Mjg0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIYXNzRW50aXRpZXMsIEhhc3NFbnRpdHkgfSBmcm9tIFwiaG9tZS1hc3Npc3RhbnQtanMtd2Vic29ja2V0XCI7XG5pbXBvcnQgeyBMYXRMbmdUdXBsZSB9IGZyb20gXCJsZWFmbGV0XCI7XG5pbXBvcnQge1xuICBjc3MsXG4gIENTU1Jlc3VsdEdyb3VwLFxuICBodG1sLFxuICBMaXRFbGVtZW50LFxuICBQcm9wZXJ0eVZhbHVlcyxcbiAgVGVtcGxhdGVSZXN1bHQsXG59IGZyb20gXCJsaXRcIjtcbmltcG9ydCB7IGN1c3RvbUVsZW1lbnQsIHByb3BlcnR5LCBxdWVyeSwgc3RhdGUgfSBmcm9tIFwibGl0L2RlY29yYXRvcnNcIjtcbmltcG9ydCB7IG1kaUltYWdlRmlsdGVyQ2VudGVyRm9jdXMgfSBmcm9tIFwiQG1kaS9qc1wiO1xuaW1wb3J0IG1lbW9pemVPbmUgZnJvbSBcIm1lbW9pemUtb25lXCI7XG5pbXBvcnQgeyBjb21wdXRlRG9tYWluIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9lbnRpdHkvY29tcHV0ZV9kb21haW5cIjtcbmltcG9ydCBwYXJzZUFzcGVjdFJhdGlvIGZyb20gXCIuLi8uLi8uLi9jb21tb24vdXRpbC9wYXJzZS1hc3BlY3QtcmF0aW9cIjtcbmltcG9ydCBcIi4uLy4uLy4uL2NvbXBvbmVudHMvaGEtY2FyZFwiO1xuaW1wb3J0IFwiLi4vLi4vLi4vY29tcG9uZW50cy9oYS1pY29uLWJ1dHRvblwiO1xuaW1wb3J0IHsgZmV0Y2hSZWNlbnQgfSBmcm9tIFwiLi4vLi4vLi4vZGF0YS9oaXN0b3J5XCI7XG5pbXBvcnQgeyBIb21lQXNzaXN0YW50IH0gZnJvbSBcIi4uLy4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgeyBmaW5kRW50aXRpZXMgfSBmcm9tIFwiLi4vY29tbW9uL2ZpbmQtZW50aXRpZXNcIjtcbmltcG9ydCB7IHByb2Nlc3NDb25maWdFbnRpdGllcyB9IGZyb20gXCIuLi9jb21tb24vcHJvY2Vzcy1jb25maWctZW50aXRpZXNcIjtcbmltcG9ydCB7IEVudGl0eUNvbmZpZyB9IGZyb20gXCIuLi9lbnRpdHktcm93cy90eXBlc1wiO1xuaW1wb3J0IHsgTG92ZWxhY2VDYXJkIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBNYXBDYXJkQ29uZmlnIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCBcIi4uLy4uLy4uL2NvbXBvbmVudHMvbWFwL2hhLW1hcFwiO1xuaW1wb3J0IHR5cGUgeyBIYU1hcCwgSGFNYXBQYXRocyB9IGZyb20gXCIuLi8uLi8uLi9jb21wb25lbnRzL21hcC9oYS1tYXBcIjtcbmltcG9ydCB7IGdldENvbG9yQnlJbmRleCB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vY29sb3IvY29sb3JzXCI7XG5cbmNvbnN0IE1JTlVURSA9IDYwMDAwO1xuXG5AY3VzdG9tRWxlbWVudChcImh1aS1tYXAtY2FyZFwiKVxuY2xhc3MgSHVpTWFwQ2FyZCBleHRlbmRzIExpdEVsZW1lbnQgaW1wbGVtZW50cyBMb3ZlbGFjZUNhcmQge1xuICBAcHJvcGVydHkoeyBhdHRyaWJ1dGU6IGZhbHNlIH0pIHB1YmxpYyBoYXNzITogSG9tZUFzc2lzdGFudDtcblxuICBAcHJvcGVydHkoeyB0eXBlOiBCb29sZWFuLCByZWZsZWN0OiB0cnVlIH0pXG4gIHB1YmxpYyBpc1BhbmVsID0gZmFsc2U7XG5cbiAgQHN0YXRlKClcbiAgcHJpdmF0ZSBfaGlzdG9yeT86IEhhc3NFbnRpdHlbXVtdO1xuXG4gIEBzdGF0ZSgpXG4gIHByaXZhdGUgX2NvbmZpZz86IE1hcENhcmRDb25maWc7XG5cbiAgQHF1ZXJ5KFwiaGEtbWFwXCIpXG4gIHByaXZhdGUgX21hcD86IEhhTWFwO1xuXG4gIHByaXZhdGUgX2RhdGU/OiBEYXRlO1xuXG4gIHByaXZhdGUgX2NvbmZpZ0VudGl0aWVzPzogc3RyaW5nW107XG5cbiAgcHJpdmF0ZSBfY29sb3JEaWN0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgcHJpdmF0ZSBfY29sb3JJbmRleCA9IDA7XG5cbiAgcHVibGljIHNldENvbmZpZyhjb25maWc6IE1hcENhcmRDb25maWcpOiB2b2lkIHtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gY2FyZCBjb25maWd1cmF0aW9uLlwiKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZy5lbnRpdGllcz8ubGVuZ3RoICYmICFjb25maWcuZ2VvX2xvY2F0aW9uX3NvdXJjZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFaXRoZXIgZW50aXRpZXMgb3IgZ2VvX2xvY2F0aW9uX3NvdXJjZXMgbXVzdCBiZSBzcGVjaWZpZWRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5lbnRpdGllcyAmJiAhQXJyYXkuaXNBcnJheShjb25maWcuZW50aXRpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnRpdGllcyBuZWVkIHRvIGJlIGFuIGFycmF5XCIpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBjb25maWcuZ2VvX2xvY2F0aW9uX3NvdXJjZXMgJiZcbiAgICAgICFBcnJheS5pc0FycmF5KGNvbmZpZy5nZW9fbG9jYXRpb25fc291cmNlcylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlb19sb2NhdGlvbl9zb3VyY2VzIG5lZWRzIHRvIGJlIGFuIGFycmF5XCIpO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLl9jb25maWdFbnRpdGllcyA9IChcbiAgICAgIGNvbmZpZy5lbnRpdGllc1xuICAgICAgICA/IHByb2Nlc3NDb25maWdFbnRpdGllczxFbnRpdHlDb25maWc+KGNvbmZpZy5lbnRpdGllcylcbiAgICAgICAgOiBbXVxuICAgICkubWFwKChlbnRpdHkpID0+IGVudGl0eS5lbnRpdHkpO1xuXG4gICAgdGhpcy5fY2xlYW51cEhpc3RvcnkoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYXJkU2l6ZSgpOiBudW1iZXIge1xuICAgIGlmICghdGhpcy5fY29uZmlnPy5hc3BlY3RfcmF0aW8pIHtcbiAgICAgIHJldHVybiA3O1xuICAgIH1cblxuICAgIGNvbnN0IHJhdGlvID0gcGFyc2VBc3BlY3RSYXRpbyh0aGlzLl9jb25maWcuYXNwZWN0X3JhdGlvKTtcbiAgICBjb25zdCBhciA9XG4gICAgICByYXRpbyAmJiByYXRpby53ID4gMCAmJiByYXRpby5oID4gMFxuICAgICAgICA/IGAkeygoMTAwICogcmF0aW8uaCkgLyByYXRpby53KS50b0ZpeGVkKDIpfWBcbiAgICAgICAgOiBcIjEwMFwiO1xuICAgIHJldHVybiAxICsgTWF0aC5mbG9vcihOdW1iZXIoYXIpIC8gMjUpIHx8IDM7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGFzeW5jIGdldENvbmZpZ0VsZW1lbnQoKSB7XG4gICAgYXdhaXQgaW1wb3J0KFwiLi4vZWRpdG9yL2NvbmZpZy1lbGVtZW50cy9odWktbWFwLWNhcmQtZWRpdG9yXCIpO1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaHVpLW1hcC1jYXJkLWVkaXRvclwiKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0U3R1YkNvbmZpZyhcbiAgICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICAgIGVudGl0aWVzOiBzdHJpbmdbXSxcbiAgICBlbnRpdGllc0ZhbGxiYWNrOiBzdHJpbmdbXVxuICApOiBNYXBDYXJkQ29uZmlnIHtcbiAgICBjb25zdCBpbmNsdWRlRG9tYWlucyA9IFtcImRldmljZV90cmFja2VyXCJdO1xuICAgIGNvbnN0IG1heEVudGl0aWVzID0gMjtcbiAgICBjb25zdCBmb3VuZEVudGl0aWVzID0gZmluZEVudGl0aWVzKFxuICAgICAgaGFzcyxcbiAgICAgIG1heEVudGl0aWVzLFxuICAgICAgZW50aXRpZXMsXG4gICAgICBlbnRpdGllc0ZhbGxiYWNrLFxuICAgICAgaW5jbHVkZURvbWFpbnNcbiAgICApO1xuXG4gICAgcmV0dXJuIHsgdHlwZTogXCJtYXBcIiwgZW50aXRpZXM6IGZvdW5kRW50aXRpZXMgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXIoKTogVGVtcGxhdGVSZXN1bHQge1xuICAgIGlmICghdGhpcy5fY29uZmlnKSB7XG4gICAgICByZXR1cm4gaHRtbGBgO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxoYS1jYXJkIGlkPVwiY2FyZFwiIC5oZWFkZXI9JHt0aGlzLl9jb25maWcudGl0bGV9PlxuICAgICAgICA8ZGl2IGlkPVwicm9vdFwiPlxuICAgICAgICAgIDxoYS1tYXBcbiAgICAgICAgICAgIC5oYXNzPSR7dGhpcy5oYXNzfVxuICAgICAgICAgICAgLmVudGl0aWVzPSR7dGhpcy5fZ2V0RW50aXRpZXMoXG4gICAgICAgICAgICAgIHRoaXMuaGFzcy5zdGF0ZXMsXG4gICAgICAgICAgICAgIHRoaXMuX2NvbmZpZyxcbiAgICAgICAgICAgICAgdGhpcy5fY29uZmlnRW50aXRpZXNcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICAuem9vbT0ke3RoaXMuX2NvbmZpZy5kZWZhdWx0X3pvb20gPz8gMTR9XG4gICAgICAgICAgICAucGF0aHM9JHt0aGlzLl9nZXRIaXN0b3J5UGF0aHModGhpcy5fY29uZmlnLCB0aGlzLl9oaXN0b3J5KX1cbiAgICAgICAgICAgIC5kYXJrTW9kZT0ke3RoaXMuX2NvbmZpZy5kYXJrX21vZGV9XG4gICAgICAgICAgPjwvaGEtbWFwPlxuICAgICAgICAgIDxoYS1pY29uLWJ1dHRvblxuICAgICAgICAgICAgLmxhYmVsPSR7dGhpcy5oYXNzIS5sb2NhbGl6ZShcbiAgICAgICAgICAgICAgXCJ1aS5wYW5lbC5sb3ZlbGFjZS5jYXJkcy5tYXAucmVzZXRfZm9jdXNcIlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIC5wYXRoPSR7bWRpSW1hZ2VGaWx0ZXJDZW50ZXJGb2N1c31cbiAgICAgICAgICAgIEBjbGljaz0ke3RoaXMuX2ZpdE1hcH1cbiAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgPjwvaGEtaWNvbi1idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9oYS1jYXJkPlxuICAgIGA7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2hvdWxkVXBkYXRlKGNoYW5nZWRQcm9wczogUHJvcGVydHlWYWx1ZXMpIHtcbiAgICBpZiAoIWNoYW5nZWRQcm9wcy5oYXMoXCJoYXNzXCIpIHx8IGNoYW5nZWRQcm9wcy5zaXplID4gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkSGFzcyA9IGNoYW5nZWRQcm9wcy5nZXQoXCJoYXNzXCIpIGFzIEhvbWVBc3Npc3RhbnQgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIW9sZEhhc3MgfHwgIXRoaXMuX2NvbmZpZ0VudGl0aWVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkSGFzcy50aGVtZXMuZGFya01vZGUgIT09IHRoaXMuaGFzcy50aGVtZXMuZGFya01vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFueSBzdGF0ZSBoYXMgY2hhbmdlZFxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuX2NvbmZpZ0VudGl0aWVzKSB7XG4gICAgICBpZiAob2xkSGFzcy5zdGF0ZXNbZW50aXR5XSAhPT0gdGhpcy5oYXNzIS5zdGF0ZXNbZW50aXR5XSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcm90ZWN0ZWQgZmlyc3RVcGRhdGVkKGNoYW5nZWRQcm9wczogUHJvcGVydHlWYWx1ZXMpOiB2b2lkIHtcbiAgICBzdXBlci5maXJzdFVwZGF0ZWQoY2hhbmdlZFByb3BzKTtcbiAgICBjb25zdCByb290ID0gdGhpcy5zaGFkb3dSb290IS5nZXRFbGVtZW50QnlJZChcInJvb3RcIik7XG5cbiAgICBpZiAoIXRoaXMuX2NvbmZpZyB8fCB0aGlzLmlzUGFuZWwgfHwgIXJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5hc3BlY3RfcmF0aW8pIHtcbiAgICAgIHJvb3Quc3R5bGUucGFkZGluZ0JvdHRvbSA9IFwiMTAwJVwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJhdGlvID0gcGFyc2VBc3BlY3RSYXRpbyh0aGlzLl9jb25maWcuYXNwZWN0X3JhdGlvKTtcblxuICAgIHJvb3Quc3R5bGUucGFkZGluZ0JvdHRvbSA9XG4gICAgICByYXRpbyAmJiByYXRpby53ID4gMCAmJiByYXRpby5oID4gMFxuICAgICAgICA/IGAkeygoMTAwICogcmF0aW8uaCkgLyByYXRpby53KS50b0ZpeGVkKDIpfSVgXG4gICAgICAgIDogKHJvb3Quc3R5bGUucGFkZGluZ0JvdHRvbSA9IFwiMTAwJVwiKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB1cGRhdGVkKGNoYW5nZWRQcm9wczogUHJvcGVydHlWYWx1ZXMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fY29uZmlnPy5ob3Vyc190b19zaG93ICYmIHRoaXMuX2NvbmZpZ0VudGl0aWVzPy5sZW5ndGgpIHtcbiAgICAgIGlmIChjaGFuZ2VkUHJvcHMuaGFzKFwiX2NvbmZpZ1wiKSkge1xuICAgICAgICB0aGlzLl9nZXRIaXN0b3J5KCk7XG4gICAgICB9IGVsc2UgaWYgKERhdGUubm93KCkgLSB0aGlzLl9kYXRlIS5nZXRUaW1lKCkgPj0gTUlOVVRFKSB7XG4gICAgICAgIHRoaXMuX2dldEhpc3RvcnkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9maXRNYXAoKSB7XG4gICAgdGhpcy5fbWFwPy5maXRNYXAoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2dldENvbG9yKGVudGl0eUlkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGxldCBjb2xvciA9IHRoaXMuX2NvbG9yRGljdFtlbnRpdHlJZF07XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGNvbG9yID0gZ2V0Q29sb3JCeUluZGV4KHRoaXMuX2NvbG9ySW5kZXgpO1xuICAgIHRoaXMuX2NvbG9ySW5kZXgrKztcbiAgICB0aGlzLl9jb2xvckRpY3RbZW50aXR5SWRdID0gY29sb3I7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0RW50aXRpZXMgPSBtZW1vaXplT25lKFxuICAgIChcbiAgICAgIHN0YXRlczogSGFzc0VudGl0aWVzLFxuICAgICAgY29uZmlnOiBNYXBDYXJkQ29uZmlnLFxuICAgICAgY29uZmlnRW50aXRpZXM/OiBzdHJpbmdbXVxuICAgICkgPT4ge1xuICAgICAgaWYgKCFzdGF0ZXMgfHwgIWNvbmZpZykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBsZXQgZW50aXRpZXMgPSBjb25maWdFbnRpdGllcyB8fCBbXTtcblxuICAgICAgaWYgKGNvbmZpZy5nZW9fbG9jYXRpb25fc291cmNlcykge1xuICAgICAgICBjb25zdCBnZW9FbnRpdGllczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHZpc2libGUgZ2VvIGxvY2F0aW9uIHNvdXJjZXNcbiAgICAgICAgY29uc3QgaW5jbHVkZXNBbGwgPSBjb25maWcuZ2VvX2xvY2F0aW9uX3NvdXJjZXMuaW5jbHVkZXMoXCJhbGxcIik7XG4gICAgICAgIGZvciAoY29uc3Qgc3RhdGVPYmogb2YgT2JqZWN0LnZhbHVlcyhzdGF0ZXMpKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29tcHV0ZURvbWFpbihzdGF0ZU9iai5lbnRpdHlfaWQpID09PSBcImdlb19sb2NhdGlvblwiICYmXG4gICAgICAgICAgICAoaW5jbHVkZXNBbGwgfHxcbiAgICAgICAgICAgICAgY29uZmlnLmdlb19sb2NhdGlvbl9zb3VyY2VzLmluY2x1ZGVzKHN0YXRlT2JqLmF0dHJpYnV0ZXMuc291cmNlKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGdlb0VudGl0aWVzLnB1c2goc3RhdGVPYmouZW50aXR5X2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbnRpdGllcyA9IFsuLi5lbnRpdGllcywgLi4uZ2VvRW50aXRpZXNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW50aXRpZXMubWFwKChlbnRpdHkpID0+ICh7XG4gICAgICAgIGVudGl0eV9pZDogZW50aXR5LFxuICAgICAgICBjb2xvcjogdGhpcy5fZ2V0Q29sb3IoZW50aXR5KSxcbiAgICAgIH0pKTtcbiAgICB9XG4gICk7XG5cbiAgcHJpdmF0ZSBfZ2V0SGlzdG9yeVBhdGhzID0gbWVtb2l6ZU9uZShcbiAgICAoXG4gICAgICBjb25maWc6IE1hcENhcmRDb25maWcsXG4gICAgICBoaXN0b3J5PzogSGFzc0VudGl0eVtdW11cbiAgICApOiBIYU1hcFBhdGhzW10gfCB1bmRlZmluZWQgPT4ge1xuICAgICAgaWYgKCFjb25maWcuaG91cnNfdG9fc2hvdyB8fCAhaGlzdG9yeSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXRoczogSGFNYXBQYXRoc1tdID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgZW50aXR5U3RhdGVzIG9mIGhpc3RvcnkpIHtcbiAgICAgICAgaWYgKGVudGl0eVN0YXRlcz8ubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaWx0ZXIgbG9jYXRpb24gZGF0YSBmcm9tIHN0YXRlcyBhbmQgcmVtb3ZlIGFsbCBpbnZhbGlkIGxvY2F0aW9uc1xuICAgICAgICBjb25zdCBwb2ludHMgPSBlbnRpdHlTdGF0ZXMucmVkdWNlKFxuICAgICAgICAgIChhY2N1bXVsYXRvcjogTGF0TG5nVHVwbGVbXSwgZW50aXR5U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhdGl0dWRlID0gZW50aXR5U3RhdGUuYXR0cmlidXRlcy5sYXRpdHVkZTtcbiAgICAgICAgICAgIGNvbnN0IGxvbmdpdHVkZSA9IGVudGl0eVN0YXRlLmF0dHJpYnV0ZXMubG9uZ2l0dWRlO1xuICAgICAgICAgICAgaWYgKGxhdGl0dWRlICYmIGxvbmdpdHVkZSkge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRvci5wdXNoKFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSBhcyBMYXRMbmdUdXBsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbXVxuICAgICAgICApIGFzIExhdExuZ1R1cGxlW107XG5cbiAgICAgICAgcGF0aHMucHVzaCh7XG4gICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgIGNvbG9yOiB0aGlzLl9nZXRDb2xvcihlbnRpdHlTdGF0ZXNbMF0uZW50aXR5X2lkKSxcbiAgICAgICAgICBncmFkdWFsT3BhY2l0eTogMC44LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRocztcbiAgICB9XG4gICk7XG5cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0SGlzdG9yeSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLl9kYXRlID0gbmV3IERhdGUoKTtcblxuICAgIGlmICghdGhpcy5fY29uZmlnRW50aXRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlbnRpdHlJZHMgPSB0aGlzLl9jb25maWdFbnRpdGllcyEuam9pbihcIixcIik7XG4gICAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICBzdGFydFRpbWUuc2V0SG91cnMoZW5kVGltZS5nZXRIb3VycygpIC0gdGhpcy5fY29uZmlnIS5ob3Vyc190b19zaG93ISk7XG4gICAgY29uc3Qgc2tpcEluaXRpYWxTdGF0ZSA9IGZhbHNlO1xuICAgIGNvbnN0IHNpZ25pZmljYW50Q2hhbmdlc09ubHkgPSBmYWxzZTtcbiAgICBjb25zdCBtaW5pbWFsUmVzcG9uc2UgPSBmYWxzZTtcblxuICAgIGNvbnN0IHN0YXRlSGlzdG9yeSA9IGF3YWl0IGZldGNoUmVjZW50KFxuICAgICAgdGhpcy5oYXNzLFxuICAgICAgZW50aXR5SWRzLFxuICAgICAgc3RhcnRUaW1lLFxuICAgICAgZW5kVGltZSxcbiAgICAgIHNraXBJbml0aWFsU3RhdGUsXG4gICAgICBzaWduaWZpY2FudENoYW5nZXNPbmx5LFxuICAgICAgbWluaW1hbFJlc3BvbnNlXG4gICAgKTtcblxuICAgIGlmIChzdGF0ZUhpc3RvcnkubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9oaXN0b3J5ID0gc3RhdGVIaXN0b3J5O1xuICB9XG5cbiAgcHJpdmF0ZSBfY2xlYW51cEhpc3RvcnkoKSB7XG4gICAgaWYgKCF0aGlzLl9oaXN0b3J5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9jb25maWchLmhvdXJzX3RvX3Nob3chIDw9IDApIHtcbiAgICAgIHRoaXMuX2hpc3RvcnkgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSB1bnVzZWQgZW50aXRpZXNcbiAgICAgIHRoaXMuX2hpc3RvcnkgPSB0aGlzLl9oaXN0b3J5IS5yZWR1Y2UoXG4gICAgICAgIChhY2N1bXVsYXRvcjogSGFzc0VudGl0eVtdW10sIGVudGl0eVN0YXRlcykgPT4ge1xuICAgICAgICAgIGNvbnN0IGVudGl0eUlkID0gZW50aXR5U3RhdGVzWzBdLmVudGl0eV9pZDtcbiAgICAgICAgICBpZiAodGhpcy5fY29uZmlnRW50aXRpZXM/LmluY2x1ZGVzKGVudGl0eUlkKSkge1xuICAgICAgICAgICAgYWNjdW11bGF0b3IucHVzaChlbnRpdHlTdGF0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIFtdXG4gICAgICApIGFzIEhhc3NFbnRpdHlbXVtdO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3R5bGVzKCk6IENTU1Jlc3VsdEdyb3VwIHtcbiAgICByZXR1cm4gY3NzYFxuICAgICAgaGEtY2FyZCB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgIGhhLW1hcCB7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQ6IGluaGVyaXQ7XG4gICAgICB9XG5cbiAgICAgIGhhLWljb24tYnV0dG9uIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDc1cHg7XG4gICAgICAgIGxlZnQ6IDNweDtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgIH1cblxuICAgICAgI3Jvb3Qge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtpc3BhbmVsXSkgI3Jvb3Qge1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBIVE1MRWxlbWVudFRhZ05hbWVNYXAge1xuICAgIFwiaHVpLW1hcC1jYXJkXCI6IEh1aU1hcENhcmQ7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/panels/lovelace/cards/hui-map-card.ts\n");

/***/ })

}]);