"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["src_dialogs_more-info_controls_more-info-light_ts"],{

/***/ "./src/common/dom/stop_propagation.ts":
/*!********************************************!*\
  !*** ./src/common/dom/stop_propagation.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"stopPropagation\": () => (/* binding */ stopPropagation)\n/* harmony export */ });\nconst stopPropagation = ev => ev.stopPropagation();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL2RvbS9zdG9wX3Byb3BhZ2F0aW9uLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vc3JjL2NvbW1vbi9kb20vc3RvcF9wcm9wYWdhdGlvbi50cz9lZjAxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBzdG9wUHJvcGFnYXRpb24gPSAoZXYpID0+IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/common/dom/stop_propagation.ts\n");

/***/ }),

/***/ "./src/components/ha-color-picker.js":
/*!*******************************************!*\
  !*** ./src/components/ha-color-picker.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _common_color_convert_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/color/convert-color */ \"./src/common/color/convert-color.ts\");\n/* harmony import */ var _mixins_events_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mixins/events-mixin */ \"./src/mixins/events-mixin.js\");\n\n/* eslint-plugin-disable lit */\n\n\n\n\n/**\n * Color-picker custom element\n *\n * @appliesMixin EventsMixin\n */\n\nclass HaColorPicker extends (0,_mixins_events_mixin__WEBPACK_IMPORTED_MODULE_3__.EventsMixin)(_polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_1__.PolymerElement) {\n  static get template() {\n    return _polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_0__.html`\n      <style>\n        :host {\n          user-select: none;\n          -webkit-user-select: none;\n        }\n\n        #canvas {\n          position: relative;\n          width: 100%;\n          max-width: 330px;\n        }\n        #canvas > * {\n          display: block;\n        }\n        #interactionLayer {\n          color: white;\n          position: absolute;\n          cursor: crosshair;\n          width: 100%;\n          height: 100%;\n          overflow: visible;\n        }\n        #backgroundLayer {\n          width: 100%;\n          overflow: visible;\n          --wheel-bordercolor: var(--ha-color-picker-wheel-bordercolor, white);\n          --wheel-borderwidth: var(--ha-color-picker-wheel-borderwidth, 3);\n          --wheel-shadow: var(\n            --ha-color-picker-wheel-shadow,\n            rgb(15, 15, 15) 10px 5px 5px 0px\n          );\n        }\n\n        #marker {\n          fill: currentColor;\n          stroke: var(--ha-color-picker-marker-bordercolor, white);\n          stroke-width: var(--ha-color-picker-marker-borderwidth, 3);\n          filter: url(#marker-shadow);\n        }\n        .dragging #marker {\n        }\n\n        #colorTooltip {\n          display: none;\n          fill: currentColor;\n          stroke: var(--ha-color-picker-tooltip-bordercolor, white);\n          stroke-width: var(--ha-color-picker-tooltip-borderwidth, 3);\n        }\n\n        .touch.dragging #colorTooltip {\n          display: inherit;\n        }\n      </style>\n      <div id=\"canvas\">\n        <svg id=\"interactionLayer\">\n          <defs>\n            <filter\n              id=\"marker-shadow\"\n              x=\"-50%\"\n              y=\"-50%\"\n              width=\"200%\"\n              height=\"200%\"\n              filterUnits=\"objectBoundingBox\"\n            >\n              <feOffset\n                result=\"offOut\"\n                in=\"SourceAlpha\"\n                dx=\"2\"\n                dy=\"2\"\n              ></feOffset>\n              <feGaussianBlur\n                result=\"blurOut\"\n                in=\"offOut\"\n                stdDeviation=\"2\"\n              ></feGaussianBlur>\n              <feComponentTransfer in=\"blurOut\" result=\"alphaOut\">\n                <feFuncA type=\"linear\" slope=\"0.3\"></feFuncA>\n              </feComponentTransfer>\n              <feBlend\n                in=\"SourceGraphic\"\n                in2=\"alphaOut\"\n                mode=\"normal\"\n              ></feBlend>\n            </filter>\n          </defs>\n        </svg>\n        <canvas id=\"backgroundLayer\"></canvas>\n      </div>\n    `;\n  }\n\n  static get properties() {\n    return {\n      hsColor: {\n        type: Object\n      },\n      // use these properties to update the state via attributes\n      desiredHsColor: {\n        type: Object,\n        observer: \"applyHsColor\"\n      },\n      // use these properties to update the state via attributes\n      desiredRgbColor: {\n        type: Object,\n        observer: \"applyRgbColor\"\n      },\n      // width, height and radius apply to the coordinates of\n      // of the canvas.\n      // border width are relative to these numbers\n      // the onscreen displayed size should be controlled with css\n      // and should be the same or smaller\n      width: {\n        type: Number,\n        value: 500\n      },\n      height: {\n        type: Number,\n        value: 500\n      },\n      radius: {\n        type: Number,\n        value: 225\n      },\n      // the amount segments for the hue\n      // 0 = continuous gradient\n      // other than 0 gives 'pie-pieces'\n      hueSegments: {\n        type: Number,\n        value: 0,\n        observer: \"segmentationChange\"\n      },\n      // the amount segments for the hue\n      // 0 = continuous gradient\n      // 1 = only fully saturated\n      // > 1 = segments from white to fully saturated\n      saturationSegments: {\n        type: Number,\n        value: 0,\n        observer: \"segmentationChange\"\n      },\n      // set to true to make the segments purely esthetical\n      // this allows selection off all collors, also\n      // interpolated between the segments\n      ignoreSegments: {\n        type: Boolean,\n        value: false\n      },\n      // throttle te amount of 'colorselected' events fired\n      // value is timeout in milliseconds\n      throttle: {\n        type: Number,\n        value: 500\n      }\n    };\n  }\n\n  ready() {\n    super.ready();\n    this.setupLayers();\n    this.drawColorWheel();\n    this.drawMarker();\n\n    if (this.desiredHsColor) {\n      this.applyHsColor(this.desiredHsColor);\n    }\n\n    if (this.desiredRgbColor) {\n      this.applyRgbColor(this.desiredRgbColor);\n    }\n\n    this.interactionLayer.addEventListener(\"mousedown\", ev => this.onMouseDown(ev));\n    this.interactionLayer.addEventListener(\"touchstart\", ev => this.onTouchStart(ev));\n  } // converts browser coordinates to canvas canvas coordinates\n  // origin is wheel center\n  // returns {x: X, y: Y} object\n\n\n  convertToCanvasCoordinates(clientX, clientY) {\n    const svgPoint = this.interactionLayer.createSVGPoint();\n    svgPoint.x = clientX;\n    svgPoint.y = clientY;\n    const cc = svgPoint.matrixTransform(this.interactionLayer.getScreenCTM().inverse());\n    return {\n      x: cc.x,\n      y: cc.y\n    };\n  } // Mouse events\n\n\n  onMouseDown(ev) {\n    const cc = this.convertToCanvasCoordinates(ev.clientX, ev.clientY); // return if we're not on the wheel\n\n    if (!this.isInWheel(cc.x, cc.y)) {\n      return;\n    } // a mousedown in wheel is always a color select action\n\n\n    this.onMouseSelect(ev); // allow dragging\n\n    this.canvas.classList.add(\"mouse\", \"dragging\");\n    this.addEventListener(\"mousemove\", this.onMouseSelect);\n    this.addEventListener(\"mouseup\", this.onMouseUp);\n  }\n\n  onMouseUp() {\n    this.canvas.classList.remove(\"mouse\", \"dragging\");\n    this.removeEventListener(\"mousemove\", this.onMouseSelect);\n  }\n\n  onMouseSelect(ev) {\n    requestAnimationFrame(() => this.processUserSelect(ev));\n  } // Touch events\n\n\n  onTouchStart(ev) {\n    const touch = ev.changedTouches[0];\n    const cc = this.convertToCanvasCoordinates(touch.clientX, touch.clientY); // return if we're not on the wheel\n\n    if (!this.isInWheel(cc.x, cc.y)) {\n      return;\n    }\n\n    if (ev.target === this.marker) {\n      // drag marker\n      ev.preventDefault();\n      this.canvas.classList.add(\"touch\", \"dragging\");\n      this.addEventListener(\"touchmove\", this.onTouchSelect);\n      this.addEventListener(\"touchend\", this.onTouchEnd);\n      return;\n    } // don't fire color selection immediately,\n    // wait for touchend and invalidate when we scroll\n\n\n    this.tapBecameScroll = false;\n    this.addEventListener(\"touchend\", this.onTap);\n    this.addEventListener(\"touchmove\", () => {\n      this.tapBecameScroll = true;\n    }, {\n      passive: true\n    });\n  }\n\n  onTap(ev) {\n    if (this.tapBecameScroll) {\n      return;\n    }\n\n    ev.preventDefault();\n    this.onTouchSelect(ev);\n  }\n\n  onTouchEnd() {\n    this.canvas.classList.remove(\"touch\", \"dragging\");\n    this.removeEventListener(\"touchmove\", this.onTouchSelect);\n  }\n\n  onTouchSelect(ev) {\n    requestAnimationFrame(() => this.processUserSelect(ev.changedTouches[0]));\n  }\n  /*\n   * General event/selection handling\n   */\n  // Process user input to color\n\n\n  processUserSelect(ev) {\n    const canvasXY = this.convertToCanvasCoordinates(ev.clientX, ev.clientY);\n    const hs = this.getColor(canvasXY.x, canvasXY.y);\n    let rgb;\n\n    if (!this.isInWheel(canvasXY.x, canvasXY.y)) {\n      const [r, g, b] = (0,_common_color_convert_color__WEBPACK_IMPORTED_MODULE_2__.hs2rgb)([hs.h, hs.s]);\n      rgb = {\n        r,\n        g,\n        b\n      };\n    } else {\n      rgb = this.getRgbColor(canvasXY.x, canvasXY.y);\n    }\n\n    this.onColorSelect(hs, rgb);\n  } // apply color to marker position and canvas\n\n\n  onColorSelect(hs, rgb) {\n    this.setMarkerOnColor(hs); // marker always follows mouse 'raw' hs value (= mouse position)\n\n    if (!this.ignoreSegments) {\n      // apply segments if needed\n      hs = this.applySegmentFilter(hs);\n    } // always apply the new color to the interface / canvas\n\n\n    this.applyColorToCanvas(hs); // throttling is applied to updating the exposed colors (properties)\n    // and firing of events\n\n    if (this.colorSelectIsThrottled) {\n      // make sure we apply the last selected color\n      // eventually after throttle limit has passed\n      clearTimeout(this.ensureFinalSelect);\n      this.ensureFinalSelect = setTimeout(() => {\n        this.fireColorSelected(hs, rgb); // do it for the final time\n      }, this.throttle);\n      return;\n    }\n\n    this.fireColorSelected(hs, rgb); // do it\n\n    this.colorSelectIsThrottled = true;\n    setTimeout(() => {\n      this.colorSelectIsThrottled = false;\n    }, this.throttle);\n  } // set color values and fire colorselected event\n\n\n  fireColorSelected(hs, rgb) {\n    this.hsColor = hs;\n    this.fire(\"colorselected\", {\n      hs,\n      rgb\n    });\n  }\n  /*\n   * Interface updating\n   */\n  // set marker position to the given color\n\n\n  setMarkerOnColor(hs) {\n    if (!this.marker || !this.tooltip) {\n      return;\n    }\n\n    const dist = hs.s * this.radius;\n    const theta = (hs.h - 180) / 180 * Math.PI;\n    const markerdX = -dist * Math.cos(theta);\n    const markerdY = -dist * Math.sin(theta);\n    const translateString = `translate(${markerdX},${markerdY})`;\n    this.marker.setAttribute(\"transform\", translateString);\n    this.tooltip.setAttribute(\"transform\", translateString);\n  } // apply given color to interface elements\n\n\n  applyColorToCanvas(hs) {\n    if (!this.interactionLayer) {\n      return;\n    } // we're not really converting hs to hsl here, but we keep it cheap\n    // setting the color on the interactionLayer, the svg elements can inherit\n\n\n    this.interactionLayer.style.color = `hsl(${hs.h}, 100%, ${100 - hs.s * 50}%)`;\n  }\n\n  applyHsColor(hs) {\n    // do nothing is we already have the same color\n    if (this.hsColor && this.hsColor.h === hs.h && this.hsColor.s === hs.s) {\n      return;\n    }\n\n    this.setMarkerOnColor(hs); // marker is always set on 'raw' hs position\n\n    if (!this.ignoreSegments) {\n      // apply segments if needed\n      hs = this.applySegmentFilter(hs);\n    }\n\n    this.hsColor = hs; // always apply the new color to the interface / canvas\n\n    this.applyColorToCanvas(hs);\n  }\n\n  applyRgbColor(rgb) {\n    const [h, s] = (0,_common_color_convert_color__WEBPACK_IMPORTED_MODULE_2__.rgb2hs)(rgb);\n    this.applyHsColor({\n      h,\n      s\n    });\n  }\n  /*\n   * input processing helpers\n   */\n  // get angle (degrees)\n\n\n  getAngle(dX, dY) {\n    const theta = Math.atan2(-dY, -dX); // radians from the left edge, clockwise = positive\n\n    const angle = theta / Math.PI * 180 + 180; // degrees, clockwise from right\n\n    return angle;\n  } // returns true when coordinates are in the colorwheel\n\n\n  isInWheel(x, y) {\n    return this.getDistance(x, y) <= 1;\n  } // returns distance from wheel center, 0 = center, 1 = edge, >1 = outside\n\n\n  getDistance(dX, dY) {\n    return Math.sqrt(dX * dX + dY * dY) / this.radius;\n  }\n  /*\n   * Getting colors\n   */\n\n\n  getColor(x, y) {\n    const hue = this.getAngle(x, y); // degrees, clockwise from right\n\n    const relativeDistance = this.getDistance(x, y); // edge of radius = 1\n\n    const sat = Math.min(relativeDistance, 1); // Distance from center\n\n    return {\n      h: hue,\n      s: sat\n    };\n  }\n\n  getRgbColor(x, y) {\n    // get current pixel\n    const imageData = this.backgroundLayer.getContext(\"2d\").getImageData(x + 250, y + 250, 1, 1);\n    const pixel = imageData.data;\n    return {\n      r: pixel[0],\n      g: pixel[1],\n      b: pixel[2]\n    };\n  }\n\n  applySegmentFilter(hs) {\n    // apply hue segment steps\n    if (this.hueSegments) {\n      const angleStep = 360 / this.hueSegments;\n      const halfAngleStep = angleStep / 2;\n      hs.h -= halfAngleStep; // take the 'centered segemnts' into account\n\n      if (hs.h < 0) {\n        hs.h += 360;\n      } // don't end up below 0\n\n\n      const rest = hs.h % angleStep;\n      hs.h -= rest - angleStep;\n    } // apply saturation segment steps\n\n\n    if (this.saturationSegments) {\n      if (this.saturationSegments === 1) {\n        hs.s = 1;\n      } else {\n        const segmentSize = 1 / this.saturationSegments;\n        const saturationStep = 1 / (this.saturationSegments - 1);\n        const calculatedSat = Math.floor(hs.s / segmentSize) * saturationStep;\n        hs.s = Math.min(calculatedSat, 1);\n      }\n    }\n\n    return hs;\n  }\n  /*\n   * Drawing related stuff\n   */\n\n\n  setupLayers() {\n    this.canvas = this.$.canvas;\n    this.backgroundLayer = this.$.backgroundLayer;\n    this.interactionLayer = this.$.interactionLayer; // coordinate origin position (center of the wheel)\n\n    this.originX = this.width / 2;\n    this.originY = this.originX; // synchronise width/height coordinates\n\n    this.backgroundLayer.width = this.width;\n    this.backgroundLayer.height = this.height;\n    this.interactionLayer.setAttribute(\"viewBox\", `${-this.originX} ${-this.originY} ${this.width} ${this.height}`);\n  }\n\n  drawColorWheel() {\n    /*\n     *  Setting up all paremeters\n     */\n    let shadowColor;\n    let shadowOffsetX;\n    let shadowOffsetY;\n    let shadowBlur;\n    const context = this.backgroundLayer.getContext(\"2d\"); // postioning and sizing\n\n    const cX = this.originX;\n    const cY = this.originY;\n    const radius = this.radius;\n    const counterClockwise = false; // styling of the wheel\n\n    const wheelStyle = window.getComputedStyle(this.backgroundLayer, null);\n    const borderWidth = parseInt(wheelStyle.getPropertyValue(\"--wheel-borderwidth\"), 10);\n    const borderColor = wheelStyle.getPropertyValue(\"--wheel-bordercolor\").trim();\n    const wheelShadow = wheelStyle.getPropertyValue(\"--wheel-shadow\").trim(); // extract shadow properties from CSS variable\n    // the shadow should be defined as: \"10px 5px 5px 0px COLOR\"\n\n    if (wheelShadow !== \"none\") {\n      const values = wheelShadow.split(\"px \");\n      shadowColor = values.pop();\n      shadowOffsetX = parseInt(values[0], 10);\n      shadowOffsetY = parseInt(values[1], 10);\n      shadowBlur = parseInt(values[2], 10) || 0;\n    }\n\n    const borderRadius = radius + borderWidth / 2;\n    const wheelRadius = radius;\n    const shadowRadius = radius + borderWidth;\n    /*\n     *  Drawing functions\n     */\n\n    function drawCircle(hueSegments, saturationSegments) {\n      hueSegments = hueSegments || 360; // reset 0 segments to 360\n\n      const angleStep = 360 / hueSegments;\n      const halfAngleStep = angleStep / 2; // center segments on color\n\n      for (let angle = 0; angle <= 360; angle += angleStep) {\n        const startAngle = (angle - halfAngleStep) * (Math.PI / 180);\n        const endAngle = (angle + halfAngleStep + 1) * (Math.PI / 180);\n        context.beginPath();\n        context.moveTo(cX, cY);\n        context.arc(cX, cY, wheelRadius, startAngle, endAngle, counterClockwise);\n        context.closePath(); // gradient\n\n        const gradient = context.createRadialGradient(cX, cY, 0, cX, cY, wheelRadius);\n        let lightness = 100; // first gradient stop\n\n        gradient.addColorStop(0, `hsl(${angle}, 100%, ${lightness}%)`); // segment gradient stops\n\n        if (saturationSegments > 0) {\n          const ratioStep = 1 / saturationSegments;\n          let ratio = 0;\n\n          for (let stop = 1; stop < saturationSegments; stop += 1) {\n            const prevLighness = lightness;\n            ratio = stop * ratioStep;\n            lightness = 100 - 50 * ratio;\n            gradient.addColorStop(ratio, `hsl(${angle}, 100%, ${prevLighness}%)`);\n            gradient.addColorStop(ratio, `hsl(${angle}, 100%, ${lightness}%)`);\n          }\n\n          gradient.addColorStop(ratio, `hsl(${angle}, 100%, 50%)`);\n        } // last gradient stop\n\n\n        gradient.addColorStop(1, `hsl(${angle}, 100%, 50%)`);\n        context.fillStyle = gradient;\n        context.fill();\n      }\n    }\n\n    function drawShadow() {\n      context.save();\n      context.beginPath();\n      context.arc(cX, cY, shadowRadius, 0, 2 * Math.PI, false);\n      context.shadowColor = shadowColor;\n      context.shadowOffsetX = shadowOffsetX;\n      context.shadowOffsetY = shadowOffsetY;\n      context.shadowBlur = shadowBlur;\n      context.fillStyle = \"white\";\n      context.fill();\n      context.restore();\n    }\n\n    function drawBorder() {\n      context.beginPath();\n      context.arc(cX, cY, borderRadius, 0, 2 * Math.PI, false);\n      context.lineWidth = borderWidth;\n      context.strokeStyle = borderColor;\n      context.stroke();\n    }\n    /*\n     *   Call the drawing functions\n     *   draws the shadow, wheel and border\n     */\n\n\n    if (wheelStyle.shadow !== \"none\") {\n      drawShadow();\n    }\n\n    drawCircle(this.hueSegments, this.saturationSegments);\n\n    if (borderWidth > 0) {\n      drawBorder();\n    }\n  }\n  /*\n   *   Draw the (draggable) marker and tooltip\n   *   on the interactionLayer)\n   */\n\n\n  drawMarker() {\n    const svgElement = this.interactionLayer;\n    const markerradius = this.radius * 0.08;\n    const tooltipradius = this.radius * 0.15;\n    const TooltipOffsetY = -(tooltipradius * 3);\n    const TooltipOffsetX = 0;\n    svgElement.marker = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    svgElement.marker.setAttribute(\"id\", \"marker\");\n    svgElement.marker.setAttribute(\"r\", markerradius);\n    this.marker = svgElement.marker;\n    svgElement.appendChild(svgElement.marker);\n    svgElement.tooltip = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    svgElement.tooltip.setAttribute(\"id\", \"colorTooltip\");\n    svgElement.tooltip.setAttribute(\"r\", tooltipradius);\n    svgElement.tooltip.setAttribute(\"cx\", TooltipOffsetX);\n    svgElement.tooltip.setAttribute(\"cy\", TooltipOffsetY);\n    this.tooltip = svgElement.tooltip;\n    svgElement.appendChild(svgElement.tooltip);\n  }\n\n  segmentationChange() {\n    if (this.backgroundLayer) {\n      this.drawColorWheel();\n    }\n  }\n\n}\n\ncustomElements.define(\"ha-color-picker\", HaColorPicker);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9oYS1jb2xvci1waWNrZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFsRUE7QUF1RUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUdBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTs7QUFFQTtBQVFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTs7QUFDQTtBQUNBOzs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2bkJBOztBQXluQkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL3NyYy9jb21wb25lbnRzL2hhLWNvbG9yLXBpY2tlci5qcz80OWE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGh0bWwgfSBmcm9tIFwiQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvaHRtbC10YWdcIjtcbi8qIGVzbGludC1wbHVnaW4tZGlzYWJsZSBsaXQgKi9cbmltcG9ydCB7IFBvbHltZXJFbGVtZW50IH0gZnJvbSBcIkBwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50XCI7XG5pbXBvcnQgeyBoczJyZ2IsIHJnYjJocyB9IGZyb20gXCIuLi9jb21tb24vY29sb3IvY29udmVydC1jb2xvclwiO1xuaW1wb3J0IHsgRXZlbnRzTWl4aW4gfSBmcm9tIFwiLi4vbWl4aW5zL2V2ZW50cy1taXhpblwiO1xuLyoqXG4gKiBDb2xvci1waWNrZXIgY3VzdG9tIGVsZW1lbnRcbiAqXG4gKiBAYXBwbGllc01peGluIEV2ZW50c01peGluXG4gKi9cbmNsYXNzIEhhQ29sb3JQaWNrZXIgZXh0ZW5kcyBFdmVudHNNaXhpbihQb2x5bWVyRWxlbWVudCkge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBodG1sYFxuICAgICAgPHN0eWxlPlxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgICNjYW52YXMge1xuICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICBtYXgtd2lkdGg6IDMzMHB4O1xuICAgICAgICB9XG4gICAgICAgICNjYW52YXMgPiAqIHtcbiAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgfVxuICAgICAgICAjaW50ZXJhY3Rpb25MYXllciB7XG4gICAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICBjdXJzb3I6IGNyb3NzaGFpcjtcbiAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XG4gICAgICAgIH1cbiAgICAgICAgI2JhY2tncm91bmRMYXllciB7XG4gICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XG4gICAgICAgICAgLS13aGVlbC1ib3JkZXJjb2xvcjogdmFyKC0taGEtY29sb3ItcGlja2VyLXdoZWVsLWJvcmRlcmNvbG9yLCB3aGl0ZSk7XG4gICAgICAgICAgLS13aGVlbC1ib3JkZXJ3aWR0aDogdmFyKC0taGEtY29sb3ItcGlja2VyLXdoZWVsLWJvcmRlcndpZHRoLCAzKTtcbiAgICAgICAgICAtLXdoZWVsLXNoYWRvdzogdmFyKFxuICAgICAgICAgICAgLS1oYS1jb2xvci1waWNrZXItd2hlZWwtc2hhZG93LFxuICAgICAgICAgICAgcmdiKDE1LCAxNSwgMTUpIDEwcHggNXB4IDVweCAwcHhcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgI21hcmtlciB7XG4gICAgICAgICAgZmlsbDogY3VycmVudENvbG9yO1xuICAgICAgICAgIHN0cm9rZTogdmFyKC0taGEtY29sb3ItcGlja2VyLW1hcmtlci1ib3JkZXJjb2xvciwgd2hpdGUpO1xuICAgICAgICAgIHN0cm9rZS13aWR0aDogdmFyKC0taGEtY29sb3ItcGlja2VyLW1hcmtlci1ib3JkZXJ3aWR0aCwgMyk7XG4gICAgICAgICAgZmlsdGVyOiB1cmwoI21hcmtlci1zaGFkb3cpO1xuICAgICAgICB9XG4gICAgICAgIC5kcmFnZ2luZyAjbWFya2VyIHtcbiAgICAgICAgfVxuXG4gICAgICAgICNjb2xvclRvb2x0aXAge1xuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgICAgZmlsbDogY3VycmVudENvbG9yO1xuICAgICAgICAgIHN0cm9rZTogdmFyKC0taGEtY29sb3ItcGlja2VyLXRvb2x0aXAtYm9yZGVyY29sb3IsIHdoaXRlKTtcbiAgICAgICAgICBzdHJva2Utd2lkdGg6IHZhcigtLWhhLWNvbG9yLXBpY2tlci10b29sdGlwLWJvcmRlcndpZHRoLCAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC50b3VjaC5kcmFnZ2luZyAjY29sb3JUb29sdGlwIHtcbiAgICAgICAgICBkaXNwbGF5OiBpbmhlcml0O1xuICAgICAgICB9XG4gICAgICA8L3N0eWxlPlxuICAgICAgPGRpdiBpZD1cImNhbnZhc1wiPlxuICAgICAgICA8c3ZnIGlkPVwiaW50ZXJhY3Rpb25MYXllclwiPlxuICAgICAgICAgIDxkZWZzPlxuICAgICAgICAgICAgPGZpbHRlclxuICAgICAgICAgICAgICBpZD1cIm1hcmtlci1zaGFkb3dcIlxuICAgICAgICAgICAgICB4PVwiLTUwJVwiXG4gICAgICAgICAgICAgIHk9XCItNTAlXCJcbiAgICAgICAgICAgICAgd2lkdGg9XCIyMDAlXCJcbiAgICAgICAgICAgICAgaGVpZ2h0PVwiMjAwJVwiXG4gICAgICAgICAgICAgIGZpbHRlclVuaXRzPVwib2JqZWN0Qm91bmRpbmdCb3hcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8ZmVPZmZzZXRcbiAgICAgICAgICAgICAgICByZXN1bHQ9XCJvZmZPdXRcIlxuICAgICAgICAgICAgICAgIGluPVwiU291cmNlQWxwaGFcIlxuICAgICAgICAgICAgICAgIGR4PVwiMlwiXG4gICAgICAgICAgICAgICAgZHk9XCIyXCJcbiAgICAgICAgICAgICAgPjwvZmVPZmZzZXQ+XG4gICAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1clxuICAgICAgICAgICAgICAgIHJlc3VsdD1cImJsdXJPdXRcIlxuICAgICAgICAgICAgICAgIGluPVwib2ZmT3V0XCJcbiAgICAgICAgICAgICAgICBzdGREZXZpYXRpb249XCIyXCJcbiAgICAgICAgICAgICAgPjwvZmVHYXVzc2lhbkJsdXI+XG4gICAgICAgICAgICAgIDxmZUNvbXBvbmVudFRyYW5zZmVyIGluPVwiYmx1ck91dFwiIHJlc3VsdD1cImFscGhhT3V0XCI+XG4gICAgICAgICAgICAgICAgPGZlRnVuY0EgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwiMC4zXCI+PC9mZUZ1bmNBPlxuICAgICAgICAgICAgICA8L2ZlQ29tcG9uZW50VHJhbnNmZXI+XG4gICAgICAgICAgICAgIDxmZUJsZW5kXG4gICAgICAgICAgICAgICAgaW49XCJTb3VyY2VHcmFwaGljXCJcbiAgICAgICAgICAgICAgICBpbjI9XCJhbHBoYU91dFwiXG4gICAgICAgICAgICAgICAgbW9kZT1cIm5vcm1hbFwiXG4gICAgICAgICAgICAgID48L2ZlQmxlbmQ+XG4gICAgICAgICAgICA8L2ZpbHRlcj5cbiAgICAgICAgICA8L2RlZnM+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICA8Y2FudmFzIGlkPVwiYmFja2dyb3VuZExheWVyXCI+PC9jYW52YXM+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG5cbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoc0NvbG9yOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIH0sXG5cbiAgICAgIC8vIHVzZSB0aGVzZSBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB0aGUgc3RhdGUgdmlhIGF0dHJpYnV0ZXNcbiAgICAgIGRlc2lyZWRIc0NvbG9yOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgb2JzZXJ2ZXI6IFwiYXBwbHlIc0NvbG9yXCIsXG4gICAgICB9LFxuXG4gICAgICAvLyB1c2UgdGhlc2UgcHJvcGVydGllcyB0byB1cGRhdGUgdGhlIHN0YXRlIHZpYSBhdHRyaWJ1dGVzXG4gICAgICBkZXNpcmVkUmdiQ29sb3I6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBvYnNlcnZlcjogXCJhcHBseVJnYkNvbG9yXCIsXG4gICAgICB9LFxuXG4gICAgICAvLyB3aWR0aCwgaGVpZ2h0IGFuZCByYWRpdXMgYXBwbHkgdG8gdGhlIGNvb3JkaW5hdGVzIG9mXG4gICAgICAvLyBvZiB0aGUgY2FudmFzLlxuICAgICAgLy8gYm9yZGVyIHdpZHRoIGFyZSByZWxhdGl2ZSB0byB0aGVzZSBudW1iZXJzXG4gICAgICAvLyB0aGUgb25zY3JlZW4gZGlzcGxheWVkIHNpemUgc2hvdWxkIGJlIGNvbnRyb2xsZWQgd2l0aCBjc3NcbiAgICAgIC8vIGFuZCBzaG91bGQgYmUgdGhlIHNhbWUgb3Igc21hbGxlclxuICAgICAgd2lkdGg6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogNTAwLFxuICAgICAgfSxcblxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDUwMCxcbiAgICAgIH0sXG5cbiAgICAgIHJhZGl1czoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiAyMjUsXG4gICAgICB9LFxuXG4gICAgICAvLyB0aGUgYW1vdW50IHNlZ21lbnRzIGZvciB0aGUgaHVlXG4gICAgICAvLyAwID0gY29udGludW91cyBncmFkaWVudFxuICAgICAgLy8gb3RoZXIgdGhhbiAwIGdpdmVzICdwaWUtcGllY2VzJ1xuICAgICAgaHVlU2VnbWVudHM6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgb2JzZXJ2ZXI6IFwic2VnbWVudGF0aW9uQ2hhbmdlXCIsXG4gICAgICB9LFxuXG4gICAgICAvLyB0aGUgYW1vdW50IHNlZ21lbnRzIGZvciB0aGUgaHVlXG4gICAgICAvLyAwID0gY29udGludW91cyBncmFkaWVudFxuICAgICAgLy8gMSA9IG9ubHkgZnVsbHkgc2F0dXJhdGVkXG4gICAgICAvLyA+IDEgPSBzZWdtZW50cyBmcm9tIHdoaXRlIHRvIGZ1bGx5IHNhdHVyYXRlZFxuICAgICAgc2F0dXJhdGlvblNlZ21lbnRzOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIG9ic2VydmVyOiBcInNlZ21lbnRhdGlvbkNoYW5nZVwiLFxuICAgICAgfSxcblxuICAgICAgLy8gc2V0IHRvIHRydWUgdG8gbWFrZSB0aGUgc2VnbWVudHMgcHVyZWx5IGVzdGhldGljYWxcbiAgICAgIC8vIHRoaXMgYWxsb3dzIHNlbGVjdGlvbiBvZmYgYWxsIGNvbGxvcnMsIGFsc29cbiAgICAgIC8vIGludGVycG9sYXRlZCBiZXR3ZWVuIHRoZSBzZWdtZW50c1xuICAgICAgaWdub3JlU2VnbWVudHM6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgfSxcblxuICAgICAgLy8gdGhyb3R0bGUgdGUgYW1vdW50IG9mICdjb2xvcnNlbGVjdGVkJyBldmVudHMgZmlyZWRcbiAgICAgIC8vIHZhbHVlIGlzIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICB0aHJvdHRsZToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiA1MDAsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICByZWFkeSgpIHtcbiAgICBzdXBlci5yZWFkeSgpO1xuICAgIHRoaXMuc2V0dXBMYXllcnMoKTtcbiAgICB0aGlzLmRyYXdDb2xvcldoZWVsKCk7XG4gICAgdGhpcy5kcmF3TWFya2VyKCk7XG5cbiAgICBpZiAodGhpcy5kZXNpcmVkSHNDb2xvcikge1xuICAgICAgdGhpcy5hcHBseUhzQ29sb3IodGhpcy5kZXNpcmVkSHNDb2xvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGVzaXJlZFJnYkNvbG9yKSB7XG4gICAgICB0aGlzLmFwcGx5UmdiQ29sb3IodGhpcy5kZXNpcmVkUmdiQ29sb3IpO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJhY3Rpb25MYXllci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIChldikgPT5cbiAgICAgIHRoaXMub25Nb3VzZURvd24oZXYpXG4gICAgKTtcbiAgICB0aGlzLmludGVyYWN0aW9uTGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgKGV2KSA9PlxuICAgICAgdGhpcy5vblRvdWNoU3RhcnQoZXYpXG4gICAgKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnRzIGJyb3dzZXIgY29vcmRpbmF0ZXMgdG8gY2FudmFzIGNhbnZhcyBjb29yZGluYXRlc1xuICAvLyBvcmlnaW4gaXMgd2hlZWwgY2VudGVyXG4gIC8vIHJldHVybnMge3g6IFgsIHk6IFl9IG9iamVjdFxuICBjb252ZXJ0VG9DYW52YXNDb29yZGluYXRlcyhjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgY29uc3Qgc3ZnUG9pbnQgPSB0aGlzLmludGVyYWN0aW9uTGF5ZXIuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICBzdmdQb2ludC54ID0gY2xpZW50WDtcbiAgICBzdmdQb2ludC55ID0gY2xpZW50WTtcbiAgICBjb25zdCBjYyA9IHN2Z1BvaW50Lm1hdHJpeFRyYW5zZm9ybShcbiAgICAgIHRoaXMuaW50ZXJhY3Rpb25MYXllci5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKClcbiAgICApO1xuICAgIHJldHVybiB7IHg6IGNjLngsIHk6IGNjLnkgfTtcbiAgfVxuXG4gIC8vIE1vdXNlIGV2ZW50c1xuXG4gIG9uTW91c2VEb3duKGV2KSB7XG4gICAgY29uc3QgY2MgPSB0aGlzLmNvbnZlcnRUb0NhbnZhc0Nvb3JkaW5hdGVzKGV2LmNsaWVudFgsIGV2LmNsaWVudFkpO1xuICAgIC8vIHJldHVybiBpZiB3ZSdyZSBub3Qgb24gdGhlIHdoZWVsXG4gICAgaWYgKCF0aGlzLmlzSW5XaGVlbChjYy54LCBjYy55KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhIG1vdXNlZG93biBpbiB3aGVlbCBpcyBhbHdheXMgYSBjb2xvciBzZWxlY3QgYWN0aW9uXG4gICAgdGhpcy5vbk1vdXNlU2VsZWN0KGV2KTtcbiAgICAvLyBhbGxvdyBkcmFnZ2luZ1xuICAgIHRoaXMuY2FudmFzLmNsYXNzTGlzdC5hZGQoXCJtb3VzZVwiLCBcImRyYWdnaW5nXCIpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VTZWxlY3QpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5vbk1vdXNlVXApO1xuICB9XG5cbiAgb25Nb3VzZVVwKCkge1xuICAgIHRoaXMuY2FudmFzLmNsYXNzTGlzdC5yZW1vdmUoXCJtb3VzZVwiLCBcImRyYWdnaW5nXCIpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VTZWxlY3QpO1xuICB9XG5cbiAgb25Nb3VzZVNlbGVjdChldikge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnByb2Nlc3NVc2VyU2VsZWN0KGV2KSk7XG4gIH1cblxuICAvLyBUb3VjaCBldmVudHNcblxuICBvblRvdWNoU3RhcnQoZXYpIHtcbiAgICBjb25zdCB0b3VjaCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIGNvbnN0IGNjID0gdGhpcy5jb252ZXJ0VG9DYW52YXNDb29yZGluYXRlcyh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgICAvLyByZXR1cm4gaWYgd2UncmUgbm90IG9uIHRoZSB3aGVlbFxuICAgIGlmICghdGhpcy5pc0luV2hlZWwoY2MueCwgY2MueSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2LnRhcmdldCA9PT0gdGhpcy5tYXJrZXIpIHtcbiAgICAgIC8vIGRyYWcgbWFya2VyXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LmFkZChcInRvdWNoXCIsIFwiZHJhZ2dpbmdcIik7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5vblRvdWNoU2VsZWN0KTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMub25Ub3VjaEVuZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGRvbid0IGZpcmUgY29sb3Igc2VsZWN0aW9uIGltbWVkaWF0ZWx5LFxuICAgIC8vIHdhaXQgZm9yIHRvdWNoZW5kIGFuZCBpbnZhbGlkYXRlIHdoZW4gd2Ugc2Nyb2xsXG4gICAgdGhpcy50YXBCZWNhbWVTY3JvbGwgPSBmYWxzZTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLm9uVGFwKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNobW92ZVwiLFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLnRhcEJlY2FtZVNjcm9sbCA9IHRydWU7XG4gICAgICB9LFxuICAgICAgeyBwYXNzaXZlOiB0cnVlIH1cbiAgICApO1xuICB9XG5cbiAgb25UYXAoZXYpIHtcbiAgICBpZiAodGhpcy50YXBCZWNhbWVTY3JvbGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLm9uVG91Y2hTZWxlY3QoZXYpO1xuICB9XG5cbiAgb25Ub3VjaEVuZCgpIHtcbiAgICB0aGlzLmNhbnZhcy5jbGFzc0xpc3QucmVtb3ZlKFwidG91Y2hcIiwgXCJkcmFnZ2luZ1wiKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5vblRvdWNoU2VsZWN0KTtcbiAgfVxuXG4gIG9uVG91Y2hTZWxlY3QoZXYpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5wcm9jZXNzVXNlclNlbGVjdChldi5jaGFuZ2VkVG91Y2hlc1swXSkpO1xuICB9XG5cbiAgLypcbiAgICogR2VuZXJhbCBldmVudC9zZWxlY3Rpb24gaGFuZGxpbmdcbiAgICovXG5cbiAgLy8gUHJvY2VzcyB1c2VyIGlucHV0IHRvIGNvbG9yXG4gIHByb2Nlc3NVc2VyU2VsZWN0KGV2KSB7XG4gICAgY29uc3QgY2FudmFzWFkgPSB0aGlzLmNvbnZlcnRUb0NhbnZhc0Nvb3JkaW5hdGVzKGV2LmNsaWVudFgsIGV2LmNsaWVudFkpO1xuICAgIGNvbnN0IGhzID0gdGhpcy5nZXRDb2xvcihjYW52YXNYWS54LCBjYW52YXNYWS55KTtcbiAgICBsZXQgcmdiO1xuICAgIGlmICghdGhpcy5pc0luV2hlZWwoY2FudmFzWFkueCwgY2FudmFzWFkueSkpIHtcbiAgICAgIGNvbnN0IFtyLCBnLCBiXSA9IGhzMnJnYihbaHMuaCwgaHMuc10pO1xuICAgICAgcmdiID0geyByLCBnLCBiIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJnYiA9IHRoaXMuZ2V0UmdiQ29sb3IoY2FudmFzWFkueCwgY2FudmFzWFkueSk7XG4gICAgfVxuICAgIHRoaXMub25Db2xvclNlbGVjdChocywgcmdiKTtcbiAgfVxuXG4gIC8vIGFwcGx5IGNvbG9yIHRvIG1hcmtlciBwb3NpdGlvbiBhbmQgY2FudmFzXG4gIG9uQ29sb3JTZWxlY3QoaHMsIHJnYikge1xuICAgIHRoaXMuc2V0TWFya2VyT25Db2xvcihocyk7IC8vIG1hcmtlciBhbHdheXMgZm9sbG93cyBtb3VzZSAncmF3JyBocyB2YWx1ZSAoPSBtb3VzZSBwb3NpdGlvbilcbiAgICBpZiAoIXRoaXMuaWdub3JlU2VnbWVudHMpIHtcbiAgICAgIC8vIGFwcGx5IHNlZ21lbnRzIGlmIG5lZWRlZFxuICAgICAgaHMgPSB0aGlzLmFwcGx5U2VnbWVudEZpbHRlcihocyk7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBhcHBseSB0aGUgbmV3IGNvbG9yIHRvIHRoZSBpbnRlcmZhY2UgLyBjYW52YXNcbiAgICB0aGlzLmFwcGx5Q29sb3JUb0NhbnZhcyhocyk7XG4gICAgLy8gdGhyb3R0bGluZyBpcyBhcHBsaWVkIHRvIHVwZGF0aW5nIHRoZSBleHBvc2VkIGNvbG9ycyAocHJvcGVydGllcylcbiAgICAvLyBhbmQgZmlyaW5nIG9mIGV2ZW50c1xuICAgIGlmICh0aGlzLmNvbG9yU2VsZWN0SXNUaHJvdHRsZWQpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBhcHBseSB0aGUgbGFzdCBzZWxlY3RlZCBjb2xvclxuICAgICAgLy8gZXZlbnR1YWxseSBhZnRlciB0aHJvdHRsZSBsaW1pdCBoYXMgcGFzc2VkXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5lbnN1cmVGaW5hbFNlbGVjdCk7XG4gICAgICB0aGlzLmVuc3VyZUZpbmFsU2VsZWN0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZmlyZUNvbG9yU2VsZWN0ZWQoaHMsIHJnYik7IC8vIGRvIGl0IGZvciB0aGUgZmluYWwgdGltZVxuICAgICAgfSwgdGhpcy50aHJvdHRsZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmlyZUNvbG9yU2VsZWN0ZWQoaHMsIHJnYik7IC8vIGRvIGl0XG4gICAgdGhpcy5jb2xvclNlbGVjdElzVGhyb3R0bGVkID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY29sb3JTZWxlY3RJc1Rocm90dGxlZCA9IGZhbHNlO1xuICAgIH0sIHRoaXMudGhyb3R0bGUpO1xuICB9XG5cbiAgLy8gc2V0IGNvbG9yIHZhbHVlcyBhbmQgZmlyZSBjb2xvcnNlbGVjdGVkIGV2ZW50XG4gIGZpcmVDb2xvclNlbGVjdGVkKGhzLCByZ2IpIHtcbiAgICB0aGlzLmhzQ29sb3IgPSBocztcbiAgICB0aGlzLmZpcmUoXCJjb2xvcnNlbGVjdGVkXCIsIHsgaHMsIHJnYiB9KTtcbiAgfVxuXG4gIC8qXG4gICAqIEludGVyZmFjZSB1cGRhdGluZ1xuICAgKi9cblxuICAvLyBzZXQgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBjb2xvclxuICBzZXRNYXJrZXJPbkNvbG9yKGhzKSB7XG4gICAgaWYgKCF0aGlzLm1hcmtlciB8fCAhdGhpcy50b29sdGlwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpc3QgPSBocy5zICogdGhpcy5yYWRpdXM7XG4gICAgY29uc3QgdGhldGEgPSAoKGhzLmggLSAxODApIC8gMTgwKSAqIE1hdGguUEk7XG4gICAgY29uc3QgbWFya2VyZFggPSAtZGlzdCAqIE1hdGguY29zKHRoZXRhKTtcbiAgICBjb25zdCBtYXJrZXJkWSA9IC1kaXN0ICogTWF0aC5zaW4odGhldGEpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZVN0cmluZyA9IGB0cmFuc2xhdGUoJHttYXJrZXJkWH0sJHttYXJrZXJkWX0pYDtcbiAgICB0aGlzLm1hcmtlci5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNsYXRlU3RyaW5nKTtcbiAgICB0aGlzLnRvb2x0aXAuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRyYW5zbGF0ZVN0cmluZyk7XG4gIH1cblxuICAvLyBhcHBseSBnaXZlbiBjb2xvciB0byBpbnRlcmZhY2UgZWxlbWVudHNcbiAgYXBwbHlDb2xvclRvQ2FudmFzKGhzKSB7XG4gICAgaWYgKCF0aGlzLmludGVyYWN0aW9uTGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gd2UncmUgbm90IHJlYWxseSBjb252ZXJ0aW5nIGhzIHRvIGhzbCBoZXJlLCBidXQgd2Uga2VlcCBpdCBjaGVhcFxuICAgIC8vIHNldHRpbmcgdGhlIGNvbG9yIG9uIHRoZSBpbnRlcmFjdGlvbkxheWVyLCB0aGUgc3ZnIGVsZW1lbnRzIGNhbiBpbmhlcml0XG4gICAgdGhpcy5pbnRlcmFjdGlvbkxheWVyLnN0eWxlLmNvbG9yID0gYGhzbCgke2hzLmh9LCAxMDAlLCAke1xuICAgICAgMTAwIC0gaHMucyAqIDUwXG4gICAgfSUpYDtcbiAgfVxuXG4gIGFwcGx5SHNDb2xvcihocykge1xuICAgIC8vIGRvIG5vdGhpbmcgaXMgd2UgYWxyZWFkeSBoYXZlIHRoZSBzYW1lIGNvbG9yXG4gICAgaWYgKHRoaXMuaHNDb2xvciAmJiB0aGlzLmhzQ29sb3IuaCA9PT0gaHMuaCAmJiB0aGlzLmhzQ29sb3IucyA9PT0gaHMucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldE1hcmtlck9uQ29sb3IoaHMpOyAvLyBtYXJrZXIgaXMgYWx3YXlzIHNldCBvbiAncmF3JyBocyBwb3NpdGlvblxuICAgIGlmICghdGhpcy5pZ25vcmVTZWdtZW50cykge1xuICAgICAgLy8gYXBwbHkgc2VnbWVudHMgaWYgbmVlZGVkXG4gICAgICBocyA9IHRoaXMuYXBwbHlTZWdtZW50RmlsdGVyKGhzKTtcbiAgICB9XG4gICAgdGhpcy5oc0NvbG9yID0gaHM7XG4gICAgLy8gYWx3YXlzIGFwcGx5IHRoZSBuZXcgY29sb3IgdG8gdGhlIGludGVyZmFjZSAvIGNhbnZhc1xuICAgIHRoaXMuYXBwbHlDb2xvclRvQ2FudmFzKGhzKTtcbiAgfVxuXG4gIGFwcGx5UmdiQ29sb3IocmdiKSB7XG4gICAgY29uc3QgW2gsIHNdID0gcmdiMmhzKHJnYik7XG4gICAgdGhpcy5hcHBseUhzQ29sb3IoeyBoLCBzIH0pO1xuICB9XG5cbiAgLypcbiAgICogaW5wdXQgcHJvY2Vzc2luZyBoZWxwZXJzXG4gICAqL1xuXG4gIC8vIGdldCBhbmdsZSAoZGVncmVlcylcbiAgZ2V0QW5nbGUoZFgsIGRZKSB7XG4gICAgY29uc3QgdGhldGEgPSBNYXRoLmF0YW4yKC1kWSwgLWRYKTsgLy8gcmFkaWFucyBmcm9tIHRoZSBsZWZ0IGVkZ2UsIGNsb2Nrd2lzZSA9IHBvc2l0aXZlXG4gICAgY29uc3QgYW5nbGUgPSAodGhldGEgLyBNYXRoLlBJKSAqIDE4MCArIDE4MDsgLy8gZGVncmVlcywgY2xvY2t3aXNlIGZyb20gcmlnaHRcbiAgICByZXR1cm4gYW5nbGU7XG4gIH1cblxuICAvLyByZXR1cm5zIHRydWUgd2hlbiBjb29yZGluYXRlcyBhcmUgaW4gdGhlIGNvbG9yd2hlZWxcbiAgaXNJbldoZWVsKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaXN0YW5jZSh4LCB5KSA8PSAxO1xuICB9XG5cbiAgLy8gcmV0dXJucyBkaXN0YW5jZSBmcm9tIHdoZWVsIGNlbnRlciwgMCA9IGNlbnRlciwgMSA9IGVkZ2UsID4xID0gb3V0c2lkZVxuICBnZXREaXN0YW5jZShkWCwgZFkpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKSAvIHRoaXMucmFkaXVzO1xuICB9XG5cbiAgLypcbiAgICogR2V0dGluZyBjb2xvcnNcbiAgICovXG5cbiAgZ2V0Q29sb3IoeCwgeSkge1xuICAgIGNvbnN0IGh1ZSA9IHRoaXMuZ2V0QW5nbGUoeCwgeSk7IC8vIGRlZ3JlZXMsIGNsb2Nrd2lzZSBmcm9tIHJpZ2h0XG4gICAgY29uc3QgcmVsYXRpdmVEaXN0YW5jZSA9IHRoaXMuZ2V0RGlzdGFuY2UoeCwgeSk7IC8vIGVkZ2Ugb2YgcmFkaXVzID0gMVxuICAgIGNvbnN0IHNhdCA9IE1hdGgubWluKHJlbGF0aXZlRGlzdGFuY2UsIDEpOyAvLyBEaXN0YW5jZSBmcm9tIGNlbnRlclxuICAgIHJldHVybiB7IGg6IGh1ZSwgczogc2F0IH07XG4gIH1cblxuICBnZXRSZ2JDb2xvcih4LCB5KSB7XG4gICAgLy8gZ2V0IGN1cnJlbnQgcGl4ZWxcbiAgICBjb25zdCBpbWFnZURhdGEgPSB0aGlzLmJhY2tncm91bmRMYXllclxuICAgICAgLmdldENvbnRleHQoXCIyZFwiKVxuICAgICAgLmdldEltYWdlRGF0YSh4ICsgMjUwLCB5ICsgMjUwLCAxLCAxKTtcbiAgICBjb25zdCBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xuICAgIHJldHVybiB7IHI6IHBpeGVsWzBdLCBnOiBwaXhlbFsxXSwgYjogcGl4ZWxbMl0gfTtcbiAgfVxuXG4gIGFwcGx5U2VnbWVudEZpbHRlcihocykge1xuICAgIC8vIGFwcGx5IGh1ZSBzZWdtZW50IHN0ZXBzXG4gICAgaWYgKHRoaXMuaHVlU2VnbWVudHMpIHtcbiAgICAgIGNvbnN0IGFuZ2xlU3RlcCA9IDM2MCAvIHRoaXMuaHVlU2VnbWVudHM7XG4gICAgICBjb25zdCBoYWxmQW5nbGVTdGVwID0gYW5nbGVTdGVwIC8gMjtcbiAgICAgIGhzLmggLT0gaGFsZkFuZ2xlU3RlcDsgLy8gdGFrZSB0aGUgJ2NlbnRlcmVkIHNlZ2VtbnRzJyBpbnRvIGFjY291bnRcbiAgICAgIGlmIChocy5oIDwgMCkge1xuICAgICAgICBocy5oICs9IDM2MDtcbiAgICAgIH0gLy8gZG9uJ3QgZW5kIHVwIGJlbG93IDBcbiAgICAgIGNvbnN0IHJlc3QgPSBocy5oICUgYW5nbGVTdGVwO1xuICAgICAgaHMuaCAtPSByZXN0IC0gYW5nbGVTdGVwO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IHNhdHVyYXRpb24gc2VnbWVudCBzdGVwc1xuICAgIGlmICh0aGlzLnNhdHVyYXRpb25TZWdtZW50cykge1xuICAgICAgaWYgKHRoaXMuc2F0dXJhdGlvblNlZ21lbnRzID09PSAxKSB7XG4gICAgICAgIGhzLnMgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudFNpemUgPSAxIC8gdGhpcy5zYXR1cmF0aW9uU2VnbWVudHM7XG4gICAgICAgIGNvbnN0IHNhdHVyYXRpb25TdGVwID0gMSAvICh0aGlzLnNhdHVyYXRpb25TZWdtZW50cyAtIDEpO1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkU2F0ID0gTWF0aC5mbG9vcihocy5zIC8gc2VnbWVudFNpemUpICogc2F0dXJhdGlvblN0ZXA7XG4gICAgICAgIGhzLnMgPSBNYXRoLm1pbihjYWxjdWxhdGVkU2F0LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhzO1xuICB9XG5cbiAgLypcbiAgICogRHJhd2luZyByZWxhdGVkIHN0dWZmXG4gICAqL1xuXG4gIHNldHVwTGF5ZXJzKCkge1xuICAgIHRoaXMuY2FudmFzID0gdGhpcy4kLmNhbnZhcztcbiAgICB0aGlzLmJhY2tncm91bmRMYXllciA9IHRoaXMuJC5iYWNrZ3JvdW5kTGF5ZXI7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkxheWVyID0gdGhpcy4kLmludGVyYWN0aW9uTGF5ZXI7XG5cbiAgICAvLyBjb29yZGluYXRlIG9yaWdpbiBwb3NpdGlvbiAoY2VudGVyIG9mIHRoZSB3aGVlbClcbiAgICB0aGlzLm9yaWdpblggPSB0aGlzLndpZHRoIC8gMjtcbiAgICB0aGlzLm9yaWdpblkgPSB0aGlzLm9yaWdpblg7XG5cbiAgICAvLyBzeW5jaHJvbmlzZSB3aWR0aC9oZWlnaHQgY29vcmRpbmF0ZXNcbiAgICB0aGlzLmJhY2tncm91bmRMYXllci53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTGF5ZXIuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkxheWVyLnNldEF0dHJpYnV0ZShcbiAgICAgIFwidmlld0JveFwiLFxuICAgICAgYCR7LXRoaXMub3JpZ2luWH0gJHstdGhpcy5vcmlnaW5ZfSAke3RoaXMud2lkdGh9ICR7dGhpcy5oZWlnaHR9YFxuICAgICk7XG4gIH1cblxuICBkcmF3Q29sb3JXaGVlbCgpIHtcbiAgICAvKlxuICAgICAqICBTZXR0aW5nIHVwIGFsbCBwYXJlbWV0ZXJzXG4gICAgICovXG4gICAgbGV0IHNoYWRvd0NvbG9yO1xuICAgIGxldCBzaGFkb3dPZmZzZXRYO1xuICAgIGxldCBzaGFkb3dPZmZzZXRZO1xuICAgIGxldCBzaGFkb3dCbHVyO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmJhY2tncm91bmRMYXllci5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgLy8gcG9zdGlvbmluZyBhbmQgc2l6aW5nXG4gICAgY29uc3QgY1ggPSB0aGlzLm9yaWdpblg7XG4gICAgY29uc3QgY1kgPSB0aGlzLm9yaWdpblk7XG4gICAgY29uc3QgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgY29uc3QgY291bnRlckNsb2Nrd2lzZSA9IGZhbHNlO1xuICAgIC8vIHN0eWxpbmcgb2YgdGhlIHdoZWVsXG4gICAgY29uc3Qgd2hlZWxTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuYmFja2dyb3VuZExheWVyLCBudWxsKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IHBhcnNlSW50KFxuICAgICAgd2hlZWxTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS13aGVlbC1ib3JkZXJ3aWR0aFwiKSxcbiAgICAgIDEwXG4gICAgKTtcbiAgICBjb25zdCBib3JkZXJDb2xvciA9IHdoZWVsU3R5bGVcbiAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKFwiLS13aGVlbC1ib3JkZXJjb2xvclwiKVxuICAgICAgLnRyaW0oKTtcbiAgICBjb25zdCB3aGVlbFNoYWRvdyA9IHdoZWVsU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0td2hlZWwtc2hhZG93XCIpLnRyaW0oKTtcbiAgICAvLyBleHRyYWN0IHNoYWRvdyBwcm9wZXJ0aWVzIGZyb20gQ1NTIHZhcmlhYmxlXG4gICAgLy8gdGhlIHNoYWRvdyBzaG91bGQgYmUgZGVmaW5lZCBhczogXCIxMHB4IDVweCA1cHggMHB4IENPTE9SXCJcbiAgICBpZiAod2hlZWxTaGFkb3cgIT09IFwibm9uZVwiKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB3aGVlbFNoYWRvdy5zcGxpdChcInB4IFwiKTtcbiAgICAgIHNoYWRvd0NvbG9yID0gdmFsdWVzLnBvcCgpO1xuICAgICAgc2hhZG93T2Zmc2V0WCA9IHBhcnNlSW50KHZhbHVlc1swXSwgMTApO1xuICAgICAgc2hhZG93T2Zmc2V0WSA9IHBhcnNlSW50KHZhbHVlc1sxXSwgMTApO1xuICAgICAgc2hhZG93Qmx1ciA9IHBhcnNlSW50KHZhbHVlc1syXSwgMTApIHx8IDA7XG4gICAgfVxuICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHJhZGl1cyArIGJvcmRlcldpZHRoIC8gMjtcbiAgICBjb25zdCB3aGVlbFJhZGl1cyA9IHJhZGl1cztcbiAgICBjb25zdCBzaGFkb3dSYWRpdXMgPSByYWRpdXMgKyBib3JkZXJXaWR0aDtcblxuICAgIC8qXG4gICAgICogIERyYXdpbmcgZnVuY3Rpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhd0NpcmNsZShodWVTZWdtZW50cywgc2F0dXJhdGlvblNlZ21lbnRzKSB7XG4gICAgICBodWVTZWdtZW50cyA9IGh1ZVNlZ21lbnRzIHx8IDM2MDsgLy8gcmVzZXQgMCBzZWdtZW50cyB0byAzNjBcbiAgICAgIGNvbnN0IGFuZ2xlU3RlcCA9IDM2MCAvIGh1ZVNlZ21lbnRzO1xuICAgICAgY29uc3QgaGFsZkFuZ2xlU3RlcCA9IGFuZ2xlU3RlcCAvIDI7IC8vIGNlbnRlciBzZWdtZW50cyBvbiBjb2xvclxuICAgICAgZm9yIChsZXQgYW5nbGUgPSAwOyBhbmdsZSA8PSAzNjA7IGFuZ2xlICs9IGFuZ2xlU3RlcCkge1xuICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gKGFuZ2xlIC0gaGFsZkFuZ2xlU3RlcCkgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIGNvbnN0IGVuZEFuZ2xlID0gKGFuZ2xlICsgaGFsZkFuZ2xlU3RlcCArIDEpICogKE1hdGguUEkgLyAxODApO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhjWCwgY1kpO1xuICAgICAgICBjb250ZXh0LmFyYyhcbiAgICAgICAgICBjWCxcbiAgICAgICAgICBjWSxcbiAgICAgICAgICB3aGVlbFJhZGl1cyxcbiAgICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICAgIGNvdW50ZXJDbG9ja3dpc2VcbiAgICAgICAgKTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgLy8gZ3JhZGllbnRcbiAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgICAgIGNYLFxuICAgICAgICAgIGNZLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgY1gsXG4gICAgICAgICAgY1ksXG4gICAgICAgICAgd2hlZWxSYWRpdXNcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGxpZ2h0bmVzcyA9IDEwMDtcbiAgICAgICAgLy8gZmlyc3QgZ3JhZGllbnQgc3RvcFxuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgYGhzbCgke2FuZ2xlfSwgMTAwJSwgJHtsaWdodG5lc3N9JSlgKTtcbiAgICAgICAgLy8gc2VnbWVudCBncmFkaWVudCBzdG9wc1xuICAgICAgICBpZiAoc2F0dXJhdGlvblNlZ21lbnRzID4gMCkge1xuICAgICAgICAgIGNvbnN0IHJhdGlvU3RlcCA9IDEgLyBzYXR1cmF0aW9uU2VnbWVudHM7XG4gICAgICAgICAgbGV0IHJhdGlvID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBzdG9wID0gMTsgc3RvcCA8IHNhdHVyYXRpb25TZWdtZW50czsgc3RvcCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2TGlnaG5lc3MgPSBsaWdodG5lc3M7XG4gICAgICAgICAgICByYXRpbyA9IHN0b3AgKiByYXRpb1N0ZXA7XG4gICAgICAgICAgICBsaWdodG5lc3MgPSAxMDAgLSA1MCAqIHJhdGlvO1xuICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKFxuICAgICAgICAgICAgICByYXRpbyxcbiAgICAgICAgICAgICAgYGhzbCgke2FuZ2xlfSwgMTAwJSwgJHtwcmV2TGlnaG5lc3N9JSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHJhdGlvLCBgaHNsKCR7YW5nbGV9LCAxMDAlLCAke2xpZ2h0bmVzc30lKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AocmF0aW8sIGBoc2woJHthbmdsZX0sIDEwMCUsIDUwJSlgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsYXN0IGdyYWRpZW50IHN0b3BcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIGBoc2woJHthbmdsZX0sIDEwMCUsIDUwJSlgKTtcblxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3U2hhZG93KCkge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMoY1gsIGNZLCBzaGFkb3dSYWRpdXMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3I7XG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSBzaGFkb3dPZmZzZXRYO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gc2hhZG93T2Zmc2V0WTtcbiAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IHNoYWRvd0JsdXI7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0JvcmRlcigpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LmFyYyhjWCwgY1ksIGJvcmRlclJhZGl1cywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogICBDYWxsIHRoZSBkcmF3aW5nIGZ1bmN0aW9uc1xuICAgICAqICAgZHJhd3MgdGhlIHNoYWRvdywgd2hlZWwgYW5kIGJvcmRlclxuICAgICAqL1xuICAgIGlmICh3aGVlbFN0eWxlLnNoYWRvdyAhPT0gXCJub25lXCIpIHtcbiAgICAgIGRyYXdTaGFkb3coKTtcbiAgICB9XG4gICAgZHJhd0NpcmNsZSh0aGlzLmh1ZVNlZ21lbnRzLCB0aGlzLnNhdHVyYXRpb25TZWdtZW50cyk7XG4gICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgZHJhd0JvcmRlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqICAgRHJhdyB0aGUgKGRyYWdnYWJsZSkgbWFya2VyIGFuZCB0b29sdGlwXG4gICAqICAgb24gdGhlIGludGVyYWN0aW9uTGF5ZXIpXG4gICAqL1xuXG4gIGRyYXdNYXJrZXIoKSB7XG4gICAgY29uc3Qgc3ZnRWxlbWVudCA9IHRoaXMuaW50ZXJhY3Rpb25MYXllcjtcbiAgICBjb25zdCBtYXJrZXJyYWRpdXMgPSB0aGlzLnJhZGl1cyAqIDAuMDg7XG4gICAgY29uc3QgdG9vbHRpcHJhZGl1cyA9IHRoaXMucmFkaXVzICogMC4xNTtcbiAgICBjb25zdCBUb29sdGlwT2Zmc2V0WSA9IC0odG9vbHRpcHJhZGl1cyAqIDMpO1xuICAgIGNvbnN0IFRvb2x0aXBPZmZzZXRYID0gMDtcblxuICAgIHN2Z0VsZW1lbnQubWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFxuICAgICAgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgXCJjaXJjbGVcIlxuICAgICk7XG4gICAgc3ZnRWxlbWVudC5tYXJrZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJtYXJrZXJcIik7XG4gICAgc3ZnRWxlbWVudC5tYXJrZXIuc2V0QXR0cmlidXRlKFwiclwiLCBtYXJrZXJyYWRpdXMpO1xuICAgIHRoaXMubWFya2VyID0gc3ZnRWxlbWVudC5tYXJrZXI7XG4gICAgc3ZnRWxlbWVudC5hcHBlbmRDaGlsZChzdmdFbGVtZW50Lm1hcmtlcik7XG5cbiAgICBzdmdFbGVtZW50LnRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXG4gICAgICBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICBcImNpcmNsZVwiXG4gICAgKTtcbiAgICBzdmdFbGVtZW50LnRvb2x0aXAuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJjb2xvclRvb2x0aXBcIik7XG4gICAgc3ZnRWxlbWVudC50b29sdGlwLnNldEF0dHJpYnV0ZShcInJcIiwgdG9vbHRpcHJhZGl1cyk7XG4gICAgc3ZnRWxlbWVudC50b29sdGlwLnNldEF0dHJpYnV0ZShcImN4XCIsIFRvb2x0aXBPZmZzZXRYKTtcbiAgICBzdmdFbGVtZW50LnRvb2x0aXAuc2V0QXR0cmlidXRlKFwiY3lcIiwgVG9vbHRpcE9mZnNldFkpO1xuICAgIHRoaXMudG9vbHRpcCA9IHN2Z0VsZW1lbnQudG9vbHRpcDtcbiAgICBzdmdFbGVtZW50LmFwcGVuZENoaWxkKHN2Z0VsZW1lbnQudG9vbHRpcCk7XG4gIH1cblxuICBzZWdtZW50YXRpb25DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuYmFja2dyb3VuZExheWVyKSB7XG4gICAgICB0aGlzLmRyYXdDb2xvcldoZWVsKCk7XG4gICAgfVxuICB9XG59XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJoYS1jb2xvci1waWNrZXJcIiwgSGFDb2xvclBpY2tlcik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/ha-color-picker.js\n");

/***/ }),

/***/ "./src/components/ha-labeled-slider.js":
/*!*********************************************!*\
  !*** ./src/components/ha-labeled-slider.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _ha_icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ha-icon */ \"./src/components/ha-icon.ts\");\n/* harmony import */ var _ha_slider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ha-slider */ \"./src/components/ha-slider.js\");\n\n/* eslint-plugin-disable lit */\n\n\n\n\n\nclass HaLabeledSlider extends _polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_1__.PolymerElement {\n  static get template() {\n    return _polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_0__.html`\n      <style>\n        :host {\n          display: block;\n        }\n\n        .title {\n          margin: 5px 0 8px;\n          color: var(--primary-text-color);\n        }\n\n        .slider-container {\n          display: flex;\n        }\n\n        ha-icon {\n          margin-top: 4px;\n          color: var(--secondary-text-color);\n        }\n\n        ha-slider {\n          flex-grow: 1;\n          background-image: var(--ha-slider-background);\n          border-radius: 4px;\n        }\n      </style>\n\n      <div class=\"title\">[[_getTitle()]]</div>\n      <div class=\"extra-container\"><slot name=\"extra\"></slot></div>\n      <div class=\"slider-container\">\n        <ha-icon icon=\"[[icon]]\" hidden$=\"[[!icon]]\"></ha-icon>\n        <ha-slider\n          min=\"[[min]]\"\n          max=\"[[max]]\"\n          step=\"[[step]]\"\n          pin=\"[[pin]]\"\n          disabled=\"[[disabled]]\"\n          value=\"{{value}}\"\n        ></ha-slider>\n      </div>\n      <template is=\"dom-if\" if=\"[[helper]]\">\n        <ha-input-helper-text>[[helper]]</ha-input-helper-text>\n      </template>\n    `;\n  }\n\n  _getTitle() {\n    return `${this.caption}${this.caption && this.required ? \" *\" : \"\"}`;\n  }\n\n  static get properties() {\n    return {\n      caption: String,\n      disabled: Boolean,\n      required: Boolean,\n      min: Number,\n      max: Number,\n      pin: Boolean,\n      step: Number,\n      helper: String,\n      extra: {\n        type: Boolean,\n        value: false\n      },\n      ignoreBarTouch: {\n        type: Boolean,\n        value: true\n      },\n      icon: {\n        type: String,\n        value: \"\"\n      },\n      value: {\n        type: Number,\n        notify: true\n      }\n    };\n  }\n\n}\n\ncustomElements.define(\"ha-labeled-slider\", HaLabeledSlider);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9oYS1sYWJlbGVkLXNsaWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUF0QkE7QUEyQkE7O0FBaEZBOztBQW1GQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vc3JjL2NvbXBvbmVudHMvaGEtbGFiZWxlZC1zbGlkZXIuanM/OGIyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBodG1sIH0gZnJvbSBcIkBwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2h0bWwtdGFnXCI7XG4vKiBlc2xpbnQtcGx1Z2luLWRpc2FibGUgbGl0ICovXG5pbXBvcnQgeyBQb2x5bWVyRWxlbWVudCB9IGZyb20gXCJAcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudFwiO1xuaW1wb3J0IFwiLi9oYS1pY29uXCI7XG5pbXBvcnQgXCIuL2hhLXNsaWRlclwiO1xuXG5jbGFzcyBIYUxhYmVsZWRTbGlkZXIgZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIC50aXRsZSB7XG4gICAgICAgICAgbWFyZ2luOiA1cHggMCA4cHg7XG4gICAgICAgICAgY29sb3I6IHZhcigtLXByaW1hcnktdGV4dC1jb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICAuc2xpZGVyLWNvbnRhaW5lciB7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhLWljb24ge1xuICAgICAgICAgIG1hcmdpbi10b3A6IDRweDtcbiAgICAgICAgICBjb2xvcjogdmFyKC0tc2Vjb25kYXJ5LXRleHQtY29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGEtc2xpZGVyIHtcbiAgICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogdmFyKC0taGEtc2xpZGVyLWJhY2tncm91bmQpO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cblxuICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+W1tfZ2V0VGl0bGUoKV1dPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiZXh0cmEtY29udGFpbmVyXCI+PHNsb3QgbmFtZT1cImV4dHJhXCI+PC9zbG90PjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInNsaWRlci1jb250YWluZXJcIj5cbiAgICAgICAgPGhhLWljb24gaWNvbj1cIltbaWNvbl1dXCIgaGlkZGVuJD1cIltbIWljb25dXVwiPjwvaGEtaWNvbj5cbiAgICAgICAgPGhhLXNsaWRlclxuICAgICAgICAgIG1pbj1cIltbbWluXV1cIlxuICAgICAgICAgIG1heD1cIltbbWF4XV1cIlxuICAgICAgICAgIHN0ZXA9XCJbW3N0ZXBdXVwiXG4gICAgICAgICAgcGluPVwiW1twaW5dXVwiXG4gICAgICAgICAgZGlzYWJsZWQ9XCJbW2Rpc2FibGVkXV1cIlxuICAgICAgICAgIHZhbHVlPVwie3t2YWx1ZX19XCJcbiAgICAgICAgPjwvaGEtc2xpZGVyPlxuICAgICAgPC9kaXY+XG4gICAgICA8dGVtcGxhdGUgaXM9XCJkb20taWZcIiBpZj1cIltbaGVscGVyXV1cIj5cbiAgICAgICAgPGhhLWlucHV0LWhlbHBlci10ZXh0PltbaGVscGVyXV08L2hhLWlucHV0LWhlbHBlci10ZXh0PlxuICAgICAgPC90ZW1wbGF0ZT5cbiAgICBgO1xuICB9XG5cbiAgX2dldFRpdGxlKCkge1xuICAgIHJldHVybiBgJHt0aGlzLmNhcHRpb259JHt0aGlzLmNhcHRpb24gJiYgdGhpcy5yZXF1aXJlZCA/IFwiICpcIiA6IFwiXCJ9YDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FwdGlvbjogU3RyaW5nLFxuICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgICByZXF1aXJlZDogQm9vbGVhbixcbiAgICAgIG1pbjogTnVtYmVyLFxuICAgICAgbWF4OiBOdW1iZXIsXG4gICAgICBwaW46IEJvb2xlYW4sXG4gICAgICBzdGVwOiBOdW1iZXIsXG4gICAgICBoZWxwZXI6IFN0cmluZyxcblxuICAgICAgZXh0cmE6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIGlnbm9yZUJhclRvdWNoOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIGljb246IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgIH0sXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJoYS1sYWJlbGVkLXNsaWRlclwiLCBIYUxhYmVsZWRTbGlkZXIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/ha-labeled-slider.js\n");

/***/ }),

/***/ "./src/dialogs/more-info/controls/more-info-light.ts":
/*!***********************************************************!*\
  !*** ./src/dialogs/more-info/controls/more-info-light.ts ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _material_mwc_list_mwc_list_item__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @material/mwc-list/mwc-list-item */ \"./node_modules/@material/mwc-list/mwc-list-item.js\");\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/decorators */ \"./node_modules/lit/decorators.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! memoize-one */ \"./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var _common_dom_stop_propagation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/dom/stop_propagation */ \"./src/common/dom/stop_propagation.ts\");\n/* harmony import */ var _common_entity_supports_feature__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/entity/supports-feature */ \"./src/common/entity/supports-feature.ts\");\n/* harmony import */ var _components_ha_attributes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/ha-attributes */ \"./src/components/ha-attributes.ts\");\n/* harmony import */ var _components_ha_button_toggle_group__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../components/ha-button-toggle-group */ \"./src/components/ha-button-toggle-group.ts\");\n/* harmony import */ var _components_ha_color_picker__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../components/ha-color-picker */ \"./src/components/ha-color-picker.js\");\n/* harmony import */ var _components_ha_icon_button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../components/ha-icon-button */ \"./src/components/ha-icon-button.ts\");\n/* harmony import */ var _components_ha_labeled_slider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../components/ha-labeled-slider */ \"./src/components/ha-labeled-slider.js\");\n/* harmony import */ var _components_ha_select__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../components/ha-select */ \"./src/components/ha-select.ts\");\n/* harmony import */ var _data_light__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../data/light */ \"./src/data/light.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_components_ha_attributes__WEBPACK_IMPORTED_MODULE_5__]);\n_components_ha_attributes__WEBPACK_IMPORTED_MODULE_5__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function () { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function (O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function (F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function (receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function (elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function (element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function (element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function (elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function (element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function (elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function (elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function (elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function (elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function (obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function (constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function (obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function (other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\nconst mdiPalette = \"M17.5,12A1.5,1.5 0 0,1 16,10.5A1.5,1.5 0 0,1 17.5,9A1.5,1.5 0 0,1 19,10.5A1.5,1.5 0 0,1 17.5,12M14.5,8A1.5,1.5 0 0,1 13,6.5A1.5,1.5 0 0,1 14.5,5A1.5,1.5 0 0,1 16,6.5A1.5,1.5 0 0,1 14.5,8M9.5,8A1.5,1.5 0 0,1 8,6.5A1.5,1.5 0 0,1 9.5,5A1.5,1.5 0 0,1 11,6.5A1.5,1.5 0 0,1 9.5,8M6.5,12A1.5,1.5 0 0,1 5,10.5A1.5,1.5 0 0,1 6.5,9A1.5,1.5 0 0,1 8,10.5A1.5,1.5 0 0,1 6.5,12M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21A1.5,1.5 0 0,0 13.5,19.5C13.5,19.11 13.35,18.76 13.11,18.5C12.88,18.23 12.73,17.88 12.73,17.5A1.5,1.5 0 0,1 14.23,16H16A5,5 0 0,0 21,11C21,6.58 16.97,3 12,3Z\";\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet MoreInfoLight = _decorate([(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.customElement)(\"more-info-light\")], function (_initialize, _LitElement) {\n  class MoreInfoLight extends _LitElement {\n    constructor(...args) {\n      super(...args);\n\n      _initialize(this);\n    }\n\n  }\n\n  return {\n    F: MoreInfoLight,\n    d: [{\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)({\n        attribute: false\n      })],\n      key: \"stateObj\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_brightnessSliderValue\",\n\n      value() {\n        return 0;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_ctSliderValue\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_cwSliderValue\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_wwSliderValue\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_wvSliderValue\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_colorBrightnessSliderValue\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_brightnessAdjusted\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_hueSegments\",\n\n      value() {\n        return 24;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_saturationSegments\",\n\n      value() {\n        return 8;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_colorPickerColor\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_mode\",\n      value: void 0\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        var _attributes$effect_li;\n\n        if (!this.hass || !this.stateObj) {\n          return lit__WEBPACK_IMPORTED_MODULE_1__.html``;\n        }\n\n        const supportsTemp = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.COLOR_TEMP);\n        const supportsWhite = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.WHITE);\n        const supportsRgbww = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBWW);\n        const supportsRgbw = !supportsRgbww && (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBW);\n        const supportsColor = supportsRgbww || supportsRgbw || (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColor)(this.stateObj);\n        return lit__WEBPACK_IMPORTED_MODULE_1__.html`\n      <div class=\"content\">\n        ${(0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsDimming)(this.stateObj) ? lit__WEBPACK_IMPORTED_MODULE_1__.html`\n              <ha-labeled-slider\n                caption=${this.hass.localize(\"ui.card.light.brightness\")}\n                icon=\"hass:brightness-5\"\n                min=\"1\"\n                max=\"100\"\n                value=${this._brightnessSliderValue}\n                @change=${this._brightnessSliderChanged}\n                pin\n              ></ha-labeled-slider>\n            ` : \"\"}\n        ${this.stateObj.state === \"on\" ? lit__WEBPACK_IMPORTED_MODULE_1__.html`\n              ${supportsTemp || supportsColor ? lit__WEBPACK_IMPORTED_MODULE_1__.html`<hr />` : \"\"}\n              ${supportsColor && (supportsTemp || supportsWhite) ? lit__WEBPACK_IMPORTED_MODULE_1__.html`<ha-button-toggle-group\n                    fullWidth\n                    .buttons=${this._toggleButtons(supportsTemp, supportsWhite)}\n                    .active=${this._mode}\n                    @value-changed=${this._modeChanged}\n                  ></ha-button-toggle-group>` : \"\"}\n              ${supportsTemp && (!supportsColor && !supportsWhite || this._mode === _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.COLOR_TEMP) ? lit__WEBPACK_IMPORTED_MODULE_1__.html`\n                    <ha-labeled-slider\n                      class=\"color_temp\"\n                      caption=${this.hass.localize(\"ui.card.light.color_temperature\")}\n                      icon=\"hass:thermometer\"\n                      .min=${this.stateObj.attributes.min_mireds}\n                      .max=${this.stateObj.attributes.max_mireds}\n                      .value=${this._ctSliderValue}\n                      @change=${this._ctSliderChanged}\n                      pin\n                    ></ha-labeled-slider>\n                  ` : \"\"}\n              ${supportsColor && (!supportsTemp && !supportsWhite || this._mode === \"color\") ? lit__WEBPACK_IMPORTED_MODULE_1__.html`\n                    <div class=\"segmentationContainer\">\n                      <ha-color-picker\n                        class=\"color\"\n                        @colorselected=${this._colorPicked}\n                        .desiredRgbColor=${this._colorPickerColor}\n                        throttle=\"500\"\n                        .hueSegments=${this._hueSegments}\n                        .saturationSegments=${this._saturationSegments}\n                      >\n                      </ha-color-picker>\n                      <ha-icon-button\n                        .path=${mdiPalette}\n                        @click=${this._segmentClick}\n                        class=\"segmentationButton\"\n                      ></ha-icon-button>\n                    </div>\n\n                    ${supportsRgbw || supportsRgbww ? lit__WEBPACK_IMPORTED_MODULE_1__.html`<ha-labeled-slider\n                          .caption=${this.hass.localize(\"ui.card.light.color_brightness\")}\n                          icon=\"hass:brightness-7\"\n                          max=\"100\"\n                          .value=${this._colorBrightnessSliderValue}\n                          @change=${this._colorBrightnessSliderChanged}\n                          pin\n                        ></ha-labeled-slider>` : \"\"}\n                    ${supportsRgbw ? lit__WEBPACK_IMPORTED_MODULE_1__.html`\n                          <ha-labeled-slider\n                            .caption=${this.hass.localize(\"ui.card.light.white_value\")}\n                            icon=\"hass:file-word-box\"\n                            max=\"100\"\n                            .name=${\"wv\"}\n                            .value=${this._wvSliderValue}\n                            @change=${this._wvSliderChanged}\n                            pin\n                          ></ha-labeled-slider>\n                        ` : \"\"}\n                    ${supportsRgbww ? lit__WEBPACK_IMPORTED_MODULE_1__.html`\n                          <ha-labeled-slider\n                            .caption=${this.hass.localize(\"ui.card.light.cold_white_value\")}\n                            icon=\"hass:file-word-box-outline\"\n                            max=\"100\"\n                            .name=${\"cw\"}\n                            .value=${this._cwSliderValue}\n                            @change=${this._wvSliderChanged}\n                            pin\n                          ></ha-labeled-slider>\n                          <ha-labeled-slider\n                            .caption=${this.hass.localize(\"ui.card.light.warm_white_value\")}\n                            icon=\"hass:file-word-box\"\n                            max=\"100\"\n                            .name=${\"ww\"}\n                            .value=${this._wwSliderValue}\n                            @change=${this._wvSliderChanged}\n                            pin\n                          ></ha-labeled-slider>\n                        ` : \"\"}\n                  ` : \"\"}\n              ${(0,_common_entity_supports_feature__WEBPACK_IMPORTED_MODULE_4__.supportsFeature)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.SUPPORT_EFFECT) && (_attributes$effect_li = this.stateObj.attributes.effect_list) !== null && _attributes$effect_li !== void 0 && _attributes$effect_li.length ? lit__WEBPACK_IMPORTED_MODULE_1__.html`\n                    <hr />\n                    <ha-select\n                      .label=${this.hass.localize(\"ui.card.light.effect\")}\n                      .value=${this.stateObj.attributes.effect || \"\"}\n                      fixedMenuPosition\n                      naturalMenuWidth\n                      @selected=${this._effectChanged}\n                      @closed=${_common_dom_stop_propagation__WEBPACK_IMPORTED_MODULE_3__.stopPropagation}\n                    >\n                      ${this.stateObj.attributes.effect_list.map(effect => lit__WEBPACK_IMPORTED_MODULE_1__.html`\n                          <mwc-list-item .value=${effect}>\n                            ${effect}\n                          </mwc-list-item>\n                        `)}\n                    </ha-select>\n                  ` : \"\"}\n            ` : \"\"}\n        <ha-attributes\n          .hass=${this.hass}\n          .stateObj=${this.stateObj}\n          extra-filters=\"brightness,color_temp,white_value,effect_list,effect,hs_color,rgb_color,rgbw_color,rgbww_color,xy_color,min_mireds,max_mireds,entity_id,supported_color_modes,color_mode\"\n        ></ha-attributes>\n      </div>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        _get(_getPrototypeOf(MoreInfoLight.prototype), \"willUpdate\", this).call(this, changedProps);\n\n        if (!changedProps.has(\"stateObj\")) {\n          return;\n        }\n\n        const stateObj = this.stateObj;\n        const oldStateObj = changedProps.get(\"stateObj\");\n\n        if (stateObj.state === \"on\") {\n          // Don't change tab when the color mode changes\n          if ((oldStateObj === null || oldStateObj === void 0 ? void 0 : oldStateObj.entity_id) !== stateObj.entity_id || (oldStateObj === null || oldStateObj === void 0 ? void 0 : oldStateObj.state) !== stateObj.state) {\n            this._mode = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightIsInColorMode)(this.stateObj) ? \"color\" : this.stateObj.attributes.color_mode;\n          }\n\n          let brightnessAdjust = 100;\n          this._brightnessAdjusted = undefined;\n\n          if (stateObj.attributes.color_mode === _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGB && !(0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBWW) && !(0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBW)) {\n            const maxVal = Math.max(...stateObj.attributes.rgb_color);\n\n            if (maxVal < 255) {\n              this._brightnessAdjusted = maxVal;\n              brightnessAdjust = this._brightnessAdjusted / 255 * 100;\n            }\n          }\n\n          this._brightnessSliderValue = Math.round(stateObj.attributes.brightness * brightnessAdjust / 255);\n          this._ctSliderValue = stateObj.attributes.color_temp;\n          this._wvSliderValue = stateObj.attributes.color_mode === _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBW ? Math.round(stateObj.attributes.rgbw_color[3] * 100 / 255) : undefined;\n          this._cwSliderValue = stateObj.attributes.color_mode === _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBWW ? Math.round(stateObj.attributes.rgbww_color[3] * 100 / 255) : undefined;\n          this._wwSliderValue = stateObj.attributes.color_mode === _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBWW ? Math.round(stateObj.attributes.rgbww_color[4] * 100 / 255) : undefined;\n          const currentRgbColor = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.getLightCurrentModeRgbColor)(stateObj);\n          this._colorBrightnessSliderValue = currentRgbColor ? Math.round(Math.max(...currentRgbColor.slice(0, 3)) * 100 / 255) : undefined;\n          this._colorPickerColor = currentRgbColor === null || currentRgbColor === void 0 ? void 0 : currentRgbColor.slice(0, 3);\n        } else {\n          this._brightnessSliderValue = 0;\n        }\n      }\n    }, {\n      kind: \"field\",\n      key: \"_toggleButtons\",\n\n      value() {\n        return (0,memoize_one__WEBPACK_IMPORTED_MODULE_12__[\"default\"])((supportsTemp, supportsWhite) => {\n          const modes = [{\n            label: \"Color\",\n            value: \"color\"\n          }];\n\n          if (supportsTemp) {\n            modes.push({\n              label: \"Temperature\",\n              value: _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.COLOR_TEMP\n            });\n          }\n\n          if (supportsWhite) {\n            modes.push({\n              label: \"White\",\n              value: _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.WHITE\n            });\n          }\n\n          return modes;\n        });\n      }\n\n    }, {\n      kind: \"method\",\n      key: \"_modeChanged\",\n      value: function _modeChanged(ev) {\n        this._mode = ev.detail.value;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_effectChanged\",\n      value: function _effectChanged(ev) {\n        const newVal = ev.target.value;\n\n        if (!newVal || this.stateObj.attributes.effect === newVal) {\n          return;\n        }\n\n        this.hass.callService(\"light\", \"turn_on\", {\n          entity_id: this.stateObj.entity_id,\n          effect: newVal\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_brightnessSliderChanged\",\n      value: function _brightnessSliderChanged(ev) {\n        const bri = Number(ev.target.value);\n\n        if (isNaN(bri)) {\n          return;\n        }\n\n        this._brightnessSliderValue = bri;\n\n        if (this._mode === _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.WHITE) {\n          this.hass.callService(\"light\", \"turn_on\", {\n            entity_id: this.stateObj.entity_id,\n            white: Math.min(255, Math.round(bri * 255 / 100))\n          });\n          return;\n        }\n\n        if (this._brightnessAdjusted) {\n          const rgb = this.stateObj.attributes.rgb_color || [0, 0, 0];\n          this.hass.callService(\"light\", \"turn_on\", {\n            entity_id: this.stateObj.entity_id,\n            brightness_pct: bri,\n            rgb_color: this._adjustColorBrightness(rgb, this._brightnessAdjusted, true)\n          });\n          return;\n        }\n\n        this.hass.callService(\"light\", \"turn_on\", {\n          entity_id: this.stateObj.entity_id,\n          brightness_pct: bri\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_ctSliderChanged\",\n      value: function _ctSliderChanged(ev) {\n        const ct = Number(ev.target.value);\n\n        if (isNaN(ct)) {\n          return;\n        }\n\n        this._ctSliderValue = ct;\n        this.hass.callService(\"light\", \"turn_on\", {\n          entity_id: this.stateObj.entity_id,\n          color_temp: ct\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_wvSliderChanged\",\n      value: function _wvSliderChanged(ev) {\n        const target = ev.target;\n        let wv = Number(target.value);\n        const name = target.name;\n\n        if (isNaN(wv)) {\n          return;\n        }\n\n        if (name === \"wv\") {\n          this._wvSliderValue = wv;\n        } else if (name === \"cw\") {\n          this._cwSliderValue = wv;\n        } else if (name === \"ww\") {\n          this._wwSliderValue = wv;\n        }\n\n        wv = Math.min(255, Math.round(wv * 255 / 100));\n        const rgb = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.getLightCurrentModeRgbColor)(this.stateObj);\n\n        if (name === \"wv\") {\n          const rgbw_color = rgb || [0, 0, 0, 0];\n          rgbw_color[3] = wv;\n          this.hass.callService(\"light\", \"turn_on\", {\n            entity_id: this.stateObj.entity_id,\n            rgbw_color\n          });\n          return;\n        }\n\n        const rgbww_color = rgb || [0, 0, 0, 0, 0];\n\n        while (rgbww_color.length < 5) {\n          rgbww_color.push(0);\n        }\n\n        rgbww_color[name === \"cw\" ? 3 : 4] = wv;\n        this.hass.callService(\"light\", \"turn_on\", {\n          entity_id: this.stateObj.entity_id,\n          rgbww_color\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_colorBrightnessSliderChanged\",\n      value: function _colorBrightnessSliderChanged(ev) {\n        var _getLightCurrentModeR;\n\n        const target = ev.target;\n        let value = Number(target.value);\n\n        if (isNaN(value)) {\n          return;\n        }\n\n        const oldValue = this._colorBrightnessSliderValue;\n        this._colorBrightnessSliderValue = value;\n        value = value * 255 / 100;\n        const rgb = ((_getLightCurrentModeR = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.getLightCurrentModeRgbColor)(this.stateObj)) === null || _getLightCurrentModeR === void 0 ? void 0 : _getLightCurrentModeR.slice(0, 3)) || [255, 255, 255];\n\n        this._setRgbWColor(this._adjustColorBrightness( // first normalize the value\n        oldValue ? this._adjustColorBrightness(rgb, oldValue * 255 / 100, true) : rgb, value));\n      }\n    }, {\n      kind: \"method\",\n      key: \"_segmentClick\",\n      value: function _segmentClick() {\n        if (this._hueSegments === 24 && this._saturationSegments === 8) {\n          this._hueSegments = 0;\n          this._saturationSegments = 0;\n        } else {\n          this._hueSegments = 24;\n          this._saturationSegments = 8;\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_adjustColorBrightness\",\n      value: function _adjustColorBrightness(rgbColor, value, invert = false) {\n        if (value !== undefined && value !== 255) {\n          let ratio = value / 255;\n\n          if (invert) {\n            ratio = 1 / ratio;\n          }\n\n          rgbColor[0] = Math.min(255, Math.round(rgbColor[0] * ratio));\n          rgbColor[1] = Math.min(255, Math.round(rgbColor[1] * ratio));\n          rgbColor[2] = Math.min(255, Math.round(rgbColor[2] * ratio));\n        }\n\n        return rgbColor;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_setRgbWColor\",\n      value: function _setRgbWColor(rgbColor) {\n        if ((0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBWW)) {\n          const rgbww_color = this.stateObj.attributes.rgbww_color ? [...this.stateObj.attributes.rgbww_color] : [0, 0, 0, 0, 0];\n          this.hass.callService(\"light\", \"turn_on\", {\n            entity_id: this.stateObj.entity_id,\n            rgbww_color: rgbColor.concat(rgbww_color.slice(3))\n          });\n        } else if ((0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBW)) {\n          const rgbw_color = this.stateObj.attributes.rgbw_color ? [...this.stateObj.attributes.rgbw_color] : [0, 0, 0, 0];\n          this.hass.callService(\"light\", \"turn_on\", {\n            entity_id: this.stateObj.entity_id,\n            rgbw_color: rgbColor.concat(rgbw_color.slice(3))\n          });\n        }\n      }\n      /**\n       * Called when a new color has been picked.\n       * should be throttled with the 'throttle=' attribute of the color picker\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"_colorPicked\",\n      value: function _colorPicked(ev) {\n        this._colorPickerColor = [ev.detail.rgb.r, ev.detail.rgb.g, ev.detail.rgb.b];\n\n        if ((0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBWW) || (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBW)) {\n          this._setRgbWColor(this._colorBrightnessSliderValue ? this._adjustColorBrightness([ev.detail.rgb.r, ev.detail.rgb.g, ev.detail.rgb.b], this._colorBrightnessSliderValue * 255 / 100) : [ev.detail.rgb.r, ev.detail.rgb.g, ev.detail.rgb.b]);\n        } else if ((0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGB)) {\n          const rgb_color = [ev.detail.rgb.r, ev.detail.rgb.g, ev.detail.rgb.b];\n\n          if (this._brightnessAdjusted) {\n            this.hass.callService(\"light\", \"turn_on\", {\n              entity_id: this.stateObj.entity_id,\n              brightness_pct: this._brightnessSliderValue,\n              rgb_color: this._adjustColorBrightness(rgb_color, this._brightnessAdjusted, true)\n            });\n          } else {\n            this.hass.callService(\"light\", \"turn_on\", {\n              entity_id: this.stateObj.entity_id,\n              rgb_color\n            });\n          }\n        } else {\n          this.hass.callService(\"light\", \"turn_on\", {\n            entity_id: this.stateObj.entity_id,\n            hs_color: [ev.detail.hs.h, ev.detail.hs.s * 100]\n          });\n        }\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return lit__WEBPACK_IMPORTED_MODULE_1__.css`\n      .content {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      }\n\n      .content > * {\n        width: 100%;\n      }\n\n      .color_temp {\n        --ha-slider-background: -webkit-linear-gradient(\n          right,\n          rgb(255, 160, 0) 0%,\n          white 50%,\n          rgb(166, 209, 255) 100%\n        );\n        /* The color temp minimum value shouldn't be rendered differently. It's not \"off\". */\n        --paper-slider-knob-start-border-color: var(--primary-color);\n        margin-bottom: 4px;\n      }\n\n      .segmentationContainer {\n        position: relative;\n        max-height: 500px;\n        display: flex;\n        justify-content: center;\n      }\n\n      ha-button-toggle-group {\n        margin-bottom: 8px;\n      }\n\n      ha-color-picker {\n        --ha-color-picker-wheel-borderwidth: 5;\n        --ha-color-picker-wheel-bordercolor: white;\n        --ha-color-picker-wheel-shadow: none;\n        --ha-color-picker-marker-borderwidth: 2;\n        --ha-color-picker-marker-bordercolor: white;\n      }\n\n      .segmentationButton {\n        position: absolute;\n        top: 5%;\n        left: 0;\n        color: var(--secondary-text-color);\n      }\n\n      hr {\n        border-color: var(--divider-color);\n        border-bottom: none;\n        margin: 16px 0;\n      }\n    `;\n      }\n    }]\n  };\n}, lit__WEBPACK_IMPORTED_MODULE_1__.LitElement);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGlhbG9ncy9tb3JlLWluZm8vY29udHJvbHMvbW9yZS1pbmZvLWxpZ2h0LnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBYUE7QUFEQTtBQUNBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7O0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7Ozs7QUFFQTtBQUFBO0FBQUE7Ozs7O0FBRUE7Ozs7QUFBQTs7Ozs7QUFFQTs7Ozs7QUFFQTs7Ozs7QUFFQTs7Ozs7QUFFQTs7Ozs7QUFFQTs7Ozs7QUFFQTs7Ozs7QUFFQTs7OztBQUFBOzs7OztBQUVBOzs7O0FBQUE7Ozs7O0FBRUE7Ozs7O0FBRUE7Ozs7OztBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBS0E7QUFLQTtBQUtBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7O0FBRUE7QUFDQTs7QUFDQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFJQTtBQUtBO0FBRUE7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTs7OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBU0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBOztBQUlBO0FBR0E7QUFNQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUVBO0FBS0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBTUE7O0FBTUE7QUFJQTtBQVFBO0FBQ0E7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUE5a0JBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9zcmMvZGlhbG9ncy9tb3JlLWluZm8vY29udHJvbHMvbW9yZS1pbmZvLWxpZ2h0LnRzPzAxMDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiQG1hdGVyaWFsL213Yy1saXN0L213Yy1saXN0LWl0ZW1cIjtcbmltcG9ydCB7IG1kaVBhbGV0dGUgfSBmcm9tIFwiQG1kaS9qc1wiO1xuaW1wb3J0IHtcbiAgY3NzLFxuICBDU1NSZXN1bHRHcm91cCxcbiAgaHRtbCxcbiAgTGl0RWxlbWVudCxcbiAgUHJvcGVydHlWYWx1ZXMsXG4gIFRlbXBsYXRlUmVzdWx0LFxufSBmcm9tIFwibGl0XCI7XG5pbXBvcnQgeyBjdXN0b21FbGVtZW50LCBwcm9wZXJ0eSwgc3RhdGUgfSBmcm9tIFwibGl0L2RlY29yYXRvcnNcIjtcbmltcG9ydCBtZW1vaXplT25lIGZyb20gXCJtZW1vaXplLW9uZVwiO1xuaW1wb3J0IHsgc3RvcFByb3BhZ2F0aW9uIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9kb20vc3RvcF9wcm9wYWdhdGlvblwiO1xuaW1wb3J0IHsgc3VwcG9ydHNGZWF0dXJlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9lbnRpdHkvc3VwcG9ydHMtZmVhdHVyZVwiO1xuaW1wb3J0IFwiLi4vLi4vLi4vY29tcG9uZW50cy9oYS1hdHRyaWJ1dGVzXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9jb21wb25lbnRzL2hhLWJ1dHRvbi10b2dnbGUtZ3JvdXBcIjtcbmltcG9ydCBcIi4uLy4uLy4uL2NvbXBvbmVudHMvaGEtY29sb3ItcGlja2VyXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9jb21wb25lbnRzL2hhLWljb24tYnV0dG9uXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9jb21wb25lbnRzL2hhLWxhYmVsZWQtc2xpZGVyXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9jb21wb25lbnRzL2hhLXNlbGVjdFwiO1xuaW1wb3J0IHtcbiAgZ2V0TGlnaHRDdXJyZW50TW9kZVJnYkNvbG9yLFxuICBMaWdodENvbG9yTW9kZXMsXG4gIExpZ2h0RW50aXR5LFxuICBsaWdodElzSW5Db2xvck1vZGUsXG4gIGxpZ2h0U3VwcG9ydHNDb2xvcixcbiAgbGlnaHRTdXBwb3J0c0NvbG9yTW9kZSxcbiAgbGlnaHRTdXBwb3J0c0RpbW1pbmcsXG4gIFNVUFBPUlRfRUZGRUNULFxufSBmcm9tIFwiLi4vLi4vLi4vZGF0YS9saWdodFwiO1xuaW1wb3J0IHR5cGUgeyBIb21lQXNzaXN0YW50IH0gZnJvbSBcIi4uLy4uLy4uL3R5cGVzXCI7XG5cbkBjdXN0b21FbGVtZW50KFwibW9yZS1pbmZvLWxpZ2h0XCIpXG5jbGFzcyBNb3JlSW5mb0xpZ2h0IGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gIEBwcm9wZXJ0eSh7IGF0dHJpYnV0ZTogZmFsc2UgfSkgcHVibGljIGhhc3MhOiBIb21lQXNzaXN0YW50O1xuXG4gIEBwcm9wZXJ0eSh7IGF0dHJpYnV0ZTogZmFsc2UgfSkgcHVibGljIHN0YXRlT2JqPzogTGlnaHRFbnRpdHk7XG5cbiAgQHN0YXRlKCkgcHJpdmF0ZSBfYnJpZ2h0bmVzc1NsaWRlclZhbHVlID0gMDtcblxuICBAc3RhdGUoKSBwcml2YXRlIF9jdFNsaWRlclZhbHVlPzogbnVtYmVyO1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX2N3U2xpZGVyVmFsdWU/OiBudW1iZXI7XG5cbiAgQHN0YXRlKCkgcHJpdmF0ZSBfd3dTbGlkZXJWYWx1ZT86IG51bWJlcjtcblxuICBAc3RhdGUoKSBwcml2YXRlIF93dlNsaWRlclZhbHVlPzogbnVtYmVyO1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX2NvbG9yQnJpZ2h0bmVzc1NsaWRlclZhbHVlPzogbnVtYmVyO1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX2JyaWdodG5lc3NBZGp1c3RlZD86IG51bWJlcjtcblxuICBAc3RhdGUoKSBwcml2YXRlIF9odWVTZWdtZW50cyA9IDI0O1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX3NhdHVyYXRpb25TZWdtZW50cyA9IDg7XG5cbiAgQHN0YXRlKCkgcHJpdmF0ZSBfY29sb3JQaWNrZXJDb2xvcj86IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuICBAc3RhdGUoKSBwcml2YXRlIF9tb2RlPzogXCJjb2xvclwiIHwgTGlnaHRDb2xvck1vZGVzO1xuXG4gIHByb3RlY3RlZCByZW5kZXIoKTogVGVtcGxhdGVSZXN1bHQge1xuICAgIGlmICghdGhpcy5oYXNzIHx8ICF0aGlzLnN0YXRlT2JqKSB7XG4gICAgICByZXR1cm4gaHRtbGBgO1xuICAgIH1cblxuICAgIGNvbnN0IHN1cHBvcnRzVGVtcCA9IGxpZ2h0U3VwcG9ydHNDb2xvck1vZGUoXG4gICAgICB0aGlzLnN0YXRlT2JqLFxuICAgICAgTGlnaHRDb2xvck1vZGVzLkNPTE9SX1RFTVBcbiAgICApO1xuXG4gICAgY29uc3Qgc3VwcG9ydHNXaGl0ZSA9IGxpZ2h0U3VwcG9ydHNDb2xvck1vZGUoXG4gICAgICB0aGlzLnN0YXRlT2JqLFxuICAgICAgTGlnaHRDb2xvck1vZGVzLldISVRFXG4gICAgKTtcblxuICAgIGNvbnN0IHN1cHBvcnRzUmdid3cgPSBsaWdodFN1cHBvcnRzQ29sb3JNb2RlKFxuICAgICAgdGhpcy5zdGF0ZU9iaixcbiAgICAgIExpZ2h0Q29sb3JNb2Rlcy5SR0JXV1xuICAgICk7XG5cbiAgICBjb25zdCBzdXBwb3J0c1JnYncgPVxuICAgICAgIXN1cHBvcnRzUmdid3cgJiZcbiAgICAgIGxpZ2h0U3VwcG9ydHNDb2xvck1vZGUodGhpcy5zdGF0ZU9iaiwgTGlnaHRDb2xvck1vZGVzLlJHQlcpO1xuXG4gICAgY29uc3Qgc3VwcG9ydHNDb2xvciA9XG4gICAgICBzdXBwb3J0c1JnYnd3IHx8IHN1cHBvcnRzUmdidyB8fCBsaWdodFN1cHBvcnRzQ29sb3IodGhpcy5zdGF0ZU9iaik7XG5cbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICR7bGlnaHRTdXBwb3J0c0RpbW1pbmcodGhpcy5zdGF0ZU9iailcbiAgICAgICAgICA/IGh0bWxgXG4gICAgICAgICAgICAgIDxoYS1sYWJlbGVkLXNsaWRlclxuICAgICAgICAgICAgICAgIGNhcHRpb249JHt0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmxpZ2h0LmJyaWdodG5lc3NcIil9XG4gICAgICAgICAgICAgICAgaWNvbj1cImhhc3M6YnJpZ2h0bmVzcy01XCJcbiAgICAgICAgICAgICAgICBtaW49XCIxXCJcbiAgICAgICAgICAgICAgICBtYXg9XCIxMDBcIlxuICAgICAgICAgICAgICAgIHZhbHVlPSR7dGhpcy5fYnJpZ2h0bmVzc1NsaWRlclZhbHVlfVxuICAgICAgICAgICAgICAgIEBjaGFuZ2U9JHt0aGlzLl9icmlnaHRuZXNzU2xpZGVyQ2hhbmdlZH1cbiAgICAgICAgICAgICAgICBwaW5cbiAgICAgICAgICAgICAgPjwvaGEtbGFiZWxlZC1zbGlkZXI+XG4gICAgICAgICAgICBgXG4gICAgICAgICAgOiBcIlwifVxuICAgICAgICAke3RoaXMuc3RhdGVPYmouc3RhdGUgPT09IFwib25cIlxuICAgICAgICAgID8gaHRtbGBcbiAgICAgICAgICAgICAgJHtzdXBwb3J0c1RlbXAgfHwgc3VwcG9ydHNDb2xvciA/IGh0bWxgPGhyIC8+YCA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7c3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNUZW1wIHx8IHN1cHBvcnRzV2hpdGUpXG4gICAgICAgICAgICAgICAgPyBodG1sYDxoYS1idXR0b24tdG9nZ2xlLWdyb3VwXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxXaWR0aFxuICAgICAgICAgICAgICAgICAgICAuYnV0dG9ucz0ke3RoaXMuX3RvZ2dsZUJ1dHRvbnMoc3VwcG9ydHNUZW1wLCBzdXBwb3J0c1doaXRlKX1cbiAgICAgICAgICAgICAgICAgICAgLmFjdGl2ZT0ke3RoaXMuX21vZGV9XG4gICAgICAgICAgICAgICAgICAgIEB2YWx1ZS1jaGFuZ2VkPSR7dGhpcy5fbW9kZUNoYW5nZWR9XG4gICAgICAgICAgICAgICAgICA+PC9oYS1idXR0b24tdG9nZ2xlLWdyb3VwPmBcbiAgICAgICAgICAgICAgICA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7c3VwcG9ydHNUZW1wICYmXG4gICAgICAgICAgICAgICgoIXN1cHBvcnRzQ29sb3IgJiYgIXN1cHBvcnRzV2hpdGUpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9PT0gTGlnaHRDb2xvck1vZGVzLkNPTE9SX1RFTVApXG4gICAgICAgICAgICAgICAgPyBodG1sYFxuICAgICAgICAgICAgICAgICAgICA8aGEtbGFiZWxlZC1zbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImNvbG9yX3RlbXBcIlxuICAgICAgICAgICAgICAgICAgICAgIGNhcHRpb249JHt0aGlzLmhhc3MubG9jYWxpemUoXG4gICAgICAgICAgICAgICAgICAgICAgICBcInVpLmNhcmQubGlnaHQuY29sb3JfdGVtcGVyYXR1cmVcIlxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImhhc3M6dGhlcm1vbWV0ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgIC5taW49JHt0aGlzLnN0YXRlT2JqLmF0dHJpYnV0ZXMubWluX21pcmVkc31cbiAgICAgICAgICAgICAgICAgICAgICAubWF4PSR7dGhpcy5zdGF0ZU9iai5hdHRyaWJ1dGVzLm1heF9taXJlZHN9XG4gICAgICAgICAgICAgICAgICAgICAgLnZhbHVlPSR7dGhpcy5fY3RTbGlkZXJWYWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICBAY2hhbmdlPSR7dGhpcy5fY3RTbGlkZXJDaGFuZ2VkfVxuICAgICAgICAgICAgICAgICAgICAgIHBpblxuICAgICAgICAgICAgICAgICAgICA+PC9oYS1sYWJlbGVkLXNsaWRlcj5cbiAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7c3VwcG9ydHNDb2xvciAmJlxuICAgICAgICAgICAgICAoKCFzdXBwb3J0c1RlbXAgJiYgIXN1cHBvcnRzV2hpdGUpIHx8IHRoaXMuX21vZGUgPT09IFwiY29sb3JcIilcbiAgICAgICAgICAgICAgICA/IGh0bWxgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWdtZW50YXRpb25Db250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8aGEtY29sb3ItcGlja2VyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImNvbG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIEBjb2xvcnNlbGVjdGVkPSR7dGhpcy5fY29sb3JQaWNrZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVzaXJlZFJnYkNvbG9yPSR7dGhpcy5fY29sb3JQaWNrZXJDb2xvcn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm90dGxlPVwiNTAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5odWVTZWdtZW50cz0ke3RoaXMuX2h1ZVNlZ21lbnRzfVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNhdHVyYXRpb25TZWdtZW50cz0ke3RoaXMuX3NhdHVyYXRpb25TZWdtZW50c31cbiAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgPC9oYS1jb2xvci1waWNrZXI+XG4gICAgICAgICAgICAgICAgICAgICAgPGhhLWljb24tYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAucGF0aD0ke21kaVBhbGV0dGV9XG4gICAgICAgICAgICAgICAgICAgICAgICBAY2xpY2s9JHt0aGlzLl9zZWdtZW50Q2xpY2t9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInNlZ21lbnRhdGlvbkJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgPjwvaGEtaWNvbi1idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgICR7c3VwcG9ydHNSZ2J3IHx8IHN1cHBvcnRzUmdid3dcbiAgICAgICAgICAgICAgICAgICAgICA/IGh0bWxgPGhhLWxhYmVsZWQtc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXB0aW9uPSR7dGhpcy5oYXNzLmxvY2FsaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidWkuY2FyZC5saWdodC5jb2xvcl9icmlnaHRuZXNzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImhhc3M6YnJpZ2h0bmVzcy03XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4PVwiMTAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbHVlPSR7dGhpcy5fY29sb3JCcmlnaHRuZXNzU2xpZGVyVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIEBjaGFuZ2U9JHt0aGlzLl9jb2xvckJyaWdodG5lc3NTbGlkZXJDaGFuZ2VkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5cbiAgICAgICAgICAgICAgICAgICAgICAgID48L2hhLWxhYmVsZWQtc2xpZGVyPmBcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiXCJ9XG4gICAgICAgICAgICAgICAgICAgICR7c3VwcG9ydHNSZ2J3XG4gICAgICAgICAgICAgICAgICAgICAgPyBodG1sYFxuICAgICAgICAgICAgICAgICAgICAgICAgICA8aGEtbGFiZWxlZC1zbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2FwdGlvbj0ke3RoaXMuaGFzcy5sb2NhbGl6ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidWkuY2FyZC5saWdodC53aGl0ZV92YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiaGFzczpmaWxlLXdvcmQtYm94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg9XCIxMDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5uYW1lPSR7XCJ3dlwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWx1ZT0ke3RoaXMuX3d2U2xpZGVyVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGNoYW5nZT0ke3RoaXMuX3d2U2xpZGVyQ2hhbmdlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvaGEtbGFiZWxlZC1zbGlkZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgICAgOiBcIlwifVxuICAgICAgICAgICAgICAgICAgICAke3N1cHBvcnRzUmdid3dcbiAgICAgICAgICAgICAgICAgICAgICA/IGh0bWxgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxoYS1sYWJlbGVkLXNsaWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXB0aW9uPSR7dGhpcy5oYXNzLmxvY2FsaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1aS5jYXJkLmxpZ2h0LmNvbGRfd2hpdGVfdmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImhhc3M6ZmlsZS13b3JkLWJveC1vdXRsaW5lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg9XCIxMDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5uYW1lPSR7XCJjd1wifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWx1ZT0ke3RoaXMuX2N3U2xpZGVyVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGNoYW5nZT0ke3RoaXMuX3d2U2xpZGVyQ2hhbmdlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvaGEtbGFiZWxlZC1zbGlkZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxoYS1sYWJlbGVkLXNsaWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXB0aW9uPSR7dGhpcy5oYXNzLmxvY2FsaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1aS5jYXJkLmxpZ2h0Lndhcm1fd2hpdGVfdmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImhhc3M6ZmlsZS13b3JkLWJveFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4PVwiMTAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubmFtZT0ke1wid3dcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsdWU9JHt0aGlzLl93d1NsaWRlclZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBjaGFuZ2U9JHt0aGlzLl93dlNsaWRlckNoYW5nZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgID48L2hhLWxhYmVsZWQtc2xpZGVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgIDogXCJcIn1cbiAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7c3VwcG9ydHNGZWF0dXJlKHRoaXMuc3RhdGVPYmosIFNVUFBPUlRfRUZGRUNUKSAmJlxuICAgICAgICAgICAgICB0aGlzLnN0YXRlT2JqIS5hdHRyaWJ1dGVzLmVmZmVjdF9saXN0Py5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IGh0bWxgXG4gICAgICAgICAgICAgICAgICAgIDxociAvPlxuICAgICAgICAgICAgICAgICAgICA8aGEtc2VsZWN0XG4gICAgICAgICAgICAgICAgICAgICAgLmxhYmVsPSR7dGhpcy5oYXNzLmxvY2FsaXplKFwidWkuY2FyZC5saWdodC5lZmZlY3RcIil9XG4gICAgICAgICAgICAgICAgICAgICAgLnZhbHVlPSR7dGhpcy5zdGF0ZU9iai5hdHRyaWJ1dGVzLmVmZmVjdCB8fCBcIlwifVxuICAgICAgICAgICAgICAgICAgICAgIGZpeGVkTWVudVBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgbmF0dXJhbE1lbnVXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgIEBzZWxlY3RlZD0ke3RoaXMuX2VmZmVjdENoYW5nZWR9XG4gICAgICAgICAgICAgICAgICAgICAgQGNsb3NlZD0ke3N0b3BQcm9wYWdhdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICR7dGhpcy5zdGF0ZU9iai5hdHRyaWJ1dGVzLmVmZmVjdF9saXN0Lm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIChlZmZlY3Q6IHN0cmluZykgPT4gaHRtbGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPG13Yy1saXN0LWl0ZW0gLnZhbHVlPSR7ZWZmZWN0fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2VmZmVjdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9td2MtbGlzdC1pdGVtPlxuICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvaGEtc2VsZWN0PlxuICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgIDogXCJcIn1cbiAgICAgICAgICAgIGBcbiAgICAgICAgICA6IFwiXCJ9XG4gICAgICAgIDxoYS1hdHRyaWJ1dGVzXG4gICAgICAgICAgLmhhc3M9JHt0aGlzLmhhc3N9XG4gICAgICAgICAgLnN0YXRlT2JqPSR7dGhpcy5zdGF0ZU9ian1cbiAgICAgICAgICBleHRyYS1maWx0ZXJzPVwiYnJpZ2h0bmVzcyxjb2xvcl90ZW1wLHdoaXRlX3ZhbHVlLGVmZmVjdF9saXN0LGVmZmVjdCxoc19jb2xvcixyZ2JfY29sb3Iscmdid19jb2xvcixyZ2J3d19jb2xvcix4eV9jb2xvcixtaW5fbWlyZWRzLG1heF9taXJlZHMsZW50aXR5X2lkLHN1cHBvcnRlZF9jb2xvcl9tb2Rlcyxjb2xvcl9tb2RlXCJcbiAgICAgICAgPjwvaGEtYXR0cmlidXRlcz5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cblxuICBwdWJsaWMgd2lsbFVwZGF0ZShjaGFuZ2VkUHJvcHM6IFByb3BlcnR5VmFsdWVzPHRoaXM+KSB7XG4gICAgc3VwZXIud2lsbFVwZGF0ZShjaGFuZ2VkUHJvcHMpO1xuXG4gICAgaWYgKCFjaGFuZ2VkUHJvcHMuaGFzKFwic3RhdGVPYmpcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGVPYmogPSB0aGlzLnN0YXRlT2JqISBhcyBMaWdodEVudGl0eTtcbiAgICBjb25zdCBvbGRTdGF0ZU9iaiA9IGNoYW5nZWRQcm9wcy5nZXQoXCJzdGF0ZU9ialwiKSBhcyBMaWdodEVudGl0eSB8IHVuZGVmaW5lZDtcblxuICAgIGlmIChzdGF0ZU9iai5zdGF0ZSA9PT0gXCJvblwiKSB7XG4gICAgICAvLyBEb24ndCBjaGFuZ2UgdGFiIHdoZW4gdGhlIGNvbG9yIG1vZGUgY2hhbmdlc1xuICAgICAgaWYgKFxuICAgICAgICBvbGRTdGF0ZU9iaj8uZW50aXR5X2lkICE9PSBzdGF0ZU9iai5lbnRpdHlfaWQgfHxcbiAgICAgICAgb2xkU3RhdGVPYmo/LnN0YXRlICE9PSBzdGF0ZU9iai5zdGF0ZVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX21vZGUgPSBsaWdodElzSW5Db2xvck1vZGUodGhpcy5zdGF0ZU9iaiEpXG4gICAgICAgICAgPyBcImNvbG9yXCJcbiAgICAgICAgICA6IHRoaXMuc3RhdGVPYmohLmF0dHJpYnV0ZXMuY29sb3JfbW9kZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGJyaWdodG5lc3NBZGp1c3QgPSAxMDA7XG4gICAgICB0aGlzLl9icmlnaHRuZXNzQWRqdXN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlT2JqLmF0dHJpYnV0ZXMuY29sb3JfbW9kZSA9PT0gTGlnaHRDb2xvck1vZGVzLlJHQiAmJlxuICAgICAgICAhbGlnaHRTdXBwb3J0c0NvbG9yTW9kZShzdGF0ZU9iaiwgTGlnaHRDb2xvck1vZGVzLlJHQldXKSAmJlxuICAgICAgICAhbGlnaHRTdXBwb3J0c0NvbG9yTW9kZShzdGF0ZU9iaiwgTGlnaHRDb2xvck1vZGVzLlJHQlcpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbWF4VmFsID0gTWF0aC5tYXgoLi4uc3RhdGVPYmouYXR0cmlidXRlcy5yZ2JfY29sb3IpO1xuICAgICAgICBpZiAobWF4VmFsIDwgMjU1KSB7XG4gICAgICAgICAgdGhpcy5fYnJpZ2h0bmVzc0FkanVzdGVkID0gbWF4VmFsO1xuICAgICAgICAgIGJyaWdodG5lc3NBZGp1c3QgPSAodGhpcy5fYnJpZ2h0bmVzc0FkanVzdGVkIC8gMjU1KSAqIDEwMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYnJpZ2h0bmVzc1NsaWRlclZhbHVlID0gTWF0aC5yb3VuZChcbiAgICAgICAgKHN0YXRlT2JqLmF0dHJpYnV0ZXMuYnJpZ2h0bmVzcyAqIGJyaWdodG5lc3NBZGp1c3QpIC8gMjU1XG4gICAgICApO1xuICAgICAgdGhpcy5fY3RTbGlkZXJWYWx1ZSA9IHN0YXRlT2JqLmF0dHJpYnV0ZXMuY29sb3JfdGVtcDtcbiAgICAgIHRoaXMuX3d2U2xpZGVyVmFsdWUgPVxuICAgICAgICBzdGF0ZU9iai5hdHRyaWJ1dGVzLmNvbG9yX21vZGUgPT09IExpZ2h0Q29sb3JNb2Rlcy5SR0JXXG4gICAgICAgICAgPyBNYXRoLnJvdW5kKChzdGF0ZU9iai5hdHRyaWJ1dGVzLnJnYndfY29sb3JbM10gKiAxMDApIC8gMjU1KVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fY3dTbGlkZXJWYWx1ZSA9XG4gICAgICAgIHN0YXRlT2JqLmF0dHJpYnV0ZXMuY29sb3JfbW9kZSA9PT0gTGlnaHRDb2xvck1vZGVzLlJHQldXXG4gICAgICAgICAgPyBNYXRoLnJvdW5kKChzdGF0ZU9iai5hdHRyaWJ1dGVzLnJnYnd3X2NvbG9yWzNdICogMTAwKSAvIDI1NSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3d3U2xpZGVyVmFsdWUgPVxuICAgICAgICBzdGF0ZU9iai5hdHRyaWJ1dGVzLmNvbG9yX21vZGUgPT09IExpZ2h0Q29sb3JNb2Rlcy5SR0JXV1xuICAgICAgICAgID8gTWF0aC5yb3VuZCgoc3RhdGVPYmouYXR0cmlidXRlcy5yZ2J3d19jb2xvcls0XSAqIDEwMCkgLyAyNTUpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRSZ2JDb2xvciA9IGdldExpZ2h0Q3VycmVudE1vZGVSZ2JDb2xvcihzdGF0ZU9iaik7XG5cbiAgICAgIHRoaXMuX2NvbG9yQnJpZ2h0bmVzc1NsaWRlclZhbHVlID0gY3VycmVudFJnYkNvbG9yXG4gICAgICAgID8gTWF0aC5yb3VuZCgoTWF0aC5tYXgoLi4uY3VycmVudFJnYkNvbG9yLnNsaWNlKDAsIDMpKSAqIDEwMCkgLyAyNTUpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLl9jb2xvclBpY2tlckNvbG9yID0gY3VycmVudFJnYkNvbG9yPy5zbGljZSgwLCAzKSBhcyBbXG4gICAgICAgIG51bWJlcixcbiAgICAgICAgbnVtYmVyLFxuICAgICAgICBudW1iZXJcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JyaWdodG5lc3NTbGlkZXJWYWx1ZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfdG9nZ2xlQnV0dG9ucyA9IG1lbW9pemVPbmUoXG4gICAgKHN1cHBvcnRzVGVtcDogYm9vbGVhbiwgc3VwcG9ydHNXaGl0ZTogYm9vbGVhbikgPT4ge1xuICAgICAgY29uc3QgbW9kZXMgPSBbeyBsYWJlbDogXCJDb2xvclwiLCB2YWx1ZTogXCJjb2xvclwiIH1dO1xuICAgICAgaWYgKHN1cHBvcnRzVGVtcCkge1xuICAgICAgICBtb2Rlcy5wdXNoKHsgbGFiZWw6IFwiVGVtcGVyYXR1cmVcIiwgdmFsdWU6IExpZ2h0Q29sb3JNb2Rlcy5DT0xPUl9URU1QIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzV2hpdGUpIHtcbiAgICAgICAgbW9kZXMucHVzaCh7IGxhYmVsOiBcIldoaXRlXCIsIHZhbHVlOiBMaWdodENvbG9yTW9kZXMuV0hJVEUgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kZXM7XG4gICAgfVxuICApO1xuXG4gIHByaXZhdGUgX21vZGVDaGFuZ2VkKGV2OiBDdXN0b21FdmVudCkge1xuICAgIHRoaXMuX21vZGUgPSBldi5kZXRhaWwudmFsdWU7XG4gIH1cblxuICBwcml2YXRlIF9lZmZlY3RDaGFuZ2VkKGV2KSB7XG4gICAgY29uc3QgbmV3VmFsID0gZXYudGFyZ2V0LnZhbHVlO1xuXG4gICAgaWYgKCFuZXdWYWwgfHwgdGhpcy5zdGF0ZU9iaiEuYXR0cmlidXRlcy5lZmZlY3QgPT09IG5ld1ZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaGFzcy5jYWxsU2VydmljZShcImxpZ2h0XCIsIFwidHVybl9vblwiLCB7XG4gICAgICBlbnRpdHlfaWQ6IHRoaXMuc3RhdGVPYmohLmVudGl0eV9pZCxcbiAgICAgIGVmZmVjdDogbmV3VmFsLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfYnJpZ2h0bmVzc1NsaWRlckNoYW5nZWQoZXY6IEN1c3RvbUV2ZW50KSB7XG4gICAgY29uc3QgYnJpID0gTnVtYmVyKChldi50YXJnZXQgYXMgYW55KS52YWx1ZSk7XG5cbiAgICBpZiAoaXNOYU4oYnJpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2JyaWdodG5lc3NTbGlkZXJWYWx1ZSA9IGJyaTtcblxuICAgIGlmICh0aGlzLl9tb2RlID09PSBMaWdodENvbG9yTW9kZXMuV0hJVEUpIHtcbiAgICAgIHRoaXMuaGFzcy5jYWxsU2VydmljZShcImxpZ2h0XCIsIFwidHVybl9vblwiLCB7XG4gICAgICAgIGVudGl0eV9pZDogdGhpcy5zdGF0ZU9iaiEuZW50aXR5X2lkLFxuICAgICAgICB3aGl0ZTogTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKChicmkgKiAyNTUpIC8gMTAwKSksXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYnJpZ2h0bmVzc0FkanVzdGVkKSB7XG4gICAgICBjb25zdCByZ2IgPVxuICAgICAgICB0aGlzLnN0YXRlT2JqIS5hdHRyaWJ1dGVzLnJnYl9jb2xvciB8fFxuICAgICAgICAoWzAsIDAsIDBdIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk7XG5cbiAgICAgIHRoaXMuaGFzcy5jYWxsU2VydmljZShcImxpZ2h0XCIsIFwidHVybl9vblwiLCB7XG4gICAgICAgIGVudGl0eV9pZDogdGhpcy5zdGF0ZU9iaiEuZW50aXR5X2lkLFxuICAgICAgICBicmlnaHRuZXNzX3BjdDogYnJpLFxuICAgICAgICByZ2JfY29sb3I6IHRoaXMuX2FkanVzdENvbG9yQnJpZ2h0bmVzcyhcbiAgICAgICAgICByZ2IsXG4gICAgICAgICAgdGhpcy5fYnJpZ2h0bmVzc0FkanVzdGVkLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaGFzcy5jYWxsU2VydmljZShcImxpZ2h0XCIsIFwidHVybl9vblwiLCB7XG4gICAgICBlbnRpdHlfaWQ6IHRoaXMuc3RhdGVPYmohLmVudGl0eV9pZCxcbiAgICAgIGJyaWdodG5lc3NfcGN0OiBicmksXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF9jdFNsaWRlckNoYW5nZWQoZXY6IEN1c3RvbUV2ZW50KSB7XG4gICAgY29uc3QgY3QgPSBOdW1iZXIoKGV2LnRhcmdldCBhcyBhbnkpLnZhbHVlKTtcblxuICAgIGlmIChpc05hTihjdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jdFNsaWRlclZhbHVlID0gY3Q7XG5cbiAgICB0aGlzLmhhc3MuY2FsbFNlcnZpY2UoXCJsaWdodFwiLCBcInR1cm5fb25cIiwge1xuICAgICAgZW50aXR5X2lkOiB0aGlzLnN0YXRlT2JqIS5lbnRpdHlfaWQsXG4gICAgICBjb2xvcl90ZW1wOiBjdCxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX3d2U2xpZGVyQ2hhbmdlZChldjogQ3VzdG9tRXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBldi50YXJnZXQgYXMgYW55O1xuICAgIGxldCB3diA9IE51bWJlcih0YXJnZXQudmFsdWUpO1xuICAgIGNvbnN0IG5hbWUgPSB0YXJnZXQubmFtZTtcblxuICAgIGlmIChpc05hTih3dikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gXCJ3dlwiKSB7XG4gICAgICB0aGlzLl93dlNsaWRlclZhbHVlID0gd3Y7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcImN3XCIpIHtcbiAgICAgIHRoaXMuX2N3U2xpZGVyVmFsdWUgPSB3djtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwid3dcIikge1xuICAgICAgdGhpcy5fd3dTbGlkZXJWYWx1ZSA9IHd2O1xuICAgIH1cblxuICAgIHd2ID0gTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKCh3diAqIDI1NSkgLyAxMDApKTtcblxuICAgIGNvbnN0IHJnYiA9IGdldExpZ2h0Q3VycmVudE1vZGVSZ2JDb2xvcih0aGlzLnN0YXRlT2JqISk7XG5cbiAgICBpZiAobmFtZSA9PT0gXCJ3dlwiKSB7XG4gICAgICBjb25zdCByZ2J3X2NvbG9yID0gcmdiIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIHJnYndfY29sb3JbM10gPSB3djtcbiAgICAgIHRoaXMuaGFzcy5jYWxsU2VydmljZShcImxpZ2h0XCIsIFwidHVybl9vblwiLCB7XG4gICAgICAgIGVudGl0eV9pZDogdGhpcy5zdGF0ZU9iaiEuZW50aXR5X2lkLFxuICAgICAgICByZ2J3X2NvbG9yLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgcmdid3dfY29sb3IgPSByZ2IgfHwgWzAsIDAsIDAsIDAsIDBdO1xuICAgIHdoaWxlIChyZ2J3d19jb2xvci5sZW5ndGggPCA1KSB7XG4gICAgICByZ2J3d19jb2xvci5wdXNoKDApO1xuICAgIH1cbiAgICByZ2J3d19jb2xvcltuYW1lID09PSBcImN3XCIgPyAzIDogNF0gPSB3djtcbiAgICB0aGlzLmhhc3MuY2FsbFNlcnZpY2UoXCJsaWdodFwiLCBcInR1cm5fb25cIiwge1xuICAgICAgZW50aXR5X2lkOiB0aGlzLnN0YXRlT2JqIS5lbnRpdHlfaWQsXG4gICAgICByZ2J3d19jb2xvcixcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX2NvbG9yQnJpZ2h0bmVzc1NsaWRlckNoYW5nZWQoZXY6IEN1c3RvbUV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXYudGFyZ2V0IGFzIGFueTtcbiAgICBsZXQgdmFsdWUgPSBOdW1iZXIodGFyZ2V0LnZhbHVlKTtcblxuICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX2NvbG9yQnJpZ2h0bmVzc1NsaWRlclZhbHVlO1xuICAgIHRoaXMuX2NvbG9yQnJpZ2h0bmVzc1NsaWRlclZhbHVlID0gdmFsdWU7XG5cbiAgICB2YWx1ZSA9ICh2YWx1ZSAqIDI1NSkgLyAxMDA7XG5cbiAgICBjb25zdCByZ2IgPSAoZ2V0TGlnaHRDdXJyZW50TW9kZVJnYkNvbG9yKHRoaXMuc3RhdGVPYmohKT8uc2xpY2UoMCwgMykgfHwgW1xuICAgICAgMjU1LCAyNTUsIDI1NSxcbiAgICBdKSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5cbiAgICB0aGlzLl9zZXRSZ2JXQ29sb3IoXG4gICAgICB0aGlzLl9hZGp1c3RDb2xvckJyaWdodG5lc3MoXG4gICAgICAgIC8vIGZpcnN0IG5vcm1hbGl6ZSB0aGUgdmFsdWVcbiAgICAgICAgb2xkVmFsdWVcbiAgICAgICAgICA/IHRoaXMuX2FkanVzdENvbG9yQnJpZ2h0bmVzcyhyZ2IsIChvbGRWYWx1ZSAqIDI1NSkgLyAxMDAsIHRydWUpXG4gICAgICAgICAgOiByZ2IsXG4gICAgICAgIHZhbHVlXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgX3NlZ21lbnRDbGljaygpIHtcbiAgICBpZiAodGhpcy5faHVlU2VnbWVudHMgPT09IDI0ICYmIHRoaXMuX3NhdHVyYXRpb25TZWdtZW50cyA9PT0gOCkge1xuICAgICAgdGhpcy5faHVlU2VnbWVudHMgPSAwO1xuICAgICAgdGhpcy5fc2F0dXJhdGlvblNlZ21lbnRzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faHVlU2VnbWVudHMgPSAyNDtcbiAgICAgIHRoaXMuX3NhdHVyYXRpb25TZWdtZW50cyA9IDg7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfYWRqdXN0Q29sb3JCcmlnaHRuZXNzKFxuICAgIHJnYkNvbG9yOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgdmFsdWU/OiBudW1iZXIsXG4gICAgaW52ZXJ0ID0gZmFsc2VcbiAgKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IDI1NSkge1xuICAgICAgbGV0IHJhdGlvID0gdmFsdWUgLyAyNTU7XG4gICAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAgIHJhdGlvID0gMSAvIHJhdGlvO1xuICAgICAgfVxuICAgICAgcmdiQ29sb3JbMF0gPSBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQocmdiQ29sb3JbMF0gKiByYXRpbykpO1xuICAgICAgcmdiQ29sb3JbMV0gPSBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQocmdiQ29sb3JbMV0gKiByYXRpbykpO1xuICAgICAgcmdiQ29sb3JbMl0gPSBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQocmdiQ29sb3JbMl0gKiByYXRpbykpO1xuICAgIH1cbiAgICByZXR1cm4gcmdiQ29sb3I7XG4gIH1cblxuICBwcml2YXRlIF9zZXRSZ2JXQ29sb3IocmdiQ29sb3I6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSkge1xuICAgIGlmIChsaWdodFN1cHBvcnRzQ29sb3JNb2RlKHRoaXMuc3RhdGVPYmohLCBMaWdodENvbG9yTW9kZXMuUkdCV1cpKSB7XG4gICAgICBjb25zdCByZ2J3d19jb2xvcjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IHRoaXNcbiAgICAgICAgLnN0YXRlT2JqIS5hdHRyaWJ1dGVzLnJnYnd3X2NvbG9yXG4gICAgICAgID8gWy4uLnRoaXMuc3RhdGVPYmohLmF0dHJpYnV0ZXMucmdid3dfY29sb3JdXG4gICAgICAgIDogWzAsIDAsIDAsIDAsIDBdO1xuICAgICAgdGhpcy5oYXNzLmNhbGxTZXJ2aWNlKFwibGlnaHRcIiwgXCJ0dXJuX29uXCIsIHtcbiAgICAgICAgZW50aXR5X2lkOiB0aGlzLnN0YXRlT2JqIS5lbnRpdHlfaWQsXG4gICAgICAgIHJnYnd3X2NvbG9yOiByZ2JDb2xvci5jb25jYXQocmdid3dfY29sb3Iuc2xpY2UoMykpLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChsaWdodFN1cHBvcnRzQ29sb3JNb2RlKHRoaXMuc3RhdGVPYmohLCBMaWdodENvbG9yTW9kZXMuUkdCVykpIHtcbiAgICAgIGNvbnN0IHJnYndfY29sb3I6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0gdGhpcy5zdGF0ZU9iaiFcbiAgICAgICAgLmF0dHJpYnV0ZXMucmdid19jb2xvclxuICAgICAgICA/IFsuLi50aGlzLnN0YXRlT2JqIS5hdHRyaWJ1dGVzLnJnYndfY29sb3JdXG4gICAgICAgIDogWzAsIDAsIDAsIDBdO1xuICAgICAgdGhpcy5oYXNzLmNhbGxTZXJ2aWNlKFwibGlnaHRcIiwgXCJ0dXJuX29uXCIsIHtcbiAgICAgICAgZW50aXR5X2lkOiB0aGlzLnN0YXRlT2JqIS5lbnRpdHlfaWQsXG4gICAgICAgIHJnYndfY29sb3I6IHJnYkNvbG9yLmNvbmNhdChyZ2J3X2NvbG9yLnNsaWNlKDMpKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIG5ldyBjb2xvciBoYXMgYmVlbiBwaWNrZWQuXG4gICAqIHNob3VsZCBiZSB0aHJvdHRsZWQgd2l0aCB0aGUgJ3Rocm90dGxlPScgYXR0cmlidXRlIG9mIHRoZSBjb2xvciBwaWNrZXJcbiAgICovXG4gIHByaXZhdGUgX2NvbG9yUGlja2VkKFxuICAgIGV2OiBDdXN0b21FdmVudDx7XG4gICAgICBoczogeyBoOiBudW1iZXI7IHM6IG51bWJlciB9O1xuICAgICAgcmdiOiB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXIgfTtcbiAgICB9PlxuICApIHtcbiAgICB0aGlzLl9jb2xvclBpY2tlckNvbG9yID0gW1xuICAgICAgZXYuZGV0YWlsLnJnYi5yLFxuICAgICAgZXYuZGV0YWlsLnJnYi5nLFxuICAgICAgZXYuZGV0YWlsLnJnYi5iLFxuICAgIF07XG5cbiAgICBpZiAoXG4gICAgICBsaWdodFN1cHBvcnRzQ29sb3JNb2RlKHRoaXMuc3RhdGVPYmohLCBMaWdodENvbG9yTW9kZXMuUkdCV1cpIHx8XG4gICAgICBsaWdodFN1cHBvcnRzQ29sb3JNb2RlKHRoaXMuc3RhdGVPYmohLCBMaWdodENvbG9yTW9kZXMuUkdCVylcbiAgICApIHtcbiAgICAgIHRoaXMuX3NldFJnYldDb2xvcihcbiAgICAgICAgdGhpcy5fY29sb3JCcmlnaHRuZXNzU2xpZGVyVmFsdWVcbiAgICAgICAgICA/IHRoaXMuX2FkanVzdENvbG9yQnJpZ2h0bmVzcyhcbiAgICAgICAgICAgICAgW2V2LmRldGFpbC5yZ2IuciwgZXYuZGV0YWlsLnJnYi5nLCBldi5kZXRhaWwucmdiLmJdLFxuICAgICAgICAgICAgICAodGhpcy5fY29sb3JCcmlnaHRuZXNzU2xpZGVyVmFsdWUgKiAyNTUpIC8gMTAwXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBbZXYuZGV0YWlsLnJnYi5yLCBldi5kZXRhaWwucmdiLmcsIGV2LmRldGFpbC5yZ2IuYl1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChsaWdodFN1cHBvcnRzQ29sb3JNb2RlKHRoaXMuc3RhdGVPYmohLCBMaWdodENvbG9yTW9kZXMuUkdCKSkge1xuICAgICAgY29uc3QgcmdiX2NvbG9yOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbXG4gICAgICAgIGV2LmRldGFpbC5yZ2IucixcbiAgICAgICAgZXYuZGV0YWlsLnJnYi5nLFxuICAgICAgICBldi5kZXRhaWwucmdiLmIsXG4gICAgICBdO1xuICAgICAgaWYgKHRoaXMuX2JyaWdodG5lc3NBZGp1c3RlZCkge1xuICAgICAgICB0aGlzLmhhc3MuY2FsbFNlcnZpY2UoXCJsaWdodFwiLCBcInR1cm5fb25cIiwge1xuICAgICAgICAgIGVudGl0eV9pZDogdGhpcy5zdGF0ZU9iaiEuZW50aXR5X2lkLFxuICAgICAgICAgIGJyaWdodG5lc3NfcGN0OiB0aGlzLl9icmlnaHRuZXNzU2xpZGVyVmFsdWUsXG4gICAgICAgICAgcmdiX2NvbG9yOiB0aGlzLl9hZGp1c3RDb2xvckJyaWdodG5lc3MoXG4gICAgICAgICAgICByZ2JfY29sb3IsXG4gICAgICAgICAgICB0aGlzLl9icmlnaHRuZXNzQWRqdXN0ZWQsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhc3MuY2FsbFNlcnZpY2UoXCJsaWdodFwiLCBcInR1cm5fb25cIiwge1xuICAgICAgICAgIGVudGl0eV9pZDogdGhpcy5zdGF0ZU9iaiEuZW50aXR5X2lkLFxuICAgICAgICAgIHJnYl9jb2xvcixcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFzcy5jYWxsU2VydmljZShcImxpZ2h0XCIsIFwidHVybl9vblwiLCB7XG4gICAgICAgIGVudGl0eV9pZDogdGhpcy5zdGF0ZU9iaiEuZW50aXR5X2lkLFxuICAgICAgICBoc19jb2xvcjogW2V2LmRldGFpbC5ocy5oLCBldi5kZXRhaWwuaHMucyAqIDEwMF0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0eWxlcygpOiBDU1NSZXN1bHRHcm91cCB7XG4gICAgcmV0dXJuIGNzc2BcbiAgICAgIC5jb250ZW50IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIH1cblxuICAgICAgLmNvbnRlbnQgPiAqIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgIC5jb2xvcl90ZW1wIHtcbiAgICAgICAgLS1oYS1zbGlkZXItYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoXG4gICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgcmdiKDI1NSwgMTYwLCAwKSAwJSxcbiAgICAgICAgICB3aGl0ZSA1MCUsXG4gICAgICAgICAgcmdiKDE2NiwgMjA5LCAyNTUpIDEwMCVcbiAgICAgICAgKTtcbiAgICAgICAgLyogVGhlIGNvbG9yIHRlbXAgbWluaW11bSB2YWx1ZSBzaG91bGRuJ3QgYmUgcmVuZGVyZWQgZGlmZmVyZW50bHkuIEl0J3Mgbm90IFwib2ZmXCIuICovXG4gICAgICAgIC0tcGFwZXItc2xpZGVyLWtub2Itc3RhcnQtYm9yZGVyLWNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogNHB4O1xuICAgICAgfVxuXG4gICAgICAuc2VnbWVudGF0aW9uQ29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXgtaGVpZ2h0OiA1MDBweDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICB9XG5cbiAgICAgIGhhLWJ1dHRvbi10b2dnbGUtZ3JvdXAge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XG4gICAgICB9XG5cbiAgICAgIGhhLWNvbG9yLXBpY2tlciB7XG4gICAgICAgIC0taGEtY29sb3ItcGlja2VyLXdoZWVsLWJvcmRlcndpZHRoOiA1O1xuICAgICAgICAtLWhhLWNvbG9yLXBpY2tlci13aGVlbC1ib3JkZXJjb2xvcjogd2hpdGU7XG4gICAgICAgIC0taGEtY29sb3ItcGlja2VyLXdoZWVsLXNoYWRvdzogbm9uZTtcbiAgICAgICAgLS1oYS1jb2xvci1waWNrZXItbWFya2VyLWJvcmRlcndpZHRoOiAyO1xuICAgICAgICAtLWhhLWNvbG9yLXBpY2tlci1tYXJrZXItYm9yZGVyY29sb3I6IHdoaXRlO1xuICAgICAgfVxuXG4gICAgICAuc2VnbWVudGF0aW9uQnV0dG9uIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDUlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICBjb2xvcjogdmFyKC0tc2Vjb25kYXJ5LXRleHQtY29sb3IpO1xuICAgICAgfVxuXG4gICAgICBociB7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tZGl2aWRlci1jb2xvcik7XG4gICAgICAgIGJvcmRlci1ib3R0b206IG5vbmU7XG4gICAgICAgIG1hcmdpbjogMTZweCAwO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgSFRNTEVsZW1lbnRUYWdOYW1lTWFwIHtcbiAgICBcIm1vcmUtaW5mby1saWdodFwiOiBNb3JlSW5mb0xpZ2h0O1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/dialogs/more-info/controls/more-info-light.ts\n");

/***/ })

}]);