/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_hls_js_dist_hls_light_min_js"],{

/***/ "./node_modules/hls.js/dist/hls.light.min.js":
/*!***************************************************!*\
  !*** ./node_modules/hls.js/dist/hls.light.min.js ***!
  \***************************************************/
/***/ (function(module) {

eval("\"undefined\" != typeof window && function (t, e) {\n   true ? module.exports = e() : 0;\n}(this, function () {\n  return function (t) {\n    var e = {};\n\n    function r(i) {\n      if (e[i]) return e[i].exports;\n      var a = e[i] = {\n        i: i,\n        l: !1,\n        exports: {}\n      };\n      return t[i].call(a.exports, a, a.exports, r), a.l = !0, a.exports;\n    }\n\n    return r.m = t, r.c = e, r.d = function (t, e, i) {\n      r.o(t, e) || Object.defineProperty(t, e, {\n        enumerable: !0,\n        get: i\n      });\n    }, r.r = function (t) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, r.t = function (t, e) {\n      if (1 & e && (t = r(t)), 8 & e) return t;\n      if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n      var i = Object.create(null);\n      if (r.r(i), Object.defineProperty(i, \"default\", {\n        enumerable: !0,\n        value: t\n      }), 2 & e && \"string\" != typeof t) for (var a in t) r.d(i, a, function (e) {\n        return t[e];\n      }.bind(null, a));\n      return i;\n    }, r.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return r.d(e, \"a\", e), e;\n    }, r.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, r.p = \"/dist/\", r(r.s = 19);\n  }([function (t, e, r) {\n    \"use strict\";\n\n    var i;\n    r.d(e, \"a\", function () {\n      return i;\n    }), function (t) {\n      t.MEDIA_ATTACHING = \"hlsMediaAttaching\", t.MEDIA_ATTACHED = \"hlsMediaAttached\", t.MEDIA_DETACHING = \"hlsMediaDetaching\", t.MEDIA_DETACHED = \"hlsMediaDetached\", t.BUFFER_RESET = \"hlsBufferReset\", t.BUFFER_CODECS = \"hlsBufferCodecs\", t.BUFFER_CREATED = \"hlsBufferCreated\", t.BUFFER_APPENDING = \"hlsBufferAppending\", t.BUFFER_APPENDED = \"hlsBufferAppended\", t.BUFFER_EOS = \"hlsBufferEos\", t.BUFFER_FLUSHING = \"hlsBufferFlushing\", t.BUFFER_FLUSHED = \"hlsBufferFlushed\", t.MANIFEST_LOADING = \"hlsManifestLoading\", t.MANIFEST_LOADED = \"hlsManifestLoaded\", t.MANIFEST_PARSED = \"hlsManifestParsed\", t.LEVEL_SWITCHING = \"hlsLevelSwitching\", t.LEVEL_SWITCHED = \"hlsLevelSwitched\", t.LEVEL_LOADING = \"hlsLevelLoading\", t.LEVEL_LOADED = \"hlsLevelLoaded\", t.LEVEL_UPDATED = \"hlsLevelUpdated\", t.LEVEL_PTS_UPDATED = \"hlsLevelPtsUpdated\", t.LEVELS_UPDATED = \"hlsLevelsUpdated\", t.AUDIO_TRACKS_UPDATED = \"hlsAudioTracksUpdated\", t.AUDIO_TRACK_SWITCHING = \"hlsAudioTrackSwitching\", t.AUDIO_TRACK_SWITCHED = \"hlsAudioTrackSwitched\", t.AUDIO_TRACK_LOADING = \"hlsAudioTrackLoading\", t.AUDIO_TRACK_LOADED = \"hlsAudioTrackLoaded\", t.SUBTITLE_TRACKS_UPDATED = \"hlsSubtitleTracksUpdated\", t.SUBTITLE_TRACKS_CLEARED = \"hlsSubtitleTracksCleared\", t.SUBTITLE_TRACK_SWITCH = \"hlsSubtitleTrackSwitch\", t.SUBTITLE_TRACK_LOADING = \"hlsSubtitleTrackLoading\", t.SUBTITLE_TRACK_LOADED = \"hlsSubtitleTrackLoaded\", t.SUBTITLE_FRAG_PROCESSED = \"hlsSubtitleFragProcessed\", t.CUES_PARSED = \"hlsCuesParsed\", t.NON_NATIVE_TEXT_TRACKS_FOUND = \"hlsNonNativeTextTracksFound\", t.INIT_PTS_FOUND = \"hlsInitPtsFound\", t.FRAG_LOADING = \"hlsFragLoading\", t.FRAG_LOAD_EMERGENCY_ABORTED = \"hlsFragLoadEmergencyAborted\", t.FRAG_LOADED = \"hlsFragLoaded\", t.FRAG_DECRYPTED = \"hlsFragDecrypted\", t.FRAG_PARSING_INIT_SEGMENT = \"hlsFragParsingInitSegment\", t.FRAG_PARSING_USERDATA = \"hlsFragParsingUserdata\", t.FRAG_PARSING_METADATA = \"hlsFragParsingMetadata\", t.FRAG_PARSED = \"hlsFragParsed\", t.FRAG_BUFFERED = \"hlsFragBuffered\", t.FRAG_CHANGED = \"hlsFragChanged\", t.FPS_DROP = \"hlsFpsDrop\", t.FPS_DROP_LEVEL_CAPPING = \"hlsFpsDropLevelCapping\", t.ERROR = \"hlsError\", t.DESTROYING = \"hlsDestroying\", t.KEY_LOADING = \"hlsKeyLoading\", t.KEY_LOADED = \"hlsKeyLoaded\", t.LIVE_BACK_BUFFER_REACHED = \"hlsLiveBackBufferReached\", t.BACK_BUFFER_REACHED = \"hlsBackBufferReached\";\n    }(i || (i = {}));\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return o;\n    }), r.d(e, \"b\", function () {\n      return l;\n    });\n\n    var i = function () {},\n        a = {\n      trace: i,\n      debug: i,\n      log: i,\n      warn: i,\n      info: i,\n      error: i\n    },\n        n = a;\n\n    function s(t) {\n      var e = self.console[t];\n      return e ? e.bind(self.console, \"[\" + t + \"] >\") : i;\n    }\n\n    function o(t) {\n      if (self.console && !0 === t || \"object\" == typeof t) {\n        !function (t) {\n          for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];\n\n          r.forEach(function (e) {\n            n[e] = t[e] ? t[e].bind(t) : s(e);\n          });\n        }(t, \"debug\", \"log\", \"info\", \"warn\", \"error\");\n\n        try {\n          n.log();\n        } catch (t) {\n          n = a;\n        }\n      } else n = a;\n    }\n\n    var l = a;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    var i, a;\n    r.d(e, \"b\", function () {\n      return i;\n    }), r.d(e, \"a\", function () {\n      return a;\n    }), function (t) {\n      t.NETWORK_ERROR = \"networkError\", t.MEDIA_ERROR = \"mediaError\", t.KEY_SYSTEM_ERROR = \"keySystemError\", t.MUX_ERROR = \"muxError\", t.OTHER_ERROR = \"otherError\";\n    }(i || (i = {})), function (t) {\n      t.KEY_SYSTEM_NO_KEYS = \"keySystemNoKeys\", t.KEY_SYSTEM_NO_ACCESS = \"keySystemNoAccess\", t.KEY_SYSTEM_NO_SESSION = \"keySystemNoSession\", t.KEY_SYSTEM_LICENSE_REQUEST_FAILED = \"keySystemLicenseRequestFailed\", t.KEY_SYSTEM_NO_INIT_DATA = \"keySystemNoInitData\", t.MANIFEST_LOAD_ERROR = \"manifestLoadError\", t.MANIFEST_LOAD_TIMEOUT = \"manifestLoadTimeOut\", t.MANIFEST_PARSING_ERROR = \"manifestParsingError\", t.MANIFEST_INCOMPATIBLE_CODECS_ERROR = \"manifestIncompatibleCodecsError\", t.LEVEL_EMPTY_ERROR = \"levelEmptyError\", t.LEVEL_LOAD_ERROR = \"levelLoadError\", t.LEVEL_LOAD_TIMEOUT = \"levelLoadTimeOut\", t.LEVEL_SWITCH_ERROR = \"levelSwitchError\", t.AUDIO_TRACK_LOAD_ERROR = \"audioTrackLoadError\", t.AUDIO_TRACK_LOAD_TIMEOUT = \"audioTrackLoadTimeOut\", t.SUBTITLE_LOAD_ERROR = \"subtitleTrackLoadError\", t.SUBTITLE_TRACK_LOAD_TIMEOUT = \"subtitleTrackLoadTimeOut\", t.FRAG_LOAD_ERROR = \"fragLoadError\", t.FRAG_LOAD_TIMEOUT = \"fragLoadTimeOut\", t.FRAG_DECRYPT_ERROR = \"fragDecryptError\", t.FRAG_PARSING_ERROR = \"fragParsingError\", t.REMUX_ALLOC_ERROR = \"remuxAllocError\", t.KEY_LOAD_ERROR = \"keyLoadError\", t.KEY_LOAD_TIMEOUT = \"keyLoadTimeOut\", t.BUFFER_ADD_CODEC_ERROR = \"bufferAddCodecError\", t.BUFFER_INCOMPATIBLE_CODECS_ERROR = \"bufferIncompatibleCodecsError\", t.BUFFER_APPEND_ERROR = \"bufferAppendError\", t.BUFFER_APPENDING_ERROR = \"bufferAppendingError\", t.BUFFER_STALLED_ERROR = \"bufferStalledError\", t.BUFFER_FULL_ERROR = \"bufferFullError\", t.BUFFER_SEEK_OVER_HOLE = \"bufferSeekOverHole\", t.BUFFER_NUDGE_ON_STALL = \"bufferNudgeOnStall\", t.INTERNAL_EXCEPTION = \"internalException\", t.INTERNAL_ABORTED = \"aborted\", t.UNKNOWN = \"unknown\";\n    }(a || (a = {}));\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return i;\n    });\n\n    var i = Number.isFinite || function (t) {\n      return \"number\" == typeof t && isFinite(t);\n    };\n\n    Number.MAX_SAFE_INTEGER;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    var i, a;\n    r.d(e, \"a\", function () {\n      return i;\n    }), r.d(e, \"b\", function () {\n      return a;\n    }), function (t) {\n      t.MANIFEST = \"manifest\", t.LEVEL = \"level\", t.AUDIO_TRACK = \"audioTrack\", t.SUBTITLE_TRACK = \"subtitleTrack\";\n    }(i || (i = {})), function (t) {\n      t.MAIN = \"main\", t.AUDIO = \"audio\", t.SUBTITLE = \"subtitle\";\n    }(a || (a = {}));\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return i;\n    }), r.d(e, \"b\", function () {\n      return v;\n    }), r.d(e, \"c\", function () {\n      return g;\n    });\n    var i,\n        a = r(3),\n        n = r(11),\n        s = r(1),\n        o = r(15),\n        l = r(12);\n\n    function u(t, e) {\n      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, d(t, e);\n    }\n\n    function d(t, e) {\n      return (d = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    function h(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    function f(t, e, r) {\n      return e && h(t.prototype, e), r && h(t, r), t;\n    }\n\n    !function (t) {\n      t.AUDIO = \"audio\", t.VIDEO = \"video\", t.AUDIOVIDEO = \"audiovideo\";\n    }(i || (i = {}));\n\n    var c = function () {\n      function t(t) {\n        var e;\n        this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = ((e = {})[i.AUDIO] = null, e[i.VIDEO] = null, e[i.AUDIOVIDEO] = null, e), this.baseurl = t;\n      }\n\n      return t.prototype.setByteRange = function (t, e) {\n        var r = t.split(\"@\", 2),\n            i = [];\n        1 === r.length ? i[0] = e ? e.byteRangeEndOffset : 0 : i[0] = parseInt(r[1]), i[1] = parseInt(r[0]) + i[0], this._byteRange = i;\n      }, f(t, [{\n        key: \"byteRange\",\n        get: function () {\n          return this._byteRange ? this._byteRange : [];\n        }\n      }, {\n        key: \"byteRangeStartOffset\",\n        get: function () {\n          return this.byteRange[0];\n        }\n      }, {\n        key: \"byteRangeEndOffset\",\n        get: function () {\n          return this.byteRange[1];\n        }\n      }, {\n        key: \"url\",\n        get: function () {\n          return !this._url && this.baseurl && this.relurl && (this._url = Object(n.buildAbsoluteURL)(this.baseurl, this.relurl, {\n            alwaysNormalize: !0\n          })), this._url || \"\";\n        },\n        set: function (t) {\n          this._url = t;\n        }\n      }]), t;\n    }(),\n        v = function (t) {\n      function e(e, r) {\n        var i;\n        return (i = t.call(this, r) || this)._decryptdata = null, i.rawProgramDateTime = null, i.programDateTime = null, i.tagList = [], i.duration = 0, i.sn = 0, i.levelkey = void 0, i.type = void 0, i.loader = null, i.level = -1, i.cc = 0, i.startPTS = void 0, i.endPTS = void 0, i.appendedPTS = void 0, i.startDTS = void 0, i.endDTS = void 0, i.start = 0, i.deltaPTS = void 0, i.maxStartPTS = void 0, i.minEndPTS = void 0, i.stats = new l.a(), i.urlId = 0, i.data = void 0, i.bitrateTest = !1, i.title = null, i.initSegment = null, i.type = e, i;\n      }\n\n      u(e, t);\n      var r = e.prototype;\n      return r.createInitializationVector = function (t) {\n        for (var e = new Uint8Array(16), r = 12; r < 16; r++) e[r] = t >> 8 * (15 - r) & 255;\n\n        return e;\n      }, r.setDecryptDataFromLevelKey = function (t, e) {\n        var r = t;\n        return \"AES-128\" === (null == t ? void 0 : t.method) && t.uri && !t.iv && ((r = o.a.fromURI(t.uri)).method = t.method, r.iv = this.createInitializationVector(e), r.keyFormat = \"identity\"), r;\n      }, r.setElementaryStreamInfo = function (t, e, r, i, a, n) {\n        void 0 === n && (n = !1);\n        var s = this.elementaryStreams,\n            o = s[t];\n        o ? (o.startPTS = Math.min(o.startPTS, e), o.endPTS = Math.max(o.endPTS, r), o.startDTS = Math.min(o.startDTS, i), o.endDTS = Math.max(o.endDTS, a)) : s[t] = {\n          startPTS: e,\n          endPTS: r,\n          startDTS: i,\n          endDTS: a,\n          partial: n\n        };\n      }, r.clearElementaryStreamInfo = function () {\n        var t = this.elementaryStreams;\n        t[i.AUDIO] = null, t[i.VIDEO] = null, t[i.AUDIOVIDEO] = null;\n      }, f(e, [{\n        key: \"decryptdata\",\n        get: function () {\n          if (!this.levelkey && !this._decryptdata) return null;\n\n          if (!this._decryptdata && this.levelkey) {\n            var t = this.sn;\n            \"number\" != typeof t && (this.levelkey && \"AES-128\" === this.levelkey.method && !this.levelkey.iv && s.b.warn('missing IV for initialization segment with method=\"' + this.levelkey.method + '\" - compliance issue'), t = 0), this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, t);\n          }\n\n          return this._decryptdata;\n        }\n      }, {\n        key: \"end\",\n        get: function () {\n          return this.start + this.duration;\n        }\n      }, {\n        key: \"endProgramDateTime\",\n        get: function () {\n          if (null === this.programDateTime) return null;\n          if (!Object(a.a)(this.programDateTime)) return null;\n          var t = Object(a.a)(this.duration) ? this.duration : 0;\n          return this.programDateTime + 1e3 * t;\n        }\n      }, {\n        key: \"encrypted\",\n        get: function () {\n          var t;\n          return !(null === (t = this.decryptdata) || void 0 === t || !t.keyFormat || !this.decryptdata.uri);\n        }\n      }]), e;\n    }(c),\n        g = function (t) {\n      function e(e, r, i, a, n) {\n        var s;\n        (s = t.call(this, i) || this).fragOffset = 0, s.duration = 0, s.gap = !1, s.independent = !1, s.relurl = void 0, s.fragment = void 0, s.index = void 0, s.stats = new l.a(), s.duration = e.decimalFloatingPoint(\"DURATION\"), s.gap = e.bool(\"GAP\"), s.independent = e.bool(\"INDEPENDENT\"), s.relurl = e.enumeratedString(\"URI\"), s.fragment = r, s.index = a;\n        var o = e.enumeratedString(\"BYTERANGE\");\n        return o && s.setByteRange(o, n), n && (s.fragOffset = n.fragOffset + n.duration), s;\n      }\n\n      return u(e, t), f(e, [{\n        key: \"start\",\n        get: function () {\n          return this.fragment.start + this.fragOffset;\n        }\n      }, {\n        key: \"end\",\n        get: function () {\n          return this.start + this.duration;\n        }\n      }, {\n        key: \"loaded\",\n        get: function () {\n          var t = this.elementaryStreams;\n          return !!(t.audio || t.video || t.audiovideo);\n        }\n      }]), e;\n    }(c);\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"b\", function () {\n      return d;\n    }), r.d(e, \"g\", function () {\n      return h;\n    }), r.d(e, \"f\", function () {\n      return f;\n    }), r.d(e, \"d\", function () {\n      return c;\n    }), r.d(e, \"c\", function () {\n      return v;\n    }), r.d(e, \"e\", function () {\n      return p;\n    }), r.d(e, \"h\", function () {\n      return m;\n    }), r.d(e, \"a\", function () {\n      return y;\n    });\n    var i = r(8),\n        a = r(5),\n        n = Math.pow(2, 32) - 1,\n        s = [].push;\n\n    function o(t) {\n      return String.fromCharCode.apply(null, t);\n    }\n\n    function l(t, e) {\n      \"data\" in t && (e += t.start, t = t.data);\n      var r = t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];\n      return r < 0 ? 4294967296 + r : r;\n    }\n\n    function u(t, e, r) {\n      \"data\" in t && (e += t.start, t = t.data), t[e] = r >> 24, t[e + 1] = r >> 16 & 255, t[e + 2] = r >> 8 & 255, t[e + 3] = 255 & r;\n    }\n\n    function d(t, e) {\n      var r,\n          i,\n          a,\n          n = [];\n      if (!e.length) return n;\n      \"data\" in t ? (r = t.data, i = t.start, a = t.end) : (i = 0, a = (r = t).byteLength);\n\n      for (var u = i; u < a;) {\n        var h = l(r, u),\n            f = h > 1 ? u + h : a;\n        if (o(r.subarray(u + 4, u + 8)) === e[0]) if (1 === e.length) n.push({\n          data: r,\n          start: u + 8,\n          end: f\n        });else {\n          var c = d({\n            data: r,\n            start: u + 8,\n            end: f\n          }, e.slice(1));\n          c.length && s.apply(n, c);\n        }\n        u = f;\n      }\n\n      return n;\n    }\n\n    function h(t) {\n      var e = d(t, [\"moov\"])[0],\n          r = e ? e.end : null,\n          i = d(t, [\"sidx\"]);\n      if (!i || !i[0]) return null;\n      var a = [],\n          n = i[0],\n          s = n.data[0],\n          o = 0 === s ? 8 : 16,\n          u = l(n, o);\n      o += 4;\n      o += 0 === s ? 8 : 16, o += 2;\n\n      var h = n.end + 0,\n          f = function (t, e) {\n        \"data\" in t && (e += t.start, t = t.data);\n        var r = t[e] << 8 | t[e + 1];\n        return r < 0 ? 65536 + r : r;\n      }(n, o);\n\n      o += 2;\n\n      for (var c = 0; c < f; c++) {\n        var v = o,\n            g = l(n, v);\n        v += 4;\n        var p = 2147483647 & g;\n        if (1 === (2147483648 & g) >>> 31) return console.warn(\"SIDX has hierarchical references (not supported)\"), null;\n        var m = l(n, v);\n        v += 4, a.push({\n          referenceSize: p,\n          subsegmentDuration: m,\n          info: {\n            duration: m / u,\n            start: h,\n            end: h + p - 1\n          }\n        }), h += p, o = v += 4;\n      }\n\n      return {\n        earliestPresentationTime: 0,\n        timescale: u,\n        version: s,\n        referencesCount: f,\n        references: a,\n        moovEndOffset: r\n      };\n    }\n\n    function f(t) {\n      for (var e = [], r = d(t, [\"moov\", \"trak\"]), i = 0; i < r.length; i++) {\n        var n = r[i],\n            s = d(n, [\"tkhd\"])[0];\n\n        if (s) {\n          var u = s.data[s.start],\n              h = 0 === u ? 12 : 20,\n              f = l(s, h),\n              c = d(n, [\"mdia\", \"mdhd\"])[0];\n\n          if (c) {\n            var v = l(c, h = 0 === (u = c.data[c.start]) ? 12 : 20),\n                g = d(n, [\"mdia\", \"hdlr\"])[0];\n\n            if (g) {\n              var p = o(g.data.subarray(g.start + 8, g.start + 12)),\n                  m = {\n                soun: a.a.AUDIO,\n                vide: a.a.VIDEO\n              }[p];\n\n              if (m) {\n                var y = d(n, [\"mdia\", \"minf\", \"stbl\", \"stsd\"])[0],\n                    b = void 0;\n                y && (b = o(y.data.subarray(y.start + 12, y.start + 16))), e[f] = {\n                  timescale: v,\n                  type: m\n                }, e[m] = {\n                  timescale: v,\n                  id: f,\n                  codec: b\n                };\n              }\n            }\n          }\n        }\n      }\n\n      return d(t, [\"moov\", \"mvex\", \"trex\"]).forEach(function (t) {\n        var r = l(t, 4),\n            i = e[r];\n        i && (i.default = {\n          duration: l(t, 12),\n          flags: l(t, 20)\n        });\n      }), e;\n    }\n\n    function c(t, e) {\n      return d(e, [\"moof\", \"traf\"]).reduce(function (e, r) {\n        var i = d(r, [\"tfdt\"])[0],\n            a = i.data[i.start],\n            n = d(r, [\"tfhd\"]).reduce(function (e, r) {\n          var n = l(r, 4),\n              s = t[n];\n\n          if (s) {\n            var o = l(i, 4);\n            1 === a && (o *= Math.pow(2, 32), o += l(i, 8));\n            var u = o / (s.timescale || 9e4);\n            if (isFinite(u) && (null === e || u < e)) return u;\n          }\n\n          return e;\n        }, null);\n        return null !== n && isFinite(n) && (null === e || n < e) ? n : e;\n      }, null) || 0;\n    }\n\n    function v(t, e) {\n      for (var r = 0, i = 0, n = 0, s = d(t, [\"moof\", \"traf\"]), o = 0; o < s.length; o++) {\n        var u = s[o],\n            f = d(u, [\"tfhd\"])[0],\n            c = e[l(f, 4)];\n\n        if (c) {\n          var v = c.default,\n              p = l(f, 0) | (null == v ? void 0 : v.flags),\n              m = null == v ? void 0 : v.duration;\n          8 & p && (m = l(f, 2 & p ? 12 : 8));\n\n          for (var y = c.timescale || 9e4, b = d(u, [\"trun\"]), T = 0; T < b.length; T++) {\n            if (!(r = g(b[T])) && m) r = m * l(b[T], 4);\n            c.type === a.a.VIDEO ? i += r / y : c.type === a.a.AUDIO && (n += r / y);\n          }\n        }\n      }\n\n      if (0 === i && 0 === n) {\n        var E = h(t);\n        if (null != E && E.references) return E.references.reduce(function (t, e) {\n          return t + e.info.duration || 0;\n        }, 0);\n      }\n\n      return i || n;\n    }\n\n    function g(t) {\n      var e = l(t, 0),\n          r = 8;\n      1 & e && (r += 4), 4 & e && (r += 4);\n\n      for (var i = 0, a = l(t, 4), n = 0; n < a; n++) {\n        if (256 & e) i += l(t, r), r += 4;\n        512 & e && (r += 4), 1024 & e && (r += 4), 2048 & e && (r += 4);\n      }\n\n      return i;\n    }\n\n    function p(t, e, r) {\n      d(e, [\"moof\", \"traf\"]).forEach(function (e) {\n        d(e, [\"tfhd\"]).forEach(function (i) {\n          var a = l(i, 4),\n              s = t[a];\n\n          if (s) {\n            var o = s.timescale || 9e4;\n            d(e, [\"tfdt\"]).forEach(function (t) {\n              var e = t.data[t.start],\n                  i = l(t, 4);\n              if (0 === e) u(t, 4, i - r * o);else {\n                i *= Math.pow(2, 32), i += l(t, 8), i -= r * o, i = Math.max(i, 0);\n                var a = Math.floor(i / (n + 1)),\n                    s = Math.floor(i % (n + 1));\n                u(t, 4, a), u(t, 8, s);\n              }\n            });\n          }\n        });\n      });\n    }\n\n    function m(t) {\n      var e = {\n        valid: null,\n        remainder: null\n      },\n          r = d(t, [\"moof\"]);\n      if (!r) return e;\n      if (r.length < 2) return e.remainder = t, e;\n      var a = r[r.length - 1];\n      return e.valid = Object(i.a)(t, 0, a.start - 8), e.remainder = Object(i.a)(t, a.start - 8), e;\n    }\n\n    function y(t, e) {\n      var r = new Uint8Array(t.length + e.length);\n      return r.set(t), r.set(e, t.length), r;\n    }\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"b\", function () {\n      return s;\n    }), r.d(e, \"a\", function () {\n      return l;\n    }), r.d(e, \"d\", function () {\n      return u;\n    }), r.d(e, \"e\", function () {\n      return d;\n    }), r.d(e, \"c\", function () {\n      return f;\n    }), r.d(e, \"f\", function () {\n      return y;\n    });\n\n    var i,\n        a = function (t, e) {\n      return e + 10 <= t.length && 73 === t[e] && 68 === t[e + 1] && 51 === t[e + 2] && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128;\n    },\n        n = function (t, e) {\n      return e + 10 <= t.length && 51 === t[e] && 68 === t[e + 1] && 73 === t[e + 2] && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128;\n    },\n        s = function (t, e) {\n      for (var r = e, i = 0; a(t, e);) {\n        i += 10, i += o(t, e + 6), n(t, e + 10) && (i += 10), e += i;\n      }\n\n      if (i > 0) return t.subarray(r, r + i);\n    },\n        o = function (t, e) {\n      var r = 0;\n      return r = (127 & t[e]) << 21, r |= (127 & t[e + 1]) << 14, r |= (127 & t[e + 2]) << 7, r |= 127 & t[e + 3];\n    },\n        l = function (t, e) {\n      return a(t, e) && o(t, e + 6) + 10 <= t.length - e;\n    },\n        u = function (t) {\n      for (var e = f(t), r = 0; r < e.length; r++) {\n        var i = e[r];\n        if (d(i)) return m(i);\n      }\n    },\n        d = function (t) {\n      return t && \"PRIV\" === t.key && \"com.apple.streaming.transportStreamTimestamp\" === t.info;\n    },\n        h = function (t) {\n      var e = String.fromCharCode(t[0], t[1], t[2], t[3]),\n          r = o(t, 4);\n      return {\n        type: e,\n        size: r,\n        data: t.subarray(10, 10 + r)\n      };\n    },\n        f = function (t) {\n      for (var e = 0, r = []; a(t, e);) {\n        for (var i = o(t, e + 6), s = (e += 10) + i; e + 8 < s;) {\n          var l = h(t.subarray(e)),\n              u = c(l);\n          u && r.push(u), e += l.size + 10;\n        }\n\n        n(t, e) && (e += 10);\n      }\n\n      return r;\n    },\n        c = function (t) {\n      return \"PRIV\" === t.type ? v(t) : \"W\" === t.type[0] ? p(t) : g(t);\n    },\n        v = function (t) {\n      if (!(t.size < 2)) {\n        var e = y(t.data, !0),\n            r = new Uint8Array(t.data.subarray(e.length + 1));\n        return {\n          key: t.type,\n          info: e,\n          data: r.buffer\n        };\n      }\n    },\n        g = function (t) {\n      if (!(t.size < 2)) {\n        if (\"TXXX\" === t.type) {\n          var e = 1,\n              r = y(t.data.subarray(e), !0);\n          e += r.length + 1;\n          var i = y(t.data.subarray(e));\n          return {\n            key: t.type,\n            info: r,\n            data: i\n          };\n        }\n\n        var a = y(t.data.subarray(1));\n        return {\n          key: t.type,\n          data: a\n        };\n      }\n    },\n        p = function (t) {\n      if (\"WXXX\" === t.type) {\n        if (t.size < 2) return;\n        var e = 1,\n            r = y(t.data.subarray(e), !0);\n        e += r.length + 1;\n        var i = y(t.data.subarray(e));\n        return {\n          key: t.type,\n          info: r,\n          data: i\n        };\n      }\n\n      var a = y(t.data);\n      return {\n        key: t.type,\n        data: a\n      };\n    },\n        m = function (t) {\n      if (8 === t.data.byteLength) {\n        var e = new Uint8Array(t.data),\n            r = 1 & e[3],\n            i = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];\n        return i /= 45, r && (i += 47721858.84), Math.round(i);\n      }\n    },\n        y = function (t, e) {\n      void 0 === e && (e = !1);\n      var r = b();\n\n      if (r) {\n        var i = r.decode(t);\n\n        if (e) {\n          var a = i.indexOf(\"\\0\");\n          return -1 !== a ? i.substring(0, a) : i;\n        }\n\n        return i.replace(/\\0/g, \"\");\n      }\n\n      for (var n, s, o, l = t.length, u = \"\", d = 0; d < l;) {\n        if (0 === (n = t[d++]) && e) return u;\n        if (0 !== n && 3 !== n) switch (n >> 4) {\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n            u += String.fromCharCode(n);\n            break;\n\n          case 12:\n          case 13:\n            s = t[d++], u += String.fromCharCode((31 & n) << 6 | 63 & s);\n            break;\n\n          case 14:\n            s = t[d++], o = t[d++], u += String.fromCharCode((15 & n) << 12 | (63 & s) << 6 | (63 & o) << 0);\n        }\n      }\n\n      return u;\n    };\n\n    function b() {\n      return i || void 0 === self.TextDecoder || (i = new self.TextDecoder(\"utf-8\")), i;\n    }\n  }, function (t, e, r) {\n    \"use strict\";\n\n    function i(t, e, r) {\n      return Uint8Array.prototype.slice ? t.slice(e, r) : new Uint8Array(Array.prototype.slice.call(t, e, r));\n    }\n\n    r.d(e, \"a\", function () {\n      return i;\n    });\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"c\", function () {\n      return St;\n    }), r.d(e, \"d\", function () {\n      return At;\n    }), r.d(e, \"a\", function () {\n      return Rt;\n    }), r.d(e, \"b\", function () {\n      return Dt;\n    });\n    var i = r(0),\n        a = r(2),\n        n = r(14),\n        s = r(3),\n        o = r(7);\n\n    var l = r(6),\n        u = r(8),\n        d = function () {\n      function t() {\n        this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.initPTS = null;\n      }\n\n      var e = t.prototype;\n      return e.resetInitSegment = function (t, e, r) {\n        this._id3Track = {\n          type: \"id3\",\n          id: 3,\n          pid: -1,\n          inputTimeScale: 9e4,\n          sequenceNumber: 0,\n          samples: [],\n          dropped: 0\n        };\n      }, e.resetTimeStamp = function () {}, e.resetContiguity = function () {}, e.canParse = function (t, e) {\n        return !1;\n      }, e.appendFrame = function (t, e, r) {}, e.demux = function (t, e) {\n        this.cachedData && (t = Object(l.a)(this.cachedData, t), this.cachedData = null);\n        var r,\n            i,\n            a = o.b(t, 0),\n            n = a ? a.length : 0,\n            s = this._audioTrack,\n            d = this._id3Track,\n            f = a ? o.d(a) : void 0,\n            c = t.length;\n\n        for (0 !== this.frameIndex && null !== this.initPTS || (this.initPTS = h(f, e)), a && a.length > 0 && d.samples.push({\n          pts: this.initPTS,\n          dts: this.initPTS,\n          data: a\n        }), i = this.initPTS; n < c;) {\n          if (this.canParse(t, n)) {\n            var v = this.appendFrame(s, t, n);\n            v ? (this.frameIndex++, i = v.sample.pts, r = n += v.length) : n = c;\n          } else o.a(t, n) ? (a = o.b(t, n), d.samples.push({\n            pts: i,\n            dts: i,\n            data: a\n          }), r = n += a.length) : n++;\n\n          if (n === c && r !== c) {\n            var g = Object(u.a)(t, r);\n            this.cachedData ? this.cachedData = Object(l.a)(this.cachedData, g) : this.cachedData = g;\n          }\n        }\n\n        return {\n          audioTrack: s,\n          avcTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          },\n          id3Track: d,\n          textTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          }\n        };\n      }, e.demuxSampleAes = function (t, e, r) {\n        return Promise.reject(new Error(\"[\" + this + \"] This demuxer does not support Sample-AES decryption\"));\n      }, e.flush = function (t) {\n        var e = this.cachedData;\n        return e && (this.cachedData = null, this.demux(e, 0)), this.frameIndex = 0, {\n          audioTrack: this._audioTrack,\n          avcTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          },\n          id3Track: this._id3Track,\n          textTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          }\n        };\n      }, e.destroy = function () {}, t;\n    }(),\n        h = function (t, e) {\n      return Object(s.a)(t) ? 90 * t : 9e4 * e;\n    },\n        f = d,\n        c = r(1);\n\n    function v(t, e) {\n      return 255 === t[e] && 240 == (246 & t[e + 1]);\n    }\n\n    function g(t, e) {\n      return 1 & t[e + 1] ? 7 : 9;\n    }\n\n    function p(t, e) {\n      return (3 & t[e + 3]) << 11 | t[e + 4] << 3 | (224 & t[e + 5]) >>> 5;\n    }\n\n    function m(t, e) {\n      return e + 1 < t.length && v(t, e);\n    }\n\n    function y(t, e) {\n      if (m(t, e)) {\n        var r = g(t, e);\n        if (e + r >= t.length) return !1;\n        var i = p(t, e);\n        if (i <= r) return !1;\n        var a = e + i;\n        return a === t.length || m(t, a);\n      }\n\n      return !1;\n    }\n\n    function b(t, e, r, n, s) {\n      if (!t.samplerate) {\n        var o = function (t, e, r, n) {\n          var s,\n              o,\n              l,\n              u,\n              d = navigator.userAgent.toLowerCase(),\n              h = n,\n              f = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];\n          s = 1 + ((192 & e[r + 2]) >>> 6);\n          var v = (60 & e[r + 2]) >>> 2;\n          if (!(v > f.length - 1)) return l = (1 & e[r + 2]) << 2, l |= (192 & e[r + 3]) >>> 6, c.b.log(\"manifest codec:\" + n + \", ADTS type:\" + s + \", samplingIndex:\" + v), /firefox/i.test(d) ? v >= 6 ? (s = 5, u = new Array(4), o = v - 3) : (s = 2, u = new Array(2), o = v) : -1 !== d.indexOf(\"android\") ? (s = 2, u = new Array(2), o = v) : (s = 5, u = new Array(4), n && (-1 !== n.indexOf(\"mp4a.40.29\") || -1 !== n.indexOf(\"mp4a.40.5\")) || !n && v >= 6 ? o = v - 3 : ((n && -1 !== n.indexOf(\"mp4a.40.2\") && (v >= 6 && 1 === l || /vivaldi/i.test(d)) || !n && 1 === l) && (s = 2, u = new Array(2)), o = v)), u[0] = s << 3, u[0] |= (14 & v) >> 1, u[1] |= (1 & v) << 7, u[1] |= l << 3, 5 === s && (u[1] |= (14 & o) >> 1, u[2] = (1 & o) << 7, u[2] |= 8, u[3] = 0), {\n            config: u,\n            samplerate: f[v],\n            channelCount: l,\n            codec: \"mp4a.40.\" + s,\n            manifestCodec: h\n          };\n          t.trigger(i.a.ERROR, {\n            type: a.b.MEDIA_ERROR,\n            details: a.a.FRAG_PARSING_ERROR,\n            fatal: !0,\n            reason: \"invalid ADTS sampling index:\" + v\n          });\n        }(e, r, n, s);\n\n        if (!o) return;\n        t.config = o.config, t.samplerate = o.samplerate, t.channelCount = o.channelCount, t.codec = o.codec, t.manifestCodec = o.manifestCodec, c.b.log(\"parsed codec:\" + t.codec + \", rate:\" + o.samplerate + \", channels:\" + o.channelCount);\n      }\n    }\n\n    function T(t) {\n      return 9216e4 / t;\n    }\n\n    function E(t, e, r, i, a) {\n      var n = function (t, e, r, i, a) {\n        var n = g(t, e),\n            s = p(t, e);\n        if ((s -= n) > 0) return {\n          headerLength: n,\n          frameLength: s,\n          stamp: r + i * a\n        };\n      }(e, r, i, a, T(t.samplerate));\n\n      if (n) {\n        var s,\n            o = n.frameLength,\n            l = n.headerLength,\n            u = n.stamp,\n            d = l + o,\n            h = Math.max(0, r + d - e.length);\n        h ? (s = new Uint8Array(d - l)).set(e.subarray(r + l, e.length), 0) : s = e.subarray(r + l, r + d);\n        var f = {\n          unit: s,\n          pts: u\n        };\n        return h || t.samples.push(f), {\n          sample: f,\n          length: d,\n          missing: h\n        };\n      }\n    }\n\n    function S(t, e) {\n      return (S = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    var L = function (t) {\n      var e, r;\n\n      function i(e, r) {\n        var i;\n        return (i = t.call(this) || this).observer = void 0, i.config = void 0, i.observer = e, i.config = r, i;\n      }\n\n      r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, S(e, r);\n      var a = i.prototype;\n      return a.resetInitSegment = function (e, r, i) {\n        t.prototype.resetInitSegment.call(this, e, r, i), this._audioTrack = {\n          container: \"audio/adts\",\n          type: \"audio\",\n          id: 2,\n          pid: -1,\n          sequenceNumber: 0,\n          isAAC: !0,\n          samples: [],\n          manifestCodec: e,\n          duration: i,\n          inputTimeScale: 9e4,\n          dropped: 0\n        };\n      }, i.probe = function (t) {\n        if (!t) return !1;\n\n        for (var e = (o.b(t, 0) || []).length, r = t.length; e < r; e++) if (y(t, e)) return c.b.log(\"ADTS sync word found !\"), !0;\n\n        return !1;\n      }, a.canParse = function (t, e) {\n        return function (t, e) {\n          return function (t, e) {\n            return e + 5 < t.length;\n          }(t, e) && v(t, e) && p(t, e) <= t.length - e;\n        }(t, e);\n      }, a.appendFrame = function (t, e, r) {\n        b(t, this.observer, e, r, t.manifestCodec);\n        var i = E(t, e, r, this.initPTS, this.frameIndex);\n        if (i && 0 === i.missing) return i;\n      }, i;\n    }(f);\n\n    L.minProbeByteLength = 9;\n\n    var A = L,\n        R = function () {\n      function t(t, e) {\n        this.remainderData = null, this.config = void 0, this.config = e;\n      }\n\n      var e = t.prototype;\n      return e.resetTimeStamp = function () {}, e.resetInitSegment = function () {}, e.resetContiguity = function () {}, t.probe = function (t) {\n        return Object(l.b)({\n          data: t,\n          start: 0,\n          end: Math.min(t.length, 16384)\n        }, [\"moof\"]).length > 0;\n      }, e.demux = function (t) {\n        var e = t,\n            r = {\n          type: \"\",\n          id: -1,\n          pid: -1,\n          inputTimeScale: 9e4,\n          sequenceNumber: -1,\n          samples: [],\n          dropped: 0\n        };\n\n        if (this.config.progressive) {\n          this.remainderData && (e = Object(l.a)(this.remainderData, t));\n          var i = Object(l.h)(e);\n          this.remainderData = i.remainder, r.samples = i.valid || new Uint8Array();\n        } else r.samples = e;\n\n        return {\n          audioTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          },\n          avcTrack: r,\n          id3Track: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          },\n          textTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          }\n        };\n      }, e.flush = function () {\n        var t = {\n          type: \"\",\n          id: -1,\n          pid: -1,\n          inputTimeScale: 9e4,\n          sequenceNumber: -1,\n          samples: [],\n          dropped: 0\n        };\n        return t.samples = this.remainderData || new Uint8Array(), this.remainderData = null, {\n          audioTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          },\n          avcTrack: t,\n          id3Track: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          },\n          textTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          }\n        };\n      }, e.demuxSampleAes = function (t, e, r) {\n        return Promise.reject(new Error(\"The MP4 demuxer does not support SAMPLE-AES decryption\"));\n      }, e.destroy = function () {}, t;\n    }();\n\n    R.minProbeByteLength = 1024;\n    var D = R,\n        _ = null,\n        k = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],\n        x = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],\n        C = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]],\n        w = [0, 1, 1, 4];\n\n    function O(t, e, r, i, a) {\n      if (!(r + 24 > e.length)) {\n        var n = I(e, r);\n\n        if (n && r + n.frameLength <= e.length) {\n          var s = i + a * (9e4 * n.samplesPerFrame / n.sampleRate),\n              o = {\n            unit: e.subarray(r, r + n.frameLength),\n            pts: s,\n            dts: s\n          };\n          return t.config = [], t.channelCount = n.channelCount, t.samplerate = n.sampleRate, t.samples.push(o), {\n            sample: o,\n            length: n.frameLength,\n            missing: 0\n          };\n        }\n      }\n    }\n\n    function I(t, e) {\n      var r = t[e + 1] >> 3 & 3,\n          i = t[e + 1] >> 1 & 3,\n          a = t[e + 2] >> 4 & 15,\n          n = t[e + 2] >> 2 & 3;\n\n      if (1 !== r && 0 !== a && 15 !== a && 3 !== n) {\n        var s = t[e + 2] >> 1 & 1,\n            o = t[e + 3] >> 6,\n            l = 1e3 * k[14 * (3 === r ? 3 - i : 3 === i ? 3 : 4) + a - 1],\n            u = x[3 * (3 === r ? 0 : 2 === r ? 1 : 2) + n],\n            d = 3 === o ? 1 : 2,\n            h = C[r][i],\n            f = w[i],\n            c = 8 * h * f,\n            v = Math.floor(h * l / u + s) * f;\n\n        if (null === _) {\n          var g = (navigator.userAgent || \"\").match(/Chrome\\/(\\d+)/i);\n          _ = g ? parseInt(g[1]) : 0;\n        }\n\n        return !!_ && _ <= 87 && 2 === i && l >= 224e3 && 0 === o && (t[e + 3] = 128 | t[e + 3]), {\n          sampleRate: u,\n          channelCount: d,\n          frameLength: v,\n          samplesPerFrame: c\n        };\n      }\n    }\n\n    function P(t, e) {\n      return 255 === t[e] && 224 == (224 & t[e + 1]) && 0 != (6 & t[e + 1]);\n    }\n\n    function F(t, e) {\n      return e + 1 < t.length && P(t, e);\n    }\n\n    function M(t, e) {\n      if (e + 1 < t.length && P(t, e)) {\n        var r = I(t, e),\n            i = 4;\n        null != r && r.frameLength && (i = r.frameLength);\n        var a = e + i;\n        return a === t.length || F(t, a);\n      }\n\n      return !1;\n    }\n\n    var N = function () {\n      function t(t) {\n        this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = t, this.bytesAvailable = t.byteLength, this.word = 0, this.bitsAvailable = 0;\n      }\n\n      var e = t.prototype;\n      return e.loadWord = function () {\n        var t = this.data,\n            e = this.bytesAvailable,\n            r = t.byteLength - e,\n            i = new Uint8Array(4),\n            a = Math.min(4, e);\n        if (0 === a) throw new Error(\"no bytes available\");\n        i.set(t.subarray(r, r + a)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = 8 * a, this.bytesAvailable -= a;\n      }, e.skipBits = function (t) {\n        var e;\n        this.bitsAvailable > t ? (this.word <<= t, this.bitsAvailable -= t) : (t -= this.bitsAvailable, t -= (e = t >> 3) >> 3, this.bytesAvailable -= e, this.loadWord(), this.word <<= t, this.bitsAvailable -= t);\n      }, e.readBits = function (t) {\n        var e = Math.min(this.bitsAvailable, t),\n            r = this.word >>> 32 - e;\n        return t > 32 && c.b.error(\"Cannot read more than 32 bits at a time\"), this.bitsAvailable -= e, this.bitsAvailable > 0 ? this.word <<= e : this.bytesAvailable > 0 && this.loadWord(), (e = t - e) > 0 && this.bitsAvailable ? r << e | this.readBits(e) : r;\n      }, e.skipLZ = function () {\n        var t;\n\n        for (t = 0; t < this.bitsAvailable; ++t) if (0 != (this.word & 2147483648 >>> t)) return this.word <<= t, this.bitsAvailable -= t, t;\n\n        return this.loadWord(), t + this.skipLZ();\n      }, e.skipUEG = function () {\n        this.skipBits(1 + this.skipLZ());\n      }, e.skipEG = function () {\n        this.skipBits(1 + this.skipLZ());\n      }, e.readUEG = function () {\n        var t = this.skipLZ();\n        return this.readBits(t + 1) - 1;\n      }, e.readEG = function () {\n        var t = this.readUEG();\n        return 1 & t ? 1 + t >>> 1 : -1 * (t >>> 1);\n      }, e.readBoolean = function () {\n        return 1 === this.readBits(1);\n      }, e.readUByte = function () {\n        return this.readBits(8);\n      }, e.readUShort = function () {\n        return this.readBits(16);\n      }, e.readUInt = function () {\n        return this.readBits(32);\n      }, e.skipScalingList = function (t) {\n        for (var e = 8, r = 8, i = 0; i < t; i++) 0 !== r && (r = (e + this.readEG() + 256) % 256), e = 0 === r ? e : r;\n      }, e.readSPS = function () {\n        var t,\n            e,\n            r,\n            i = 0,\n            a = 0,\n            n = 0,\n            s = 0,\n            o = this.readUByte.bind(this),\n            l = this.readBits.bind(this),\n            u = this.readUEG.bind(this),\n            d = this.readBoolean.bind(this),\n            h = this.skipBits.bind(this),\n            f = this.skipEG.bind(this),\n            c = this.skipUEG.bind(this),\n            v = this.skipScalingList.bind(this);\n        o();\n        var g = o();\n\n        if (l(5), h(3), o(), c(), 100 === g || 110 === g || 122 === g || 244 === g || 44 === g || 83 === g || 86 === g || 118 === g || 128 === g) {\n          var p = u();\n          if (3 === p && h(1), c(), c(), h(1), d()) for (e = 3 !== p ? 8 : 12, r = 0; r < e; r++) d() && v(r < 6 ? 16 : 64);\n        }\n\n        c();\n        var m = u();\n        if (0 === m) u();else if (1 === m) for (h(1), f(), f(), t = u(), r = 0; r < t; r++) f();\n        c(), h(1);\n        var y = u(),\n            b = u(),\n            T = l(1);\n        0 === T && h(1), h(1), d() && (i = u(), a = u(), n = u(), s = u());\n        var E = [1, 1];\n        if (d() && d()) switch (o()) {\n          case 1:\n            E = [1, 1];\n            break;\n\n          case 2:\n            E = [12, 11];\n            break;\n\n          case 3:\n            E = [10, 11];\n            break;\n\n          case 4:\n            E = [16, 11];\n            break;\n\n          case 5:\n            E = [40, 33];\n            break;\n\n          case 6:\n            E = [24, 11];\n            break;\n\n          case 7:\n            E = [20, 11];\n            break;\n\n          case 8:\n            E = [32, 11];\n            break;\n\n          case 9:\n            E = [80, 33];\n            break;\n\n          case 10:\n            E = [18, 11];\n            break;\n\n          case 11:\n            E = [15, 11];\n            break;\n\n          case 12:\n            E = [64, 33];\n            break;\n\n          case 13:\n            E = [160, 99];\n            break;\n\n          case 14:\n            E = [4, 3];\n            break;\n\n          case 15:\n            E = [3, 2];\n            break;\n\n          case 16:\n            E = [2, 1];\n            break;\n\n          case 255:\n            E = [o() << 8 | o(), o() << 8 | o()];\n        }\n        return {\n          width: Math.ceil(16 * (y + 1) - 2 * i - 2 * a),\n          height: (2 - T) * (b + 1) * 16 - (T ? 2 : 4) * (n + s),\n          pixelRatio: E\n        };\n      }, e.readSliceType = function () {\n        return this.readUByte(), this.readUEG(), this.readUEG();\n      }, t;\n    }(),\n        B = function () {\n      function t(t, e, r) {\n        this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new n.a(t, e, {\n          removePKCS7Padding: !1\n        });\n      }\n\n      var e = t.prototype;\n      return e.decryptBuffer = function (t, e) {\n        this.decrypter.decrypt(t, this.keyData.key.buffer, this.keyData.iv.buffer, e);\n      }, e.decryptAacSample = function (t, e, r, i) {\n        var a = t[e].unit,\n            n = a.subarray(16, a.length - a.length % 16),\n            s = n.buffer.slice(n.byteOffset, n.byteOffset + n.length),\n            o = this;\n        this.decryptBuffer(s, function (n) {\n          var s = new Uint8Array(n);\n          a.set(s, 16), i || o.decryptAacSamples(t, e + 1, r);\n        });\n      }, e.decryptAacSamples = function (t, e, r) {\n        for (;; e++) {\n          if (e >= t.length) return void r();\n\n          if (!(t[e].unit.length < 32)) {\n            var i = this.decrypter.isSync();\n            if (this.decryptAacSample(t, e, r, i), !i) return;\n          }\n        }\n      }, e.getAvcEncryptedData = function (t) {\n        for (var e = 16 * Math.floor((t.length - 48) / 160) + 16, r = new Int8Array(e), i = 0, a = 32; a < t.length - 16; a += 160, i += 16) r.set(t.subarray(a, a + 16), i);\n\n        return r;\n      }, e.getAvcDecryptedUnit = function (t, e) {\n        for (var r = new Uint8Array(e), i = 0, a = 32; a < t.length - 16; a += 160, i += 16) t.set(r.subarray(i, i + 16), a);\n\n        return t;\n      }, e.decryptAvcSample = function (t, e, r, i, a, n) {\n        var s = X(a.data),\n            o = this.getAvcEncryptedData(s),\n            l = this;\n        this.decryptBuffer(o.buffer, function (o) {\n          a.data = l.getAvcDecryptedUnit(s, o), n || l.decryptAvcSamples(t, e, r + 1, i);\n        });\n      }, e.decryptAvcSamples = function (t, e, r, i) {\n        if (t instanceof Uint8Array) throw new Error(\"Cannot decrypt samples of type Uint8Array\");\n\n        for (;; e++, r = 0) {\n          if (e >= t.length) return void i();\n\n          for (var a = t[e].units; !(r >= a.length); r++) {\n            var n = a[r];\n\n            if (!(n.data.length <= 48 || 1 !== n.type && 5 !== n.type)) {\n              var s = this.decrypter.isSync();\n              if (this.decryptAvcSample(t, e, r, i, n, s), !s) return;\n            }\n          }\n        }\n      }, t;\n    }(),\n        U = {\n      video: 1,\n      audio: 2,\n      id3: 3,\n      text: 4\n    },\n        G = function () {\n      function t(t, e, r) {\n        this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this.aacLastPTS = null, this._initPTS = null, this._initDTS = null, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.observer = t, this.config = e, this.typeSupported = r;\n      }\n\n      t.probe = function (e) {\n        var r = t.syncOffset(e);\n        return !(r < 0) && (r && c.b.warn(\"MPEG2-TS detected but first sync word found @ offset \" + r + \", junk ahead ?\"), !0);\n      }, t.syncOffset = function (t) {\n        for (var e = Math.min(1e3, t.length - 564), r = 0; r < e;) {\n          if (71 === t[r] && 71 === t[r + 188] && 71 === t[r + 376]) return r;\n          r++;\n        }\n\n        return -1;\n      }, t.createTrack = function (t, e) {\n        return {\n          container: \"video\" === t || \"audio\" === t ? \"video/mp2t\" : void 0,\n          type: t,\n          id: U[t],\n          pid: -1,\n          inputTimeScale: 9e4,\n          sequenceNumber: 0,\n          samples: [],\n          dropped: 0,\n          duration: \"audio\" === t ? e : void 0\n        };\n      };\n      var e = t.prototype;\n      return e.resetInitSegment = function (e, r, i) {\n        this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = t.createTrack(\"video\", i), this._audioTrack = t.createTrack(\"audio\", i), this._id3Track = t.createTrack(\"id3\", i), this._txtTrack = t.createTrack(\"text\", i), this._audioTrack.isAAC = !0, this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = e, this.videoCodec = r, this._duration = i;\n      }, e.resetTimeStamp = function () {}, e.resetContiguity = function () {\n        var t = this._audioTrack,\n            e = this._avcTrack,\n            r = this._id3Track;\n        t && (t.pesData = null), e && (e.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.aacLastPTS = null;\n      }, e.demux = function (e, r, n, s) {\n        var o;\n        void 0 === n && (n = !1), void 0 === s && (s = !1), n || (this.sampleAes = null);\n        var u = this._avcTrack,\n            d = this._audioTrack,\n            h = this._id3Track,\n            f = u.pid,\n            v = u.pesData,\n            g = d.pid,\n            p = h.pid,\n            m = d.pesData,\n            y = h.pesData,\n            b = !1,\n            T = this.pmtParsed,\n            E = this._pmtId,\n            S = e.length;\n        if (this.remainderData && (S = (e = Object(l.a)(this.remainderData, e)).length, this.remainderData = null), S < 188 && !s) return this.remainderData = e, {\n          audioTrack: d,\n          avcTrack: u,\n          id3Track: h,\n          textTrack: this._txtTrack\n        };\n        var L = Math.max(0, t.syncOffset(e));\n        (S -= (S + L) % 188) < e.byteLength && !s && (this.remainderData = new Uint8Array(e.buffer, S, e.buffer.byteLength - S));\n\n        for (var A = 0, R = L; R < S; R += 188) if (71 === e[R]) {\n          var D = !!(64 & e[R + 1]),\n              _ = ((31 & e[R + 1]) << 8) + e[R + 2],\n              k = void 0;\n\n          if ((48 & e[R + 3]) >> 4 > 1) {\n            if ((k = R + 5 + e[R + 4]) === R + 188) continue;\n          } else k = R + 4;\n\n          switch (_) {\n            case f:\n              D && (v && (o = V(v)) && this.parseAVCPES(o, !1), v = {\n                data: [],\n                size: 0\n              }), v && (v.data.push(e.subarray(k, R + 188)), v.size += R + 188 - k);\n              break;\n\n            case g:\n              D && (m && (o = V(m)) && (d.isAAC ? this.parseAACPES(o) : this.parseMPEGPES(o)), m = {\n                data: [],\n                size: 0\n              }), m && (m.data.push(e.subarray(k, R + 188)), m.size += R + 188 - k);\n              break;\n\n            case p:\n              D && (y && (o = V(y)) && this.parseID3PES(o), y = {\n                data: [],\n                size: 0\n              }), y && (y.data.push(e.subarray(k, R + 188)), y.size += R + 188 - k);\n              break;\n\n            case 0:\n              D && (k += e[k] + 1), E = this._pmtId = H(e, k);\n              break;\n\n            case E:\n              D && (k += e[k] + 1);\n              var x = K(e, k, !0 === this.typeSupported.mpeg || !0 === this.typeSupported.mp3, n);\n              (f = x.avc) > 0 && (u.pid = f), (g = x.audio) > 0 && (d.pid = g, d.isAAC = x.isAAC), (p = x.id3) > 0 && (h.pid = p), b && !T && (c.b.log(\"reparse from beginning\"), b = !1, R = L - 188), T = this.pmtParsed = !0;\n              break;\n\n            case 17:\n            case 8191:\n              break;\n\n            default:\n              b = !0;\n          }\n        } else A++;\n\n        A > 0 && this.observer.emit(i.a.ERROR, i.a.ERROR, {\n          type: a.b.MEDIA_ERROR,\n          details: a.a.FRAG_PARSING_ERROR,\n          fatal: !1,\n          reason: \"Found \" + A + \" TS packet/s that do not start with 0x47\"\n        }), u.pesData = v, d.pesData = m, h.pesData = y;\n        var C = {\n          audioTrack: d,\n          avcTrack: u,\n          id3Track: h,\n          textTrack: this._txtTrack\n        };\n        return s && this.extractRemainingSamples(C), C;\n      }, e.flush = function () {\n        var t,\n            e = this.remainderData;\n        return this.remainderData = null, t = e ? this.demux(e, -1, !1, !0) : {\n          audioTrack: this._audioTrack,\n          avcTrack: this._avcTrack,\n          textTrack: this._txtTrack,\n          id3Track: this._id3Track\n        }, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t;\n      }, e.extractRemainingSamples = function (t) {\n        var e,\n            r = t.audioTrack,\n            i = t.avcTrack,\n            a = t.id3Track,\n            n = i.pesData,\n            s = r.pesData,\n            o = a.pesData;\n        n && (e = V(n)) ? (this.parseAVCPES(e, !0), i.pesData = null) : i.pesData = n, s && (e = V(s)) ? (r.isAAC ? this.parseAACPES(e) : this.parseMPEGPES(e), r.pesData = null) : (null != s && s.size && c.b.log(\"last AAC PES packet truncated,might overlap between fragments\"), r.pesData = s), o && (e = V(o)) ? (this.parseID3PES(e), a.pesData = null) : a.pesData = o;\n      }, e.demuxSampleAes = function (t, e, r) {\n        var i = this.demux(t, r, !0, !this.config.progressive),\n            a = this.sampleAes = new B(this.observer, this.config, e);\n        return this.decrypt(i, a);\n      }, e.decrypt = function (t, e) {\n        return new Promise(function (r) {\n          var i = t.audioTrack,\n              a = t.avcTrack;\n          i.samples && i.isAAC ? e.decryptAacSamples(i.samples, 0, function () {\n            a.samples ? e.decryptAvcSamples(a.samples, 0, 0, function () {\n              r(t);\n            }) : r(t);\n          }) : a.samples && e.decryptAvcSamples(a.samples, 0, 0, function () {\n            r(t);\n          });\n        });\n      }, e.destroy = function () {\n        this._initPTS = this._initDTS = null, this._duration = 0;\n      }, e.parseAVCPES = function (t, e) {\n        var r,\n            i = this,\n            a = this._avcTrack,\n            n = this.parseAVCNALu(t.data),\n            s = this.avcSample,\n            l = !1;\n        t.data = null, s && n.length && !a.audFound && (W(s, a), s = this.avcSample = j(!1, t.pts, t.dts, \"\")), n.forEach(function (e) {\n          switch (e.type) {\n            case 1:\n              r = !0, s || (s = i.avcSample = j(!0, t.pts, t.dts, \"\")), s.frame = !0;\n              var n = e.data;\n\n              if (l && n.length > 4) {\n                var u = new N(n).readSliceType();\n                2 !== u && 4 !== u && 7 !== u && 9 !== u || (s.key = !0);\n              }\n\n              break;\n\n            case 5:\n              r = !0, s || (s = i.avcSample = j(!0, t.pts, t.dts, \"\")), s.key = !0, s.frame = !0;\n              break;\n\n            case 6:\n              r = !0;\n              var d = new N(X(e.data));\n              d.readUByte();\n\n              for (var h = 0, f = 0, c = !1, v = 0; !c && d.bytesAvailable > 1;) {\n                h = 0;\n\n                do {\n                  h += v = d.readUByte();\n                } while (255 === v);\n\n                f = 0;\n\n                do {\n                  f += v = d.readUByte();\n                } while (255 === v);\n\n                if (4 === h && 0 !== d.bytesAvailable) {\n                  if (c = !0, 181 === d.readUByte()) if (49 === d.readUShort()) if (1195456820 === d.readUInt()) if (3 === d.readUByte()) {\n                    for (var g = d.readUByte(), p = 31 & g, m = [g, d.readUByte()], y = 0; y < p; y++) m.push(d.readUByte()), m.push(d.readUByte()), m.push(d.readUByte());\n\n                    Y(i._txtTrack.samples, {\n                      type: 3,\n                      pts: t.pts,\n                      bytes: m\n                    });\n                  }\n                } else if (5 === h && 0 !== d.bytesAvailable) {\n                  if (c = !0, f > 16) {\n                    for (var b = [], T = 0; T < 16; T++) b.push(d.readUByte().toString(16)), 3 !== T && 5 !== T && 7 !== T && 9 !== T || b.push(\"-\");\n\n                    for (var E = f - 16, S = new Uint8Array(E), L = 0; L < E; L++) S[L] = d.readUByte();\n\n                    Y(i._txtTrack.samples, {\n                      pts: t.pts,\n                      payloadType: h,\n                      uuid: b.join(\"\"),\n                      userData: Object(o.f)(S),\n                      userDataBytes: S\n                    });\n                  }\n                } else if (f < d.bytesAvailable) for (var A = 0; A < f; A++) d.readUByte();\n              }\n\n              break;\n\n            case 7:\n              if (r = !0, l = !0, !a.sps) {\n                var R = new N(e.data).readSPS();\n                a.width = R.width, a.height = R.height, a.pixelRatio = R.pixelRatio, a.sps = [e.data], a.duration = i._duration;\n\n                for (var D = e.data.subarray(1, 4), _ = \"avc1.\", k = 0; k < 3; k++) {\n                  var x = D[k].toString(16);\n                  x.length < 2 && (x = \"0\" + x), _ += x;\n                }\n\n                a.codec = _;\n              }\n\n              break;\n\n            case 8:\n              r = !0, a.pps || (a.pps = [e.data]);\n              break;\n\n            case 9:\n              r = !1, a.audFound = !0, s && W(s, a), s = i.avcSample = j(!1, t.pts, t.dts, \"\");\n              break;\n\n            case 12:\n              r = !1;\n              break;\n\n            default:\n              r = !1, s && (s.debug += \"unknown NAL \" + e.type + \" \");\n          }\n\n          s && r && s.units.push(e);\n        }), e && s && (W(s, a), this.avcSample = null);\n      }, e.getLastNalUnit = function () {\n        var t,\n            e,\n            r = this.avcSample;\n\n        if (!r || 0 === r.units.length) {\n          var i = this._avcTrack.samples;\n          r = i[i.length - 1];\n        }\n\n        if (null !== (t = r) && void 0 !== t && t.units) {\n          var a = r.units;\n          e = a[a.length - 1];\n        }\n\n        return e;\n      }, e.parseAVCNALu = function (t) {\n        var e,\n            r,\n            i = t.byteLength,\n            a = this._avcTrack,\n            n = a.naluState || 0,\n            s = n,\n            o = [],\n            l = 0,\n            u = -1,\n            d = 0;\n\n        for (-1 === n && (u = 0, d = 31 & t[0], n = 0, l = 1); l < i;) if (e = t[l++], n) {\n          if (1 !== n) {\n            if (e) {\n              if (1 === e) {\n                if (u >= 0) {\n                  var h = {\n                    data: t.subarray(u, l - n - 1),\n                    type: d\n                  };\n                  o.push(h);\n                } else {\n                  var f = this.getLastNalUnit();\n\n                  if (f && (s && l <= 4 - s && f.state && (f.data = f.data.subarray(0, f.data.byteLength - s)), (r = l - n - 1) > 0)) {\n                    var c = new Uint8Array(f.data.byteLength + r);\n                    c.set(f.data, 0), c.set(t.subarray(0, r), f.data.byteLength), f.data = c, f.state = 0;\n                  }\n                }\n\n                l < i ? (u = l, d = 31 & t[l], n = 0) : n = -1;\n              } else n = 0;\n            } else n = 3;\n          } else n = e ? 0 : 2;\n        } else n = e ? 0 : 1;\n\n        if (u >= 0 && n >= 0) {\n          var v = {\n            data: t.subarray(u, i),\n            type: d,\n            state: n\n          };\n          o.push(v);\n        }\n\n        if (0 === o.length) {\n          var g = this.getLastNalUnit();\n\n          if (g) {\n            var p = new Uint8Array(g.data.byteLength + t.byteLength);\n            p.set(g.data, 0), p.set(t, g.data.byteLength), g.data = p;\n          }\n        }\n\n        return a.naluState = n, o;\n      }, e.parseAACPES = function (t) {\n        var e,\n            r,\n            n,\n            s,\n            o,\n            l = 0,\n            u = this._audioTrack,\n            d = this.aacOverFlow,\n            h = t.data;\n\n        if (d) {\n          this.aacOverFlow = null;\n          var f = d.sample.unit.byteLength,\n              v = Math.min(d.missing, f),\n              g = f - v;\n          d.sample.unit.set(h.subarray(0, v), g), u.samples.push(d.sample), l = d.missing;\n        }\n\n        for (e = l, r = h.length; e < r - 1 && !m(h, e); e++);\n\n        if (e !== l && (e < r - 1 ? (n = \"AAC PES did not start with ADTS header,offset:\" + e, s = !1) : (n = \"no ADTS header found in AAC PES\", s = !0), c.b.warn(\"parsing error:\" + n), this.observer.emit(i.a.ERROR, i.a.ERROR, {\n          type: a.b.MEDIA_ERROR,\n          details: a.a.FRAG_PARSING_ERROR,\n          fatal: s,\n          reason: n\n        }), s)) return;\n        if (b(u, this.observer, h, e, this.audioCodec), void 0 !== t.pts) o = t.pts;else {\n          if (!d) return void c.b.warn(\"[tsdemuxer]: AAC PES unknown PTS\");\n          var p = T(u.samplerate);\n          o = d.sample.pts + p;\n        }\n\n        for (var y = 0; e < r;) {\n          if (m(h, e)) {\n            if (e + 5 < r) {\n              var S = E(u, h, e, o, y);\n\n              if (S) {\n                if (!S.missing) {\n                  e += S.length, y++;\n                  continue;\n                }\n\n                this.aacOverFlow = S;\n              }\n            }\n\n            break;\n          }\n\n          e++;\n        }\n      }, e.parseMPEGPES = function (t) {\n        var e = t.data,\n            r = e.length,\n            i = 0,\n            a = 0,\n            n = t.pts;\n        if (void 0 !== n) {\n          for (; a < r;) if (F(e, a)) {\n            var s = O(this._audioTrack, e, a, n, i);\n            if (!s) break;\n            a += s.length, i++;\n          } else a++;\n        } else c.b.warn(\"[tsdemuxer]: MPEG PES unknown PTS\");\n      }, e.parseID3PES = function (t) {\n        void 0 !== t.pts ? this._id3Track.samples.push(t) : c.b.warn(\"[tsdemuxer]: ID3 PES unknown PTS\");\n      }, t;\n    }();\n\n    function j(t, e, r, i) {\n      return {\n        key: t,\n        frame: !1,\n        pts: e,\n        dts: r,\n        units: [],\n        debug: i,\n        length: 0\n      };\n    }\n\n    function H(t, e) {\n      return (31 & t[e + 10]) << 8 | t[e + 11];\n    }\n\n    function K(t, e, r, i) {\n      var a = {\n        audio: -1,\n        avc: -1,\n        id3: -1,\n        isAAC: !0\n      },\n          n = e + 3 + ((15 & t[e + 1]) << 8 | t[e + 2]) - 4;\n\n      for (e += 12 + ((15 & t[e + 10]) << 8 | t[e + 11]); e < n;) {\n        var s = (31 & t[e + 1]) << 8 | t[e + 2];\n\n        switch (t[e]) {\n          case 207:\n            if (!i) {\n              c.b.log(\"ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream\");\n              break;\n            }\n\n          case 15:\n            -1 === a.audio && (a.audio = s);\n            break;\n\n          case 21:\n            -1 === a.id3 && (a.id3 = s);\n            break;\n\n          case 219:\n            if (!i) {\n              c.b.log(\"H.264 with AES-128-CBC slice encryption found in unencrypted stream\");\n              break;\n            }\n\n          case 27:\n            -1 === a.avc && (a.avc = s);\n            break;\n\n          case 3:\n          case 4:\n            r ? -1 === a.audio && (a.audio = s, a.isAAC = !1) : c.b.log(\"MPEG audio found, not supported in this browser\");\n            break;\n\n          case 36:\n            c.b.warn(\"Unsupported HEVC stream type found\");\n        }\n\n        e += 5 + ((15 & t[e + 3]) << 8 | t[e + 4]);\n      }\n\n      return a;\n    }\n\n    function V(t) {\n      var e,\n          r,\n          i,\n          a,\n          n,\n          s = 0,\n          o = t.data;\n      if (!t || 0 === t.size) return null;\n\n      for (; o[0].length < 19 && o.length > 1;) {\n        var l = new Uint8Array(o[0].length + o[1].length);\n        l.set(o[0]), l.set(o[1], o[0].length), o[0] = l, o.splice(1, 1);\n      }\n\n      if (1 === ((e = o[0])[0] << 16) + (e[1] << 8) + e[2]) {\n        if ((r = (e[4] << 8) + e[5]) && r > t.size - 6) return null;\n        var u = e[7];\n        192 & u && (a = 536870912 * (14 & e[9]) + 4194304 * (255 & e[10]) + 16384 * (254 & e[11]) + 128 * (255 & e[12]) + (254 & e[13]) / 2, 64 & u ? a - (n = 536870912 * (14 & e[14]) + 4194304 * (255 & e[15]) + 16384 * (254 & e[16]) + 128 * (255 & e[17]) + (254 & e[18]) / 2) > 54e5 && (c.b.warn(Math.round((a - n) / 9e4) + \"s delta between PTS and DTS, align them\"), a = n) : n = a);\n        var d = (i = e[8]) + 9;\n        if (t.size <= d) return null;\n        t.size -= d;\n\n        for (var h = new Uint8Array(t.size), f = 0, v = o.length; f < v; f++) {\n          var g = (e = o[f]).byteLength;\n\n          if (d) {\n            if (d > g) {\n              d -= g;\n              continue;\n            }\n\n            e = e.subarray(d), g -= d, d = 0;\n          }\n\n          h.set(e, s), s += g;\n        }\n\n        return r && (r -= i + 3), {\n          data: h,\n          pts: a,\n          dts: n,\n          len: r\n        };\n      }\n\n      return null;\n    }\n\n    function W(t, e) {\n      if (t.units.length && t.frame) {\n        if (void 0 === t.pts) {\n          var r = e.samples,\n              i = r.length;\n          if (!i) return void e.dropped++;\n          var a = r[i - 1];\n          t.pts = a.pts, t.dts = a.dts;\n        }\n\n        e.samples.push(t);\n      }\n\n      t.debug.length && c.b.log(t.pts + \"/\" + t.dts + \":\" + t.debug);\n    }\n\n    function Y(t, e) {\n      var r = t.length;\n\n      if (r > 0) {\n        if (e.pts >= t[r - 1].pts) t.push(e);else for (var i = r - 1; i >= 0; i--) if (e.pts < t[i].pts) {\n          t.splice(i, 0, e);\n          break;\n        }\n      } else t.push(e);\n    }\n\n    function X(t) {\n      for (var e = t.byteLength, r = [], i = 1; i < e - 2;) 0 === t[i] && 0 === t[i + 1] && 3 === t[i + 2] ? (r.push(i + 2), i += 2) : i++;\n\n      if (0 === r.length) return t;\n      var a = e - r.length,\n          n = new Uint8Array(a),\n          s = 0;\n\n      for (i = 0; i < a; s++, i++) s === r[0] && (s++, r.shift()), n[i] = t[s];\n\n      return n;\n    }\n\n    G.minProbeByteLength = 188;\n    var q = G;\n\n    function z(t, e) {\n      return (z = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    var Q = function (t) {\n      var e, r;\n\n      function i() {\n        return t.apply(this, arguments) || this;\n      }\n\n      r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, z(e, r);\n      var a = i.prototype;\n      return a.resetInitSegment = function (e, r, i) {\n        t.prototype.resetInitSegment.call(this, e, r, i), this._audioTrack = {\n          container: \"audio/mpeg\",\n          type: \"audio\",\n          id: 2,\n          pid: -1,\n          sequenceNumber: 0,\n          isAAC: !1,\n          samples: [],\n          manifestCodec: e,\n          duration: i,\n          inputTimeScale: 9e4,\n          dropped: 0\n        };\n      }, i.probe = function (t) {\n        if (!t) return !1;\n\n        for (var e = (o.b(t, 0) || []).length, r = t.length; e < r; e++) if (M(t, e)) return c.b.log(\"MPEG Audio sync word found !\"), !0;\n\n        return !1;\n      }, a.canParse = function (t, e) {\n        return function (t, e) {\n          return P(t, e) && 4 <= t.length - e;\n        }(t, e);\n      }, a.appendFrame = function (t, e, r) {\n        if (null !== this.initPTS) return O(t, e, r, this.initPTS, this.frameIndex);\n      }, i;\n    }(f);\n\n    Q.minProbeByteLength = 4;\n\n    var $ = Q,\n        Z = function () {\n      function t() {}\n\n      return t.getSilentFrame = function (t, e) {\n        switch (t) {\n          case \"mp4a.40.2\":\n            if (1 === e) return new Uint8Array([0, 200, 0, 128, 35, 128]);\n            if (2 === e) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);\n            if (3 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);\n            if (4 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);\n            if (5 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);\n            if (6 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);\n            break;\n\n          default:\n            if (1 === e) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n            if (2 === e) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n            if (3 === e) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n        }\n      }, t;\n    }(),\n        J = Math.pow(2, 32) - 1,\n        tt = function () {\n      function t() {}\n\n      return t.init = function () {\n        var e;\n\n        for (e in t.types = {\n          avc1: [],\n          avcC: [],\n          btrt: [],\n          dinf: [],\n          dref: [],\n          esds: [],\n          ftyp: [],\n          hdlr: [],\n          mdat: [],\n          mdhd: [],\n          mdia: [],\n          mfhd: [],\n          minf: [],\n          moof: [],\n          moov: [],\n          mp4a: [],\n          \".mp3\": [],\n          mvex: [],\n          mvhd: [],\n          pasp: [],\n          sdtp: [],\n          stbl: [],\n          stco: [],\n          stsc: [],\n          stsd: [],\n          stsz: [],\n          stts: [],\n          tfdt: [],\n          tfhd: [],\n          traf: [],\n          trak: [],\n          trun: [],\n          trex: [],\n          tkhd: [],\n          vmhd: [],\n          smhd: []\n        }, t.types) t.types.hasOwnProperty(e) && (t.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);\n\n        var r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),\n            i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);\n        t.HDLR_TYPES = {\n          video: r,\n          audio: i\n        };\n        var a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),\n            n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);\n        t.STTS = t.STSC = t.STCO = n, t.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), t.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), t.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), t.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);\n        var s = new Uint8Array([105, 115, 111, 109]),\n            o = new Uint8Array([97, 118, 99, 49]),\n            l = new Uint8Array([0, 0, 0, 1]);\n        t.FTYP = t.box(t.types.ftyp, s, l, s, o), t.DINF = t.box(t.types.dinf, t.box(t.types.dref, a));\n      }, t.box = function (t) {\n        for (var e = 8, r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++) i[a - 1] = arguments[a];\n\n        for (var n = i.length, s = n; n--;) e += i[n].byteLength;\n\n        var o = new Uint8Array(e);\n\n        for (o[0] = e >> 24 & 255, o[1] = e >> 16 & 255, o[2] = e >> 8 & 255, o[3] = 255 & e, o.set(t, 4), n = 0, e = 8; n < s; n++) o.set(i[n], e), e += i[n].byteLength;\n\n        return o;\n      }, t.hdlr = function (e) {\n        return t.box(t.types.hdlr, t.HDLR_TYPES[e]);\n      }, t.mdat = function (e) {\n        return t.box(t.types.mdat, e);\n      }, t.mdhd = function (e, r) {\n        r *= e;\n        var i = Math.floor(r / (J + 1)),\n            a = Math.floor(r % (J + 1));\n        return t.box(t.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 85, 196, 0, 0]));\n      }, t.mdia = function (e) {\n        return t.box(t.types.mdia, t.mdhd(e.timescale, e.duration), t.hdlr(e.type), t.minf(e));\n      }, t.mfhd = function (e) {\n        return t.box(t.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e]));\n      }, t.minf = function (e) {\n        return \"audio\" === e.type ? t.box(t.types.minf, t.box(t.types.smhd, t.SMHD), t.DINF, t.stbl(e)) : t.box(t.types.minf, t.box(t.types.vmhd, t.VMHD), t.DINF, t.stbl(e));\n      }, t.moof = function (e, r, i) {\n        return t.box(t.types.moof, t.mfhd(e), t.traf(i, r));\n      }, t.moov = function (e) {\n        for (var r = e.length, i = []; r--;) i[r] = t.trak(e[r]);\n\n        return t.box.apply(null, [t.types.moov, t.mvhd(e[0].timescale, e[0].duration)].concat(i).concat(t.mvex(e)));\n      }, t.mvex = function (e) {\n        for (var r = e.length, i = []; r--;) i[r] = t.trex(e[r]);\n\n        return t.box.apply(null, [t.types.mvex].concat(i));\n      }, t.mvhd = function (e, r) {\n        r *= e;\n        var i = Math.floor(r / (J + 1)),\n            a = Math.floor(r % (J + 1)),\n            n = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);\n        return t.box(t.types.mvhd, n);\n      }, t.sdtp = function (e) {\n        var r,\n            i,\n            a = e.samples || [],\n            n = new Uint8Array(4 + a.length);\n\n        for (r = 0; r < a.length; r++) i = a[r].flags, n[r + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy;\n\n        return t.box(t.types.sdtp, n);\n      }, t.stbl = function (e) {\n        return t.box(t.types.stbl, t.stsd(e), t.box(t.types.stts, t.STTS), t.box(t.types.stsc, t.STSC), t.box(t.types.stsz, t.STSZ), t.box(t.types.stco, t.STCO));\n      }, t.avc1 = function (e) {\n        var r,\n            i,\n            a,\n            n = [],\n            s = [];\n\n        for (r = 0; r < e.sps.length; r++) a = (i = e.sps[r]).byteLength, n.push(a >>> 8 & 255), n.push(255 & a), n = n.concat(Array.prototype.slice.call(i));\n\n        for (r = 0; r < e.pps.length; r++) a = (i = e.pps[r]).byteLength, s.push(a >>> 8 & 255), s.push(255 & a), s = s.concat(Array.prototype.slice.call(i));\n\n        var o = t.box(t.types.avcC, new Uint8Array([1, n[3], n[4], n[5], 255, 224 | e.sps.length].concat(n).concat([e.pps.length]).concat(s))),\n            l = e.width,\n            u = e.height,\n            d = e.pixelRatio[0],\n            h = e.pixelRatio[1];\n        return t.box(t.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, u >> 8 & 255, 255 & u, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, t.box(t.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), t.box(t.types.pasp, new Uint8Array([d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d, h >> 24, h >> 16 & 255, h >> 8 & 255, 255 & h])));\n      }, t.esds = function (t) {\n        var e = t.config.length;\n        return new Uint8Array([0, 0, 0, 0, 3, 23 + e, 0, 1, 0, 4, 15 + e, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([e]).concat(t.config).concat([6, 1, 2]));\n      }, t.mp4a = function (e) {\n        var r = e.samplerate;\n        return t.box(t.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]), t.box(t.types.esds, t.esds(e)));\n      }, t.mp3 = function (e) {\n        var r = e.samplerate;\n        return t.box(t.types[\".mp3\"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]));\n      }, t.stsd = function (e) {\n        return \"audio\" === e.type ? e.isAAC || \"mp3\" !== e.codec ? t.box(t.types.stsd, t.STSD, t.mp4a(e)) : t.box(t.types.stsd, t.STSD, t.mp3(e)) : t.box(t.types.stsd, t.STSD, t.avc1(e));\n      }, t.tkhd = function (e) {\n        var r = e.id,\n            i = e.duration * e.timescale,\n            a = e.width,\n            n = e.height,\n            s = Math.floor(i / (J + 1)),\n            o = Math.floor(i % (J + 1));\n        return t.box(t.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, a >> 8 & 255, 255 & a, 0, 0, n >> 8 & 255, 255 & n, 0, 0]));\n      }, t.traf = function (e, r) {\n        var i = t.sdtp(e),\n            a = e.id,\n            n = Math.floor(r / (J + 1)),\n            s = Math.floor(r % (J + 1));\n        return t.box(t.types.traf, t.box(t.types.tfhd, new Uint8Array([0, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a])), t.box(t.types.tfdt, new Uint8Array([1, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s])), t.trun(e, i.length + 16 + 20 + 8 + 16 + 8 + 8), i);\n      }, t.trak = function (e) {\n        return e.duration = e.duration || 4294967295, t.box(t.types.trak, t.tkhd(e), t.mdia(e));\n      }, t.trex = function (e) {\n        var r = e.id;\n        return t.box(t.types.trex, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]));\n      }, t.trun = function (e, r) {\n        var i,\n            a,\n            n,\n            s,\n            o,\n            l,\n            u = e.samples || [],\n            d = u.length,\n            h = 12 + 16 * d,\n            f = new Uint8Array(h);\n\n        for (r += 8 + h, f.set([0, 0, 15, 1, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r], 0), i = 0; i < d; i++) n = (a = u[i]).duration, s = a.size, o = a.flags, l = a.cts, f.set([n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, o.isLeading << 2 | o.dependsOn, o.isDependedOn << 6 | o.hasRedundancy << 4 | o.paddingValue << 1 | o.isNonSync, 61440 & o.degradPrio, 15 & o.degradPrio, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l], 12 + 16 * i);\n\n        return t.box(t.types.trun, f);\n      }, t.initSegment = function (e) {\n        t.types || t.init();\n        var r = t.moov(e),\n            i = new Uint8Array(t.FTYP.byteLength + r.byteLength);\n        return i.set(t.FTYP), i.set(r, t.FTYP.byteLength), i;\n      }, t;\n    }();\n\n    tt.types = void 0, tt.HDLR_TYPES = void 0, tt.STTS = void 0, tt.STSC = void 0, tt.STCO = void 0, tt.STSZ = void 0, tt.VMHD = void 0, tt.SMHD = void 0, tt.STSD = void 0, tt.FTYP = void 0, tt.DINF = void 0;\n    var et = tt,\n        rt = r(4);\n\n    function it(t, e, r, i) {\n      void 0 === r && (r = 1), void 0 === i && (i = !1);\n      var a = t * e * r;\n      return i ? Math.round(a) : a;\n    }\n\n    function at(t, e) {\n      return void 0 === e && (e = !1), it(t, 1e3, 1 / 9e4, e);\n    }\n\n    function nt() {\n      return (nt = Object.assign || function (t) {\n        for (var e = 1; e < arguments.length; e++) {\n          var r = arguments[e];\n\n          for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);\n        }\n\n        return t;\n      }).apply(this, arguments);\n    }\n\n    var st = null,\n        ot = null,\n        lt = !1,\n        ut = function () {\n      function t(t, e, r, i) {\n        if (void 0 === i && (i = \"\"), this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = void 0, this._initDTS = void 0, this.nextAvcDts = null, this.nextAudioPts = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.observer = t, this.config = e, this.typeSupported = r, this.ISGenerated = !1, null === st) {\n          var a = (navigator.userAgent || \"\").match(/Chrome\\/(\\d+)/i);\n          st = a ? parseInt(a[1]) : 0;\n        }\n\n        if (null === ot) {\n          var n = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n          ot = n ? parseInt(n[1]) : 0;\n        }\n\n        lt = !!st && st < 75 || !!ot && ot < 600;\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {}, e.resetTimeStamp = function (t) {\n        c.b.log(\"[mp4-remuxer]: initPTS & initDTS reset\"), this._initPTS = this._initDTS = t;\n      }, e.resetNextTimestamp = function () {\n        c.b.log(\"[mp4-remuxer]: reset next timestamp\"), this.isVideoContiguous = !1, this.isAudioContiguous = !1;\n      }, e.resetInitSegment = function () {\n        c.b.log(\"[mp4-remuxer]: ISGenerated flag reset\"), this.ISGenerated = !1;\n      }, e.getVideoStartPts = function (t) {\n        var e = !1,\n            r = t.reduce(function (t, r) {\n          var i = r.pts - t;\n          return i < -4294967296 ? (e = !0, dt(t, r.pts)) : i > 0 ? t : r.pts;\n        }, t[0].pts);\n        return e && c.b.debug(\"PTS rollover detected\"), r;\n      }, e.remux = function (t, e, r, i, a, n, s, o) {\n        var l,\n            u,\n            d,\n            h,\n            f,\n            v,\n            g = a,\n            p = a,\n            m = t.pid > -1,\n            y = e.pid > -1,\n            b = e.samples.length,\n            T = t.samples.length > 0,\n            E = b > 1;\n\n        if ((!m || T) && (!y || E) || this.ISGenerated || s) {\n          this.ISGenerated || (d = this.generateIS(t, e, a));\n          var S = this.isVideoContiguous,\n              L = -1;\n          if (E && (L = function (t) {\n            for (var e = 0; e < t.length; e++) if (t[e].key) return e;\n\n            return -1;\n          }(e.samples), !S && this.config.forceKeyFrameOnDiscontinuity)) if (v = !0, L > 0) {\n            c.b.warn(\"[mp4-remuxer]: Dropped \" + L + \" out of \" + b + \" video samples due to a missing keyframe\");\n            var A = this.getVideoStartPts(e.samples);\n            e.samples = e.samples.slice(L), e.dropped += L, p += (e.samples[0].pts - A) / (e.timescale || 9e4);\n          } else -1 === L && (c.b.warn(\"[mp4-remuxer]: No keyframe found out of \" + b + \" video samples\"), v = !1);\n\n          if (this.ISGenerated) {\n            if (T && E) {\n              var R = this.getVideoStartPts(e.samples),\n                  D = (dt(t.samples[0].pts, R) - R) / e.inputTimeScale;\n              g += Math.max(0, D), p += Math.max(0, -D);\n            }\n\n            if (T) {\n              if (t.samplerate || (c.b.warn(\"[mp4-remuxer]: regenerate InitSegment as audio detected\"), d = this.generateIS(t, e, a)), u = this.remuxAudio(t, g, this.isAudioContiguous, n, y || E || o === rt.b.AUDIO ? p : void 0), E) {\n                var _ = u ? u.endPTS - u.startPTS : 0;\n\n                e.inputTimeScale || (c.b.warn(\"[mp4-remuxer]: regenerate InitSegment as video detected\"), d = this.generateIS(t, e, a)), l = this.remuxVideo(e, p, S, _);\n              }\n            } else E && (l = this.remuxVideo(e, p, S, 0));\n\n            l && (l.firstKeyFrame = L, l.independent = -1 !== L);\n          }\n        }\n\n        return this.ISGenerated && (r.samples.length && (f = this.remuxID3(r, a)), i.samples.length && (h = this.remuxText(i, a))), {\n          audio: u,\n          video: l,\n          initSegment: d,\n          independent: v,\n          text: h,\n          id3: f\n        };\n      }, e.generateIS = function (t, e, r) {\n        var i,\n            a,\n            n,\n            o = t.samples,\n            l = e.samples,\n            u = this.typeSupported,\n            d = {},\n            h = !Object(s.a)(this._initPTS),\n            f = \"audio/mp4\";\n\n        if (h && (i = a = 1 / 0), t.config && o.length && (t.timescale = t.samplerate, t.isAAC || (u.mpeg ? (f = \"audio/mpeg\", t.codec = \"\") : u.mp3 && (t.codec = \"mp3\")), d.audio = {\n          id: \"audio\",\n          container: f,\n          codec: t.codec,\n          initSegment: !t.isAAC && u.mpeg ? new Uint8Array(0) : et.initSegment([t]),\n          metadata: {\n            channelCount: t.channelCount\n          }\n        }, h && (n = t.inputTimeScale, i = a = o[0].pts - Math.round(n * r))), e.sps && e.pps && l.length && (e.timescale = e.inputTimeScale, d.video = {\n          id: \"main\",\n          container: \"video/mp4\",\n          codec: e.codec,\n          initSegment: et.initSegment([e]),\n          metadata: {\n            width: e.width,\n            height: e.height\n          }\n        }, h)) {\n          n = e.inputTimeScale;\n          var c = this.getVideoStartPts(l),\n              v = Math.round(n * r);\n          a = Math.min(a, dt(l[0].dts, c) - v), i = Math.min(i, c - v);\n        }\n\n        if (Object.keys(d).length) return this.ISGenerated = !0, h && (this._initPTS = i, this._initDTS = a), {\n          tracks: d,\n          initPTS: i,\n          timescale: n\n        };\n      }, e.remuxVideo = function (t, e, r, n) {\n        var s,\n            o,\n            l,\n            u = t.inputTimeScale,\n            d = t.samples,\n            h = [],\n            f = d.length,\n            v = this._initPTS,\n            g = this.nextAvcDts,\n            p = 8,\n            m = Number.POSITIVE_INFINITY,\n            y = Number.NEGATIVE_INFINITY,\n            b = 0,\n            T = !1;\n        r && null !== g || (g = e * u - (d[0].pts - dt(d[0].dts, d[0].pts)));\n\n        for (var E = 0; E < f; E++) {\n          var S = d[E];\n\n          if (S.pts = dt(S.pts - v, g), S.dts = dt(S.dts - v, g), S.dts > S.pts) {\n            b = Math.max(Math.min(b, S.pts - S.dts), -18e3);\n          }\n\n          S.dts < d[E > 0 ? E - 1 : E].dts && (T = !0);\n        }\n\n        T && d.sort(function (t, e) {\n          var r = t.dts - e.dts,\n              i = t.pts - e.pts;\n          return r || i;\n        }), o = d[0].dts, l = d[d.length - 1].dts;\n        var L = Math.round((l - o) / (f - 1));\n\n        if (b < 0) {\n          if (b < -2 * L) {\n            c.b.warn(\"PTS < DTS detected in video samples, offsetting DTS from PTS by \" + at(-L, !0) + \" ms\");\n\n            for (var A = b, R = 0; R < f; R++) d[R].dts = A = Math.max(A, d[R].pts - L), d[R].pts = Math.max(A, d[R].pts);\n          } else {\n            c.b.warn(\"PTS < DTS detected in video samples, shifting DTS by \" + at(b, !0) + \" ms to overcome this issue\");\n\n            for (var D = 0; D < f; D++) d[D].dts = d[D].dts + b;\n          }\n\n          o = d[0].dts;\n        }\n\n        if (r) {\n          var _ = o - g,\n              k = _ > L;\n\n          if (k || _ < -1) {\n            k ? c.b.warn(\"AVC: \" + at(_, !0) + \" ms (\" + _ + \"dts) hole between fragments detected, filling it\") : c.b.warn(\"AVC: \" + at(-_, !0) + \" ms (\" + _ + \"dts) overlapping between fragments detected\"), o = g;\n            var x = d[0].pts - _;\n            d[0].dts = o, d[0].pts = x, c.b.log(\"Video: First PTS/DTS adjusted: \" + at(x, !0) + \"/\" + at(o, !0) + \", delta: \" + at(_, !0) + \" ms\");\n          }\n        }\n\n        lt && (o = Math.max(0, o));\n\n        for (var C = 0, w = 0, O = 0; O < f; O++) {\n          for (var I = d[O], P = I.units, F = P.length, M = 0, N = 0; N < F; N++) M += P[N].data.length;\n\n          w += M, C += F, I.length = M, I.dts = Math.max(I.dts, o), I.pts = Math.max(I.pts, I.dts, 0), m = Math.min(I.pts, m), y = Math.max(I.pts, y);\n        }\n\n        l = d[f - 1].dts;\n        var B,\n            U = w + 4 * C + 8;\n\n        try {\n          B = new Uint8Array(U);\n        } catch (t) {\n          return void this.observer.emit(i.a.ERROR, i.a.ERROR, {\n            type: a.b.MUX_ERROR,\n            details: a.a.REMUX_ALLOC_ERROR,\n            fatal: !1,\n            bytes: U,\n            reason: \"fail allocating video mdat \" + U\n          });\n        }\n\n        var G = new DataView(B.buffer);\n        G.setUint32(0, U), B.set(et.types.mdat, 4);\n\n        for (var j = 0; j < f; j++) {\n          for (var H = d[j], K = H.units, V = 0, W = 0, Y = K.length; W < Y; W++) {\n            var X = K[W],\n                q = X.data,\n                z = X.data.byteLength;\n            G.setUint32(p, z), p += 4, B.set(q, p), p += z, V += 4 + z;\n          }\n\n          if (j < f - 1) s = d[j + 1].dts - H.dts;else {\n            var Q = this.config,\n                $ = H.dts - d[j > 0 ? j - 1 : j].dts;\n\n            if (Q.stretchShortVideoTrack && null !== this.nextAudioPts) {\n              var Z = Math.floor(Q.maxBufferHole * u),\n                  J = (n ? m + n * u : this.nextAudioPts) - H.pts;\n              J > Z ? ((s = J - $) < 0 && (s = $), c.b.log(\"[mp4-remuxer]: It is approximately \" + J / 90 + \" ms to the next segment; using duration \" + s / 90 + \" ms for the last video frame.\")) : s = $;\n            } else s = $;\n          }\n          var tt = Math.round(H.pts - H.dts);\n          h.push(new ht(H.key, s, V, tt));\n        }\n\n        if (h.length && st && st < 70) {\n          var rt = h[0].flags;\n          rt.dependsOn = 2, rt.isNonSync = 0;\n        }\n\n        this.nextAvcDts = g = l + s, this.isVideoContiguous = !0;\n        var it = {\n          data1: et.moof(t.sequenceNumber++, o, nt({}, t, {\n            samples: h\n          })),\n          data2: B,\n          startPTS: m / u,\n          endPTS: (y + s) / u,\n          startDTS: o / u,\n          endDTS: g / u,\n          type: \"video\",\n          hasAudio: !1,\n          hasVideo: !0,\n          nb: h.length,\n          dropped: t.dropped\n        };\n        return t.samples = [], t.dropped = 0, it;\n      }, e.remuxAudio = function (t, e, r, n, s) {\n        var o = t.inputTimeScale,\n            l = o / (t.samplerate ? t.samplerate : o),\n            u = t.isAAC ? 1024 : 1152,\n            d = u * l,\n            h = this._initPTS,\n            f = !t.isAAC && this.typeSupported.mpeg,\n            v = [],\n            g = t.samples,\n            p = f ? 0 : 8,\n            m = this.nextAudioPts || -1,\n            y = e * o;\n\n        if (this.isAudioContiguous = r = r || g.length && m > 0 && (n && Math.abs(y - m) < 9e3 || Math.abs(dt(g[0].pts - h, y) - m) < 20 * d), g.forEach(function (t) {\n          t.pts = dt(t.pts - h, y);\n        }), !r || m < 0) {\n          if (!(g = g.filter(function (t) {\n            return t.pts >= 0;\n          })).length) return;\n          m = 0 === s ? 0 : n ? Math.max(0, y) : g[0].pts;\n        }\n\n        if (t.isAAC) for (var b = void 0 !== s, T = this.config.maxAudioFramesDrift, E = 0, S = m; E < g.length; E++) {\n          var L = g[E],\n              A = L.pts,\n              R = A - S,\n              D = Math.abs(1e3 * R / o);\n          if (R <= -T * d && b) 0 === E && (c.b.warn(\"Audio frame @ \" + (A / o).toFixed(3) + \"s overlaps nextAudioPts by \" + Math.round(1e3 * R / o) + \" ms.\"), this.nextAudioPts = m = S = A);else if (R >= T * d && D < 1e4 && b) {\n            var _ = Math.round(R / d);\n\n            (S = A - _ * d) < 0 && (_--, S += d), 0 === E && (this.nextAudioPts = m = S), c.b.warn(\"[mp4-remuxer]: Injecting \" + _ + \" audio frame @ \" + (S / o).toFixed(3) + \"s due to \" + Math.round(1e3 * R / o) + \" ms gap.\");\n\n            for (var k = 0; k < _; k++) {\n              var x = Math.max(S, 0),\n                  C = Z.getSilentFrame(t.manifestCodec || t.codec, t.channelCount);\n              C || (c.b.log(\"[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.\"), C = L.unit.subarray()), g.splice(E, 0, {\n                unit: C,\n                pts: x\n              }), S += d, E++;\n            }\n          }\n          L.pts = S, S += d;\n        }\n\n        for (var w, O = null, I = null, P = 0, F = g.length; F--;) P += g[F].unit.byteLength;\n\n        for (var M = 0, N = g.length; M < N; M++) {\n          var B = g[M],\n              U = B.unit,\n              G = B.pts;\n\n          if (null !== I) {\n            v[M - 1].duration = Math.round((G - I) / l);\n          } else {\n            if (r && t.isAAC && (G = m), O = G, !(P > 0)) return;\n            P += p;\n\n            try {\n              w = new Uint8Array(P);\n            } catch (t) {\n              return void this.observer.emit(i.a.ERROR, i.a.ERROR, {\n                type: a.b.MUX_ERROR,\n                details: a.a.REMUX_ALLOC_ERROR,\n                fatal: !1,\n                bytes: P,\n                reason: \"fail allocating audio mdat \" + P\n              });\n            }\n\n            f || (new DataView(w.buffer).setUint32(0, P), w.set(et.types.mdat, 4));\n          }\n\n          w.set(U, p);\n          var j = U.byteLength;\n          p += j, v.push(new ht(!0, u, j, 0)), I = G;\n        }\n\n        var H = v.length;\n\n        if (H) {\n          var K = v[v.length - 1];\n          this.nextAudioPts = m = I + l * K.duration;\n          var V = f ? new Uint8Array(0) : et.moof(t.sequenceNumber++, O / l, nt({}, t, {\n            samples: v\n          }));\n          t.samples = [];\n          var W = O / o,\n              Y = m / o,\n              X = {\n            data1: V,\n            data2: w,\n            startPTS: W,\n            endPTS: Y,\n            startDTS: W,\n            endDTS: Y,\n            type: \"audio\",\n            hasAudio: !0,\n            hasVideo: !1,\n            nb: H\n          };\n          return this.isAudioContiguous = !0, X;\n        }\n      }, e.remuxEmptyAudio = function (t, e, r, i) {\n        var a = t.inputTimeScale,\n            n = a / (t.samplerate ? t.samplerate : a),\n            s = this.nextAudioPts,\n            o = (null !== s ? s : i.startDTS * a) + this._initDTS,\n            l = i.endDTS * a + this._initDTS,\n            u = 1024 * n,\n            d = Math.ceil((l - o) / u),\n            h = Z.getSilentFrame(t.manifestCodec || t.codec, t.channelCount);\n\n        if (c.b.warn(\"[mp4-remuxer]: remux empty Audio\"), h) {\n          for (var f = [], v = 0; v < d; v++) {\n            var g = o + v * u;\n            f.push({\n              unit: h,\n              pts: g,\n              dts: g\n            });\n          }\n\n          return t.samples = f, this.remuxAudio(t, e, r, !1);\n        }\n\n        c.b.trace(\"[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec\");\n      }, e.remuxID3 = function (t, e) {\n        var r = t.samples.length;\n\n        if (r) {\n          for (var i = t.inputTimeScale, a = this._initPTS, n = this._initDTS, s = 0; s < r; s++) {\n            var o = t.samples[s];\n            o.pts = dt(o.pts - a, e * i) / i, o.dts = dt(o.dts - n, e * i) / i;\n          }\n\n          var l = t.samples;\n          return t.samples = [], {\n            samples: l\n          };\n        }\n      }, e.remuxText = function (t, e) {\n        var r = t.samples.length;\n\n        if (r) {\n          for (var i = t.inputTimeScale, a = this._initPTS, n = 0; n < r; n++) {\n            var s = t.samples[n];\n            s.pts = dt(s.pts - a, e * i) / i;\n          }\n\n          t.samples.sort(function (t, e) {\n            return t.pts - e.pts;\n          });\n          var o = t.samples;\n          return t.samples = [], {\n            samples: o\n          };\n        }\n      }, t;\n    }();\n\n    function dt(t, e) {\n      var r;\n      if (null === e) return t;\n\n      for (r = e < t ? -8589934592 : 8589934592; Math.abs(t - e) > 4294967296;) t += r;\n\n      return t;\n    }\n\n    var ht = function (t, e, r, i) {\n      this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = e, this.size = r, this.cts = i, this.flags = new ft(t);\n    },\n        ft = function (t) {\n      this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = t ? 2 : 1, this.isNonSync = t ? 0 : 1;\n    },\n        ct = r(5),\n        vt = function () {\n      function t() {\n        this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = void 0, this.initTracks = void 0, this.lastEndDTS = null;\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {}, e.resetTimeStamp = function (t) {\n        this.initPTS = t, this.lastEndDTS = null;\n      }, e.resetNextTimestamp = function () {\n        this.lastEndDTS = null;\n      }, e.resetInitSegment = function (t, e, r) {\n        this.audioCodec = e, this.videoCodec = r, this.generateInitSegment(t), this.emitInitSegment = !0;\n      }, e.generateInitSegment = function (t) {\n        var e = this.audioCodec,\n            r = this.videoCodec;\n        if (!t || !t.byteLength) return this.initTracks = void 0, void (this.initData = void 0);\n        var i = this.initData = Object(l.f)(t);\n        e || (e = pt(i.audio, ct.a.AUDIO)), r || (r = pt(i.video, ct.a.VIDEO));\n        var a = {};\n        i.audio && i.video ? a.audiovideo = {\n          container: \"video/mp4\",\n          codec: e + \",\" + r,\n          initSegment: t,\n          id: \"main\"\n        } : i.audio ? a.audio = {\n          container: \"audio/mp4\",\n          codec: e,\n          initSegment: t,\n          id: \"audio\"\n        } : i.video ? a.video = {\n          container: \"video/mp4\",\n          codec: r,\n          initSegment: t,\n          id: \"main\"\n        } : c.b.warn(\"[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.\"), this.initTracks = a;\n      }, e.remux = function (t, e, r, i, a) {\n        var n = this.initPTS,\n            o = this.lastEndDTS,\n            u = {\n          audio: void 0,\n          video: void 0,\n          text: i,\n          id3: r,\n          initSegment: void 0\n        };\n        Object(s.a)(o) || (o = this.lastEndDTS = a || 0);\n        var d = e.samples;\n        if (!d || !d.length) return u;\n        var h = {\n          initPTS: void 0,\n          timescale: 1\n        },\n            f = this.initData;\n        if (f && f.length || (this.generateInitSegment(d), f = this.initData), !f || !f.length) return c.b.warn(\"[passthrough-remuxer.ts]: Failed to generate initSegment.\"), u;\n        this.emitInitSegment && (h.tracks = this.initTracks, this.emitInitSegment = !1), Object(s.a)(n) || (this.initPTS = h.initPTS = n = gt(f, d, o));\n        var v = Object(l.c)(d, f),\n            g = o,\n            p = v + g;\n        Object(l.e)(f, d, n), v > 0 ? this.lastEndDTS = p : (c.b.warn(\"Duration parsed from mp4 should be greater than zero\"), this.resetNextTimestamp());\n        var m = !!f.audio,\n            y = !!f.video,\n            b = \"\";\n        m && (b += \"audio\"), y && (b += \"video\");\n        var T = {\n          data1: d,\n          startPTS: g,\n          startDTS: g,\n          endPTS: p,\n          endDTS: p,\n          type: b,\n          hasAudio: m,\n          hasVideo: y,\n          nb: 1,\n          dropped: 0\n        };\n        return u.audio = \"audio\" === T.type ? T : void 0, u.video = \"audio\" !== T.type ? T : void 0, u.text = i, u.id3 = r, u.initSegment = h, u;\n      }, t;\n    }(),\n        gt = function (t, e, r) {\n      return Object(l.d)(t, e) - r;\n    };\n\n    function pt(t, e) {\n      var r = null == t ? void 0 : t.codec;\n      return r && r.length > 4 ? r : \"hvc1\" === r ? \"hvc1.1.c.L120.90\" : \"av01\" === r ? \"av01.0.04M.08\" : \"avc1\" === r || e === ct.a.VIDEO ? \"avc1.42e01e\" : \"mp4a.40.5\";\n    }\n\n    var mt,\n        yt = vt,\n        bt = r(16);\n\n    try {\n      mt = self.performance.now.bind(self.performance);\n    } catch (t) {\n      c.b.debug(\"Unable to use Performance API on this environment\"), mt = self.Date.now;\n    }\n\n    var Tt = [{\n      demux: q,\n      remux: ut\n    }, {\n      demux: D,\n      remux: yt\n    }, {\n      demux: A,\n      remux: ut\n    }, {\n      demux: $,\n      remux: ut\n    }],\n        Et = 1024;\n    Tt.forEach(function (t) {\n      var e = t.demux;\n      Et = Math.max(Et, e.minProbeByteLength);\n    });\n\n    var St = function () {\n      function t(t, e, r, i, a) {\n        this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.cache = new bt.a(), this.observer = t, this.typeSupported = e, this.config = r, this.vendor = i, this.id = a;\n      }\n\n      var e = t.prototype;\n      return e.configure = function (t) {\n        this.transmuxConfig = t, this.decrypter && this.decrypter.reset();\n      }, e.push = function (t, e, r, i) {\n        var a = this,\n            n = r.transmuxing;\n        n.executeStart = mt();\n        var s = new Uint8Array(t),\n            o = this.cache,\n            u = this.config,\n            d = this.currentTransmuxState,\n            h = this.transmuxConfig;\n        i && (this.currentTransmuxState = i);\n\n        var f = function (t, e) {\n          var r = null;\n          t.byteLength > 0 && null != e && null != e.key && null !== e.iv && null != e.method && (r = e);\n          return r;\n        }(s, e);\n\n        if (f && \"AES-128\" === f.method) {\n          var c = this.getDecrypter();\n          if (!u.enableSoftwareAES) return this.decryptionPromise = c.webCryptoDecrypt(s, f.key.buffer, f.iv.buffer).then(function (t) {\n            var e = a.push(t, null, r);\n            return a.decryptionPromise = null, e;\n          }), this.decryptionPromise;\n          var v = c.softwareDecrypt(s, f.key.buffer, f.iv.buffer);\n          if (!v) return n.executeEnd = mt(), Lt(r);\n          s = new Uint8Array(v);\n        }\n\n        var g = i || d,\n            p = g.contiguous,\n            m = g.discontinuity,\n            y = g.trackSwitch,\n            b = g.accurateTimeOffset,\n            T = g.timeOffset,\n            E = g.initSegmentChange,\n            S = h.audioCodec,\n            L = h.videoCodec,\n            A = h.defaultInitPts,\n            R = h.duration,\n            D = h.initSegmentData;\n\n        if ((m || y || E) && this.resetInitSegment(D, S, L, R), (m || E) && this.resetInitialTimestamp(A), p || this.resetContiguity(), this.needsProbing(s, m, y)) {\n          if (o.dataLength) {\n            var _ = o.flush();\n\n            s = Object(l.a)(_, s);\n          }\n\n          this.configureTransmuxer(s, h);\n        }\n\n        var k = this.transmux(s, f, T, b, r),\n            x = this.currentTransmuxState;\n        return x.contiguous = !0, x.discontinuity = !1, x.trackSwitch = !1, n.executeEnd = mt(), k;\n      }, e.flush = function (t) {\n        var e = this,\n            r = t.transmuxing;\n        r.executeStart = mt();\n        var n = this.decrypter,\n            s = this.cache,\n            o = this.currentTransmuxState,\n            l = this.decryptionPromise;\n        if (l) return l.then(function () {\n          return e.flush(t);\n        });\n        var u = [],\n            d = o.timeOffset;\n\n        if (n) {\n          var h = n.flush();\n          h && u.push(this.push(h, null, t));\n        }\n\n        var f = s.dataLength;\n        s.reset();\n        var c = this.demuxer,\n            v = this.remuxer;\n        if (!c || !v) return f >= Et && this.observer.emit(i.a.ERROR, i.a.ERROR, {\n          type: a.b.MEDIA_ERROR,\n          details: a.a.FRAG_PARSING_ERROR,\n          fatal: !0,\n          reason: \"no demux matching with content found\"\n        }), r.executeEnd = mt(), [Lt(t)];\n        var g = c.flush(d);\n        return At(g) ? g.then(function (r) {\n          return e.flushRemux(u, r, t), u;\n        }) : (this.flushRemux(u, g, t), u);\n      }, e.flushRemux = function (t, e, r) {\n        var i = e.audioTrack,\n            a = e.avcTrack,\n            n = e.id3Track,\n            s = e.textTrack,\n            o = this.currentTransmuxState,\n            l = o.accurateTimeOffset,\n            u = o.timeOffset;\n        c.b.log(\"[transmuxer.ts]: Flushed fragment \" + r.sn + (r.part > -1 ? \" p: \" + r.part : \"\") + \" of level \" + r.level);\n        var d = this.remuxer.remux(i, a, n, s, u, l, !0, this.id);\n        t.push({\n          remuxResult: d,\n          chunkMeta: r\n        }), r.transmuxing.executeEnd = mt();\n      }, e.resetInitialTimestamp = function (t) {\n        var e = this.demuxer,\n            r = this.remuxer;\n        e && r && (e.resetTimeStamp(t), r.resetTimeStamp(t));\n      }, e.resetContiguity = function () {\n        var t = this.demuxer,\n            e = this.remuxer;\n        t && e && (t.resetContiguity(), e.resetNextTimestamp());\n      }, e.resetInitSegment = function (t, e, r, i) {\n        var a = this.demuxer,\n            n = this.remuxer;\n        a && n && (a.resetInitSegment(e, r, i), n.resetInitSegment(t, e, r));\n      }, e.destroy = function () {\n        this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0);\n      }, e.transmux = function (t, e, r, i, a) {\n        return e && \"SAMPLE-AES\" === e.method ? this.transmuxSampleAes(t, e, r, i, a) : this.transmuxUnencrypted(t, r, i, a);\n      }, e.transmuxUnencrypted = function (t, e, r, i) {\n        var a = this.demuxer.demux(t, e, !1, !this.config.progressive),\n            n = a.audioTrack,\n            s = a.avcTrack,\n            o = a.id3Track,\n            l = a.textTrack;\n        return {\n          remuxResult: this.remuxer.remux(n, s, o, l, e, r, !1, this.id),\n          chunkMeta: i\n        };\n      }, e.transmuxSampleAes = function (t, e, r, i, a) {\n        var n = this;\n        return this.demuxer.demuxSampleAes(t, e, r).then(function (t) {\n          return {\n            remuxResult: n.remuxer.remux(t.audioTrack, t.avcTrack, t.id3Track, t.textTrack, r, i, !1, n.id),\n            chunkMeta: a\n          };\n        });\n      }, e.configureTransmuxer = function (t, e) {\n        for (var r, i = this.config, a = this.observer, n = this.typeSupported, s = this.vendor, o = e.audioCodec, l = e.defaultInitPts, u = e.duration, d = e.initSegmentData, h = e.videoCodec, f = 0, v = Tt.length; f < v; f++) if (Tt[f].demux.probe(t)) {\n          r = Tt[f];\n          break;\n        }\n\n        r || (c.b.warn(\"Failed to find demuxer by probing frag, treating as mp4 passthrough\"), r = {\n          demux: D,\n          remux: yt\n        });\n        var g = this.demuxer,\n            p = this.remuxer,\n            m = r.remux,\n            y = r.demux;\n        p && p instanceof m || (this.remuxer = new m(a, i, n, s)), g && g instanceof y || (this.demuxer = new y(a, i, n), this.probe = y.probe), this.resetInitSegment(d, o, h, u), this.resetInitialTimestamp(l);\n      }, e.needsProbing = function (t, e, r) {\n        return !this.demuxer || !this.remuxer || e || r;\n      }, e.getDecrypter = function () {\n        var t = this.decrypter;\n        return t || (t = this.decrypter = new n.a(this.observer, this.config)), t;\n      }, t;\n    }();\n\n    var Lt = function (t) {\n      return {\n        remuxResult: {},\n        chunkMeta: t\n      };\n    };\n\n    function At(t) {\n      return \"then\" in t && t.then instanceof Function;\n    }\n\n    var Rt = function (t, e, r, i, a) {\n      this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = t, this.videoCodec = e, this.initSegmentData = r, this.duration = i, this.defaultInitPts = a;\n    },\n        Dt = function (t, e, r, i, a, n) {\n      this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = t, this.contiguous = e, this.accurateTimeOffset = r, this.trackSwitch = i, this.timeOffset = a, this.initSegmentChange = n;\n    };\n  }, function (t, e) {\n    t.exports = void 0;\n  }, function (t, e, r) {\n    var i, a, n, s, o;\n    i = /^((?:[a-zA-Z0-9+\\-.]+:)?)(\\/\\/[^\\/?#]*)?((?:[^\\/?#]*\\/)*[^;?#]*)?(;[^?#]*)?(\\?[^#]*)?(#[^]*)?$/, a = /^([^\\/?#]*)([^]*)$/, n = /(?:\\/|^)\\.(?=\\/)/g, s = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g, o = {\n      buildAbsoluteURL: function (t, e, r) {\n        if (r = r || {}, t = t.trim(), !(e = e.trim())) {\n          if (!r.alwaysNormalize) return t;\n          var i = o.parseURL(t);\n          if (!i) throw new Error(\"Error trying to parse base URL.\");\n          return i.path = o.normalizePath(i.path), o.buildURLFromParts(i);\n        }\n\n        var n = o.parseURL(e);\n        if (!n) throw new Error(\"Error trying to parse relative URL.\");\n        if (n.scheme) return r.alwaysNormalize ? (n.path = o.normalizePath(n.path), o.buildURLFromParts(n)) : e;\n        var s = o.parseURL(t);\n        if (!s) throw new Error(\"Error trying to parse base URL.\");\n\n        if (!s.netLoc && s.path && \"/\" !== s.path[0]) {\n          var l = a.exec(s.path);\n          s.netLoc = l[1], s.path = l[2];\n        }\n\n        s.netLoc && !s.path && (s.path = \"/\");\n        var u = {\n          scheme: s.scheme,\n          netLoc: n.netLoc,\n          path: null,\n          params: n.params,\n          query: n.query,\n          fragment: n.fragment\n        };\n        if (!n.netLoc && (u.netLoc = s.netLoc, \"/\" !== n.path[0])) if (n.path) {\n          var d = s.path,\n              h = d.substring(0, d.lastIndexOf(\"/\") + 1) + n.path;\n          u.path = o.normalizePath(h);\n        } else u.path = s.path, n.params || (u.params = s.params, n.query || (u.query = s.query));\n        return null === u.path && (u.path = r.alwaysNormalize ? o.normalizePath(n.path) : n.path), o.buildURLFromParts(u);\n      },\n      parseURL: function (t) {\n        var e = i.exec(t);\n        return e ? {\n          scheme: e[1] || \"\",\n          netLoc: e[2] || \"\",\n          path: e[3] || \"\",\n          params: e[4] || \"\",\n          query: e[5] || \"\",\n          fragment: e[6] || \"\"\n        } : null;\n      },\n      normalizePath: function (t) {\n        for (t = t.split(\"\").reverse().join(\"\").replace(n, \"\"); t.length !== (t = t.replace(s, \"\")).length;);\n\n        return t.split(\"\").reverse().join(\"\");\n      },\n      buildURLFromParts: function (t) {\n        return t.scheme + t.netLoc + t.path + t.params + t.query + t.fragment;\n      }\n    }, t.exports = o;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return i;\n    });\n\n    var i = function () {\n      this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {\n        start: 0,\n        first: 0,\n        end: 0\n      }, this.parsing = {\n        start: 0,\n        end: 0\n      }, this.buffering = {\n        start: 0,\n        first: 0,\n        end: 0\n      };\n    };\n  }, function (t, e, r) {\n    \"use strict\";\n\n    var i = Object.prototype.hasOwnProperty,\n        a = \"~\";\n\n    function n() {}\n\n    function s(t, e, r) {\n      this.fn = t, this.context = e, this.once = r || !1;\n    }\n\n    function o(t, e, r, i, n) {\n      if (\"function\" != typeof r) throw new TypeError(\"The listener must be a function\");\n      var o = new s(r, i || t, n),\n          l = a ? a + e : e;\n      return t._events[l] ? t._events[l].fn ? t._events[l] = [t._events[l], o] : t._events[l].push(o) : (t._events[l] = o, t._eventsCount++), t;\n    }\n\n    function l(t, e) {\n      0 == --t._eventsCount ? t._events = new n() : delete t._events[e];\n    }\n\n    function u() {\n      this._events = new n(), this._eventsCount = 0;\n    }\n\n    Object.create && (n.prototype = Object.create(null), new n().__proto__ || (a = !1)), u.prototype.eventNames = function () {\n      var t,\n          e,\n          r = [];\n      if (0 === this._eventsCount) return r;\n\n      for (e in t = this._events) i.call(t, e) && r.push(a ? e.slice(1) : e);\n\n      return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(t)) : r;\n    }, u.prototype.listeners = function (t) {\n      var e = a ? a + t : t,\n          r = this._events[e];\n      if (!r) return [];\n      if (r.fn) return [r.fn];\n\n      for (var i = 0, n = r.length, s = new Array(n); i < n; i++) s[i] = r[i].fn;\n\n      return s;\n    }, u.prototype.listenerCount = function (t) {\n      var e = a ? a + t : t,\n          r = this._events[e];\n      return r ? r.fn ? 1 : r.length : 0;\n    }, u.prototype.emit = function (t, e, r, i, n, s) {\n      var o = a ? a + t : t;\n      if (!this._events[o]) return !1;\n      var l,\n          u,\n          d = this._events[o],\n          h = arguments.length;\n\n      if (d.fn) {\n        switch (d.once && this.removeListener(t, d.fn, void 0, !0), h) {\n          case 1:\n            return d.fn.call(d.context), !0;\n\n          case 2:\n            return d.fn.call(d.context, e), !0;\n\n          case 3:\n            return d.fn.call(d.context, e, r), !0;\n\n          case 4:\n            return d.fn.call(d.context, e, r, i), !0;\n\n          case 5:\n            return d.fn.call(d.context, e, r, i, n), !0;\n\n          case 6:\n            return d.fn.call(d.context, e, r, i, n, s), !0;\n        }\n\n        for (u = 1, l = new Array(h - 1); u < h; u++) l[u - 1] = arguments[u];\n\n        d.fn.apply(d.context, l);\n      } else {\n        var f,\n            c = d.length;\n\n        for (u = 0; u < c; u++) switch (d[u].once && this.removeListener(t, d[u].fn, void 0, !0), h) {\n          case 1:\n            d[u].fn.call(d[u].context);\n            break;\n\n          case 2:\n            d[u].fn.call(d[u].context, e);\n            break;\n\n          case 3:\n            d[u].fn.call(d[u].context, e, r);\n            break;\n\n          case 4:\n            d[u].fn.call(d[u].context, e, r, i);\n            break;\n\n          default:\n            if (!l) for (f = 1, l = new Array(h - 1); f < h; f++) l[f - 1] = arguments[f];\n            d[u].fn.apply(d[u].context, l);\n        }\n      }\n\n      return !0;\n    }, u.prototype.on = function (t, e, r) {\n      return o(this, t, e, r, !1);\n    }, u.prototype.once = function (t, e, r) {\n      return o(this, t, e, r, !0);\n    }, u.prototype.removeListener = function (t, e, r, i) {\n      var n = a ? a + t : t;\n      if (!this._events[n]) return this;\n      if (!e) return l(this, n), this;\n      var s = this._events[n];\n      if (s.fn) s.fn !== e || i && !s.once || r && s.context !== r || l(this, n);else {\n        for (var o = 0, u = [], d = s.length; o < d; o++) (s[o].fn !== e || i && !s[o].once || r && s[o].context !== r) && u.push(s[o]);\n\n        u.length ? this._events[n] = 1 === u.length ? u[0] : u : l(this, n);\n      }\n      return this;\n    }, u.prototype.removeAllListeners = function (t) {\n      var e;\n      return t ? (e = a ? a + t : t, this._events[e] && l(this, e)) : (this._events = new n(), this._eventsCount = 0), this;\n    }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = a, u.EventEmitter = u, t.exports = u;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return u;\n    });\n\n    var i = function () {\n      function t(t, e) {\n        this.subtle = void 0, this.aesIV = void 0, this.subtle = t, this.aesIV = e;\n      }\n\n      return t.prototype.decrypt = function (t, e) {\n        return this.subtle.decrypt({\n          name: \"AES-CBC\",\n          iv: this.aesIV\n        }, e, t);\n      }, t;\n    }(),\n        a = function () {\n      function t(t, e) {\n        this.subtle = void 0, this.key = void 0, this.subtle = t, this.key = e;\n      }\n\n      return t.prototype.expandKey = function () {\n        return this.subtle.importKey(\"raw\", this.key, {\n          name: \"AES-CBC\"\n        }, !1, [\"encrypt\", \"decrypt\"]);\n      }, t;\n    }(),\n        n = r(8);\n\n    var s = function () {\n      function t() {\n        this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable();\n      }\n\n      var e = t.prototype;\n      return e.uint8ArrayToUint32Array_ = function (t) {\n        for (var e = new DataView(t), r = new Uint32Array(4), i = 0; i < 4; i++) r[i] = e.getUint32(4 * i);\n\n        return r;\n      }, e.initTable = function () {\n        var t = this.sBox,\n            e = this.invSBox,\n            r = this.subMix,\n            i = r[0],\n            a = r[1],\n            n = r[2],\n            s = r[3],\n            o = this.invSubMix,\n            l = o[0],\n            u = o[1],\n            d = o[2],\n            h = o[3],\n            f = new Uint32Array(256),\n            c = 0,\n            v = 0,\n            g = 0;\n\n        for (g = 0; g < 256; g++) f[g] = g < 128 ? g << 1 : g << 1 ^ 283;\n\n        for (g = 0; g < 256; g++) {\n          var p = v ^ v << 1 ^ v << 2 ^ v << 3 ^ v << 4;\n          p = p >>> 8 ^ 255 & p ^ 99, t[c] = p, e[p] = c;\n          var m = f[c],\n              y = f[m],\n              b = f[y],\n              T = 257 * f[p] ^ 16843008 * p;\n          i[c] = T << 24 | T >>> 8, a[c] = T << 16 | T >>> 16, n[c] = T << 8 | T >>> 24, s[c] = T, T = 16843009 * b ^ 65537 * y ^ 257 * m ^ 16843008 * c, l[p] = T << 24 | T >>> 8, u[p] = T << 16 | T >>> 16, d[p] = T << 8 | T >>> 24, h[p] = T, c ? (c = m ^ f[f[f[b ^ m]]], v ^= f[f[v]]) : c = v = 1;\n        }\n      }, e.expandKey = function (t) {\n        for (var e = this.uint8ArrayToUint32Array_(t), r = !0, i = 0; i < e.length && r;) r = e[i] === this.key[i], i++;\n\n        if (!r) {\n          this.key = e;\n          var a = this.keySize = e.length;\n          if (4 !== a && 6 !== a && 8 !== a) throw new Error(\"Invalid aes key size=\" + a);\n          var n,\n              s,\n              o,\n              l,\n              u = this.ksRows = 4 * (a + 6 + 1),\n              d = this.keySchedule = new Uint32Array(u),\n              h = this.invKeySchedule = new Uint32Array(u),\n              f = this.sBox,\n              c = this.rcon,\n              v = this.invSubMix,\n              g = v[0],\n              p = v[1],\n              m = v[2],\n              y = v[3];\n\n          for (n = 0; n < u; n++) n < a ? o = d[n] = e[n] : (l = o, n % a == 0 ? (l = f[(l = l << 8 | l >>> 24) >>> 24] << 24 | f[l >>> 16 & 255] << 16 | f[l >>> 8 & 255] << 8 | f[255 & l], l ^= c[n / a | 0] << 24) : a > 6 && n % a == 4 && (l = f[l >>> 24] << 24 | f[l >>> 16 & 255] << 16 | f[l >>> 8 & 255] << 8 | f[255 & l]), d[n] = o = (d[n - a] ^ l) >>> 0);\n\n          for (s = 0; s < u; s++) n = u - s, l = 3 & s ? d[n] : d[n - 4], h[s] = s < 4 || n <= 4 ? l : g[f[l >>> 24]] ^ p[f[l >>> 16 & 255]] ^ m[f[l >>> 8 & 255]] ^ y[f[255 & l]], h[s] = h[s] >>> 0;\n        }\n      }, e.networkToHostOrderSwap = function (t) {\n        return t << 24 | (65280 & t) << 8 | (16711680 & t) >> 8 | t >>> 24;\n      }, e.decrypt = function (t, e, r) {\n        for (var i, a, n, s, o, l, u, d, h, f, c, v, g, p, m = this.keySize + 6, y = this.invKeySchedule, b = this.invSBox, T = this.invSubMix, E = T[0], S = T[1], L = T[2], A = T[3], R = this.uint8ArrayToUint32Array_(r), D = R[0], _ = R[1], k = R[2], x = R[3], C = new Int32Array(t), w = new Int32Array(C.length), O = this.networkToHostOrderSwap; e < C.length;) {\n          for (h = O(C[e]), f = O(C[e + 1]), c = O(C[e + 2]), v = O(C[e + 3]), o = h ^ y[0], l = v ^ y[1], u = c ^ y[2], d = f ^ y[3], g = 4, p = 1; p < m; p++) i = E[o >>> 24] ^ S[l >> 16 & 255] ^ L[u >> 8 & 255] ^ A[255 & d] ^ y[g], a = E[l >>> 24] ^ S[u >> 16 & 255] ^ L[d >> 8 & 255] ^ A[255 & o] ^ y[g + 1], n = E[u >>> 24] ^ S[d >> 16 & 255] ^ L[o >> 8 & 255] ^ A[255 & l] ^ y[g + 2], s = E[d >>> 24] ^ S[o >> 16 & 255] ^ L[l >> 8 & 255] ^ A[255 & u] ^ y[g + 3], o = i, l = a, u = n, d = s, g += 4;\n\n          i = b[o >>> 24] << 24 ^ b[l >> 16 & 255] << 16 ^ b[u >> 8 & 255] << 8 ^ b[255 & d] ^ y[g], a = b[l >>> 24] << 24 ^ b[u >> 16 & 255] << 16 ^ b[d >> 8 & 255] << 8 ^ b[255 & o] ^ y[g + 1], n = b[u >>> 24] << 24 ^ b[d >> 16 & 255] << 16 ^ b[o >> 8 & 255] << 8 ^ b[255 & l] ^ y[g + 2], s = b[d >>> 24] << 24 ^ b[o >> 16 & 255] << 16 ^ b[l >> 8 & 255] << 8 ^ b[255 & u] ^ y[g + 3], w[e] = O(i ^ D), w[e + 1] = O(s ^ _), w[e + 2] = O(n ^ k), w[e + 3] = O(a ^ x), D = h, _ = f, k = c, x = v, e += 4;\n        }\n\n        return w.buffer;\n      }, t;\n    }(),\n        o = r(1),\n        l = r(6),\n        u = function () {\n      function t(t, e, r) {\n        var i = (void 0 === r ? {} : r).removePKCS7Padding,\n            a = void 0 === i || i;\n        if (this.logEnabled = !0, this.observer = void 0, this.config = void 0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.observer = t, this.config = e, this.removePKCS7Padding = a, a) try {\n          var n = self.crypto;\n          n && (this.subtle = n.subtle || n.webkitSubtle);\n        } catch (t) {}\n        null === this.subtle && (this.config.enableSoftwareAES = !0);\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.observer = null;\n      }, e.isSync = function () {\n        return this.config.enableSoftwareAES;\n      }, e.flush = function () {\n        var t = this.currentResult;\n\n        if (t) {\n          var e,\n              r,\n              i,\n              a = new Uint8Array(t);\n          return this.reset(), this.removePKCS7Padding ? (r = (e = a).byteLength, (i = r && new DataView(e.buffer).getUint8(r - 1)) ? Object(n.a)(e, 0, r - i) : e) : a;\n        }\n\n        this.reset();\n      }, e.reset = function () {\n        this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null);\n      }, e.decrypt = function (t, e, r, i) {\n        if (this.config.enableSoftwareAES) {\n          this.softwareDecrypt(new Uint8Array(t), e, r);\n          var a = this.flush();\n          a && i(a.buffer);\n        } else this.webCryptoDecrypt(new Uint8Array(t), e, r).then(i);\n      }, e.softwareDecrypt = function (t, e, r) {\n        var i = this.currentIV,\n            a = this.currentResult,\n            o = this.remainderData;\n        this.logOnce(\"JS AES decrypt\"), o && (t = Object(l.a)(o, t), this.remainderData = null);\n        var u = this.getValidChunk(t);\n        if (!u.length) return null;\n        i && (r = i);\n        var d = this.softwareDecrypter;\n        d || (d = this.softwareDecrypter = new s()), d.expandKey(e);\n        var h = a;\n        return this.currentResult = d.decrypt(u.buffer, 0, r), this.currentIV = Object(n.a)(u, -16).buffer, h || null;\n      }, e.webCryptoDecrypt = function (t, e, r) {\n        var n = this,\n            s = this.subtle;\n        return this.key === e && this.fastAesKey || (this.key = e, this.fastAesKey = new a(s, e)), this.fastAesKey.expandKey().then(function (e) {\n          return s ? new i(s, r).decrypt(t.buffer, e) : Promise.reject(new Error(\"web crypto not initialized\"));\n        }).catch(function (i) {\n          return n.onWebCryptoError(i, t, e, r);\n        });\n      }, e.onWebCryptoError = function (t, e, r, i) {\n        return o.b.warn(\"[decrypter.ts]: WebCrypto Error, disable WebCrypto API:\", t), this.config.enableSoftwareAES = !0, this.logEnabled = !0, this.softwareDecrypt(e, r, i);\n      }, e.getValidChunk = function (t) {\n        var e = t,\n            r = t.length - t.length % 16;\n        return r !== t.length && (e = Object(n.a)(t, 0, r), this.remainderData = Object(n.a)(t, r)), e;\n      }, e.logOnce = function (t) {\n        this.logEnabled && (o.b.log(\"[decrypter.ts]: \" + t), this.logEnabled = !1);\n      }, t;\n    }();\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return n;\n    });\n    var i = r(11);\n\n    function a(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    var n = function () {\n      function t(t, e) {\n        this._uri = null, this.method = null, this.keyFormat = null, this.keyFormatVersions = null, this.keyID = null, this.key = null, this.iv = null, this._uri = e ? Object(i.buildAbsoluteURL)(t, e, {\n          alwaysNormalize: !0\n        }) : t;\n      }\n\n      var e, r, n;\n      return t.fromURL = function (e, r) {\n        return new t(e, r);\n      }, t.fromURI = function (e) {\n        return new t(e);\n      }, e = t, (r = [{\n        key: \"uri\",\n        get: function () {\n          return this._uri;\n        }\n      }]) && a(e.prototype, r), n && a(e, n), t;\n    }();\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return i;\n    });\n\n    var i = function () {\n      function t() {\n        this.chunks = [], this.dataLength = 0;\n      }\n\n      var e = t.prototype;\n      return e.push = function (t) {\n        this.chunks.push(t), this.dataLength += t.length;\n      }, e.flush = function () {\n        var t,\n            e = this.chunks,\n            r = this.dataLength;\n        return e.length ? (t = 1 === e.length ? e[0] : function (t, e) {\n          for (var r = new Uint8Array(e), i = 0, a = 0; a < t.length; a++) {\n            var n = t[a];\n            r.set(n, i), i += n.length;\n          }\n\n          return r;\n        }(e, r), this.reset(), t) : new Uint8Array(0);\n      }, e.reset = function () {\n        this.chunks.length = 0, this.dataLength = 0;\n      }, t;\n    }();\n  }, function (t, e, r) {\n    function i(t) {\n      var e = {};\n\n      function r(i) {\n        if (e[i]) return e[i].exports;\n        var a = e[i] = {\n          i: i,\n          l: !1,\n          exports: {}\n        };\n        return t[i].call(a.exports, a, a.exports, r), a.l = !0, a.exports;\n      }\n\n      r.m = t, r.c = e, r.i = function (t) {\n        return t;\n      }, r.d = function (t, e, i) {\n        r.o(t, e) || Object.defineProperty(t, e, {\n          configurable: !1,\n          enumerable: !0,\n          get: i\n        });\n      }, r.r = function (t) {\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      }, r.n = function (t) {\n        var e = t && t.__esModule ? function () {\n          return t.default;\n        } : function () {\n          return t;\n        };\n        return r.d(e, \"a\", e), e;\n      }, r.o = function (t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }, r.p = \"/\", r.oe = function (t) {\n        throw console.error(t), t;\n      };\n      var i = r(r.s = ENTRY_MODULE);\n      return i.default || i;\n    }\n\n    function a(t) {\n      return (t + \"\").replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"\\\\$&\");\n    }\n\n    function n(t, e, i) {\n      var n = {};\n      n[i] = [];\n      var s = e.toString(),\n          o = s.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/);\n      if (!o) return n;\n\n      for (var l, u = o[1], d = new RegExp(\"(\\\\\\\\n|\\\\W)\" + a(u) + \"\\\\(\\\\s*(/\\\\*.*?\\\\*/)?\\\\s*.*?([\\\\.|\\\\-|\\\\+|\\\\w|/|@]+).*?\\\\)\", \"g\"); l = d.exec(s);) \"dll-reference\" !== l[3] && n[i].push(l[3]);\n\n      for (d = new RegExp(\"\\\\(\" + a(u) + '\\\\(\"(dll-reference\\\\s([\\\\.|\\\\-|\\\\+|\\\\w|/|@]+))\"\\\\)\\\\)\\\\(\\\\s*(/\\\\*.*?\\\\*/)?\\\\s*.*?([\\\\.|\\\\-|\\\\+|\\\\w|/|@]+).*?\\\\)', \"g\"); l = d.exec(s);) t[l[2]] || (n[i].push(l[1]), t[l[2]] = r(l[1]).m), n[l[2]] = n[l[2]] || [], n[l[2]].push(l[4]);\n\n      for (var h, f = Object.keys(n), c = 0; c < f.length; c++) for (var v = 0; v < n[f[c]].length; v++) h = n[f[c]][v], isNaN(1 * h) || (n[f[c]][v] = 1 * n[f[c]][v]);\n\n      return n;\n    }\n\n    function s(t) {\n      return Object.keys(t).reduce(function (e, r) {\n        return e || t[r].length > 0;\n      }, !1);\n    }\n\n    t.exports = function (t, e) {\n      e = e || {};\n      var a = {\n        main: r.m\n      },\n          o = e.all ? {\n        main: Object.keys(a.main)\n      } : function (t, e) {\n        for (var r = {\n          main: [e]\n        }, i = {\n          main: []\n        }, a = {\n          main: {}\n        }; s(r);) for (var o = Object.keys(r), l = 0; l < o.length; l++) {\n          var u = o[l],\n              d = r[u].pop();\n\n          if (a[u] = a[u] || {}, !a[u][d] && t[u][d]) {\n            a[u][d] = !0, i[u] = i[u] || [], i[u].push(d);\n\n            for (var h = n(t, t[u][d], u), f = Object.keys(h), c = 0; c < f.length; c++) r[f[c]] = r[f[c]] || [], r[f[c]] = r[f[c]].concat(h[f[c]]);\n          }\n        }\n\n        return i;\n      }(a, t),\n          l = \"\";\n      Object.keys(o).filter(function (t) {\n        return \"main\" !== t;\n      }).forEach(function (t) {\n        for (var e = 0; o[t][e];) e++;\n\n        o[t].push(e), a[t][e] = \"(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })\", l = l + \"var \" + t + \" = (\" + i.toString().replace(\"ENTRY_MODULE\", JSON.stringify(e)) + \")({\" + o[t].map(function (e) {\n          return JSON.stringify(e) + \": \" + a[t][e].toString();\n        }).join(\",\") + \"});\\n\";\n      }), l = l + \"new ((\" + i.toString().replace(\"ENTRY_MODULE\", JSON.stringify(t)) + \")({\" + o.main.map(function (t) {\n        return JSON.stringify(t) + \": \" + a.main[t].toString();\n      }).join(\",\") + \"}))(self);\";\n      var u = new window.Blob([l], {\n        type: \"text/javascript\"\n      });\n      if (e.bare) return u;\n      var d = (window.URL || window.webkitURL || window.mozURL || window.msURL).createObjectURL(u),\n          h = new window.Worker(d);\n      return h.objectURL = d, h;\n    };\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.r(e), r.d(e, \"default\", function () {\n      return o;\n    });\n    var i = r(9),\n        a = r(0),\n        n = r(1),\n        s = r(13);\n\n    function o(t) {\n      var e = new s.EventEmitter(),\n          r = function (e, r) {\n        t.postMessage({\n          event: e,\n          data: r\n        });\n      };\n\n      e.on(a.a.FRAG_DECRYPTED, r), e.on(a.a.ERROR, r), t.addEventListener(\"message\", function (a) {\n        var s = a.data;\n\n        switch (s.cmd) {\n          case \"init\":\n            var o = JSON.parse(s.config);\n            t.transmuxer = new i.c(e, s.typeSupported, o, s.vendor, s.id), Object(n.a)(o.debug), r(\"init\", null);\n            break;\n\n          case \"configure\":\n            t.transmuxer.configure(s.config);\n            break;\n\n          case \"demux\":\n            var u = t.transmuxer.push(s.data, s.decryptdata, s.chunkMeta, s.state);\n            Object(i.d)(u) ? u.then(function (e) {\n              l(t, e);\n            }) : l(t, u);\n            break;\n\n          case \"flush\":\n            var h = s.chunkMeta,\n                f = t.transmuxer.flush(h);\n            Object(i.d)(f) ? f.then(function (e) {\n              d(t, e, h);\n            }) : d(t, f, h);\n        }\n      });\n    }\n\n    function l(t, e) {\n      if ((r = e.remuxResult).audio || r.video || r.text || r.id3 || r.initSegment) {\n        var r,\n            i = [],\n            a = e.remuxResult,\n            n = a.audio,\n            s = a.video;\n        n && u(i, n), s && u(i, s), t.postMessage({\n          event: \"transmuxComplete\",\n          data: e\n        }, i);\n      }\n    }\n\n    function u(t, e) {\n      e.data1 && t.push(e.data1.buffer), e.data2 && t.push(e.data2.buffer);\n    }\n\n    function d(t, e, r) {\n      e.forEach(function (e) {\n        l(t, e);\n      }), t.postMessage({\n        event: \"flush\",\n        data: r\n      });\n    }\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.r(e), r.d(e, \"default\", function () {\n      return we;\n    });\n    var i = r(11),\n        a = r(3),\n        n = r(0),\n        s = r(2),\n        o = r(1),\n        l = r(6),\n        u = r(5);\n\n    function d(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    var h = function () {\n      function t(t) {\n        this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.needSidxRanges = !1, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = \"\", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.fragments = [], this.url = t;\n      }\n\n      var e, r, i;\n      return t.prototype.reloaded = function (t) {\n        if (!t) return this.advanced = !0, void (this.updated = !0);\n        var e = this.lastPartSn - t.lastPartSn,\n            r = this.lastPartIndex - t.lastPartIndex;\n        this.updated = this.endSN !== t.endSN || !!r || !!e, this.advanced = this.endSN > t.endSN || e > 0 || 0 === e && r > 0, this.updated || this.advanced ? this.misses = Math.floor(.6 * t.misses) : this.misses = t.misses + 1, this.availabilityDelay = t.availabilityDelay;\n      }, e = t, (r = [{\n        key: \"hasProgramDateTime\",\n        get: function () {\n          return !!this.fragments.length && Object(a.a)(this.fragments[this.fragments.length - 1].programDateTime);\n        }\n      }, {\n        key: \"levelTargetDuration\",\n        get: function () {\n          return this.averagetargetduration || this.targetduration || 10;\n        }\n      }, {\n        key: \"drift\",\n        get: function () {\n          var t = this.driftEndTime - this.driftStartTime;\n          return t > 0 ? 1e3 * (this.driftEnd - this.driftStart) / t : 1;\n        }\n      }, {\n        key: \"edge\",\n        get: function () {\n          return this.partEnd || this.fragmentEnd;\n        }\n      }, {\n        key: \"partEnd\",\n        get: function () {\n          var t;\n          return null !== (t = this.partList) && void 0 !== t && t.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd;\n        }\n      }, {\n        key: \"fragmentEnd\",\n        get: function () {\n          var t;\n          return null !== (t = this.fragments) && void 0 !== t && t.length ? this.fragments[this.fragments.length - 1].end : 0;\n        }\n      }, {\n        key: \"age\",\n        get: function () {\n          return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0;\n        }\n      }, {\n        key: \"lastPartIndex\",\n        get: function () {\n          var t;\n          return null !== (t = this.partList) && void 0 !== t && t.length ? this.partList[this.partList.length - 1].index : -1;\n        }\n      }, {\n        key: \"lastPartSn\",\n        get: function () {\n          var t;\n          return null !== (t = this.partList) && void 0 !== t && t.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN;\n        }\n      }]) && d(e.prototype, r), i && d(e, i), t;\n    }(),\n        f = r(15),\n        c = /^(\\d+)x(\\d+)$/,\n        v = /\\s*(.+?)\\s*=((?:\\\".*?\\\")|.*?)(?:,|$)/g,\n        g = function () {\n      function t(e) {\n        for (var r in \"string\" == typeof e && (e = t.parseAttrList(e)), e) e.hasOwnProperty(r) && (this[r] = e[r]);\n      }\n\n      var e = t.prototype;\n      return e.decimalInteger = function (t) {\n        var e = parseInt(this[t], 10);\n        return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e;\n      }, e.hexadecimalInteger = function (t) {\n        if (this[t]) {\n          var e = (this[t] || \"0x\").slice(2);\n          e = (1 & e.length ? \"0\" : \"\") + e;\n\n          for (var r = new Uint8Array(e.length / 2), i = 0; i < e.length / 2; i++) r[i] = parseInt(e.slice(2 * i, 2 * i + 2), 16);\n\n          return r;\n        }\n\n        return null;\n      }, e.hexadecimalIntegerAsNumber = function (t) {\n        var e = parseInt(this[t], 16);\n        return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e;\n      }, e.decimalFloatingPoint = function (t) {\n        return parseFloat(this[t]);\n      }, e.optionalFloat = function (t, e) {\n        var r = this[t];\n        return r ? parseFloat(r) : e;\n      }, e.enumeratedString = function (t) {\n        return this[t];\n      }, e.bool = function (t) {\n        return \"YES\" === this[t];\n      }, e.decimalResolution = function (t) {\n        var e = c.exec(this[t]);\n        if (null !== e) return {\n          width: parseInt(e[1], 10),\n          height: parseInt(e[2], 10)\n        };\n      }, t.parseAttrList = function (t) {\n        var e,\n            r = {};\n\n        for (v.lastIndex = 0; null !== (e = v.exec(t));) {\n          var i = e[2];\n          0 === i.indexOf('\"') && i.lastIndexOf('\"') === i.length - 1 && (i = i.slice(1, -1)), r[e[1]] = i;\n        }\n\n        return r;\n      }, t;\n    }(),\n        p = {\n      audio: {\n        a3ds: !0,\n        \"ac-3\": !0,\n        \"ac-4\": !0,\n        alac: !0,\n        alaw: !0,\n        dra1: !0,\n        \"dts+\": !0,\n        \"dts-\": !0,\n        dtsc: !0,\n        dtse: !0,\n        dtsh: !0,\n        \"ec-3\": !0,\n        enca: !0,\n        g719: !0,\n        g726: !0,\n        m4ae: !0,\n        mha1: !0,\n        mha2: !0,\n        mhm1: !0,\n        mhm2: !0,\n        mlpa: !0,\n        mp4a: !0,\n        \"raw \": !0,\n        Opus: !0,\n        samr: !0,\n        sawb: !0,\n        sawp: !0,\n        sevc: !0,\n        sqcp: !0,\n        ssmv: !0,\n        twos: !0,\n        ulaw: !0\n      },\n      video: {\n        avc1: !0,\n        avc2: !0,\n        avc3: !0,\n        avc4: !0,\n        avcp: !0,\n        av01: !0,\n        drac: !0,\n        dvav: !0,\n        dvhe: !0,\n        encv: !0,\n        hev1: !0,\n        hvc1: !0,\n        mjp2: !0,\n        mp4v: !0,\n        mvc1: !0,\n        mvc2: !0,\n        mvc3: !0,\n        mvc4: !0,\n        resv: !0,\n        rv60: !0,\n        s263: !0,\n        svc1: !0,\n        svc2: !0,\n        \"vc-1\": !0,\n        vp08: !0,\n        vp09: !0\n      },\n      text: {\n        stpp: !0,\n        wvtt: !0\n      }\n    };\n\n    function m(t, e) {\n      return MediaSource.isTypeSupported((e || \"video\") + '/mp4;codecs=\"' + t + '\"');\n    }\n\n    var y = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-SESSION-DATA:([^\\r\\n]*)[\\r\\n]+/g,\n        b = /#EXT-X-MEDIA:(.*)/g,\n        T = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source, /(?!#) *(\\S[\\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join(\"|\"), \"g\"),\n        E = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(PLAYLIST-TYPE):(.+)/.source, /#EXT-X-(MEDIA-SEQUENCE): *(\\d+)/.source, /#EXT-X-(SKIP):(.+)/.source, /#EXT-X-(TARGETDURATION): *(\\d+)/.source, /#EXT-X-(KEY):(.+)/.source, /#EXT-X-(START):(.+)/.source, /#EXT-X-(ENDLIST)/.source, /#EXT-X-(DISCONTINUITY-SEQ)UENCE: *(\\d+)/.source, /#EXT-X-(DIS)CONTINUITY/.source, /#EXT-X-(VERSION):(\\d+)/.source, /#EXT-X-(MAP):(.+)/.source, /#EXT-X-(SERVER-CONTROL):(.+)/.source, /#EXT-X-(PART-INF):(.+)/.source, /#EXT-X-(GAP)/.source, /#EXT-X-(BITRATE):\\s*(\\d+)/.source, /#EXT-X-(PART):(.+)/.source, /#EXT-X-(PRELOAD-HINT):(.+)/.source, /#EXT-X-(RENDITION-REPORT):(.+)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join(\"|\")),\n        S = /\\.(mp4|m4s|m4v|m4a)$/i;\n\n    var L = function () {\n      function t() {}\n\n      return t.findGroup = function (t, e) {\n        for (var r = 0; r < t.length; r++) {\n          var i = t[r];\n          if (i.id === e) return i;\n        }\n      }, t.convertAVC1ToAVCOTI = function (t) {\n        var e = t.split(\".\");\n\n        if (e.length > 2) {\n          var r = e.shift() + \".\";\n          return r += parseInt(e.shift()).toString(16), r += (\"000\" + parseInt(e.shift()).toString(16)).substr(-4);\n        }\n\n        return t;\n      }, t.resolve = function (t, e) {\n        return i.buildAbsoluteURL(e, t, {\n          alwaysNormalize: !0\n        });\n      }, t.parseMasterPlaylist = function (e, r) {\n        var i,\n            a = [],\n            n = {},\n            s = !1;\n\n        for (y.lastIndex = 0; null != (i = y.exec(e));) if (i[1]) {\n          var o = new g(i[1]),\n              l = {\n            attrs: o,\n            bitrate: o.decimalInteger(\"AVERAGE-BANDWIDTH\") || o.decimalInteger(\"BANDWIDTH\"),\n            name: o.NAME,\n            url: t.resolve(i[2], r)\n          },\n              u = o.decimalResolution(\"RESOLUTION\");\n          u && (l.width = u.width, l.height = u.height), A((o.CODECS || \"\").split(/[ ,]+/).filter(function (t) {\n            return t;\n          }), l), l.videoCodec && -1 !== l.videoCodec.indexOf(\"avc1\") && (l.videoCodec = t.convertAVC1ToAVCOTI(l.videoCodec)), a.push(l);\n        } else if (i[3]) {\n          var d = new g(i[3]);\n          d[\"DATA-ID\"] && (s = !0, n[d[\"DATA-ID\"]] = d);\n        }\n\n        return {\n          levels: a,\n          sessionData: s ? n : null\n        };\n      }, t.parseMasterPlaylistMedia = function (e, r, i, a) {\n        var n;\n        void 0 === a && (a = []);\n        var s = [],\n            o = 0;\n\n        for (b.lastIndex = 0; null !== (n = b.exec(e));) {\n          var l = new g(n[1]);\n\n          if (l.TYPE === i) {\n            var u = {\n              attrs: l,\n              bitrate: 0,\n              id: o++,\n              groupId: l[\"GROUP-ID\"],\n              instreamId: l[\"INSTREAM-ID\"],\n              name: l.NAME || l.LANGUAGE || \"\",\n              type: i,\n              default: l.bool(\"DEFAULT\"),\n              autoselect: l.bool(\"AUTOSELECT\"),\n              forced: l.bool(\"FORCED\"),\n              lang: l.LANGUAGE,\n              url: l.URI ? t.resolve(l.URI, r) : \"\"\n            };\n\n            if (a.length) {\n              var d = t.findGroup(a, u.groupId) || a[0];\n              R(u, d, \"audioCodec\"), R(u, d, \"textCodec\");\n            }\n\n            s.push(u);\n          }\n        }\n\n        return s;\n      }, t.parseLevelPlaylist = function (t, e, r, n, s) {\n        var l,\n            d,\n            c,\n            v = new h(e),\n            p = v.fragments,\n            m = null,\n            y = 0,\n            b = 0,\n            L = 0,\n            A = 0,\n            R = null,\n            _ = new u.b(n, e),\n            k = -1,\n            x = !1;\n\n        for (T.lastIndex = 0, v.m3u8 = t; null !== (l = T.exec(t));) {\n          x && (x = !1, (_ = new u.b(n, e)).start = L, _.sn = y, _.cc = A, _.level = r, m && (_.initSegment = m, _.rawProgramDateTime = m.rawProgramDateTime));\n          var C = l[1];\n\n          if (C) {\n            _.duration = parseFloat(C);\n            var w = (\" \" + l[2]).slice(1);\n            _.title = w || null, _.tagList.push(w ? [\"INF\", C, w] : [\"INF\", C]);\n          } else if (l[3]) Object(a.a)(_.duration) && (_.start = L, c && (_.levelkey = c), _.sn = y, _.level = r, _.cc = A, _.urlId = s, p.push(_), _.relurl = (\" \" + l[3]).slice(1), D(_, R), R = _, L += _.duration, y++, b = 0, x = !0);else if (l[4]) {\n            var O = (\" \" + l[4]).slice(1);\n            R ? _.setByteRange(O, R) : _.setByteRange(O);\n          } else if (l[5]) _.rawProgramDateTime = (\" \" + l[5]).slice(1), _.tagList.push([\"PROGRAM-DATE-TIME\", _.rawProgramDateTime]), -1 === k && (k = p.length);else {\n            if (!(l = l[0].match(E))) {\n              o.b.warn(\"No matches on slow regex match for level playlist!\");\n              continue;\n            }\n\n            for (d = 1; d < l.length && void 0 === l[d]; d++);\n\n            var I = (\" \" + l[d]).slice(1),\n                P = (\" \" + l[d + 1]).slice(1),\n                F = l[d + 2] ? (\" \" + l[d + 2]).slice(1) : \"\";\n\n            switch (I) {\n              case \"PLAYLIST-TYPE\":\n                v.type = P.toUpperCase();\n                break;\n\n              case \"MEDIA-SEQUENCE\":\n                y = v.startSN = parseInt(P);\n                break;\n\n              case \"SKIP\":\n                var M = new g(P),\n                    N = M.decimalInteger(\"SKIPPED-SEGMENTS\");\n\n                if (Object(a.a)(N)) {\n                  v.skippedSegments = N;\n\n                  for (var B = N; B--;) p.unshift(null);\n\n                  y += N;\n                }\n\n                var U = M.enumeratedString(\"RECENTLY-REMOVED-DATERANGES\");\n                U && (v.recentlyRemovedDateranges = U.split(\"\\t\"));\n                break;\n\n              case \"TARGETDURATION\":\n                v.targetduration = parseFloat(P);\n                break;\n\n              case \"VERSION\":\n                v.version = parseInt(P);\n                break;\n\n              case \"EXTM3U\":\n                break;\n\n              case \"ENDLIST\":\n                v.live = !1;\n                break;\n\n              case \"#\":\n                (P || F) && _.tagList.push(F ? [P, F] : [P]);\n                break;\n\n              case \"DIS\":\n                A++;\n\n              case \"GAP\":\n                _.tagList.push([I]);\n\n                break;\n\n              case \"BITRATE\":\n                _.tagList.push([I, P]);\n\n                break;\n\n              case \"DISCONTINUITY-SEQ\":\n                A = parseInt(P);\n                break;\n\n              case \"KEY\":\n                var G,\n                    j = new g(P),\n                    H = j.enumeratedString(\"METHOD\"),\n                    K = j.URI,\n                    V = j.hexadecimalInteger(\"IV\"),\n                    W = j.enumeratedString(\"KEYFORMATVERSIONS\"),\n                    Y = j.enumeratedString(\"KEYID\"),\n                    X = null != (G = j.enumeratedString(\"KEYFORMAT\")) ? G : \"identity\";\n\n                if ([\"com.apple.streamingkeydelivery\", \"com.microsoft.playready\", \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\", \"com.widevine\"].indexOf(X) > -1) {\n                  o.b.warn(\"Keyformat \" + X + \" is not supported from the manifest\");\n                  continue;\n                }\n\n                if (\"identity\" !== X) continue;\n                H && (c = f.a.fromURL(e, K), K && [\"AES-128\", \"SAMPLE-AES\", \"SAMPLE-AES-CENC\"].indexOf(H) >= 0 && (c.method = H, c.keyFormat = X, Y && (c.keyID = Y), W && (c.keyFormatVersions = W), c.iv = V));\n                break;\n\n              case \"START\":\n                var q = new g(P).decimalFloatingPoint(\"TIME-OFFSET\");\n                Object(a.a)(q) && (v.startTimeOffset = q);\n                break;\n\n              case \"MAP\":\n                var z = new g(P);\n                _.relurl = z.URI, z.BYTERANGE && _.setByteRange(z.BYTERANGE), _.level = r, _.sn = \"initSegment\", c && (_.levelkey = c), _.initSegment = null, m = _, x = !0;\n                break;\n\n              case \"SERVER-CONTROL\":\n                var Q = new g(P);\n                v.canBlockReload = Q.bool(\"CAN-BLOCK-RELOAD\"), v.canSkipUntil = Q.optionalFloat(\"CAN-SKIP-UNTIL\", 0), v.canSkipDateRanges = v.canSkipUntil > 0 && Q.bool(\"CAN-SKIP-DATERANGES\"), v.partHoldBack = Q.optionalFloat(\"PART-HOLD-BACK\", 0), v.holdBack = Q.optionalFloat(\"HOLD-BACK\", 0);\n                break;\n\n              case \"PART-INF\":\n                var $ = new g(P);\n                v.partTarget = $.decimalFloatingPoint(\"PART-TARGET\");\n                break;\n\n              case \"PART\":\n                var Z = v.partList;\n                Z || (Z = v.partList = []);\n                var J = b > 0 ? Z[Z.length - 1] : void 0,\n                    tt = b++,\n                    et = new u.c(new g(P), _, e, tt, J);\n                Z.push(et), _.duration += et.duration;\n                break;\n\n              case \"PRELOAD-HINT\":\n                var rt = new g(P);\n                v.preloadHint = rt;\n                break;\n\n              case \"RENDITION-REPORT\":\n                var it = new g(P);\n                v.renditionReports = v.renditionReports || [], v.renditionReports.push(it);\n                break;\n\n              default:\n                o.b.warn(\"line parsed but not handled: \" + l);\n            }\n          }\n        }\n\n        R && !R.relurl ? (p.pop(), L -= R.duration, v.partList && (v.fragmentHint = R)) : v.partList && (D(_, R), _.cc = A, v.fragmentHint = _);\n        var at = p.length,\n            nt = p[0],\n            st = p[at - 1];\n\n        if ((L += v.skippedSegments * v.targetduration) > 0 && at && st) {\n          v.averagetargetduration = L / at;\n          var ot = st.sn;\n          v.endSN = \"initSegment\" !== ot ? ot : 0, nt && (v.startCC = nt.cc, nt.initSegment || v.fragments.every(function (t) {\n            return t.relurl && (e = t.relurl, S.test(null != (r = null === (a = i.parseURL(e)) || void 0 === a ? void 0 : a.path) ? r : \"\"));\n            var e, r, a;\n          }) && (o.b.warn(\"MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX\"), (_ = new u.b(n, e)).relurl = st.relurl, _.level = r, _.sn = \"initSegment\", nt.initSegment = _, v.needSidxRanges = !0));\n        } else v.endSN = 0, v.startCC = 0;\n\n        return v.fragmentHint && (L += v.fragmentHint.duration), v.totalduration = L, v.endCC = A, k > 0 && function (t, e) {\n          for (var r = t[e], i = e; i--;) {\n            var a = t[i];\n            if (!a) return;\n            a.programDateTime = r.programDateTime - 1e3 * a.duration, r = a;\n          }\n        }(p, k), v;\n      }, t;\n    }();\n\n    function A(t, e) {\n      [\"video\", \"audio\", \"text\"].forEach(function (r) {\n        var i = t.filter(function (t) {\n          return function (t, e) {\n            var r = p[e];\n            return !!r && !0 === r[t.slice(0, 4)];\n          }(t, r);\n        });\n\n        if (i.length) {\n          var a = i.filter(function (t) {\n            return 0 === t.lastIndexOf(\"avc1\", 0) || 0 === t.lastIndexOf(\"mp4a\", 0);\n          });\n          e[r + \"Codec\"] = a.length > 0 ? a[0] : i[0], t = t.filter(function (t) {\n            return -1 === i.indexOf(t);\n          });\n        }\n      }), e.unknownCodecs = t;\n    }\n\n    function R(t, e, r) {\n      var i = e[r];\n      i && (t[r] = i);\n    }\n\n    function D(t, e) {\n      t.rawProgramDateTime ? t.programDateTime = Date.parse(t.rawProgramDateTime) : null != e && e.programDateTime && (t.programDateTime = e.endProgramDateTime), Object(a.a)(t.programDateTime) || (t.programDateTime = null, t.rawProgramDateTime = null);\n    }\n\n    var _ = r(4);\n\n    function k(t, e) {\n      var r = t.url;\n      return void 0 !== r && 0 !== r.indexOf(\"data:\") || (r = e.url), r;\n    }\n\n    var x = function () {\n      function t(t) {\n        this.hls = void 0, this.loaders = Object.create(null), this.hls = t, this.registerListeners();\n      }\n\n      var e = t.prototype;\n      return e.registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.MANIFEST_LOADING, this.onManifestLoading, this), t.on(n.a.LEVEL_LOADING, this.onLevelLoading, this), t.on(n.a.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), t.on(n.a.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n      }, e.unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.MANIFEST_LOADING, this.onManifestLoading, this), t.off(n.a.LEVEL_LOADING, this.onLevelLoading, this), t.off(n.a.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), t.off(n.a.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n      }, e.createInternalLoader = function (t) {\n        var e = this.hls.config,\n            r = e.pLoader,\n            i = e.loader,\n            a = new (r || i)(e);\n        return t.loader = a, this.loaders[t.type] = a, a;\n      }, e.getInternalLoader = function (t) {\n        return this.loaders[t.type];\n      }, e.resetInternalLoader = function (t) {\n        this.loaders[t] && delete this.loaders[t];\n      }, e.destroyInternalLoaders = function () {\n        for (var t in this.loaders) {\n          var e = this.loaders[t];\n          e && e.destroy(), this.resetInternalLoader(t);\n        }\n      }, e.destroy = function () {\n        this.unregisterListeners(), this.destroyInternalLoaders();\n      }, e.onManifestLoading = function (t, e) {\n        var r = e.url;\n        this.load({\n          id: null,\n          groupId: null,\n          level: 0,\n          responseType: \"text\",\n          type: _.a.MANIFEST,\n          url: r,\n          deliveryDirectives: null\n        });\n      }, e.onLevelLoading = function (t, e) {\n        var r = e.id,\n            i = e.level,\n            a = e.url,\n            n = e.deliveryDirectives;\n        this.load({\n          id: r,\n          groupId: null,\n          level: i,\n          responseType: \"text\",\n          type: _.a.LEVEL,\n          url: a,\n          deliveryDirectives: n\n        });\n      }, e.onAudioTrackLoading = function (t, e) {\n        var r = e.id,\n            i = e.groupId,\n            a = e.url,\n            n = e.deliveryDirectives;\n        this.load({\n          id: r,\n          groupId: i,\n          level: null,\n          responseType: \"text\",\n          type: _.a.AUDIO_TRACK,\n          url: a,\n          deliveryDirectives: n\n        });\n      }, e.onSubtitleTrackLoading = function (t, e) {\n        var r = e.id,\n            i = e.groupId,\n            a = e.url,\n            n = e.deliveryDirectives;\n        this.load({\n          id: r,\n          groupId: i,\n          level: null,\n          responseType: \"text\",\n          type: _.a.SUBTITLE_TRACK,\n          url: a,\n          deliveryDirectives: n\n        });\n      }, e.load = function (t) {\n        var e,\n            r,\n            i,\n            a,\n            n,\n            s,\n            l = this.hls.config,\n            u = this.getInternalLoader(t);\n\n        if (u) {\n          var d = u.context;\n          if (d && d.url === t.url) return void o.b.trace(\"[playlist-loader]: playlist request ongoing\");\n          o.b.log(\"[playlist-loader]: aborting previous loader for type: \" + t.type), u.abort();\n        }\n\n        switch (t.type) {\n          case _.a.MANIFEST:\n            r = l.manifestLoadingMaxRetry, i = l.manifestLoadingTimeOut, a = l.manifestLoadingRetryDelay, n = l.manifestLoadingMaxRetryTimeout;\n            break;\n\n          case _.a.LEVEL:\n          case _.a.AUDIO_TRACK:\n          case _.a.SUBTITLE_TRACK:\n            r = 0, i = l.levelLoadingTimeOut;\n            break;\n\n          default:\n            r = l.levelLoadingMaxRetry, i = l.levelLoadingTimeOut, a = l.levelLoadingRetryDelay, n = l.levelLoadingMaxRetryTimeout;\n        }\n\n        if ((u = this.createInternalLoader(t), null !== (e = t.deliveryDirectives) && void 0 !== e && e.part) && (t.type === _.a.LEVEL && null !== t.level ? s = this.hls.levels[t.level].details : t.type === _.a.AUDIO_TRACK && null !== t.id ? s = this.hls.audioTracks[t.id].details : t.type === _.a.SUBTITLE_TRACK && null !== t.id && (s = this.hls.subtitleTracks[t.id].details), s)) {\n          var h = s.partTarget,\n              f = s.targetduration;\n          h && f && (i = Math.min(1e3 * Math.max(3 * h, .8 * f), i));\n        }\n\n        var c = {\n          timeout: i,\n          maxRetry: r,\n          retryDelay: a,\n          maxRetryDelay: n,\n          highWaterMark: 0\n        },\n            v = {\n          onSuccess: this.loadsuccess.bind(this),\n          onError: this.loaderror.bind(this),\n          onTimeout: this.loadtimeout.bind(this)\n        };\n        u.load(t, c, v);\n      }, e.loadsuccess = function (t, e, r, i) {\n        if (void 0 === i && (i = null), r.isSidxRequest) return this.handleSidxRequest(t, r), void this.handlePlaylistLoaded(t, e, r, i);\n        this.resetInternalLoader(r.type);\n        var a = t.data;\n        0 === a.indexOf(\"#EXTM3U\") ? (e.parsing.start = performance.now(), a.indexOf(\"#EXTINF:\") > 0 || a.indexOf(\"#EXT-X-TARGETDURATION:\") > 0 ? this.handleTrackOrLevelPlaylist(t, e, r, i) : this.handleMasterPlaylist(t, e, r, i)) : this.handleManifestParsingError(t, r, \"no EXTM3U delimiter\", i);\n      }, e.loaderror = function (t, e, r) {\n        void 0 === r && (r = null), this.handleNetworkError(e, r, !1, t);\n      }, e.loadtimeout = function (t, e, r) {\n        void 0 === r && (r = null), this.handleNetworkError(e, r, !0);\n      }, e.handleMasterPlaylist = function (t, e, r, i) {\n        var a = this.hls,\n            s = t.data,\n            l = k(t, r),\n            u = L.parseMasterPlaylist(s, l),\n            d = u.levels,\n            h = u.sessionData;\n\n        if (d.length) {\n          var f = d.map(function (t) {\n            return {\n              id: t.attrs.AUDIO,\n              audioCodec: t.audioCodec\n            };\n          }),\n              c = d.map(function (t) {\n            return {\n              id: t.attrs.SUBTITLES,\n              textCodec: t.textCodec\n            };\n          }),\n              v = L.parseMasterPlaylistMedia(s, l, \"AUDIO\", f),\n              p = L.parseMasterPlaylistMedia(s, l, \"SUBTITLES\", c),\n              m = L.parseMasterPlaylistMedia(s, l, \"CLOSED-CAPTIONS\");\n          if (v.length) v.some(function (t) {\n            return !t.url;\n          }) || !d[0].audioCodec || d[0].attrs.AUDIO || (o.b.log(\"[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one\"), v.unshift({\n            type: \"main\",\n            name: \"main\",\n            default: !1,\n            autoselect: !1,\n            forced: !1,\n            id: -1,\n            attrs: new g({}),\n            bitrate: 0,\n            url: \"\"\n          }));\n          a.trigger(n.a.MANIFEST_LOADED, {\n            levels: d,\n            audioTracks: v,\n            subtitles: p,\n            captions: m,\n            url: l,\n            stats: e,\n            networkDetails: i,\n            sessionData: h\n          });\n        } else this.handleManifestParsingError(t, r, \"no level found in manifest\", i);\n      }, e.handleTrackOrLevelPlaylist = function (t, e, r, i) {\n        var o = this.hls,\n            l = r.id,\n            u = r.level,\n            d = r.type,\n            h = k(t, r),\n            f = Object(a.a)(l) ? l : 0,\n            c = Object(a.a)(u) ? u : f,\n            v = function (t) {\n          switch (t.type) {\n            case _.a.AUDIO_TRACK:\n              return _.b.AUDIO;\n\n            case _.a.SUBTITLE_TRACK:\n              return _.b.SUBTITLE;\n\n            default:\n              return _.b.MAIN;\n          }\n        }(r),\n            p = L.parseLevelPlaylist(t.data, h, c, v, f);\n\n        if (p.fragments.length) {\n          if (d === _.a.MANIFEST) {\n            var m = {\n              attrs: new g({}),\n              bitrate: 0,\n              details: p,\n              name: \"\",\n              url: h\n            };\n            o.trigger(n.a.MANIFEST_LOADED, {\n              levels: [m],\n              audioTracks: [],\n              url: h,\n              stats: e,\n              networkDetails: i,\n              sessionData: null\n            });\n          }\n\n          if (e.parsing.end = performance.now(), p.needSidxRanges) {\n            var y,\n                b = null === (y = p.fragments[0].initSegment) || void 0 === y ? void 0 : y.url;\n            this.load({\n              url: b,\n              isSidxRequest: !0,\n              type: d,\n              level: u,\n              levelDetails: p,\n              id: l,\n              groupId: null,\n              rangeStart: 0,\n              rangeEnd: 2048,\n              responseType: \"arraybuffer\",\n              deliveryDirectives: null\n            });\n          } else r.levelDetails = p, this.handlePlaylistLoaded(t, e, r, i);\n        } else o.trigger(n.a.ERROR, {\n          type: s.b.NETWORK_ERROR,\n          details: s.a.LEVEL_EMPTY_ERROR,\n          fatal: !1,\n          url: h,\n          reason: \"no fragments found in level\",\n          level: \"number\" == typeof r.level ? r.level : void 0\n        });\n      }, e.handleSidxRequest = function (t, e) {\n        var r = Object(l.g)(new Uint8Array(t.data));\n\n        if (r) {\n          var i = r.references,\n              a = e.levelDetails;\n          i.forEach(function (t, e) {\n            var i = t.info,\n                n = a.fragments[e];\n            0 === n.byteRange.length && n.setByteRange(String(1 + i.end - i.start) + \"@\" + String(i.start)), n.initSegment && n.initSegment.setByteRange(String(r.moovEndOffset) + \"@0\");\n          });\n        }\n      }, e.handleManifestParsingError = function (t, e, r, i) {\n        this.hls.trigger(n.a.ERROR, {\n          type: s.b.NETWORK_ERROR,\n          details: s.a.MANIFEST_PARSING_ERROR,\n          fatal: e.type === _.a.MANIFEST,\n          url: t.url,\n          reason: r,\n          response: t,\n          context: e,\n          networkDetails: i\n        });\n      }, e.handleNetworkError = function (t, e, r, i) {\n        void 0 === r && (r = !1), o.b.warn(\"[playlist-loader]: A network \" + (r ? \"timeout\" : \"error\") + \" occurred while loading \" + t.type + \" level: \" + t.level + \" id: \" + t.id + ' group-id: \"' + t.groupId + '\"');\n        var a = s.a.UNKNOWN,\n            l = !1,\n            u = this.getInternalLoader(t);\n\n        switch (t.type) {\n          case _.a.MANIFEST:\n            a = r ? s.a.MANIFEST_LOAD_TIMEOUT : s.a.MANIFEST_LOAD_ERROR, l = !0;\n            break;\n\n          case _.a.LEVEL:\n            a = r ? s.a.LEVEL_LOAD_TIMEOUT : s.a.LEVEL_LOAD_ERROR, l = !1;\n            break;\n\n          case _.a.AUDIO_TRACK:\n            a = r ? s.a.AUDIO_TRACK_LOAD_TIMEOUT : s.a.AUDIO_TRACK_LOAD_ERROR, l = !1;\n            break;\n\n          case _.a.SUBTITLE_TRACK:\n            a = r ? s.a.SUBTITLE_TRACK_LOAD_TIMEOUT : s.a.SUBTITLE_LOAD_ERROR, l = !1;\n        }\n\n        u && this.resetInternalLoader(t.type);\n        var d = {\n          type: s.b.NETWORK_ERROR,\n          details: a,\n          fatal: l,\n          url: t.url,\n          loader: u,\n          context: t,\n          networkDetails: e\n        };\n        i && (d.response = i), this.hls.trigger(n.a.ERROR, d);\n      }, e.handlePlaylistLoaded = function (t, e, r, i) {\n        var a = r.type,\n            s = r.level,\n            o = r.id,\n            l = r.groupId,\n            u = r.loader,\n            d = r.levelDetails,\n            h = r.deliveryDirectives;\n\n        if (null != d && d.targetduration) {\n          if (u) switch (d.live && (u.getCacheAge && (d.ageHeader = u.getCacheAge() || 0), u.getCacheAge && !isNaN(d.ageHeader) || (d.ageHeader = 0)), a) {\n            case _.a.MANIFEST:\n            case _.a.LEVEL:\n              this.hls.trigger(n.a.LEVEL_LOADED, {\n                details: d,\n                level: s || 0,\n                id: o || 0,\n                stats: e,\n                networkDetails: i,\n                deliveryDirectives: h\n              });\n              break;\n\n            case _.a.AUDIO_TRACK:\n              this.hls.trigger(n.a.AUDIO_TRACK_LOADED, {\n                details: d,\n                id: o || 0,\n                groupId: l || \"\",\n                stats: e,\n                networkDetails: i,\n                deliveryDirectives: h\n              });\n              break;\n\n            case _.a.SUBTITLE_TRACK:\n              this.hls.trigger(n.a.SUBTITLE_TRACK_LOADED, {\n                details: d,\n                id: o || 0,\n                groupId: l || \"\",\n                stats: e,\n                networkDetails: i,\n                deliveryDirectives: h\n              });\n          }\n        } else this.handleManifestParsingError(t, r, \"invalid target duration\", i);\n      }, t;\n    }(),\n        C = function () {\n      function t(t) {\n        this.hls = void 0, this.loaders = {}, this.decryptkey = null, this.decrypturl = null, this.hls = t, this._registerListeners();\n      }\n\n      var e = t.prototype;\n      return e._registerListeners = function () {\n        this.hls.on(n.a.KEY_LOADING, this.onKeyLoading, this);\n      }, e._unregisterListeners = function () {\n        this.hls.off(n.a.KEY_LOADING, this.onKeyLoading);\n      }, e.destroy = function () {\n        for (var t in this._unregisterListeners(), this.loaders) {\n          var e = this.loaders[t];\n          e && e.destroy();\n        }\n\n        this.loaders = {};\n      }, e.onKeyLoading = function (t, e) {\n        var r = e.frag,\n            i = r.type,\n            a = this.loaders[i];\n\n        if (r.decryptdata) {\n          var s = r.decryptdata.uri;\n\n          if (s !== this.decrypturl || null === this.decryptkey) {\n            var l = this.hls.config;\n            if (a && (o.b.warn(\"abort previous key loader for type:\" + i), a.abort()), !s) return void o.b.warn(\"key uri is falsy\");\n            var u = l.loader,\n                d = r.loader = this.loaders[i] = new u(l);\n            this.decrypturl = s, this.decryptkey = null;\n            var h = {\n              url: s,\n              frag: r,\n              responseType: \"arraybuffer\"\n            },\n                f = {\n              timeout: l.fragLoadingTimeOut,\n              maxRetry: 0,\n              retryDelay: l.fragLoadingRetryDelay,\n              maxRetryDelay: l.fragLoadingMaxRetryTimeout,\n              highWaterMark: 0\n            },\n                c = {\n              onSuccess: this.loadsuccess.bind(this),\n              onError: this.loaderror.bind(this),\n              onTimeout: this.loadtimeout.bind(this)\n            };\n            d.load(h, f, c);\n          } else this.decryptkey && (r.decryptdata.key = this.decryptkey, this.hls.trigger(n.a.KEY_LOADED, {\n            frag: r\n          }));\n        } else o.b.warn(\"Missing decryption data on fragment in onKeyLoading\");\n      }, e.loadsuccess = function (t, e, r) {\n        var i = r.frag;\n        i.decryptdata ? (this.decryptkey = i.decryptdata.key = new Uint8Array(t.data), i.loader = null, delete this.loaders[i.type], this.hls.trigger(n.a.KEY_LOADED, {\n          frag: i\n        })) : o.b.error(\"after key load, decryptdata unset\");\n      }, e.loaderror = function (t, e) {\n        var r = e.frag,\n            i = r.loader;\n        i && i.abort(), delete this.loaders[r.type], this.hls.trigger(n.a.ERROR, {\n          type: s.b.NETWORK_ERROR,\n          details: s.a.KEY_LOAD_ERROR,\n          fatal: !1,\n          frag: r,\n          response: t\n        });\n      }, e.loadtimeout = function (t, e) {\n        var r = e.frag,\n            i = r.loader;\n        i && i.abort(), delete this.loaders[r.type], this.hls.trigger(n.a.ERROR, {\n          type: s.b.NETWORK_ERROR,\n          details: s.a.KEY_LOAD_TIMEOUT,\n          fatal: !1,\n          frag: r\n        });\n      }, t;\n    }();\n\n    function w(t, e) {\n      var r;\n\n      try {\n        r = new Event(\"addtrack\");\n      } catch (t) {\n        (r = document.createEvent(\"Event\")).initEvent(\"addtrack\", !1, !1);\n      }\n\n      r.track = t, e.dispatchEvent(r);\n    }\n\n    function O(t, e, r) {\n      var i = t.mode;\n      if (\"disabled\" === i && (t.mode = \"hidden\"), t.cues && t.cues.length > 0) for (var a = function (t, e, r) {\n        var i = [],\n            a = function (t, e) {\n          if (e < t[0].startTime) return 0;\n          var r = t.length - 1;\n          if (e > t[r].endTime) return -1;\n          var i = 0,\n              a = r;\n\n          for (; i <= a;) {\n            var n = Math.floor((a + i) / 2);\n            if (e < t[n].startTime) a = n - 1;else {\n              if (!(e > t[n].startTime && i < r)) return n;\n              i = n + 1;\n            }\n          }\n\n          return t[i].startTime - e < e - t[a].startTime ? i : a;\n        }(t, e);\n\n        if (a > -1) for (var n = a, s = t.length; n < s; n++) {\n          var o = t[n];\n          if (o.startTime >= e && o.endTime <= r) i.push(o);else if (o.startTime > r) return i;\n        }\n        return i;\n      }(t.cues, e, r), n = 0; n < a.length; n++) t.removeCue(a[n]);\n      \"disabled\" === i && (t.mode = i);\n    }\n\n    var I = r(7),\n        P = function () {\n      function t(t) {\n        this.hls = void 0, this.id3Track = null, this.media = null, this.hls = t, this._registerListeners();\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this._unregisterListeners();\n      }, e._registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(n.a.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), t.on(n.a.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      }, e._unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(n.a.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), t.off(n.a.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      }, e.onMediaAttached = function (t, e) {\n        this.media = e.media;\n      }, e.onMediaDetaching = function () {\n        this.id3Track && (!function (t) {\n          var e = t.mode;\n          if (\"disabled\" === e && (t.mode = \"hidden\"), t.cues) for (var r = t.cues.length; r--;) t.removeCue(t.cues[r]);\n          \"disabled\" === e && (t.mode = e);\n        }(this.id3Track), this.id3Track = null, this.media = null);\n      }, e.getID3Track = function (t) {\n        if (this.media) {\n          for (var e = 0; e < t.length; e++) {\n            var r = t[e];\n            if (\"metadata\" === r.kind && \"id3\" === r.label) return w(r, this.media), r;\n          }\n\n          return this.media.addTextTrack(\"metadata\", \"id3\");\n        }\n      }, e.onFragParsingMetadata = function (t, e) {\n        if (this.media) {\n          var r = e.frag,\n              i = e.samples;\n          this.id3Track || (this.id3Track = this.getID3Track(this.media.textTracks), this.id3Track.mode = \"hidden\");\n\n          for (var a = self.WebKitDataCue || self.VTTCue || self.TextTrackCue, n = 0; n < i.length; n++) {\n            var s = I.c(i[n].data);\n\n            if (s) {\n              var o = i[n].pts,\n                  l = n < i.length - 1 ? i[n + 1].pts : r.end;\n              l - o <= 0 && (l = o + .25);\n\n              for (var u = 0; u < s.length; u++) {\n                var d = s[u];\n\n                if (!I.e(d)) {\n                  var h = new a(o, l, \"\");\n                  h.value = d, this.id3Track.addCue(h);\n                }\n              }\n            }\n          }\n        }\n      }, e.onBufferFlushing = function (t, e) {\n        var r = e.startOffset,\n            i = e.endOffset,\n            a = e.type;\n\n        if (!a || \"audio\" === a) {\n          var n = this.id3Track;\n          n && O(n, r, i);\n        }\n      }, t;\n    }();\n\n    function F(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    var M,\n        N = function () {\n      function t(t) {\n        var e = this;\n        this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = function () {\n          return e.timeupdate();\n        }, this.hls = t, this.config = t.config, this.registerListeners();\n      }\n\n      var e,\n          r,\n          i,\n          a = t.prototype;\n      return a.destroy = function () {\n        this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null;\n      }, a.registerListeners = function () {\n        this.hls.on(n.a.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(n.a.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(n.a.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(n.a.ERROR, this.onError, this);\n      }, a.unregisterListeners = function () {\n        this.hls.off(n.a.MEDIA_ATTACHED, this.onMediaAttached), this.hls.off(n.a.MEDIA_DETACHING, this.onMediaDetaching), this.hls.off(n.a.MANIFEST_LOADING, this.onManifestLoading), this.hls.off(n.a.LEVEL_UPDATED, this.onLevelUpdated), this.hls.off(n.a.ERROR, this.onError);\n      }, a.onMediaAttached = function (t, e) {\n        this.media = e.media, this.media.addEventListener(\"timeupdate\", this.timeupdateHandler);\n      }, a.onMediaDetaching = function () {\n        this.media && (this.media.removeEventListener(\"timeupdate\", this.timeupdateHandler), this.media = null);\n      }, a.onManifestLoading = function () {\n        this.levelDetails = null, this._latency = null, this.stallCount = 0;\n      }, a.onLevelUpdated = function (t, e) {\n        var r = e.details;\n        this.levelDetails = r, r.advanced && this.timeupdate(), !r.live && this.media && this.media.removeEventListener(\"timeupdate\", this.timeupdateHandler);\n      }, a.onError = function (t, e) {\n        e.details === s.a.BUFFER_STALLED_ERROR && (this.stallCount++, o.b.warn(\"[playback-rate-controller]: Stall detected, adjusting target latency\"));\n      }, a.timeupdate = function () {\n        var t = this.media,\n            e = this.levelDetails;\n\n        if (t && e) {\n          this.currentTime = t.currentTime;\n          var r = this.computeLatency();\n\n          if (null !== r) {\n            this._latency = r;\n            var i = this.config,\n                a = i.lowLatencyMode,\n                n = i.maxLiveSyncPlaybackRate;\n\n            if (a && 1 !== n) {\n              var s = this.targetLatency;\n\n              if (null !== s) {\n                var o = r - s,\n                    l = o < Math.min(this.maxLatency, s + e.targetduration);\n\n                if (e.live && l && o > .05 && this.forwardBufferLength > 1) {\n                  var u = Math.min(2, Math.max(1, n)),\n                      d = Math.round(2 / (1 + Math.exp(-.75 * o - this.edgeStalled)) * 20) / 20;\n                  t.playbackRate = Math.min(u, Math.max(1, d));\n                } else 1 !== t.playbackRate && 0 !== t.playbackRate && (t.playbackRate = 1);\n              }\n            }\n          }\n        }\n      }, a.estimateLiveEdge = function () {\n        var t = this.levelDetails;\n        return null === t ? null : t.edge + t.age;\n      }, a.computeLatency = function () {\n        var t = this.estimateLiveEdge();\n        return null === t ? null : t - this.currentTime;\n      }, e = t, (r = [{\n        key: \"latency\",\n        get: function () {\n          return this._latency || 0;\n        }\n      }, {\n        key: \"maxLatency\",\n        get: function () {\n          var t = this.config,\n              e = this.levelDetails;\n          return void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : e ? t.liveMaxLatencyDurationCount * e.targetduration : 0;\n        }\n      }, {\n        key: \"targetLatency\",\n        get: function () {\n          var t = this.levelDetails;\n          if (null === t) return null;\n          var e = t.holdBack,\n              r = t.partHoldBack,\n              i = t.targetduration,\n              a = this.config,\n              n = a.liveSyncDuration,\n              s = a.liveSyncDurationCount,\n              o = a.lowLatencyMode,\n              l = this.hls.userConfig,\n              u = o && r || e;\n          (l.liveSyncDuration || l.liveSyncDurationCount || 0 === u) && (u = void 0 !== n ? n : s * i);\n          var d = i;\n          return u + Math.min(1 * this.stallCount, d);\n        }\n      }, {\n        key: \"liveSyncPosition\",\n        get: function () {\n          var t = this.estimateLiveEdge(),\n              e = this.targetLatency,\n              r = this.levelDetails;\n          if (null === t || null === e || null === r) return null;\n          var i = r.edge,\n              a = t - e - this.edgeStalled,\n              n = i - r.totalduration,\n              s = i - (this.config.lowLatencyMode && r.partTarget || r.targetduration);\n          return Math.min(Math.max(n, a), s);\n        }\n      }, {\n        key: \"drift\",\n        get: function () {\n          var t = this.levelDetails;\n          return null === t ? 1 : t.drift;\n        }\n      }, {\n        key: \"edgeStalled\",\n        get: function () {\n          var t = this.levelDetails;\n          if (null === t) return 0;\n          var e = 3 * (this.config.lowLatencyMode && t.partTarget || t.targetduration);\n          return Math.max(t.age - e, 0);\n        }\n      }, {\n        key: \"forwardBufferLength\",\n        get: function () {\n          var t = this.media,\n              e = this.levelDetails;\n          if (!t || !e) return 0;\n          var r = t.buffered.length;\n          return r ? t.buffered.end(r - 1) : e.edge - this.currentTime;\n        }\n      }]) && F(e.prototype, r), i && F(e, i), t;\n    }();\n\n    function B(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    !function (t) {\n      t.No = \"\", t.Yes = \"YES\", t.v2 = \"v2\";\n    }(M || (M = {}));\n\n    var U = function () {\n      function t(t, e, r) {\n        this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = t, this.part = e, this.skip = r;\n      }\n\n      return t.prototype.addDirectives = function (t) {\n        var e = new self.URL(t);\n        return void 0 !== this.msn && e.searchParams.set(\"_HLS_msn\", this.msn.toString()), void 0 !== this.part && e.searchParams.set(\"_HLS_part\", this.part.toString()), this.skip && e.searchParams.set(\"_HLS_skip\", this.skip), e.toString();\n      }, t;\n    }(),\n        G = function () {\n      function t(t) {\n        this.attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.audioGroupIds = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this._urlId = 0, this.url = [t.url], this.attrs = t.attrs, this.bitrate = t.bitrate, t.details && (this.details = t.details), this.id = t.id || 0, this.name = t.name, this.width = t.width || 0, this.height = t.height || 0, this.audioCodec = t.audioCodec, this.videoCodec = t.videoCodec, this.unknownCodecs = t.unknownCodecs, this.codecSet = [t.videoCodec, t.audioCodec].filter(function (t) {\n          return t;\n        }).join(\",\").replace(/\\.[^.,]+/g, \"\");\n      }\n\n      var e, r, i;\n      return e = t, (r = [{\n        key: \"maxBitrate\",\n        get: function () {\n          return Math.max(this.realBitrate, this.bitrate);\n        }\n      }, {\n        key: \"uri\",\n        get: function () {\n          return this.url[this._urlId] || \"\";\n        }\n      }, {\n        key: \"urlId\",\n        get: function () {\n          return this._urlId;\n        },\n        set: function (t) {\n          var e = t % this.url.length;\n          this._urlId !== e && (this.details = void 0, this._urlId = e);\n        }\n      }]) && B(e.prototype, r), i && B(e, i), t;\n    }();\n\n    function j(t, e, r) {\n      switch (e) {\n        case \"audio\":\n          t.audioGroupIds || (t.audioGroupIds = []), t.audioGroupIds.push(r);\n          break;\n\n        case \"text\":\n          t.textGroupIds || (t.textGroupIds = []), t.textGroupIds.push(r);\n      }\n    }\n\n    function H(t) {\n      var e = {};\n      t.forEach(function (t) {\n        var r = t.groupId || \"\";\n        t.id = e[r] = e[r] || 0, e[r]++;\n      });\n    }\n\n    function K(t, e) {\n      var r = e.startPTS;\n\n      if (Object(a.a)(r)) {\n        var i,\n            n = 0;\n        e.sn > t.sn ? (n = r - t.start, i = t) : (n = t.start - r, i = e), i.duration !== n && (i.duration = n);\n      } else if (e.sn > t.sn) {\n        t.cc === e.cc && t.minEndPTS ? e.start = t.start + (t.minEndPTS - t.start) : e.start = t.start + t.duration;\n      } else e.start = Math.max(t.start - e.duration, 0);\n    }\n\n    function V(t, e, r, i, n, s) {\n      i - r <= 0 && (o.b.warn(\"Fragment should have a positive duration\", e), i = r + e.duration, s = n + e.duration);\n      var l = r,\n          u = i,\n          d = e.startPTS,\n          h = e.endPTS;\n\n      if (Object(a.a)(d)) {\n        var f = Math.abs(d - r);\n        Object(a.a)(e.deltaPTS) ? e.deltaPTS = Math.max(f, e.deltaPTS) : e.deltaPTS = f, l = Math.max(r, d), r = Math.min(r, d), n = Math.min(n, e.startDTS), u = Math.min(i, h), i = Math.max(i, h), s = Math.max(s, e.endDTS);\n      }\n\n      e.duration = i - r;\n      var c = r - e.start;\n      e.appendedPTS = i, e.start = e.startPTS = r, e.maxStartPTS = l, e.startDTS = n, e.endPTS = i, e.minEndPTS = u, e.endDTS = s;\n      var v,\n          g = e.sn;\n      if (!t || g < t.startSN || g > t.endSN) return 0;\n      var p = g - t.startSN,\n          m = t.fragments;\n\n      for (m[p] = e, v = p; v > 0; v--) K(m[v], m[v - 1]);\n\n      for (v = p; v < m.length - 1; v++) K(m[v], m[v + 1]);\n\n      return t.fragmentHint && K(m[m.length - 1], t.fragmentHint), t.PTSKnown = t.alignedSliding = !0, c;\n    }\n\n    function W(t, e) {\n      for (var r = null, i = t.fragments, n = i.length - 1; n >= 0; n--) {\n        var s = i[n].initSegment;\n\n        if (s) {\n          r = s;\n          break;\n        }\n      }\n\n      t.fragmentHint && delete t.fragmentHint.endPTS;\n      var l,\n          u = 0;\n      ((function (t, e, r) {\n        for (var i = e.skippedSegments, a = Math.max(t.startSN, e.startSN) - e.startSN, n = (t.fragmentHint ? 1 : 0) + (i ? e.endSN : Math.min(t.endSN, e.endSN)) - e.startSN, s = e.startSN - t.startSN, o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, l = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments, u = a; u <= n; u++) {\n          var d = l[s + u],\n              h = o[u];\n          i && !h && u < i && (h = e.fragments[u] = d), d && h && r(d, h);\n        }\n      })(t, e, function (t, i) {\n        t.relurl && (u = t.cc - i.cc), Object(a.a)(t.startPTS) && Object(a.a)(t.endPTS) && (i.start = i.startPTS = t.startPTS, i.startDTS = t.startDTS, i.appendedPTS = t.appendedPTS, i.maxStartPTS = t.maxStartPTS, i.endPTS = t.endPTS, i.endDTS = t.endDTS, i.minEndPTS = t.minEndPTS, i.duration = t.endPTS - t.startPTS, i.duration && (l = i), e.PTSKnown = e.alignedSliding = !0), i.elementaryStreams = t.elementaryStreams, i.loader = t.loader, i.stats = t.stats, i.urlId = t.urlId, t.initSegment && (i.initSegment = t.initSegment, r = t.initSegment);\n      }), r) && (e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments).forEach(function (t) {\n        var e;\n        t.initSegment && t.initSegment.relurl !== (null === (e = r) || void 0 === e ? void 0 : e.relurl) || (t.initSegment = r);\n      });\n\n      if (e.skippedSegments && (e.deltaUpdateFailed = e.fragments.some(function (t) {\n        return !t;\n      }), e.deltaUpdateFailed)) {\n        o.b.warn(\"[level-helper] Previous playlist missing segments skipped in delta playlist\");\n\n        for (var d = e.skippedSegments; d--;) e.fragments.shift();\n\n        e.startSN = e.fragments[0].sn, e.startCC = e.fragments[0].cc;\n      }\n\n      var h = e.fragments;\n\n      if (u) {\n        o.b.warn(\"discontinuity sliding from playlist, take drift into account\");\n\n        for (var f = 0; f < h.length; f++) h[f].cc += u;\n      }\n\n      e.skippedSegments && (e.startCC = e.fragments[0].cc), function (t, e, r) {\n        if (t && e) for (var i = 0, a = 0, n = t.length; a <= n; a++) {\n          var s = t[a],\n              o = e[a + i];\n          s && o && s.index === o.index && s.fragment.sn === o.fragment.sn ? r(s, o) : i--;\n        }\n      }(t.partList, e.partList, function (t, e) {\n        e.elementaryStreams = t.elementaryStreams, e.stats = t.stats;\n      }), l ? V(e, l, l.startPTS, l.endPTS, l.startDTS, l.endDTS) : Y(t, e), h.length && (e.totalduration = e.edge - h[0].start), e.driftStartTime = t.driftStartTime, e.driftStart = t.driftStart;\n      var c = e.advancedDateTime;\n\n      if (e.advanced && c) {\n        var v = e.edge;\n        e.driftStart || (e.driftStartTime = c, e.driftStart = v), e.driftEndTime = c, e.driftEnd = v;\n      } else e.driftEndTime = t.driftEndTime, e.driftEnd = t.driftEnd, e.advancedDateTime = t.advancedDateTime;\n    }\n\n    function Y(t, e) {\n      var r = e.startSN + e.skippedSegments - t.startSN,\n          i = t.fragments;\n      r < 0 || r >= i.length || function (t, e) {\n        if (e) {\n          for (var r = t.fragments, i = t.skippedSegments; i < r.length; i++) r[i].start += e;\n\n          t.fragmentHint && (t.fragmentHint.start += e);\n        }\n      }(e, i[r].start);\n    }\n\n    var X = function () {\n      function t(t, e) {\n        this.hls = void 0, this.timer = -1, this.canLoad = !1, this.retryCount = 0, this.log = void 0, this.warn = void 0, this.log = o.b.log.bind(o.b, e + \":\"), this.warn = o.b.warn.bind(o.b, e + \":\"), this.hls = t;\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.clearTimer(), this.hls = this.log = this.warn = null;\n      }, e.onError = function (t, e) {\n        e.fatal && e.type === s.b.NETWORK_ERROR && this.clearTimer();\n      }, e.clearTimer = function () {\n        clearTimeout(this.timer), this.timer = -1;\n      }, e.startLoad = function () {\n        this.canLoad = !0, this.retryCount = 0, this.loadPlaylist();\n      }, e.stopLoad = function () {\n        this.canLoad = !1, this.clearTimer();\n      }, e.switchParams = function (t, e) {\n        var r = null == e ? void 0 : e.renditionReports;\n        if (r) for (var i = 0; i < r.length; i++) {\n          var n = r[i],\n              s = \"\" + n.URI;\n\n          if (s === t.substr(-s.length)) {\n            var o = parseInt(n[\"LAST-MSN\"]),\n                l = parseInt(n[\"LAST-PART\"]);\n\n            if (e && this.hls.config.lowLatencyMode) {\n              var u = Math.min(e.age - e.partTarget, e.targetduration);\n              void 0 !== l && u > e.partTarget && (l += 1);\n            }\n\n            if (Object(a.a)(o)) return new U(o, Object(a.a)(l) ? l : void 0, M.No);\n          }\n        }\n      }, e.loadPlaylist = function (t) {}, e.shouldLoadTrack = function (t) {\n        return this.canLoad && t && !!t.url && (!t.details || t.details.live);\n      }, e.playlistLoaded = function (t, e, r) {\n        var i = this,\n            a = e.details,\n            n = e.stats,\n            s = n.loading.end ? Math.max(0, self.performance.now() - n.loading.end) : 0;\n\n        if (a.advancedDateTime = Date.now() - s, a.live || null != r && r.live) {\n          if (a.reloaded(r), r && this.log(\"live playlist \" + t + \" \" + (a.advanced ? \"REFRESHED \" + a.lastPartSn + \"-\" + a.lastPartIndex : \"MISSED\")), r && a.fragments.length > 0 && W(r, a), !this.canLoad || !a.live) return;\n          var o,\n              l = void 0,\n              u = void 0;\n\n          if (a.canBlockReload && a.endSN && a.advanced) {\n            var d = this.hls.config.lowLatencyMode,\n                h = a.lastPartSn,\n                f = a.endSN,\n                c = a.lastPartIndex,\n                v = h === f;\n            -1 !== c ? (l = v ? f + 1 : h, u = v ? d ? 0 : c : c + 1) : l = f + 1;\n            var g = a.age,\n                p = g + a.ageHeader,\n                m = Math.min(p - a.partTarget, 1.5 * a.targetduration);\n\n            if (m > 0) {\n              if (r && m > r.tuneInGoal) this.warn(\"CDN Tune-in goal increased from: \" + r.tuneInGoal + \" to: \" + m + \" with playlist age: \" + a.age), m = 0;else {\n                var y = Math.floor(m / a.targetduration);\n                if (l += y, void 0 !== u) u += Math.round(m % a.targetduration / a.partTarget);\n                this.log(\"CDN Tune-in age: \" + a.ageHeader + \"s last advanced \" + g.toFixed(2) + \"s goal: \" + m + \" skip sn \" + y + \" to part \" + u);\n              }\n              a.tuneInGoal = m;\n            }\n\n            if (o = this.getDeliveryDirectives(a, e.deliveryDirectives, l, u), d || !v) return void this.loadPlaylist(o);\n          } else o = this.getDeliveryDirectives(a, e.deliveryDirectives, l, u);\n\n          var b = function (t, e) {\n            var r,\n                i = 1e3 * t.levelTargetDuration,\n                a = i / 2,\n                n = t.age,\n                s = n > 0 && n < 3 * i,\n                o = e.loading.end - e.loading.start,\n                l = t.availabilityDelay;\n            if (!1 === t.updated) {\n              if (s) {\n                var u = 333 * t.misses;\n                r = Math.max(Math.min(a, 2 * o), u), t.availabilityDelay = (t.availabilityDelay || 0) + r;\n              } else r = a;\n            } else s ? (l = Math.min(l || i / 2, n), t.availabilityDelay = l, r = l + i - n) : r = i - o;\n            return Math.round(r);\n          }(a, n);\n\n          void 0 !== l && a.canBlockReload && (b -= a.partTarget || 1), this.log(\"reload live playlist \" + t + \" in \" + Math.round(b) + \" ms\"), this.timer = self.setTimeout(function () {\n            return i.loadPlaylist(o);\n          }, b);\n        } else this.clearTimer();\n      }, e.getDeliveryDirectives = function (t, e, r, i) {\n        var a = function (t, e) {\n          var r = t.canSkipUntil,\n              i = t.canSkipDateRanges,\n              a = t.endSN;\n          return r && (void 0 !== e ? e - a : 0) < r ? i ? M.v2 : M.Yes : M.No;\n        }(t, r);\n\n        return null != e && e.skip && t.deltaUpdateFailed && (r = e.msn, i = e.part, a = M.No), new U(r, i, a);\n      }, e.retryLoadingOrFail = function (t) {\n        var e,\n            r = this,\n            i = this.hls.config,\n            a = this.retryCount < i.levelLoadingMaxRetry;\n        if (a) {\n          if (this.retryCount++, t.details.indexOf(\"LoadTimeOut\") > -1 && null !== (e = t.context) && void 0 !== e && e.deliveryDirectives) this.warn(\"retry playlist loading #\" + this.retryCount + ' after \"' + t.details + '\"'), this.loadPlaylist();else {\n            var n = Math.min(Math.pow(2, this.retryCount) * i.levelLoadingRetryDelay, i.levelLoadingMaxRetryTimeout);\n            this.timer = self.setTimeout(function () {\n              return r.loadPlaylist();\n            }, n), this.warn(\"retry playlist loading #\" + this.retryCount + \" in \" + n + ' ms after \"' + t.details + '\"');\n          }\n        } else this.warn('cannot recover from error \"' + t.details + '\"'), this.clearTimer(), t.fatal = !0;\n        return a;\n      }, t;\n    }();\n\n    function q() {\n      return (q = Object.assign || function (t) {\n        for (var e = 1; e < arguments.length; e++) {\n          var r = arguments[e];\n\n          for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);\n        }\n\n        return t;\n      }).apply(this, arguments);\n    }\n\n    function z(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    function Q(t, e) {\n      return (Q = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    var $,\n        Z = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),\n        J = function (t) {\n      var e, r;\n\n      function i(e) {\n        var r;\n        return (r = t.call(this, e, \"[level-controller]\") || this)._levels = [], r._firstLevel = -1, r._startLevel = void 0, r.currentLevelIndex = -1, r.manualLevelIndex = -1, r.onParsedComplete = void 0, r._registerListeners(), r;\n      }\n\n      r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Q(e, r);\n      var a,\n          o,\n          l,\n          u = i.prototype;\n      return u._registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.MANIFEST_LOADED, this.onManifestLoaded, this), t.on(n.a.LEVEL_LOADED, this.onLevelLoaded, this), t.on(n.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.on(n.a.FRAG_LOADED, this.onFragLoaded, this), t.on(n.a.ERROR, this.onError, this);\n      }, u._unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.MANIFEST_LOADED, this.onManifestLoaded, this), t.off(n.a.LEVEL_LOADED, this.onLevelLoaded, this), t.off(n.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.off(n.a.FRAG_LOADED, this.onFragLoaded, this), t.off(n.a.ERROR, this.onError, this);\n      }, u.destroy = function () {\n        this._unregisterListeners(), this.manualLevelIndex = -1, this._levels.length = 0, t.prototype.destroy.call(this);\n      }, u.startLoad = function () {\n        this._levels.forEach(function (t) {\n          t.loadError = 0;\n        }), t.prototype.startLoad.call(this);\n      }, u.onManifestLoaded = function (t, e) {\n        var r,\n            i,\n            a = [],\n            o = [],\n            l = [],\n            u = {},\n            d = !1,\n            h = !1,\n            f = !1;\n\n        if (e.levels.forEach(function (t) {\n          var e = t.attrs;\n          d = d || !(!t.width || !t.height), h = h || !!t.videoCodec, f = f || !!t.audioCodec, Z && t.audioCodec && -1 !== t.audioCodec.indexOf(\"mp4a.40.34\") && (t.audioCodec = void 0);\n          var r = t.bitrate + \"-\" + t.attrs.RESOLUTION + \"-\" + t.attrs.CODECS;\n          (i = u[r]) ? i.url.push(t.url) : (i = new G(t), u[r] = i, a.push(i)), e && (e.AUDIO && j(i, \"audio\", e.AUDIO), e.SUBTITLES && j(i, \"text\", e.SUBTITLES));\n        }), (d || h) && f && (a = a.filter(function (t) {\n          var e = t.videoCodec,\n              r = t.width,\n              i = t.height;\n          return !!e || !(!r || !i);\n        })), a = a.filter(function (t) {\n          var e = t.audioCodec,\n              r = t.videoCodec;\n          return (!e || m(e, \"audio\")) && (!r || m(r, \"video\"));\n        }), e.audioTracks && H(o = e.audioTracks.filter(function (t) {\n          return !t.audioCodec || m(t.audioCodec, \"audio\");\n        })), e.subtitles && H(l = e.subtitles), a.length > 0) {\n          r = a[0].bitrate, a.sort(function (t, e) {\n            return t.bitrate - e.bitrate;\n          }), this._levels = a;\n\n          for (var c = 0; c < a.length; c++) if (a[c].bitrate === r) {\n            this._firstLevel = c, this.log(\"manifest loaded, \" + a.length + \" level(s) found, first bitrate: \" + r);\n            break;\n          }\n\n          var v = f && !h,\n              g = {\n            levels: a,\n            audioTracks: o,\n            subtitleTracks: l,\n            firstLevel: this._firstLevel,\n            stats: e.stats,\n            audio: f,\n            video: h,\n            altAudio: !v && o.some(function (t) {\n              return !!t.url;\n            })\n          };\n          this.hls.trigger(n.a.MANIFEST_PARSED, g), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition);\n        } else this.hls.trigger(n.a.ERROR, {\n          type: s.b.MEDIA_ERROR,\n          details: s.a.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n          fatal: !0,\n          url: e.url,\n          reason: \"no level with compatible codecs found in manifest\"\n        });\n      }, u.onError = function (e, r) {\n        if (t.prototype.onError.call(this, e, r), !r.fatal) {\n          var i = r.context,\n              a = this._levels[this.currentLevelIndex];\n          if (i && (i.type === _.a.AUDIO_TRACK && a.audioGroupIds && i.groupId === a.audioGroupIds[a.urlId] || i.type === _.a.SUBTITLE_TRACK && a.textGroupIds && i.groupId === a.textGroupIds[a.urlId])) this.redundantFailover(this.currentLevelIndex);else {\n            var n,\n                o = !1,\n                l = !0;\n\n            switch (r.details) {\n              case s.a.FRAG_LOAD_ERROR:\n              case s.a.FRAG_LOAD_TIMEOUT:\n              case s.a.KEY_LOAD_ERROR:\n              case s.a.KEY_LOAD_TIMEOUT:\n                if (r.frag) {\n                  var u = this._levels[r.frag.level];\n                  u ? (u.fragmentError++, u.fragmentError > this.hls.config.fragLoadingMaxRetry && (n = r.frag.level)) : n = r.frag.level;\n                }\n\n                break;\n\n              case s.a.LEVEL_LOAD_ERROR:\n              case s.a.LEVEL_LOAD_TIMEOUT:\n                i && (i.deliveryDirectives && (l = !1), n = i.level), o = !0;\n                break;\n\n              case s.a.REMUX_ALLOC_ERROR:\n                n = r.level, o = !0;\n            }\n\n            void 0 !== n && this.recoverLevel(r, n, o, l);\n          }\n        }\n      }, u.recoverLevel = function (t, e, r, i) {\n        var a = t.details,\n            n = this._levels[e];\n\n        if (n.loadError++, r) {\n          if (!this.retryLoadingOrFail(t)) return void (this.currentLevelIndex = -1);\n          t.levelRetry = !0;\n        }\n\n        if (i) {\n          var s = n.url.length;\n          if (s > 1 && n.loadError < s) t.levelRetry = !0, this.redundantFailover(e);else if (-1 === this.manualLevelIndex) {\n            var o = 0 === e ? this._levels.length - 1 : e - 1;\n            this.currentLevelIndex !== o && 0 === this._levels[o].loadError && (this.warn(a + \": switch to \" + o), t.levelRetry = !0, this.hls.nextAutoLevel = o);\n          }\n        }\n      }, u.redundantFailover = function (t) {\n        var e = this._levels[t],\n            r = e.url.length;\n\n        if (r > 1) {\n          var i = (e.urlId + 1) % r;\n          this.warn(\"Switching to redundant URL-id \" + i), this._levels.forEach(function (t) {\n            t.urlId = i;\n          }), this.level = t;\n        }\n      }, u.onFragLoaded = function (t, e) {\n        var r = e.frag;\n\n        if (void 0 !== r && r.type === _.b.MAIN) {\n          var i = this._levels[r.level];\n          void 0 !== i && (i.fragmentError = 0, i.loadError = 0);\n        }\n      }, u.onLevelLoaded = function (t, e) {\n        var r,\n            i,\n            a = e.level,\n            n = e.details,\n            s = this._levels[a];\n        if (!s) return this.warn(\"Invalid level index \" + a), void (null !== (i = e.deliveryDirectives) && void 0 !== i && i.skip && (n.deltaUpdateFailed = !0));\n        a === this.currentLevelIndex ? (0 === s.fragmentError && (s.loadError = 0, this.retryCount = 0), this.playlistLoaded(a, e, s.details)) : null !== (r = e.deliveryDirectives) && void 0 !== r && r.skip && (n.deltaUpdateFailed = !0);\n      }, u.onAudioTrackSwitched = function (t, e) {\n        var r = this.hls.levels[this.currentLevelIndex];\n\n        if (r && r.audioGroupIds) {\n          for (var i = -1, a = this.hls.audioTracks[e.id].groupId, n = 0; n < r.audioGroupIds.length; n++) if (r.audioGroupIds[n] === a) {\n            i = n;\n            break;\n          }\n\n          i !== r.urlId && (r.urlId = i, this.startLoad());\n        }\n      }, u.loadPlaylist = function (t) {\n        var e = this.currentLevelIndex,\n            r = this._levels[e];\n\n        if (this.canLoad && r && r.url.length > 0) {\n          var i = r.urlId,\n              a = r.url[i];\n          if (t) try {\n            a = t.addDirectives(a);\n          } catch (t) {\n            this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + t);\n          }\n          this.log(\"Attempt loading level index \" + e + (t ? \" at sn \" + t.msn + \" part \" + t.part : \"\") + \" with URL-id \" + i + \" \" + a), this.clearTimer(), this.hls.trigger(n.a.LEVEL_LOADING, {\n            url: a,\n            level: e,\n            id: i,\n            deliveryDirectives: t || null\n          });\n        }\n      }, u.removeLevel = function (t, e) {\n        var r = function (t, r) {\n          return r !== e;\n        },\n            i = this._levels.filter(function (i, a) {\n          return a !== t || i.url.length > 1 && void 0 !== e && (i.url = i.url.filter(r), i.audioGroupIds && (i.audioGroupIds = i.audioGroupIds.filter(r)), i.textGroupIds && (i.textGroupIds = i.textGroupIds.filter(r)), i.urlId = 0, !0);\n        }).map(function (t, e) {\n          var r = t.details;\n          return null != r && r.fragments && r.fragments.forEach(function (t) {\n            t.level = e;\n          }), t;\n        });\n\n        this._levels = i, this.hls.trigger(n.a.LEVELS_UPDATED, {\n          levels: i\n        });\n      }, a = i, (o = [{\n        key: \"levels\",\n        get: function () {\n          return 0 === this._levels.length ? null : this._levels;\n        }\n      }, {\n        key: \"level\",\n        get: function () {\n          return this.currentLevelIndex;\n        },\n        set: function (t) {\n          var e,\n              r = this._levels;\n\n          if (0 !== r.length && (this.currentLevelIndex !== t || null === (e = r[t]) || void 0 === e || !e.details)) {\n            if (t < 0 || t >= r.length) {\n              var i = t < 0;\n              if (this.hls.trigger(n.a.ERROR, {\n                type: s.b.OTHER_ERROR,\n                details: s.a.LEVEL_SWITCH_ERROR,\n                level: t,\n                fatal: i,\n                reason: \"invalid level idx\"\n              }), i) return;\n              t = Math.min(t, r.length - 1);\n            }\n\n            this.clearTimer();\n            var a = this.currentLevelIndex,\n                o = r[a],\n                l = r[t];\n            this.log(\"switching to level \" + t + \" from \" + a), this.currentLevelIndex = t;\n            var u = q({}, l, {\n              level: t,\n              maxBitrate: l.maxBitrate,\n              uri: l.uri,\n              urlId: l.urlId\n            });\n            delete u._urlId, this.hls.trigger(n.a.LEVEL_SWITCHING, u);\n            var d = l.details;\n\n            if (!d || d.live) {\n              var h = this.switchParams(l.uri, null == o ? void 0 : o.details);\n              this.loadPlaylist(h);\n            }\n          }\n        }\n      }, {\n        key: \"manualLevel\",\n        get: function () {\n          return this.manualLevelIndex;\n        },\n        set: function (t) {\n          this.manualLevelIndex = t, void 0 === this._startLevel && (this._startLevel = t), -1 !== t && (this.level = t);\n        }\n      }, {\n        key: \"firstLevel\",\n        get: function () {\n          return this._firstLevel;\n        },\n        set: function (t) {\n          this._firstLevel = t;\n        }\n      }, {\n        key: \"startLevel\",\n        get: function () {\n          if (void 0 === this._startLevel) {\n            var t = this.hls.config.startLevel;\n            return void 0 !== t ? t : this._firstLevel;\n          }\n\n          return this._startLevel;\n        },\n        set: function (t) {\n          this._startLevel = t;\n        }\n      }, {\n        key: \"nextLoadLevel\",\n        get: function () {\n          return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel;\n        },\n        set: function (t) {\n          this.level = t, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = t);\n        }\n      }]) && z(a.prototype, o), l && z(a, l), i;\n    }(X);\n\n    !function (t) {\n      t.NOT_LOADED = \"NOT_LOADED\", t.BACKTRACKED = \"BACKTRACKED\", t.APPENDING = \"APPENDING\", t.PARTIAL = \"PARTIAL\", t.OK = \"OK\";\n    }($ || ($ = {}));\n\n    var tt = function () {\n      function t(t) {\n        this.activeFragment = null, this.activeParts = null, this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hls = t, this._registerListeners();\n      }\n\n      var e = t.prototype;\n      return e._registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.BUFFER_APPENDED, this.onBufferAppended, this), t.on(n.a.FRAG_BUFFERED, this.onFragBuffered, this), t.on(n.a.FRAG_LOADED, this.onFragLoaded, this);\n      }, e._unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.BUFFER_APPENDED, this.onBufferAppended, this), t.off(n.a.FRAG_BUFFERED, this.onFragBuffered, this), t.off(n.a.FRAG_LOADED, this.onFragLoaded, this);\n      }, e.destroy = function () {\n        this._unregisterListeners(), this.fragments = this.timeRanges = null;\n      }, e.getAppendedFrag = function (t, e) {\n        if (e === _.b.MAIN) {\n          var r = this.activeFragment,\n              i = this.activeParts;\n          if (!r) return null;\n          if (i) for (var a = i.length; a--;) {\n            var n = i[a],\n                s = n ? n.end : r.appendedPTS;\n            if (n.start <= t && void 0 !== s && t <= s) return a > 9 && (this.activeParts = i.slice(a - 9)), n;\n          } else if (r.start <= t && void 0 !== r.appendedPTS && t <= r.appendedPTS) return r;\n        }\n\n        return this.getBufferedFrag(t, e);\n      }, e.getBufferedFrag = function (t, e) {\n        for (var r = this.fragments, i = Object.keys(r), a = i.length; a--;) {\n          var n = r[i[a]];\n\n          if ((null == n ? void 0 : n.body.type) === e && n.buffered) {\n            var s = n.body;\n            if (s.start <= t && t <= s.end) return s;\n          }\n        }\n\n        return null;\n      }, e.detectEvictedFragments = function (t, e, r) {\n        var i = this;\n        Object.keys(this.fragments).forEach(function (a) {\n          var n = i.fragments[a];\n          if (n) if (n.buffered) {\n            var s = n.range[t];\n            s && s.time.some(function (t) {\n              var r = !i.isTimeBuffered(t.startPTS, t.endPTS, e);\n              return r && i.removeFragment(n.body), r;\n            });\n          } else n.body.type === r && i.removeFragment(n.body);\n        });\n      }, e.detectPartialFragments = function (t) {\n        var e = this,\n            r = this.timeRanges,\n            i = t.frag,\n            a = t.part;\n\n        if (r && \"initSegment\" !== i.sn) {\n          var n = rt(i),\n              s = this.fragments[n];\n          s && (Object.keys(r).forEach(function (t) {\n            var n = i.elementaryStreams[t];\n\n            if (n) {\n              var o = r[t],\n                  l = null !== a || !0 === n.partial;\n              s.range[t] = e.getBufferedTimes(i, a, l, o);\n            }\n          }), s.backtrack = s.loaded = null, Object.keys(s.range).length ? s.buffered = !0 : this.removeFragment(s.body));\n        }\n      }, e.fragBuffered = function (t) {\n        var e = rt(t),\n            r = this.fragments[e];\n        r && (r.backtrack = r.loaded = null, r.buffered = !0);\n      }, e.getBufferedTimes = function (t, e, r, i) {\n        for (var a = {\n          time: [],\n          partial: r\n        }, n = e ? e.start : t.start, s = e ? e.end : t.end, o = t.minEndPTS || s, l = t.maxStartPTS || n, u = 0; u < i.length; u++) {\n          var d = i.start(u) - this.bufferPadding,\n              h = i.end(u) + this.bufferPadding;\n\n          if (l >= d && o <= h) {\n            a.time.push({\n              startPTS: Math.max(n, i.start(u)),\n              endPTS: Math.min(s, i.end(u))\n            });\n            break;\n          }\n\n          if (n < h && s > d) a.partial = !0, a.time.push({\n            startPTS: Math.max(n, i.start(u)),\n            endPTS: Math.min(s, i.end(u))\n          });else if (s <= d) break;\n        }\n\n        return a;\n      }, e.getPartialFragment = function (t) {\n        var e,\n            r,\n            i,\n            a = null,\n            n = 0,\n            s = this.bufferPadding,\n            o = this.fragments;\n        return Object.keys(o).forEach(function (l) {\n          var u = o[l];\n          u && et(u) && (r = u.body.start - s, i = u.body.end + s, t >= r && t <= i && (e = Math.min(t - r, i - t), n <= e && (a = u.body, n = e)));\n        }), a;\n      }, e.getState = function (t) {\n        var e = rt(t),\n            r = this.fragments[e];\n        return r ? r.buffered ? et(r) ? $.PARTIAL : $.OK : r.backtrack ? $.BACKTRACKED : $.APPENDING : $.NOT_LOADED;\n      }, e.backtrack = function (t, e) {\n        var r = rt(t),\n            i = this.fragments[r];\n        if (!i || i.backtrack) return null;\n        var a = i.backtrack = e || i.loaded;\n        return i.loaded = null, a;\n      }, e.getBacktrackData = function (t) {\n        var e = rt(t),\n            r = this.fragments[e];\n\n        if (r) {\n          var i,\n              a = r.backtrack;\n          if (null != a && null !== (i = a.payload) && void 0 !== i && i.byteLength) return a;\n          this.removeFragment(t);\n        }\n\n        return null;\n      }, e.isTimeBuffered = function (t, e, r) {\n        for (var i, a, n = 0; n < r.length; n++) {\n          if (i = r.start(n) - this.bufferPadding, a = r.end(n) + this.bufferPadding, t >= i && e <= a) return !0;\n          if (e <= i) return !1;\n        }\n\n        return !1;\n      }, e.onFragLoaded = function (t, e) {\n        var r = e.frag,\n            i = e.part;\n\n        if (\"initSegment\" !== r.sn && !r.bitrateTest && !i) {\n          var a = rt(r);\n          this.fragments[a] = {\n            body: r,\n            loaded: e,\n            backtrack: null,\n            buffered: !1,\n            range: Object.create(null)\n          };\n        }\n      }, e.onBufferAppended = function (t, e) {\n        var r = this,\n            i = e.frag,\n            a = e.part,\n            n = e.timeRanges;\n        if (i.type === _.b.MAIN) if (this.activeFragment = i, a) {\n          var s = this.activeParts;\n          s || (this.activeParts = s = []), s.push(a);\n        } else this.activeParts = null;\n        this.timeRanges = n, Object.keys(n).forEach(function (t) {\n          var e = n[t];\n          if (r.detectEvictedFragments(t, e), !a) for (var s = 0; s < e.length; s++) i.appendedPTS = Math.max(e.end(s), i.appendedPTS || 0);\n        });\n      }, e.onFragBuffered = function (t, e) {\n        this.detectPartialFragments(e);\n      }, e.hasFragment = function (t) {\n        var e = rt(t);\n        return !!this.fragments[e];\n      }, e.removeFragmentsInRange = function (t, e, r) {\n        var i = this;\n        Object.keys(this.fragments).forEach(function (a) {\n          var n = i.fragments[a];\n\n          if (n && n.buffered) {\n            var s = n.body;\n            s.type === r && s.start < e && s.end > t && i.removeFragment(s);\n          }\n        });\n      }, e.removeFragment = function (t) {\n        var e = rt(t);\n        t.stats.loaded = 0, t.clearElementaryStreamInfo(), delete this.fragments[e];\n      }, e.removeAllFragments = function () {\n        this.fragments = Object.create(null), this.activeFragment = null, this.activeParts = null;\n      }, t;\n    }();\n\n    function et(t) {\n      var e, r;\n      return t.buffered && ((null === (e = t.range.video) || void 0 === e ? void 0 : e.partial) || (null === (r = t.range.audio) || void 0 === r ? void 0 : r.partial));\n    }\n\n    function rt(t) {\n      return t.type + \"_\" + t.level + \"_\" + t.urlId + \"_\" + t.sn;\n    }\n\n    var it = function () {\n      function t() {\n        this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this);\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.onHandlerDestroying(), this.onHandlerDestroyed();\n      }, e.onHandlerDestroying = function () {\n        this.clearNextTick(), this.clearInterval();\n      }, e.onHandlerDestroyed = function () {}, e.hasInterval = function () {\n        return !!this._tickInterval;\n      }, e.hasNextTick = function () {\n        return !!this._tickTimer;\n      }, e.setInterval = function (t) {\n        return !this._tickInterval && (this._tickInterval = self.setInterval(this._boundTick, t), !0);\n      }, e.clearInterval = function () {\n        return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0);\n      }, e.clearNextTick = function () {\n        return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0);\n      }, e.tick = function () {\n        this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0);\n      }, e.tickImmediate = function () {\n        this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0);\n      }, e.doTick = function () {}, t;\n    }(),\n        at = {\n      length: 0,\n      start: function () {\n        return 0;\n      },\n      end: function () {\n        return 0;\n      }\n    },\n        nt = function () {\n      function t() {}\n\n      return t.isBuffered = function (e, r) {\n        try {\n          if (e) for (var i = t.getBuffered(e), a = 0; a < i.length; a++) if (r >= i.start(a) && r <= i.end(a)) return !0;\n        } catch (t) {}\n\n        return !1;\n      }, t.bufferInfo = function (e, r, i) {\n        try {\n          if (e) {\n            var a,\n                n = t.getBuffered(e),\n                s = [];\n\n            for (a = 0; a < n.length; a++) s.push({\n              start: n.start(a),\n              end: n.end(a)\n            });\n\n            return this.bufferedInfo(s, r, i);\n          }\n        } catch (t) {}\n\n        return {\n          len: 0,\n          start: r,\n          end: r,\n          nextStart: void 0\n        };\n      }, t.bufferedInfo = function (t, e, r) {\n        e = Math.max(0, e), t.sort(function (t, e) {\n          var r = t.start - e.start;\n          return r || e.end - t.end;\n        });\n        var i = [];\n        if (r) for (var a = 0; a < t.length; a++) {\n          var n = i.length;\n\n          if (n) {\n            var s = i[n - 1].end;\n            t[a].start - s < r ? t[a].end > s && (i[n - 1].end = t[a].end) : i.push(t[a]);\n          } else i.push(t[a]);\n        } else i = t;\n\n        for (var o, l = 0, u = e, d = e, h = 0; h < i.length; h++) {\n          var f = i[h].start,\n              c = i[h].end;\n          if (e + r >= f && e < c) u = f, l = (d = c) - e;else if (e + r < f) {\n            o = f;\n            break;\n          }\n        }\n\n        return {\n          len: l,\n          start: u || 0,\n          end: d || 0,\n          nextStart: o\n        };\n      }, t.getBuffered = function (t) {\n        try {\n          return t.buffered;\n        } catch (t) {\n          return o.b.log(\"failed to get media.buffered\", t), at;\n        }\n      }, t;\n    }(),\n        st = function (t, e, r, i, a, n) {\n      void 0 === i && (i = 0), void 0 === a && (a = -1), void 0 === n && (n = !1), this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = {\n        start: 0,\n        executeStart: 0,\n        executeEnd: 0,\n        end: 0\n      }, this.buffering = {\n        audio: {\n          start: 0,\n          executeStart: 0,\n          executeEnd: 0,\n          end: 0\n        },\n        video: {\n          start: 0,\n          executeStart: 0,\n          executeEnd: 0,\n          end: 0\n        },\n        audiovideo: {\n          start: 0,\n          executeStart: 0,\n          executeEnd: 0,\n          end: 0\n        }\n      }, this.level = t, this.sn = e, this.id = r, this.size = i, this.part = a, this.partial = n;\n    };\n\n    function ot(t, e) {\n      if (t) {\n        var r = t.start + e;\n        t.start = t.startPTS = r, t.endPTS = r + t.duration;\n      }\n    }\n\n    function lt(t, e) {\n      for (var r = e.fragments, i = 0, a = r.length; i < a; i++) ot(r[i], t);\n\n      e.fragmentHint && ot(e.fragmentHint, t), e.alignedSliding = !0;\n    }\n\n    function ut(t, e, r) {\n      e && (!function (t, e, r) {\n        if (function (t, e, r) {\n          return !(!e.details || !(r.endCC > r.startCC || t && t.cc < r.startCC));\n        }(t, r, e)) {\n          var i = function (t, e) {\n            var r = t.fragments,\n                i = e.fragments;\n\n            if (i.length && r.length) {\n              var a = function (t, e) {\n                for (var r = null, i = 0, a = t.length; i < a; i++) {\n                  var n = t[i];\n\n                  if (n && n.cc === e) {\n                    r = n;\n                    break;\n                  }\n                }\n\n                return r;\n              }(r, i[0].cc);\n\n              if (a && (!a || a.startPTS)) return a;\n              o.b.log(\"No frag in previous level to align on\");\n            } else o.b.log(\"No fragments to align\");\n          }(r.details, e);\n\n          i && Object(a.a)(i.start) && (o.b.log(\"Adjusting PTS using last level due to CC increase within current level \" + e.url), lt(i.start, e));\n        }\n      }(t, r, e), !r.alignedSliding && e.details && function (t, e) {\n        if (!e.fragments.length || !t.hasProgramDateTime || !e.hasProgramDateTime) return;\n        var r = e.fragments[0].programDateTime,\n            i = t.fragments[0].programDateTime,\n            n = (i - r) / 1e3 + e.fragments[0].start;\n        n && Object(a.a)(n) && (o.b.log(\"Adjusting PTS using programDateTime delta \" + (i - r) + \"ms, sliding:\" + n.toFixed(3) + \" \" + t.url + \" \"), lt(n, t));\n      }(r, e.details), r.alignedSliding || !e.details || r.skippedSegments || Y(e.details, r));\n    }\n\n    var dt = {\n      search: function (t, e) {\n        for (var r = 0, i = t.length - 1, a = null, n = null; r <= i;) {\n          var s = e(n = t[a = (r + i) / 2 | 0]);\n          if (s > 0) r = a + 1;else {\n            if (!(s < 0)) return n;\n            i = a - 1;\n          }\n        }\n\n        return null;\n      }\n    };\n\n    function ht(t, e, r) {\n      void 0 === t && (t = 0), void 0 === e && (e = 0);\n      var i = Math.min(e, r.duration + (r.deltaPTS ? r.deltaPTS : 0));\n      return r.start + r.duration - i <= t ? 1 : r.start - i > t && r.start ? -1 : 0;\n    }\n\n    function ft(t, e, r) {\n      var i = 1e3 * Math.min(e, r.duration + (r.deltaPTS ? r.deltaPTS : 0));\n      return (r.endProgramDateTime || 0) - i > t;\n    }\n\n    function ct(t) {\n      var e = \"function\" == typeof Map ? new Map() : void 0;\n      return (ct = function (t) {\n        if (null === t || (r = t, -1 === Function.toString.call(r).indexOf(\"[native code]\"))) return t;\n        var r;\n        if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n\n        if (void 0 !== e) {\n          if (e.has(t)) return e.get(t);\n          e.set(t, i);\n        }\n\n        function i() {\n          return vt(t, arguments, mt(this).constructor);\n        }\n\n        return i.prototype = Object.create(t.prototype, {\n          constructor: {\n            value: i,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), pt(i, t);\n      })(t);\n    }\n\n    function vt(t, e, r) {\n      return (vt = gt() ? Reflect.construct : function (t, e, r) {\n        var i = [null];\n        i.push.apply(i, e);\n        var a = new (Function.bind.apply(t, i))();\n        return r && pt(a, r.prototype), a;\n      }).apply(null, arguments);\n    }\n\n    function gt() {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n\n    function pt(t, e) {\n      return (pt = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    function mt(t) {\n      return (mt = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n        return t.__proto__ || Object.getPrototypeOf(t);\n      })(t);\n    }\n\n    var yt = Math.pow(2, 17),\n        bt = function () {\n      function t(t) {\n        this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = t;\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.loader && (this.loader.destroy(), this.loader = null);\n      }, e.abort = function () {\n        this.loader && this.loader.abort();\n      }, e.load = function (t, e) {\n        var r = this,\n            i = t.url;\n        if (!i) return Promise.reject(new Et({\n          type: s.b.NETWORK_ERROR,\n          details: s.a.FRAG_LOAD_ERROR,\n          fatal: !1,\n          frag: t,\n          networkDetails: null\n        }, \"Fragment does not have a \" + (i ? \"part list\" : \"url\")));\n        this.abort();\n        var a = this.config,\n            n = a.fLoader,\n            o = a.loader;\n        return new Promise(function (i, l) {\n          r.loader && r.loader.destroy();\n          var u = r.loader = t.loader = n ? new n(a) : new o(a),\n              d = Tt(t),\n              h = {\n            timeout: a.fragLoadingTimeOut,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: a.fragLoadingMaxRetryTimeout,\n            highWaterMark: yt\n          };\n          t.stats = u.stats, u.load(d, h, {\n            onSuccess: function (e, a, n, s) {\n              r.resetLoader(t, u), i({\n                frag: t,\n                part: null,\n                payload: e.data,\n                networkDetails: s\n              });\n            },\n            onError: function (e, i, a) {\n              r.resetLoader(t, u), l(new Et({\n                type: s.b.NETWORK_ERROR,\n                details: s.a.FRAG_LOAD_ERROR,\n                fatal: !1,\n                frag: t,\n                response: e,\n                networkDetails: a\n              }));\n            },\n            onAbort: function (e, i, a) {\n              r.resetLoader(t, u), l(new Et({\n                type: s.b.NETWORK_ERROR,\n                details: s.a.INTERNAL_ABORTED,\n                fatal: !1,\n                frag: t,\n                networkDetails: a\n              }));\n            },\n            onTimeout: function (e, i, a) {\n              r.resetLoader(t, u), l(new Et({\n                type: s.b.NETWORK_ERROR,\n                details: s.a.FRAG_LOAD_TIMEOUT,\n                fatal: !1,\n                frag: t,\n                networkDetails: a\n              }));\n            },\n            onProgress: function (r, i, a, n) {\n              e && e({\n                frag: t,\n                part: null,\n                payload: a,\n                networkDetails: n\n              });\n            }\n          });\n        });\n      }, e.loadPart = function (t, e, r) {\n        var i = this;\n        this.abort();\n        var a = this.config,\n            n = a.fLoader,\n            o = a.loader;\n        return new Promise(function (l, u) {\n          i.loader && i.loader.destroy();\n          var d = i.loader = t.loader = n ? new n(a) : new o(a),\n              h = Tt(t, e),\n              f = {\n            timeout: a.fragLoadingTimeOut,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: a.fragLoadingMaxRetryTimeout,\n            highWaterMark: yt\n          };\n          e.stats = d.stats, d.load(h, f, {\n            onSuccess: function (a, n, s, o) {\n              i.resetLoader(t, d), i.updateStatsFromPart(t, e);\n              var u = {\n                frag: t,\n                part: e,\n                payload: a.data,\n                networkDetails: o\n              };\n              r(u), l(u);\n            },\n            onError: function (r, a, n) {\n              i.resetLoader(t, d), u(new Et({\n                type: s.b.NETWORK_ERROR,\n                details: s.a.FRAG_LOAD_ERROR,\n                fatal: !1,\n                frag: t,\n                part: e,\n                response: r,\n                networkDetails: n\n              }));\n            },\n            onAbort: function (r, a, n) {\n              t.stats.aborted = e.stats.aborted, i.resetLoader(t, d), u(new Et({\n                type: s.b.NETWORK_ERROR,\n                details: s.a.INTERNAL_ABORTED,\n                fatal: !1,\n                frag: t,\n                part: e,\n                networkDetails: n\n              }));\n            },\n            onTimeout: function (r, a, n) {\n              i.resetLoader(t, d), u(new Et({\n                type: s.b.NETWORK_ERROR,\n                details: s.a.FRAG_LOAD_TIMEOUT,\n                fatal: !1,\n                frag: t,\n                part: e,\n                networkDetails: n\n              }));\n            }\n          });\n        });\n      }, e.updateStatsFromPart = function (t, e) {\n        var r = t.stats,\n            i = e.stats,\n            a = i.total;\n\n        if (r.loaded += i.loaded, a) {\n          var n = Math.round(t.duration / e.duration),\n              s = Math.min(Math.round(r.loaded / a), n),\n              o = (n - s) * Math.round(r.loaded / s);\n          r.total = r.loaded + o;\n        } else r.total = Math.max(r.loaded, r.total);\n\n        var l = r.loading,\n            u = i.loading;\n        l.start ? l.first += u.first - u.start : (l.start = u.start, l.first = u.first), l.end = u.end;\n      }, e.resetLoader = function (t, e) {\n        t.loader = null, this.loader === e && (self.clearTimeout(this.partLoadTimeout), this.loader = null), e.destroy();\n      }, t;\n    }();\n\n    function Tt(t, e) {\n      void 0 === e && (e = null);\n      var r = e || t,\n          i = {\n        frag: t,\n        part: e,\n        responseType: \"arraybuffer\",\n        url: r.url,\n        headers: {},\n        rangeStart: 0,\n        rangeEnd: 0\n      },\n          n = r.byteRangeStartOffset,\n          s = r.byteRangeEndOffset;\n      return Object(a.a)(n) && Object(a.a)(s) && (i.rangeStart = n, i.rangeEnd = s), i;\n    }\n\n    var Et = function (t) {\n      var e, r;\n\n      function i(e) {\n        for (var r, i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++) a[n - 1] = arguments[n];\n\n        return (r = t.call.apply(t, [this].concat(a)) || this).data = void 0, r.data = e, r;\n      }\n\n      return r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, pt(e, r), i;\n    }(ct(Error)),\n        St = r(14),\n        Lt = {\n      toString: function (t) {\n        for (var e = \"\", r = t.length, i = 0; i < r; i++) e += \"[\" + t.start(i).toFixed(3) + \",\" + t.end(i).toFixed(3) + \"]\";\n\n        return e;\n      }\n    };\n\n    function At(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    function Rt(t, e) {\n      return (Rt = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    var Dt = \"STOPPED\",\n        _t = \"IDLE\",\n        kt = \"KEY_LOADING\",\n        xt = \"FRAG_LOADING\",\n        Ct = \"FRAG_LOADING_WAITING_RETRY\",\n        wt = \"PARSING\",\n        Ot = \"PARSED\",\n        It = \"BACKTRACKING\",\n        Pt = \"ENDED\",\n        Ft = \"ERROR\",\n        Mt = \"WAITING_LEVEL\",\n        Nt = function (t) {\n      var e, r;\n\n      function i(e, r, i) {\n        var a;\n        return (a = t.call(this) || this).hls = void 0, a.fragPrevious = null, a.fragCurrent = null, a.fragmentTracker = void 0, a.transmuxer = null, a._state = Dt, a.media = void 0, a.mediaBuffer = void 0, a.config = void 0, a.bitrateTest = !1, a.lastCurrentTime = 0, a.nextLoadPosition = 0, a.startPosition = 0, a.loadedmetadata = !1, a.fragLoadError = 0, a.retryDate = 0, a.levels = null, a.fragmentLoader = void 0, a.levelLastLoaded = null, a.startFragRequested = !1, a.decrypter = void 0, a.initPTS = [], a.onvseeking = null, a.onvended = null, a.logPrefix = \"\", a.log = void 0, a.warn = void 0, a.logPrefix = i, a.log = o.b.log.bind(o.b, i + \":\"), a.warn = o.b.warn.bind(o.b, i + \":\"), a.hls = e, a.fragmentLoader = new bt(e.config), a.fragmentTracker = r, a.config = e.config, a.decrypter = new St.a(e, e.config), e.on(n.a.KEY_LOADED, a.onKeyLoaded, function (t) {\n          if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          return t;\n        }(a)), a;\n      }\n\n      r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Rt(e, r);\n      var u,\n          d,\n          h,\n          f = i.prototype;\n      return f.doTick = function () {\n        this.onTickEnd();\n      }, f.onTickEnd = function () {}, f.startLoad = function (t) {}, f.stopLoad = function () {\n        this.fragmentLoader.abort();\n        var t = this.fragCurrent;\n        t && this.fragmentTracker.removeFragment(t), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = Dt;\n      }, f._streamEnded = function (t, e) {\n        var r = this.fragCurrent,\n            i = this.fragmentTracker;\n\n        if (!e.live && r && r.sn >= e.endSN && !t.nextStart) {\n          var a = e.partList;\n\n          if (null != a && a.length) {\n            var n = a[a.length - 1];\n            return nt.isBuffered(this.media, n.start + n.duration / 2);\n          }\n\n          var s = i.getState(r);\n          return s === $.PARTIAL || s === $.OK;\n        }\n\n        return !1;\n      }, f.onMediaAttached = function (t, e) {\n        var r = this.media = this.mediaBuffer = e.media;\n        this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), r.addEventListener(\"seeking\", this.onvseeking), r.addEventListener(\"ended\", this.onvended);\n        var i = this.config;\n        this.levels && i.autoStartLoad && this.state === Dt && this.startLoad(i.startPosition);\n      }, f.onMediaDetaching = function () {\n        var t = this.media;\n        null != t && t.ended && (this.log(\"MSE detaching and video ended, reset startPosition\"), this.startPosition = this.lastCurrentTime = 0), t && (t.removeEventListener(\"seeking\", this.onvseeking), t.removeEventListener(\"ended\", this.onvended), this.onvseeking = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad();\n      }, f.onMediaSeeking = function () {\n        var t = this.config,\n            e = this.fragCurrent,\n            r = this.media,\n            i = this.mediaBuffer,\n            n = this.state,\n            s = r ? r.currentTime : 0,\n            o = nt.bufferInfo(i || r, s, t.maxBufferHole);\n        if (this.log(\"media seeking to \" + (Object(a.a)(s) ? s.toFixed(3) : s) + \", state: \" + n), n === Pt) this.resetLoadingState();else if (e && !o.len) {\n          var l = t.maxFragLookUpTolerance,\n              u = e.start - l,\n              d = s > e.start + e.duration + l;\n          (s < u || d) && (d && e.loader && (this.log(\"seeking outside of buffer while fragment load in progress, cancel fragment load\"), e.loader.abort()), this.resetLoadingState());\n        }\n        r && (this.lastCurrentTime = s), this.loadedmetadata || o.len || (this.nextLoadPosition = this.startPosition = s), this.tickImmediate();\n      }, f.onMediaEnded = function () {\n        this.startPosition = this.lastCurrentTime = 0;\n      }, f.onKeyLoaded = function (t, e) {\n        if (this.state === kt && e.frag === this.fragCurrent && this.levels) {\n          this.state = _t;\n          var r = this.levels[e.frag.level].details;\n          r && this.loadFragment(e.frag, r, e.frag.start);\n        }\n      }, f.onHandlerDestroying = function () {\n        this.stopLoad(), t.prototype.onHandlerDestroying.call(this);\n      }, f.onHandlerDestroyed = function () {\n        this.state = Dt, this.hls.off(n.a.KEY_LOADED, this.onKeyLoaded, this), this.fragmentLoader && this.fragmentLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.fragmentLoader = this.fragmentTracker = null, t.prototype.onHandlerDestroyed.call(this);\n      }, f.loadKey = function (t, e) {\n        this.log(\"Loading key for \" + t.sn + \" of [\" + e.startSN + \"-\" + e.endSN + \"], \" + (\"[stream-controller]\" === this.logPrefix ? \"level\" : \"track\") + \" \" + t.level), this.state = kt, this.fragCurrent = t, this.hls.trigger(n.a.KEY_LOADING, {\n          frag: t\n        });\n      }, f.loadFragment = function (t, e, r) {\n        this._loadFragForPlayback(t, e, r);\n      }, f._loadFragForPlayback = function (t, e, r) {\n        var i = this;\n\n        this._doFragLoad(t, e, r, function (e) {\n          if (i.fragContextChanged(t)) return i.warn(\"Fragment \" + t.sn + (e.part ? \" p: \" + e.part.index : \"\") + \" of level \" + t.level + \" was dropped during download.\"), void i.fragmentTracker.removeFragment(t);\n          t.stats.chunkCount++, i._handleFragmentLoadProgress(e);\n        }).then(function (e) {\n          if (e) {\n            i.fragLoadError = 0;\n            var r = i.state;\n            if (!i.fragContextChanged(t)) return \"payload\" in e && (i.log(\"Loaded fragment \" + t.sn + \" of level \" + t.level), i.hls.trigger(n.a.FRAG_LOADED, e), i.state === It) ? (i.fragmentTracker.backtrack(t, e), void i.resetFragmentLoading(t)) : void i._handleFragmentLoadComplete(e);\n            (r === xt || r === It || !i.fragCurrent && r === wt) && (i.fragmentTracker.removeFragment(t), i.state = _t);\n          }\n        }).catch(function (e) {\n          i.warn(e), i.resetFragmentLoading(t);\n        });\n      }, f.flushMainBuffer = function (t, e, r) {\n        if (void 0 === r && (r = null), t - e) {\n          var i = {\n            startOffset: t,\n            endOffset: e,\n            type: r\n          };\n          this.fragLoadError = 0, this.hls.trigger(n.a.BUFFER_FLUSHING, i);\n        }\n      }, f._loadInitSegment = function (t) {\n        var e = this;\n\n        this._doFragLoad(t).then(function (r) {\n          if (!r || e.fragContextChanged(t) || !e.levels) throw new Error(\"init load aborted\");\n          return r;\n        }).then(function (r) {\n          var i = e.hls,\n              a = r.payload,\n              s = t.decryptdata;\n\n          if (a && a.byteLength > 0 && s && s.key && s.iv && \"AES-128\" === s.method) {\n            var o = self.performance.now();\n            return e.decrypter.webCryptoDecrypt(new Uint8Array(a), s.key.buffer, s.iv.buffer).then(function (e) {\n              var a = self.performance.now();\n              return i.trigger(n.a.FRAG_DECRYPTED, {\n                frag: t,\n                payload: e,\n                stats: {\n                  tstart: o,\n                  tdecrypt: a\n                }\n              }), r.payload = e, r;\n            });\n          }\n\n          return r;\n        }).then(function (r) {\n          var i = e.fragCurrent,\n              a = e.hls,\n              s = e.levels;\n          if (!s) throw new Error(\"init load aborted, missing levels\");\n          s[t.level].details;\n          var o = t.stats;\n          e.state = _t, e.fragLoadError = 0, t.data = new Uint8Array(r.payload), o.parsing.start = o.buffering.start = self.performance.now(), o.parsing.end = o.buffering.end = self.performance.now(), r.frag === i && a.trigger(n.a.FRAG_BUFFERED, {\n            stats: o,\n            frag: i,\n            part: null,\n            id: t.type\n          }), e.tick();\n        }).catch(function (r) {\n          e.warn(r), e.resetFragmentLoading(t);\n        });\n      }, f.fragContextChanged = function (t) {\n        var e = this.fragCurrent;\n        return !t || !e || t.level !== e.level || t.sn !== e.sn || t.urlId !== e.urlId;\n      }, f.fragBufferedComplete = function (t, e) {\n        var r = this.mediaBuffer ? this.mediaBuffer : this.media;\n        this.log(\"Buffered \" + t.type + \" sn: \" + t.sn + (e ? \" part: \" + e.index : \"\") + \" of \" + (\"[stream-controller]\" === this.logPrefix ? \"level\" : \"track\") + \" \" + t.level + \" \" + Lt.toString(nt.getBuffered(r))), this.state = _t, this.tick();\n      }, f._handleFragmentLoadComplete = function (t) {\n        var e = this.transmuxer;\n\n        if (e) {\n          var r = t.frag,\n              i = t.part,\n              a = t.partsLoaded,\n              n = !a || 0 === a.length || a.some(function (t) {\n            return !t;\n          }),\n              s = new st(r.level, r.sn, r.stats.chunkCount + 1, 0, i ? i.index : -1, !n);\n          e.flush(s);\n        }\n      }, f._handleFragmentLoadProgress = function (t) {}, f._doFragLoad = function (t, e, r, i) {\n        var s = this;\n        if (void 0 === r && (r = null), !this.levels) throw new Error(\"frag load aborted, missing levels\");\n\n        if (r = Math.max(t.start, r || 0), this.config.lowLatencyMode && e) {\n          var o = e.partList;\n\n          if (o && i) {\n            r > t.end && e.fragmentHint && (t = e.fragmentHint);\n            var l = this.getNextPart(o, t, r);\n\n            if (l > -1) {\n              var u = o[l];\n              return this.log(\"Loading part sn: \" + t.sn + \" p: \" + u.index + \" cc: \" + t.cc + \" of playlist [\" + e.startSN + \"-\" + e.endSN + \"] parts [0-\" + l + \"-\" + (o.length - 1) + \"] \" + (\"[stream-controller]\" === this.logPrefix ? \"level\" : \"track\") + \": \" + t.level + \", target: \" + parseFloat(r.toFixed(3))), this.nextLoadPosition = u.start + u.duration, this.state = xt, this.hls.trigger(n.a.FRAG_LOADING, {\n                frag: t,\n                part: o[l],\n                targetBufferTime: r\n              }), this.doFragPartsLoad(t, o, l, i).catch(function (t) {\n                return s.handleFragLoadError(t);\n              });\n            }\n\n            if (!t.url || this.loadedEndOfParts(o, r)) return Promise.resolve(null);\n          }\n        }\n\n        return this.log(\"Loading fragment \" + t.sn + \" cc: \" + t.cc + \" \" + (e ? \"of [\" + e.startSN + \"-\" + e.endSN + \"] \" : \"\") + (\"[stream-controller]\" === this.logPrefix ? \"level\" : \"track\") + \": \" + t.level + \", target: \" + parseFloat(r.toFixed(3))), Object(a.a)(t.sn) && !this.bitrateTest && (this.nextLoadPosition = t.start + t.duration), this.state = xt, this.hls.trigger(n.a.FRAG_LOADING, {\n          frag: t,\n          targetBufferTime: r\n        }), this.fragmentLoader.load(t, i).catch(function (t) {\n          return s.handleFragLoadError(t);\n        });\n      }, f.doFragPartsLoad = function (t, e, r, i) {\n        var a = this;\n        return new Promise(function (s, o) {\n          var l = [];\n          !function r(u) {\n            var d = e[u];\n            a.fragmentLoader.loadPart(t, d, i).then(function (i) {\n              l[d.index] = i;\n              var o = i.part;\n              a.hls.trigger(n.a.FRAG_LOADED, i);\n              var h = e[u + 1];\n              if (!h || h.fragment !== t) return s({\n                frag: t,\n                part: o,\n                partsLoaded: l\n              });\n              r(u + 1);\n            }).catch(o);\n          }(r);\n        });\n      }, f.handleFragLoadError = function (t) {\n        var e = t.data;\n        return e && e.details === s.a.INTERNAL_ABORTED ? this.handleFragLoadAborted(e.frag, e.part) : this.hls.trigger(n.a.ERROR, e), null;\n      }, f._handleTransmuxerFlush = function (t) {\n        var e = this.getCurrentContext(t);\n\n        if (e && this.state === wt) {\n          var r = e.frag,\n              i = e.part,\n              a = e.level,\n              n = self.performance.now();\n          r.stats.parsing.end = n, i && (i.stats.parsing.end = n), this.updateLevelTiming(r, i, a, t.partial);\n        } else this.fragCurrent || (this.state = _t);\n      }, f.getCurrentContext = function (t) {\n        var e = this.levels,\n            r = t.level,\n            i = t.sn,\n            a = t.part;\n        if (!e || !e[r]) return this.warn(\"Levels object was unset while buffering fragment \" + i + \" of level \" + r + \". The current chunk will not be buffered.\"), null;\n        var n = e[r],\n            s = a > -1 ? function (t, e, r) {\n          if (!t || !t.details) return null;\n          var i = t.details.partList;\n          if (i) for (var a = i.length; a--;) {\n            var n = i[a];\n            if (n.index === r && n.fragment.sn === e) return n;\n          }\n          return null;\n        }(n, i, a) : null,\n            o = s ? s.fragment : function (t, e, r) {\n          if (!t || !t.details) return null;\n          var i = t.details,\n              a = i.fragments[e - i.startSN];\n          return a || ((a = i.fragmentHint) && a.sn === e ? a : e < i.startSN && r && r.sn === e ? r : null);\n        }(n, i, this.fragCurrent);\n        return o ? {\n          frag: o,\n          part: s,\n          level: n\n        } : null;\n      }, f.bufferFragmentData = function (t, e, r, i) {\n        if (t && this.state === wt) {\n          var a = t.data1,\n              s = t.data2,\n              o = a;\n\n          if (a && s && (o = Object(l.a)(a, s)), o && o.length) {\n            var u = {\n              type: t.type,\n              frag: e,\n              part: r,\n              chunkMeta: i,\n              parent: e.type,\n              data: o\n            };\n            this.hls.trigger(n.a.BUFFER_APPENDING, u), t.dropped && t.independent && !r && this.flushBufferGap(e);\n          }\n        }\n      }, f.flushBufferGap = function (t) {\n        var e = this.media;\n        if (e) if (nt.isBuffered(e, e.currentTime)) {\n          var r = e.currentTime,\n              i = nt.bufferInfo(e, r, 0),\n              a = t.duration,\n              n = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * a),\n              s = Math.max(Math.min(t.start - n, i.end - n), r + n);\n          t.start - s > n && this.flushMainBuffer(s, t.start);\n        } else this.flushMainBuffer(0, t.start);\n      }, f.getFwdBufferInfo = function (t, e) {\n        var r = this.config,\n            i = this.getLoadPosition();\n        if (!Object(a.a)(i)) return null;\n        var n = nt.bufferInfo(t, i, r.maxBufferHole);\n\n        if (0 === n.len && void 0 !== n.nextStart) {\n          var s = this.fragmentTracker.getBufferedFrag(i, e);\n          if (s && n.nextStart < s.end) return nt.bufferInfo(t, i, Math.max(n.nextStart, r.maxBufferHole));\n        }\n\n        return n;\n      }, f.getMaxBufferLength = function (t) {\n        var e,\n            r = this.config;\n        return e = t ? Math.max(8 * r.maxBufferSize / t, r.maxBufferLength) : r.maxBufferLength, Math.min(e, r.maxMaxBufferLength);\n      }, f.reduceMaxBufferLength = function (t) {\n        var e = this.config,\n            r = t || e.maxBufferLength;\n        return e.maxMaxBufferLength >= r && (e.maxMaxBufferLength /= 2, this.warn(\"Reduce max buffer length to \" + e.maxMaxBufferLength + \"s\"), !0);\n      }, f.getNextFragment = function (t, e) {\n        var r,\n            i,\n            a = e.fragments,\n            n = a.length;\n        if (!n) return null;\n        var s,\n            o = this.config,\n            l = a[0].start;\n\n        if (e.live) {\n          var u = o.initialLiveManifestSize;\n          if (n < u) return this.warn(\"Not enough fragments to start playback (have: \" + n + \", need: \" + u + \")\"), null;\n          e.PTSKnown || this.startFragRequested || -1 !== this.startPosition || (s = this.getInitialLiveFragment(e, a), this.startPosition = s ? this.hls.liveSyncPosition || s.start : t);\n        } else t <= l && (s = a[0]);\n\n        if (!s) {\n          var d = o.lowLatencyMode ? e.partEnd : e.fragmentEnd;\n          s = this.getFragmentAtPosition(t, d, e);\n        }\n\n        return null === (r = s) || void 0 === r || !r.initSegment || null !== (i = s) && void 0 !== i && i.initSegment.data || this.bitrateTest || (s = s.initSegment), s;\n      }, f.getNextPart = function (t, e, r) {\n        for (var i = -1, a = !1, n = !0, s = 0, o = t.length; s < o; s++) {\n          var l = t[s];\n          if (n = n && !l.independent, i > -1 && r < l.start) break;\n          var u = l.loaded;\n          !u && (a || l.independent || n) && l.fragment === e && (i = s), a = u;\n        }\n\n        return i;\n      }, f.loadedEndOfParts = function (t, e) {\n        var r = t[t.length - 1];\n        return r && e > r.start && r.loaded;\n      }, f.getInitialLiveFragment = function (t, e) {\n        var r = this.fragPrevious,\n            i = null;\n\n        if (r) {\n          if (t.hasProgramDateTime && (this.log(\"Live playlist, switching playlist, load frag with same PDT: \" + r.programDateTime), i = function (t, e, r) {\n            if (null === e || !Array.isArray(t) || !t.length || !Object(a.a)(e)) return null;\n            if (e < (t[0].programDateTime || 0)) return null;\n            if (e >= (t[t.length - 1].endProgramDateTime || 0)) return null;\n            r = r || 0;\n\n            for (var i = 0; i < t.length; ++i) {\n              var n = t[i];\n              if (ft(e, r, n)) return n;\n            }\n\n            return null;\n          }(e, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), !i) {\n            var n = r.sn + 1;\n\n            if (n >= t.startSN && n <= t.endSN) {\n              var s = e[n - t.startSN];\n              r.cc === s.cc && (i = s, this.log(\"Live playlist, switching playlist, load frag with next SN: \" + i.sn));\n            }\n\n            i || (i = function (t, e) {\n              return dt.search(t, function (t) {\n                return t.cc < e ? 1 : t.cc > e ? -1 : 0;\n              });\n            }(e, r.cc)) && this.log(\"Live playlist, switching playlist, load frag with same CC: \" + i.sn);\n          }\n        } else {\n          var o = this.hls.liveSyncPosition;\n          null !== o && (i = this.getFragmentAtPosition(o, this.bitrateTest ? t.fragmentEnd : t.edge, t));\n        }\n\n        return i;\n      }, f.getFragmentAtPosition = function (t, e, r) {\n        var i,\n            a = this.config,\n            n = this.fragPrevious,\n            s = r.fragments,\n            o = r.endSN,\n            l = r.fragmentHint,\n            u = a.maxFragLookUpTolerance,\n            d = !!(a.lowLatencyMode && r.partList && l);\n        (d && l && !this.bitrateTest && (s = s.concat(l), o = l.sn), t < e) ? i = function (t, e, r, i) {\n          void 0 === r && (r = 0), void 0 === i && (i = 0);\n          var a = null;\n          if (t ? a = e[t.sn - e[0].sn + 1] || null : 0 === r && 0 === e[0].start && (a = e[0]), a && 0 === ht(r, i, a)) return a;\n          var n = dt.search(e, ht.bind(null, r, i));\n          return n || a;\n        }(n, s, t, t > e - u ? 0 : u) : i = s[s.length - 1];\n\n        if (i) {\n          var h = i.sn - r.startSN,\n              f = n && i.level === n.level,\n              c = s[h + 1];\n\n          if (this.fragmentTracker.getState(i) === $.BACKTRACKED) {\n            i = null;\n\n            for (var v = h; s[v] && this.fragmentTracker.getState(s[v]) === $.BACKTRACKED;) i = n ? s[v--] : s[--v];\n\n            i || (i = c);\n          } else n && i.sn === n.sn && !d && f && (i.sn < o && this.fragmentTracker.getState(c) !== $.OK ? (this.log(\"SN \" + i.sn + \" just loaded, load next one: \" + c.sn), i = c) : i = null);\n        }\n\n        return i;\n      }, f.synchronizeToLiveEdge = function (t) {\n        var e = this.config,\n            r = this.media;\n\n        if (r) {\n          var i = this.hls.liveSyncPosition,\n              a = r.currentTime,\n              n = t.fragments[0].start,\n              s = t.edge,\n              o = a >= n - e.maxFragLookUpTolerance && a <= s;\n\n          if (null !== i && r.duration > i && (a < i || !o)) {\n            var l = void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : e.liveMaxLatencyDurationCount * t.targetduration;\n            (!o && r.readyState < 4 || a < s - l) && (this.loadedmetadata || (this.nextLoadPosition = i), r.readyState && (this.warn(\"Playback: \" + a.toFixed(3) + \" is located too far from the end of live sliding playlist: \" + s + \", reset currentTime to : \" + i.toFixed(3)), r.currentTime = i));\n          }\n        }\n      }, f.alignPlaylists = function (t, e) {\n        var r = this.levels,\n            i = this.levelLastLoaded,\n            n = this.fragPrevious,\n            s = null !== i ? r[i] : null,\n            o = t.fragments.length;\n        if (!o) return this.warn(\"No fragments in live playlist\"), 0;\n        var l = t.fragments[0].start,\n            u = !e,\n            d = t.alignedSliding && Object(a.a)(l);\n\n        if (u || !d && !l) {\n          ut(n, s, t);\n          var h = t.fragments[0].start;\n          return this.log(\"Live playlist sliding: \" + h.toFixed(2) + \" start-sn: \" + (e ? e.startSN : \"na\") + \"->\" + t.startSN + \" prev-sn: \" + (n ? n.sn : \"na\") + \" fragments: \" + o), h;\n        }\n\n        return l;\n      }, f.waitForCdnTuneIn = function (t) {\n        return t.live && t.canBlockReload && t.tuneInGoal > Math.max(t.partHoldBack, 3 * t.partTarget);\n      }, f.setStartPosition = function (t, e) {\n        var r = this.startPosition;\n\n        if (r < e && (r = -1), -1 === r || -1 === this.lastCurrentTime) {\n          var i = t.startTimeOffset;\n          Object(a.a)(i) ? (r = e + i, i < 0 && (r += t.totalduration), r = Math.min(Math.max(e, r), e + t.totalduration), this.log(\"Start time offset \" + i + \" found in playlist, adjust startPosition to \" + r), this.startPosition = r) : t.live ? r = this.hls.liveSyncPosition || e : this.startPosition = r = 0, this.lastCurrentTime = r;\n        }\n\n        this.nextLoadPosition = r;\n      }, f.getLoadPosition = function () {\n        var t = this.media,\n            e = 0;\n        return this.loadedmetadata && t ? e = t.currentTime : this.nextLoadPosition && (e = this.nextLoadPosition), e;\n      }, f.handleFragLoadAborted = function (t, e) {\n        this.transmuxer && \"initSegment\" !== t.sn && t.stats.aborted && (this.warn(\"Fragment \" + t.sn + (e ? \" part\" + e.index : \"\") + \" of level \" + t.level + \" was aborted\"), this.resetFragmentLoading(t));\n      }, f.resetFragmentLoading = function (t) {\n        this.fragCurrent && this.fragContextChanged(t) || (this.state = _t);\n      }, f.onFragmentOrKeyLoadError = function (t, e) {\n        if (!e.fatal) {\n          var r = e.frag;\n\n          if (r && r.type === t) {\n            this.fragCurrent;\n            var i = this.config;\n\n            if (this.fragLoadError + 1 <= i.fragLoadingMaxRetry) {\n              if (this.resetLiveStartWhenNotLoaded(r.level)) return;\n              var a = Math.min(Math.pow(2, this.fragLoadError) * i.fragLoadingRetryDelay, i.fragLoadingMaxRetryTimeout);\n              this.warn(\"Fragment \" + r.sn + \" of \" + t + \" \" + r.level + \" failed to load, retrying in \" + a + \"ms\"), this.retryDate = self.performance.now() + a, this.fragLoadError++, this.state = Ct;\n            } else e.levelRetry ? (t === _.b.AUDIO && (this.fragCurrent = null), this.fragLoadError = 0, this.state = _t) : (o.b.error(e.details + \" reaches max retry, redispatch as fatal ...\"), e.fatal = !0, this.hls.stopLoad(), this.state = Ft);\n          }\n        }\n      }, f.afterBufferFlushed = function (t, e, r) {\n        if (t) {\n          var i = nt.getBuffered(t);\n          this.fragmentTracker.detectEvictedFragments(e, i, r), this.state === Pt && this.resetLoadingState();\n        }\n      }, f.resetLoadingState = function () {\n        this.fragCurrent = null, this.fragPrevious = null, this.state = _t;\n      }, f.resetLiveStartWhenNotLoaded = function (t) {\n        if (!this.loadedmetadata) {\n          this.startFragRequested = !1;\n          var e = this.levels ? this.levels[t].details : null;\n          if (null != e && e.live) return this.startPosition = -1, this.setStartPosition(e, 0), this.resetLoadingState(), !0;\n          this.nextLoadPosition = this.startPosition;\n        }\n\n        return !1;\n      }, f.updateLevelTiming = function (t, e, r, i) {\n        var a = this,\n            s = r.details;\n        Object.keys(t.elementaryStreams).reduce(function (e, o) {\n          var l = t.elementaryStreams[o];\n\n          if (l) {\n            var u = l.endPTS - l.startPTS;\n            if (u <= 0) return a.warn(\"Could not parse fragment \" + t.sn + \" \" + o + \" duration reliably (\" + u + \") resetting transmuxer to fallback to playlist timing\"), a.resetTransmuxer(), e || !1;\n            var d = i ? 0 : V(s, t, l.startPTS, l.endPTS, l.startDTS, l.endDTS);\n            return a.hls.trigger(n.a.LEVEL_PTS_UPDATED, {\n              details: s,\n              level: r,\n              drift: d,\n              type: o,\n              frag: t,\n              start: l.startPTS,\n              end: l.endPTS\n            }), !0;\n          }\n\n          return e;\n        }, !1) ? (this.state = Ot, this.hls.trigger(n.a.FRAG_PARSED, {\n          frag: t,\n          part: e\n        })) : this.resetLoadingState();\n      }, f.resetTransmuxer = function () {\n        this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null);\n      }, u = i, (d = [{\n        key: \"state\",\n        get: function () {\n          return this._state;\n        },\n        set: function (t) {\n          var e = this._state;\n          e !== t && (this._state = t, this.log(e + \"->\" + t));\n        }\n      }]) && At(u.prototype, d), h && At(u, h), i;\n    }(it);\n\n    function Bt() {\n      return self.MediaSource || self.WebKitMediaSource;\n    }\n\n    function Ut() {\n      return self.SourceBuffer || self.WebKitSourceBuffer;\n    }\n\n    var Gt = r(17),\n        jt = r(9),\n        Ht = r(13),\n        Kt = Bt() || {\n      isTypeSupported: function () {\n        return !1;\n      }\n    },\n        Vt = function () {\n      function t(t, e, r, i) {\n        var a = this;\n        this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.worker = void 0, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, this.hls = t, this.id = e, this.onTransmuxComplete = r, this.onFlush = i;\n\n        var l = t.config,\n            u = function (e, r) {\n          (r = r || {}).frag = a.frag, r.id = a.id, t.trigger(e, r);\n        };\n\n        this.observer = new Ht.EventEmitter(), this.observer.on(n.a.FRAG_DECRYPTED, u), this.observer.on(n.a.ERROR, u);\n        var d = {\n          mp4: Kt.isTypeSupported(\"video/mp4\"),\n          mpeg: Kt.isTypeSupported(\"audio/mpeg\"),\n          mp3: Kt.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n        },\n            h = navigator.vendor;\n\n        if (l.enableWorker && \"undefined\" != typeof Worker) {\n          var f;\n          o.b.log(\"demuxing in webworker\");\n\n          try {\n            f = this.worker = Gt(18), this.onwmsg = this.onWorkerMessage.bind(this), f.addEventListener(\"message\", this.onwmsg), f.onerror = function (e) {\n              t.trigger(n.a.ERROR, {\n                type: s.b.OTHER_ERROR,\n                details: s.a.INTERNAL_EXCEPTION,\n                fatal: !0,\n                event: \"demuxerWorker\",\n                error: new Error(e.message + \"  (\" + e.filename + \":\" + e.lineno + \")\")\n              });\n            }, f.postMessage({\n              cmd: \"init\",\n              typeSupported: d,\n              vendor: h,\n              id: e,\n              config: JSON.stringify(l)\n            });\n          } catch (t) {\n            o.b.warn(\"Error in worker:\", t), o.b.error(\"Error while initializing DemuxerWorker, fallback to inline\"), f && self.URL.revokeObjectURL(f.objectURL), this.transmuxer = new jt.c(this.observer, d, l, h, e), this.worker = null;\n          }\n        } else this.transmuxer = new jt.c(this.observer, d, l, h, e);\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        var t = this.worker;\n        if (t) t.removeEventListener(\"message\", this.onwmsg), t.terminate(), this.worker = null;else {\n          var e = this.transmuxer;\n          e && (e.destroy(), this.transmuxer = null);\n        }\n        var r = this.observer;\n        r && r.removeAllListeners(), this.observer = null;\n      }, e.push = function (t, e, r, i, a, n, s, l, u, d) {\n        var h,\n            f,\n            c = this;\n        u.transmuxing.start = self.performance.now();\n        var v = this.transmuxer,\n            g = this.worker,\n            p = n ? n.start : a.start,\n            m = a.decryptdata,\n            y = this.frag,\n            b = !(y && a.cc === y.cc),\n            T = !(y && u.level === y.level),\n            E = y ? u.sn - y.sn : -1,\n            S = this.part ? u.part - this.part.index : 1,\n            L = !T && (1 === E || 0 === E && 1 === S),\n            A = self.performance.now();\n        (T || E || 0 === a.stats.parsing.start) && (a.stats.parsing.start = A), !n || !S && L || (n.stats.parsing.start = A);\n        var R = !(y && (null === (h = a.initSegment) || void 0 === h ? void 0 : h.url) === (null === (f = y.initSegment) || void 0 === f ? void 0 : f.url)),\n            D = new jt.b(b, L, l, T, p, R);\n\n        if (!L || b || R) {\n          o.b.log(\"[transmuxer-interface, \" + a.type + \"]: Starting new transmux session for sn: \" + u.sn + \" p: \" + u.part + \" level: \" + u.level + \" id: \" + u.id + \"\\n        discontinuity: \" + b + \"\\n        trackSwitch: \" + T + \"\\n        contiguous: \" + L + \"\\n        accurateTimeOffset: \" + l + \"\\n        timeOffset: \" + p + \"\\n        initSegmentChange: \" + R);\n\n          var _ = new jt.a(r, i, e, s, d);\n\n          this.configureTransmuxer(_);\n        }\n\n        if (this.frag = a, this.part = n, g) g.postMessage({\n          cmd: \"demux\",\n          data: t,\n          decryptdata: m,\n          chunkMeta: u,\n          state: D\n        }, t instanceof ArrayBuffer ? [t] : []);else if (v) {\n          var k = v.push(t, m, u, D);\n          Object(jt.d)(k) ? k.then(function (t) {\n            c.handleTransmuxComplete(t);\n          }) : this.handleTransmuxComplete(k);\n        }\n      }, e.flush = function (t) {\n        var e = this;\n        t.transmuxing.start = self.performance.now();\n        var r = this.transmuxer,\n            i = this.worker;\n        if (i) i.postMessage({\n          cmd: \"flush\",\n          chunkMeta: t\n        });else if (r) {\n          var a = r.flush(t);\n          Object(jt.d)(a) ? a.then(function (r) {\n            e.handleFlushResult(r, t);\n          }) : this.handleFlushResult(a, t);\n        }\n      }, e.handleFlushResult = function (t, e) {\n        var r = this;\n        t.forEach(function (t) {\n          r.handleTransmuxComplete(t);\n        }), this.onFlush(e);\n      }, e.onWorkerMessage = function (t) {\n        var e = t.data,\n            r = this.hls;\n\n        switch (e.event) {\n          case \"init\":\n            self.URL.revokeObjectURL(this.worker.objectURL);\n            break;\n\n          case \"transmuxComplete\":\n            this.handleTransmuxComplete(e.data);\n            break;\n\n          case \"flush\":\n            this.onFlush(e.data);\n            break;\n\n          default:\n            e.data = e.data || {}, e.data.frag = this.frag, e.data.id = this.id, r.trigger(e.event, e.data);\n        }\n      }, e.configureTransmuxer = function (t) {\n        var e = this.worker,\n            r = this.transmuxer;\n        e ? e.postMessage({\n          cmd: \"configure\",\n          config: t\n        }) : r && r.configure(t);\n      }, e.handleTransmuxComplete = function (t) {\n        t.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(t);\n      }, t;\n    }(),\n        Wt = function () {\n      function t(t, e, r, i) {\n        this.config = void 0, this.media = void 0, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = t, this.media = e, this.fragmentTracker = r, this.hls = i;\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.hls = this.fragmentTracker = this.media = null;\n      }, e.poll = function (t) {\n        var e = this.config,\n            r = this.media,\n            i = this.stalled,\n            a = r.currentTime,\n            n = r.seeking,\n            s = this.seeking && !n,\n            l = !this.seeking && n;\n\n        if (this.seeking = n, a === t) {\n          if ((l || s) && (this.stalled = null), !r.paused && !r.ended && 0 !== r.playbackRate && nt.getBuffered(r).length) {\n            var u = nt.bufferInfo(r, a, 0),\n                d = u.len > 0,\n                h = u.nextStart || 0;\n\n            if (d || h) {\n              if (n) {\n                var f = u.len > 2,\n                    c = !h || h - a > 2 && !this.fragmentTracker.getPartialFragment(a);\n                if (f || c) return;\n                this.moved = !1;\n              }\n\n              if (!this.moved && null !== this.stalled) {\n                var v,\n                    g = Math.max(h, u.start || 0) - a,\n                    p = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,\n                    m = (null == p || null === (v = p.details) || void 0 === v ? void 0 : v.live) ? 2 * p.details.targetduration : 2;\n                if (g > 0 && g <= m) return void this._trySkipBufferHole(null);\n              }\n\n              var y = self.performance.now();\n\n              if (null !== i) {\n                var b = y - i;\n                !n && b >= 250 && this._reportStall(u.len);\n                var T = nt.bufferInfo(r, a, e.maxBufferHole);\n\n                this._tryFixBufferStall(T, b);\n              } else this.stalled = y;\n            }\n          }\n        } else if (this.moved = !0, null !== i) {\n          if (this.stallReported) {\n            var E = self.performance.now() - i;\n            o.b.warn(\"playback not stuck anymore @\" + a + \", after \" + Math.round(E) + \"ms\"), this.stallReported = !1;\n          }\n\n          this.stalled = null, this.nudgeRetry = 0;\n        }\n      }, e._tryFixBufferStall = function (t, e) {\n        var r = this.config,\n            i = this.fragmentTracker,\n            a = this.media.currentTime,\n            n = i.getPartialFragment(a);\n        if (n && this._trySkipBufferHole(n)) return;\n        t.len > r.maxBufferHole && e > 1e3 * r.highBufferWatchdogPeriod && (o.b.warn(\"Trying to nudge playhead over buffer-hole\"), this.stalled = null, this._tryNudgeBuffer());\n      }, e._reportStall = function (t) {\n        var e = this.hls,\n            r = this.media;\n        this.stallReported || (this.stallReported = !0, o.b.warn(\"Playback stalling at @\" + r.currentTime + \" due to low buffer (buffer=\" + t + \")\"), e.trigger(n.a.ERROR, {\n          type: s.b.MEDIA_ERROR,\n          details: s.a.BUFFER_STALLED_ERROR,\n          fatal: !1,\n          buffer: t\n        }));\n      }, e._trySkipBufferHole = function (t) {\n        for (var e = this.config, r = this.hls, i = this.media, a = i.currentTime, l = 0, u = nt.getBuffered(i), d = 0; d < u.length; d++) {\n          var h = u.start(d);\n\n          if (a + e.maxBufferHole >= l && a < h) {\n            var f = Math.max(h + .05, i.currentTime + .1);\n            return o.b.warn(\"skipping hole, adjusting currentTime from \" + a + \" to \" + f), this.moved = !0, this.stalled = null, i.currentTime = f, t && r.trigger(n.a.ERROR, {\n              type: s.b.MEDIA_ERROR,\n              details: s.a.BUFFER_SEEK_OVER_HOLE,\n              fatal: !1,\n              reason: \"fragment loaded with buffer holes, seeking from \" + a + \" to \" + f,\n              frag: t\n            }), f;\n          }\n\n          l = u.end(d);\n        }\n\n        return 0;\n      }, e._tryNudgeBuffer = function () {\n        var t = this.config,\n            e = this.hls,\n            r = this.media,\n            i = r.currentTime,\n            a = (this.nudgeRetry || 0) + 1;\n\n        if (this.nudgeRetry = a, a < t.nudgeMaxRetry) {\n          var l = i + a * t.nudgeOffset;\n          o.b.warn(\"Nudging 'currentTime' from \" + i + \" to \" + l), r.currentTime = l, e.trigger(n.a.ERROR, {\n            type: s.b.MEDIA_ERROR,\n            details: s.a.BUFFER_NUDGE_ON_STALL,\n            fatal: !1\n          });\n        } else o.b.error(\"Playhead still not moving while enough data buffered @\" + i + \" after \" + t.nudgeMaxRetry + \" nudges\"), e.trigger(n.a.ERROR, {\n          type: s.b.MEDIA_ERROR,\n          details: s.a.BUFFER_STALLED_ERROR,\n          fatal: !0\n        });\n      }, t;\n    }();\n\n    function Yt(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    function Xt(t, e) {\n      return (Xt = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    var qt = function (t) {\n      var e, r;\n\n      function i(e, r) {\n        var i;\n        return (i = t.call(this, e, r, \"[stream-controller]\") || this).audioCodecSwap = !1, i.gapController = null, i.level = -1, i._forceStartLoad = !1, i.altAudio = !1, i.audioOnly = !1, i.fragPlaying = null, i.onvplaying = null, i.onvseeked = null, i.fragLastKbps = 0, i.stalled = !1, i.couldBacktrack = !1, i.audioCodecSwitch = !1, i.videoBuffer = null, i._registerListeners(), i;\n      }\n\n      r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Xt(e, r);\n      var l,\n          d,\n          h,\n          f = i.prototype;\n      return f._registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(n.a.MANIFEST_LOADING, this.onManifestLoading, this), t.on(n.a.MANIFEST_PARSED, this.onManifestParsed, this), t.on(n.a.LEVEL_LOADING, this.onLevelLoading, this), t.on(n.a.LEVEL_LOADED, this.onLevelLoaded, this), t.on(n.a.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), t.on(n.a.ERROR, this.onError, this), t.on(n.a.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.on(n.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.on(n.a.BUFFER_CREATED, this.onBufferCreated, this), t.on(n.a.BUFFER_FLUSHED, this.onBufferFlushed, this), t.on(n.a.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(n.a.FRAG_BUFFERED, this.onFragBuffered, this);\n      }, f._unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(n.a.MANIFEST_LOADING, this.onManifestLoading, this), t.off(n.a.MANIFEST_PARSED, this.onManifestParsed, this), t.off(n.a.LEVEL_LOADED, this.onLevelLoaded, this), t.off(n.a.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), t.off(n.a.ERROR, this.onError, this), t.off(n.a.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.off(n.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.off(n.a.BUFFER_CREATED, this.onBufferCreated, this), t.off(n.a.BUFFER_FLUSHED, this.onBufferFlushed, this), t.off(n.a.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(n.a.FRAG_BUFFERED, this.onFragBuffered, this);\n      }, f.onHandlerDestroying = function () {\n        this._unregisterListeners(), this.onMediaDetaching();\n      }, f.startLoad = function (t) {\n        if (this.levels) {\n          var e = this.lastCurrentTime,\n              r = this.hls;\n\n          if (this.stopLoad(), this.setInterval(100), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {\n            var i = r.startLevel;\n            -1 === i && (r.config.testBandwidth ? (i = 0, this.bitrateTest = !0) : i = r.nextAutoLevel), this.level = r.nextLoadLevel = i, this.loadedmetadata = !1;\n          }\n\n          e > 0 && -1 === t && (this.log(\"Override startPosition with lastCurrentTime @\" + e.toFixed(3)), t = e), this.state = _t, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = t, this.tick();\n        } else this._forceStartLoad = !0, this.state = Dt;\n      }, f.stopLoad = function () {\n        this._forceStartLoad = !1, t.prototype.stopLoad.call(this);\n      }, f.doTick = function () {\n        switch (this.state) {\n          case _t:\n            this.doTickIdle();\n            break;\n\n          case Mt:\n            var t,\n                e = this.levels,\n                r = this.level,\n                i = null == e || null === (t = e[r]) || void 0 === t ? void 0 : t.details;\n\n            if (i && (!i.live || this.levelLastLoaded === this.level)) {\n              if (this.waitForCdnTuneIn(i)) break;\n              this.state = _t;\n              break;\n            }\n\n            break;\n\n          case Ct:\n            var a,\n                n = self.performance.now(),\n                s = this.retryDate;\n            (!s || n >= s || null !== (a = this.media) && void 0 !== a && a.seeking) && (this.log(\"retryDate reached, switch back to IDLE state\"), this.state = _t);\n        }\n\n        this.onTickEnd();\n      }, f.onTickEnd = function () {\n        t.prototype.onTickEnd.call(this), this.checkBuffer(), this.checkFragmentChanged();\n      }, f.doTickIdle = function () {\n        var t,\n            e,\n            r = this.hls,\n            i = this.levelLastLoaded,\n            a = this.levels,\n            s = this.media,\n            o = r.config,\n            l = r.nextLoadLevel;\n\n        if (null !== i && (s || !this.startFragRequested && o.startFragPrefetch) && (!this.altAudio || !this.audioOnly) && a && a[l]) {\n          var d = a[l];\n          this.level = r.nextLoadLevel = l;\n          var h = d.details;\n          if (!h || this.state === Mt || h.live && this.levelLastLoaded !== l) this.state = Mt;else {\n            var f = this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : s, _.b.MAIN);\n            if (null !== f) if (!(f.len >= this.getMaxBufferLength(d.maxBitrate))) {\n              if (this._streamEnded(f, h)) {\n                var c = {};\n                return this.altAudio && (c.type = \"video\"), this.hls.trigger(n.a.BUFFER_EOS, c), void (this.state = Pt);\n              }\n\n              var v = f.end,\n                  g = this.getNextFragment(v, h);\n\n              if (this.couldBacktrack && !this.fragPrevious && g && \"initSegment\" !== g.sn) {\n                var p = g.sn - h.startSN;\n                p > 1 && (g = h.fragments[p - 1], this.fragmentTracker.removeFragment(g));\n              }\n\n              if (g && this.fragmentTracker.getState(g) === $.OK && this.nextLoadPosition > v) {\n                var m = this.audioOnly && !this.altAudio ? u.a.AUDIO : u.a.VIDEO;\n                this.afterBufferFlushed(s, m, _.b.MAIN), g = this.getNextFragment(this.nextLoadPosition, h);\n              }\n\n              g && (!g.initSegment || g.initSegment.data || this.bitrateTest || (g = g.initSegment), \"identity\" !== (null === (t = g.decryptdata) || void 0 === t ? void 0 : t.keyFormat) || null !== (e = g.decryptdata) && void 0 !== e && e.key ? this.loadFragment(g, h, v) : this.loadKey(g, h));\n            }\n          }\n        }\n      }, f.loadFragment = function (e, r, i) {\n        var a,\n            n = this.fragmentTracker.getState(e);\n\n        if (this.fragCurrent = e, n === $.BACKTRACKED) {\n          var s = this.fragmentTracker.getBacktrackData(e);\n          if (s) return this._handleFragmentLoadProgress(s), void this._handleFragmentLoadComplete(s);\n          n = $.NOT_LOADED;\n        }\n\n        n === $.NOT_LOADED || n === $.PARTIAL ? \"initSegment\" === e.sn ? this._loadInitSegment(e) : this.bitrateTest ? (e.bitrateTest = !0, this.log(\"Fragment \" + e.sn + \" of level \" + e.level + \" is being downloaded to test bitrate and will not be buffered\"), this._loadBitrateTestFrag(e)) : (this.startFragRequested = !0, t.prototype.loadFragment.call(this, e, r, i)) : n === $.APPENDING ? this.reduceMaxBufferLength(e.duration) && this.fragmentTracker.removeFragment(e) : 0 === (null === (a = this.media) || void 0 === a ? void 0 : a.buffered.length) && this.fragmentTracker.removeAllFragments();\n      }, f.getAppendedFrag = function (t) {\n        var e = this.fragmentTracker.getAppendedFrag(t, _.b.MAIN);\n        return e && \"fragment\" in e ? e.fragment : e;\n      }, f.getBufferedFrag = function (t) {\n        return this.fragmentTracker.getBufferedFrag(t, _.b.MAIN);\n      }, f.followingBufferedFrag = function (t) {\n        return t ? this.getBufferedFrag(t.end + .5) : null;\n      }, f.immediateLevelSwitch = function () {\n        this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n      }, f.nextLevelSwitch = function () {\n        var t = this.levels,\n            e = this.media;\n\n        if (null != e && e.readyState) {\n          var r,\n              i = this.getAppendedFrag(e.currentTime);\n\n          if (i && i.start > 1 && this.flushMainBuffer(0, i.start - 1), !e.paused && t) {\n            var a = t[this.hls.nextLoadLevel],\n                n = this.fragLastKbps;\n            r = n && this.fragCurrent ? this.fragCurrent.duration * a.maxBitrate / (1e3 * n) + 1 : 0;\n          } else r = 0;\n\n          var s = this.getBufferedFrag(e.currentTime + r);\n\n          if (s) {\n            var o = this.followingBufferedFrag(s);\n\n            if (o) {\n              this.abortCurrentFrag();\n              var l = o.maxStartPTS ? o.maxStartPTS : o.start,\n                  u = o.duration,\n                  d = Math.max(s.end, l + Math.min(Math.max(u - this.config.maxFragLookUpTolerance, .5 * u), .75 * u));\n              this.flushMainBuffer(d, Number.POSITIVE_INFINITY);\n            }\n          }\n        }\n      }, f.abortCurrentFrag = function () {\n        var t = this.fragCurrent;\n        this.fragCurrent = null, null != t && t.loader && t.loader.abort(), this.state === kt && (this.state = _t), this.nextLoadPosition = this.getLoadPosition();\n      }, f.flushMainBuffer = function (e, r) {\n        t.prototype.flushMainBuffer.call(this, e, r, this.altAudio ? \"video\" : null);\n      }, f.onMediaAttached = function (e, r) {\n        t.prototype.onMediaAttached.call(this, e, r);\n        var i = r.media;\n        this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), i.addEventListener(\"playing\", this.onvplaying), i.addEventListener(\"seeked\", this.onvseeked), this.gapController = new Wt(this.config, i, this.fragmentTracker, this.hls);\n      }, f.onMediaDetaching = function () {\n        var e = this.media;\n        e && (e.removeEventListener(\"playing\", this.onvplaying), e.removeEventListener(\"seeked\", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), t.prototype.onMediaDetaching.call(this);\n      }, f.onMediaPlaying = function () {\n        this.tick();\n      }, f.onMediaSeeked = function () {\n        var t = this.media,\n            e = t ? t.currentTime : null;\n        Object(a.a)(e) && this.log(\"Media seeked to \" + e.toFixed(3)), this.tick();\n      }, f.onManifestLoading = function () {\n        this.log(\"Trigger BUFFER_RESET\"), this.hls.trigger(n.a.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = this.stalled = !1, this.startPosition = this.lastCurrentTime = 0, this.fragPlaying = null;\n      }, f.onManifestParsed = function (t, e) {\n        var r,\n            i,\n            a,\n            n = !1,\n            s = !1;\n        e.levels.forEach(function (t) {\n          (r = t.audioCodec) && (-1 !== r.indexOf(\"mp4a.40.2\") && (n = !0), -1 !== r.indexOf(\"mp4a.40.5\") && (s = !0));\n        }), this.audioCodecSwitch = n && s && !(\"function\" == typeof (null == (a = Ut()) || null === (i = a.prototype) || void 0 === i ? void 0 : i.changeType)), this.audioCodecSwitch && this.log(\"Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC\"), this.levels = e.levels, this.startFragRequested = !1;\n      }, f.onLevelLoading = function (t, e) {\n        var r = this.levels;\n\n        if (r && this.state === _t) {\n          var i = r[e.level];\n          (!i.details || i.details.live && this.levelLastLoaded !== e.level || this.waitForCdnTuneIn(i.details)) && (this.state = Mt);\n        }\n      }, f.onLevelLoaded = function (t, e) {\n        var r,\n            i = this.levels,\n            a = e.level,\n            s = e.details,\n            o = s.totalduration;\n\n        if (i) {\n          this.log(\"Level \" + a + \" loaded [\" + s.startSN + \",\" + s.endSN + \"], cc [\" + s.startCC + \", \" + s.endCC + \"] duration:\" + o);\n          var l = this.fragCurrent;\n          !l || this.state !== xt && this.state !== Ct || l.level !== e.level && l.loader && (this.state = _t, l.loader.abort());\n          var u = i[a],\n              d = 0;\n\n          if (s.live || null !== (r = u.details) && void 0 !== r && r.live) {\n            if (s.fragments[0] || (s.deltaUpdateFailed = !0), s.deltaUpdateFailed) return;\n            d = this.alignPlaylists(s, u.details);\n          }\n\n          if (u.details = s, this.levelLastLoaded = a, this.hls.trigger(n.a.LEVEL_UPDATED, {\n            details: s,\n            level: a\n          }), this.state === Mt) {\n            if (this.waitForCdnTuneIn(s)) return;\n            this.state = _t;\n          }\n\n          this.startFragRequested ? s.live && this.synchronizeToLiveEdge(s) : this.setStartPosition(s, d), this.tick();\n        } else this.warn(\"Levels were reset while loading level \" + a);\n      }, f._handleFragmentLoadProgress = function (t) {\n        var e,\n            r = t.frag,\n            i = t.part,\n            a = t.payload,\n            n = this.levels;\n\n        if (n) {\n          var s = n[r.level],\n              o = s.details;\n\n          if (o) {\n            var l = s.videoCodec,\n                u = o.PTSKnown || !o.live,\n                d = null === (e = r.initSegment) || void 0 === e ? void 0 : e.data,\n                h = this._getAudioCodec(s),\n                f = this.transmuxer = this.transmuxer || new Vt(this.hls, _.b.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)),\n                c = i ? i.index : -1,\n                v = -1 !== c,\n                g = new st(r.level, r.sn, r.stats.chunkCount, a.byteLength, c, v),\n                p = this.initPTS[r.cc];\n\n            f.push(a, d, h, l, r, i, o.totalduration, u, g, p);\n          } else this.warn(\"Dropping fragment \" + r.sn + \" of level \" + r.level + \" after level details were reset\");\n        } else this.warn(\"Levels were reset while fragment load was in progress. Fragment \" + r.sn + \" of level \" + r.level + \" will not be buffered\");\n      }, f.onAudioTrackSwitching = function (t, e) {\n        var r = this.altAudio,\n            i = !!e.url,\n            a = e.id;\n\n        if (!i) {\n          if (this.mediaBuffer !== this.media) {\n            this.log(\"Switching on main audio, use media.buffered to schedule main fragment loading\"), this.mediaBuffer = this.media;\n            var s = this.fragCurrent;\n            null != s && s.loader && (this.log(\"Switching to main audio track, cancel main fragment load\"), s.loader.abort()), this.resetTransmuxer(), this.resetLoadingState();\n          } else this.audioOnly && this.resetTransmuxer();\n\n          var o = this.hls;\n          r && o.trigger(n.a.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: Number.POSITIVE_INFINITY,\n            type: \"audio\"\n          }), o.trigger(n.a.AUDIO_TRACK_SWITCHED, {\n            id: a\n          });\n        }\n      }, f.onAudioTrackSwitched = function (t, e) {\n        var r = e.id,\n            i = !!this.hls.audioTracks[r].url;\n\n        if (i) {\n          var a = this.videoBuffer;\n          a && this.mediaBuffer !== a && (this.log(\"Switching on alternate audio, use video.buffered to schedule main fragment loading\"), this.mediaBuffer = a);\n        }\n\n        this.altAudio = i, this.tick();\n      }, f.onBufferCreated = function (t, e) {\n        var r,\n            i,\n            a = e.tracks,\n            n = !1;\n\n        for (var s in a) {\n          var o = a[s];\n\n          if (\"main\" === o.id) {\n            if (i = s, r = o, \"video\" === s) {\n              var l = a[s];\n              l && (this.videoBuffer = l.buffer);\n            }\n          } else n = !0;\n        }\n\n        n && r ? (this.log(\"Alternate track found, use \" + i + \".buffered to schedule main fragment loading\"), this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media;\n      }, f.onFragBuffered = function (t, e) {\n        var r = e.frag,\n            i = e.part;\n\n        if (!r || r.type === _.b.MAIN) {\n          if (this.fragContextChanged(r)) return this.warn(\"Fragment \" + r.sn + (i ? \" p: \" + i.index : \"\") + \" of level \" + r.level + \" finished buffering, but was aborted. state: \" + this.state), void (this.state === Ot && (this.state = _t));\n          var a = i ? i.stats : r.stats;\n          this.fragLastKbps = Math.round(8 * a.total / (a.buffering.end - a.loading.first)), \"initSegment\" !== r.sn && (this.fragPrevious = r), this.fragBufferedComplete(r, i);\n        }\n      }, f.onError = function (t, e) {\n        switch (e.details) {\n          case s.a.FRAG_LOAD_ERROR:\n          case s.a.FRAG_LOAD_TIMEOUT:\n          case s.a.KEY_LOAD_ERROR:\n          case s.a.KEY_LOAD_TIMEOUT:\n            this.onFragmentOrKeyLoadError(_.b.MAIN, e);\n            break;\n\n          case s.a.LEVEL_LOAD_ERROR:\n          case s.a.LEVEL_LOAD_TIMEOUT:\n            this.state !== Ft && (e.fatal ? (this.warn(\"\" + e.details), this.state = Ft) : e.levelRetry || this.state !== Mt || (this.state = _t));\n            break;\n\n          case s.a.BUFFER_FULL_ERROR:\n            if (\"main\" === e.parent && (this.state === wt || this.state === Ot)) {\n              var r = !0,\n                  i = this.getFwdBufferInfo(this.media, _.b.MAIN);\n              i && i.len > .5 && (r = !this.reduceMaxBufferLength(i.len)), r && (this.warn(\"buffer full error also media.currentTime is not buffered, flush main\"), this.immediateLevelSwitch()), this.resetLoadingState();\n            }\n\n        }\n      }, f.checkBuffer = function () {\n        var t = this.media,\n            e = this.gapController;\n\n        if (t && e && t.readyState) {\n          var r = nt.getBuffered(t);\n          !this.loadedmetadata && r.length ? (this.loadedmetadata = !0, this.seekToStartPos()) : e.poll(this.lastCurrentTime), this.lastCurrentTime = t.currentTime;\n        }\n      }, f.onFragLoadEmergencyAborted = function () {\n        this.state = _t, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate();\n      }, f.onBufferFlushed = function (t, e) {\n        var r = e.type;\n\n        if (r !== u.a.AUDIO || this.audioOnly && !this.altAudio) {\n          var i = (r === u.a.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n          this.afterBufferFlushed(i, r, _.b.MAIN);\n        }\n      }, f.onLevelsUpdated = function (t, e) {\n        this.levels = e.levels;\n      }, f.swapAudioCodec = function () {\n        this.audioCodecSwap = !this.audioCodecSwap;\n      }, f.seekToStartPos = function () {\n        var t = this.media,\n            e = t.currentTime,\n            r = this.startPosition;\n\n        if (r >= 0 && e < r) {\n          if (t.seeking) return void o.b.log(\"could not seek to \" + r + \", already seeking at \" + e);\n          var i = nt.getBuffered(t),\n              a = (i.length ? i.start(0) : 0) - r;\n          a > 0 && (a < this.config.maxBufferHole || a < this.config.maxFragLookUpTolerance) && (o.b.log(\"adjusting start position by \" + a + \" to match buffer start\"), r += a, this.startPosition = r), this.log(\"seek to target start position \" + r + \" from current time \" + e), t.currentTime = r;\n        }\n      }, f._getAudioCodec = function (t) {\n        var e = this.config.defaultAudioCodec || t.audioCodec;\n        return this.audioCodecSwap && e && (this.log(\"Swapping audio codec\"), e = -1 !== e.indexOf(\"mp4a.40.5\") ? \"mp4a.40.2\" : \"mp4a.40.5\"), e;\n      }, f._loadBitrateTestFrag = function (t) {\n        var e = this;\n\n        this._doFragLoad(t).then(function (r) {\n          var i = e.hls;\n\n          if (r && !i.nextLoadLevel && !e.fragContextChanged(t)) {\n            e.fragLoadError = 0, e.state = _t, e.startFragRequested = !1, e.bitrateTest = !1;\n            var a = t.stats;\n            a.parsing.start = a.parsing.end = a.buffering.start = a.buffering.end = self.performance.now(), i.trigger(n.a.FRAG_LOADED, r);\n          }\n        });\n      }, f._handleTransmuxComplete = function (t) {\n        var e,\n            r = \"main\",\n            i = this.hls,\n            s = t.remuxResult,\n            o = t.chunkMeta,\n            l = this.getCurrentContext(o);\n        if (!l) return this.warn(\"The loading context changed while buffering fragment \" + o.sn + \" of level \" + o.level + \". This chunk will not be buffered.\"), void this.resetLiveStartWhenNotLoaded(o.level);\n        var d = l.frag,\n            h = l.part,\n            f = l.level,\n            c = s.video,\n            v = s.text,\n            g = s.id3,\n            p = s.initSegment,\n            m = this.altAudio ? void 0 : s.audio;\n\n        if (!this.fragContextChanged(d)) {\n          if (this.state = wt, p) {\n            p.tracks && (this._bufferInitSegment(f, p.tracks, d, o), i.trigger(n.a.FRAG_PARSING_INIT_SEGMENT, {\n              frag: d,\n              id: r,\n              tracks: p.tracks\n            }));\n            var y = p.initPTS,\n                b = p.timescale;\n            Object(a.a)(y) && (this.initPTS[d.cc] = y, i.trigger(n.a.INIT_PTS_FOUND, {\n              frag: d,\n              id: r,\n              initPTS: y,\n              timescale: b\n            }));\n          }\n\n          if (c && !1 !== s.independent) {\n            if (f.details) {\n              var T = c.startPTS,\n                  E = c.endPTS,\n                  S = c.startDTS,\n                  L = c.endDTS;\n              if (h) h.elementaryStreams[c.type] = {\n                startPTS: T,\n                endPTS: E,\n                startDTS: S,\n                endDTS: L\n              };else if (c.firstKeyFrame && c.independent && (this.couldBacktrack = !0), c.dropped && c.independent) {\n                if (this.getLoadPosition() + this.config.maxBufferHole < T) return void this.backtrack(d);\n                d.setElementaryStreamInfo(c.type, d.start, E, d.start, L, !0);\n              }\n              d.setElementaryStreamInfo(c.type, T, E, S, L), this.bufferFragmentData(c, d, h, o);\n            }\n          } else if (!1 === s.independent) return void this.backtrack(d);\n\n          if (m) {\n            var A = m.startPTS,\n                R = m.endPTS,\n                D = m.startDTS,\n                _ = m.endDTS;\n            h && (h.elementaryStreams[u.a.AUDIO] = {\n              startPTS: A,\n              endPTS: R,\n              startDTS: D,\n              endDTS: _\n            }), d.setElementaryStreamInfo(u.a.AUDIO, A, R, D, _), this.bufferFragmentData(m, d, h, o);\n          }\n\n          if (null != g && null !== (e = g.samples) && void 0 !== e && e.length) {\n            var k = {\n              frag: d,\n              id: r,\n              samples: g.samples\n            };\n            i.trigger(n.a.FRAG_PARSING_METADATA, k);\n          }\n\n          if (v) {\n            var x = {\n              frag: d,\n              id: r,\n              samples: v.samples\n            };\n            i.trigger(n.a.FRAG_PARSING_USERDATA, x);\n          }\n        }\n      }, f._bufferInitSegment = function (t, e, r, i) {\n        var a = this;\n\n        if (this.state === wt) {\n          this.audioOnly = !!e.audio && !e.video, this.altAudio && !this.audioOnly && delete e.audio;\n          var s = e.audio,\n              o = e.video,\n              l = e.audiovideo;\n\n          if (s) {\n            var u = t.audioCodec,\n                d = navigator.userAgent.toLowerCase();\n            this.audioCodecSwitch && (u && (u = -1 !== u.indexOf(\"mp4a.40.5\") ? \"mp4a.40.2\" : \"mp4a.40.5\"), 1 !== s.metadata.channelCount && -1 === d.indexOf(\"firefox\") && (u = \"mp4a.40.5\")), -1 !== d.indexOf(\"android\") && \"audio/mpeg\" !== s.container && (u = \"mp4a.40.2\", this.log(\"Android: force audio codec to \" + u)), t.audioCodec && t.audioCodec !== u && this.log('Swapping manifest audio codec \"' + t.audioCodec + '\" for \"' + u + '\"'), s.levelCodec = u, s.id = \"main\", this.log(\"Init audio buffer, container:\" + s.container + \", codecs[selected/level/parsed]=[\" + (u || \"\") + \"/\" + (t.audioCodec || \"\") + \"/\" + s.codec + \"]\");\n          }\n\n          o && (o.levelCodec = t.videoCodec, o.id = \"main\", this.log(\"Init video buffer, container:\" + o.container + \", codecs[level/parsed]=[\" + (t.videoCodec || \"\") + \"/\" + o.codec + \"]\")), l && this.log(\"Init audiovideo buffer, container:\" + l.container + \", codecs[level/parsed]=[\" + (t.attrs.CODECS || \"\") + \"/\" + l.codec + \"]\"), this.hls.trigger(n.a.BUFFER_CODECS, e), Object.keys(e).forEach(function (t) {\n            var s = e[t].initSegment;\n            null != s && s.byteLength && a.hls.trigger(n.a.BUFFER_APPENDING, {\n              type: t,\n              data: s,\n              frag: r,\n              part: null,\n              chunkMeta: i,\n              parent: r.type\n            });\n          }), this.tick();\n        }\n      }, f.backtrack = function (t) {\n        this.couldBacktrack = !0, this.resetTransmuxer(), this.flushBufferGap(t);\n        var e = this.fragmentTracker.backtrack(t);\n        this.fragPrevious = null, this.nextLoadPosition = t.start, e ? this.resetFragmentLoading(t) : this.state = It;\n      }, f.checkFragmentChanged = function () {\n        var t = this.media,\n            e = null;\n\n        if (t && t.readyState > 1 && !1 === t.seeking) {\n          var r = t.currentTime;\n\n          if (nt.isBuffered(t, r) ? e = this.getAppendedFrag(r) : nt.isBuffered(t, r + .1) && (e = this.getAppendedFrag(r + .1)), e) {\n            var i = this.fragPlaying,\n                a = e.level;\n            i && e.sn === i.sn && i.level === a && e.urlId === i.urlId || (this.hls.trigger(n.a.FRAG_CHANGED, {\n              frag: e\n            }), i && i.level === a || this.hls.trigger(n.a.LEVEL_SWITCHED, {\n              level: a\n            }), this.fragPlaying = e);\n          }\n        }\n      }, l = i, (d = [{\n        key: \"nextLevel\",\n        get: function () {\n          var t = this.nextBufferedFrag;\n          return t ? t.level : -1;\n        }\n      }, {\n        key: \"currentLevel\",\n        get: function () {\n          var t = this.media;\n\n          if (t) {\n            var e = this.getAppendedFrag(t.currentTime);\n            if (e) return e.level;\n          }\n\n          return -1;\n        }\n      }, {\n        key: \"nextBufferedFrag\",\n        get: function () {\n          var t = this.media;\n\n          if (t) {\n            var e = this.getAppendedFrag(t.currentTime);\n            return this.followingBufferedFrag(e);\n          }\n\n          return null;\n        }\n      }, {\n        key: \"forceStartLoad\",\n        get: function () {\n          return this._forceStartLoad;\n        }\n      }]) && Yt(l.prototype, d), h && Yt(l, h), i;\n    }(Nt),\n        zt = function () {\n      function t(t, e, r) {\n        void 0 === e && (e = 0), void 0 === r && (r = 0), this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = t, this.alpha_ = t ? Math.exp(Math.log(.5) / t) : 0, this.estimate_ = e, this.totalWeight_ = r;\n      }\n\n      var e = t.prototype;\n      return e.sample = function (t, e) {\n        var r = Math.pow(this.alpha_, t);\n        this.estimate_ = e * (1 - r) + r * this.estimate_, this.totalWeight_ += t;\n      }, e.getTotalWeight = function () {\n        return this.totalWeight_;\n      }, e.getEstimate = function () {\n        if (this.alpha_) {\n          var t = 1 - Math.pow(this.alpha_, this.totalWeight_);\n          if (t) return this.estimate_ / t;\n        }\n\n        return this.estimate_;\n      }, t;\n    }(),\n        Qt = function () {\n      function t(t, e, r) {\n        this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new zt(t), this.fast_ = new zt(e);\n      }\n\n      var e = t.prototype;\n      return e.update = function (t, e) {\n        var r = this.slow_,\n            i = this.fast_;\n        this.slow_.halfLife !== t && (this.slow_ = new zt(t, r.getEstimate(), r.getTotalWeight())), this.fast_.halfLife !== e && (this.fast_ = new zt(e, i.getEstimate(), i.getTotalWeight()));\n      }, e.sample = function (t, e) {\n        var r = (t = Math.max(t, this.minDelayMs_)) / 1e3,\n            i = 8 * e / r;\n        this.fast_.sample(r, i), this.slow_.sample(r, i);\n      }, e.canEstimate = function () {\n        var t = this.fast_;\n        return t && t.getTotalWeight() >= this.minWeight_;\n      }, e.getEstimate = function () {\n        return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;\n      }, e.destroy = function () {}, t;\n    }();\n\n    function $t(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    var Zt = function () {\n      function t(t) {\n        this.hls = void 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = void 0, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this.hls = t;\n        var e = t.config;\n        this.bwEstimator = new Qt(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate), this.registerListeners();\n      }\n\n      var e,\n          r,\n          i,\n          l = t.prototype;\n      return l.registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.FRAG_LOADING, this.onFragLoading, this), t.on(n.a.FRAG_LOADED, this.onFragLoaded, this), t.on(n.a.FRAG_BUFFERED, this.onFragBuffered, this), t.on(n.a.LEVEL_LOADED, this.onLevelLoaded, this), t.on(n.a.ERROR, this.onError, this);\n      }, l.unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.FRAG_LOADING, this.onFragLoading, this), t.off(n.a.FRAG_LOADED, this.onFragLoaded, this), t.off(n.a.FRAG_BUFFERED, this.onFragBuffered, this), t.off(n.a.LEVEL_LOADED, this.onLevelLoaded, this), t.off(n.a.ERROR, this.onError, this);\n      }, l.destroy = function () {\n        this.unregisterListeners(), this.clearTimer(), this.hls = this.onCheck = null, this.fragCurrent = this.partCurrent = null;\n      }, l.onFragLoading = function (t, e) {\n        var r,\n            i = e.frag;\n        i.type === _.b.MAIN && (this.timer || (this.fragCurrent = i, this.partCurrent = null != (r = e.part) ? r : null, this.timer = self.setInterval(this.onCheck, 100)));\n      }, l.onLevelLoaded = function (t, e) {\n        var r = this.hls.config;\n        e.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD);\n      }, l._abandonRulesCheck = function () {\n        var t = this.fragCurrent,\n            e = this.partCurrent,\n            r = this.hls,\n            i = r.autoLevelEnabled,\n            s = r.config,\n            l = r.media;\n\n        if (t && l) {\n          var u = e ? e.stats : t.stats,\n              d = e ? e.duration : t.duration;\n          if (u.aborted) return o.b.warn(\"frag loader destroy or aborted, disarm abandonRules\"), this.clearTimer(), void (this._nextAutoLevel = -1);\n\n          if (i && !l.paused && l.playbackRate && l.readyState) {\n            var h = performance.now() - u.loading.start,\n                f = Math.abs(l.playbackRate);\n\n            if (!(h <= 500 * d / f)) {\n              var c = r.levels,\n                  v = r.minAutoLevel,\n                  g = c[t.level],\n                  p = u.total || Math.max(u.loaded, Math.round(d * g.maxBitrate / 8)),\n                  m = Math.max(1, u.bwEstimate ? u.bwEstimate / 8 : 1e3 * u.loaded / h),\n                  y = (p - u.loaded) / m,\n                  b = l.currentTime,\n                  T = (nt.bufferInfo(l, b, s.maxBufferHole).end - b) / f;\n\n              if (!(T >= 2 * d / f || y <= T)) {\n                var E,\n                    S = Number.POSITIVE_INFINITY;\n\n                for (E = t.level - 1; E > v; E--) {\n                  if ((S = d * c[E].maxBitrate / (6.4 * m)) < T) break;\n                }\n\n                if (!(S >= y)) {\n                  var L = this.bwEstimator.getEstimate();\n                  o.b.warn(\"Fragment \" + t.sn + (e ? \" part \" + e.index : \"\") + \" of level \" + t.level + \" is loading too slowly and will cause an underbuffer; aborting and switching to level \" + E + \"\\n      Current BW estimate: \" + (Object(a.a)(L) ? (L / 1024).toFixed(3) : \"Unknown\") + \" Kb/s\\n      Estimated load time for current fragment: \" + y.toFixed(3) + \" s\\n      Estimated load time for the next fragment: \" + S.toFixed(3) + \" s\\n      Time to underbuffer: \" + T.toFixed(3) + \" s\"), r.nextLoadLevel = E, this.bwEstimator.sample(h, u.loaded), this.clearTimer(), t.loader && (this.fragCurrent = this.partCurrent = null, t.loader.abort()), r.trigger(n.a.FRAG_LOAD_EMERGENCY_ABORTED, {\n                    frag: t,\n                    part: e,\n                    stats: u\n                  });\n                }\n              }\n            }\n          }\n        }\n      }, l.onFragLoaded = function (t, e) {\n        var r = e.frag,\n            i = e.part;\n\n        if (r.type === _.b.MAIN && Object(a.a)(r.sn)) {\n          var s = i ? i.stats : r.stats,\n              o = i ? i.duration : r.duration;\n\n          if (this.clearTimer(), this.lastLoadedFragLevel = r.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {\n            var l = this.hls.levels[r.level],\n                u = (l.loaded ? l.loaded.bytes : 0) + s.loaded,\n                d = (l.loaded ? l.loaded.duration : 0) + o;\n            l.loaded = {\n              bytes: u,\n              duration: d\n            }, l.realBitrate = Math.round(8 * u / d);\n          }\n\n          if (r.bitrateTest) {\n            var h = {\n              stats: s,\n              frag: r,\n              part: i,\n              id: r.type\n            };\n            this.onFragBuffered(n.a.FRAG_BUFFERED, h), r.bitrateTest = !1;\n          }\n        }\n      }, l.onFragBuffered = function (t, e) {\n        var r = e.frag,\n            i = e.part,\n            a = i ? i.stats : r.stats;\n\n        if (!a.aborted && r.type === _.b.MAIN && \"initSegment\" !== r.sn) {\n          var n = a.parsing.end - a.loading.start;\n          this.bwEstimator.sample(n, a.loaded), a.bwEstimate = this.bwEstimator.getEstimate(), r.bitrateTest ? this.bitrateTestDelay = n / 1e3 : this.bitrateTestDelay = 0;\n        }\n      }, l.onError = function (t, e) {\n        switch (e.details) {\n          case s.a.FRAG_LOAD_ERROR:\n          case s.a.FRAG_LOAD_TIMEOUT:\n            this.clearTimer();\n        }\n      }, l.clearTimer = function () {\n        self.clearInterval(this.timer), this.timer = void 0;\n      }, l.getNextABRAutoLevel = function () {\n        var t = this.fragCurrent,\n            e = this.partCurrent,\n            r = this.hls,\n            i = r.maxAutoLevel,\n            a = r.config,\n            n = r.minAutoLevel,\n            s = r.media,\n            l = e ? e.duration : t ? t.duration : 0,\n            u = s ? s.currentTime : 0,\n            d = s && 0 !== s.playbackRate ? Math.abs(s.playbackRate) : 1,\n            h = this.bwEstimator ? this.bwEstimator.getEstimate() : a.abrEwmaDefaultEstimate,\n            f = (nt.bufferInfo(s, u, a.maxBufferHole).end - u) / d,\n            c = this.findBestLevel(h, n, i, f, a.abrBandWidthFactor, a.abrBandWidthUpFactor);\n        if (c >= 0) return c;\n        o.b.trace((f ? \"rebuffering expected\" : \"buffer is empty\") + \", finding optimal quality level\");\n        var v = l ? Math.min(l, a.maxStarvationDelay) : a.maxStarvationDelay,\n            g = a.abrBandWidthFactor,\n            p = a.abrBandWidthUpFactor;\n\n        if (!f) {\n          var m = this.bitrateTestDelay;\n          if (m) v = (l ? Math.min(l, a.maxLoadingDelay) : a.maxLoadingDelay) - m, o.b.trace(\"bitrate test took \" + Math.round(1e3 * m) + \"ms, set first fragment max fetchDuration to \" + Math.round(1e3 * v) + \" ms\"), g = p = 1;\n        }\n\n        return c = this.findBestLevel(h, n, i, f + v, g, p), Math.max(c, 0);\n      }, l.findBestLevel = function (t, e, r, i, a, n) {\n        for (var s, l = this.fragCurrent, u = this.partCurrent, d = this.lastLoadedFragLevel, h = this.hls.levels, f = h[d], c = !(null == f || null === (s = f.details) || void 0 === s || !s.live), v = null == f ? void 0 : f.codecSet, g = u ? u.duration : l ? l.duration : 0, p = r; p >= e; p--) {\n          var m = h[p];\n\n          if (m && (!v || m.codecSet === v)) {\n            var y = m.details,\n                b = (u ? null == y ? void 0 : y.partTarget : null == y ? void 0 : y.averagetargetduration) || g,\n                T = void 0;\n            T = p <= d ? a * t : n * t;\n            var E = h[p].maxBitrate,\n                S = E * b / T;\n            if (o.b.trace(\"level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: \" + p + \"/\" + Math.round(T) + \"/\" + E + \"/\" + b + \"/\" + i + \"/\" + S), T > E && (!S || c && !this.bitrateTestDelay || S < i)) return p;\n          }\n        }\n\n        return -1;\n      }, e = t, (r = [{\n        key: \"nextAutoLevel\",\n        get: function () {\n          var t = this._nextAutoLevel,\n              e = this.bwEstimator;\n          if (!(-1 === t || e && e.canEstimate())) return t;\n          var r = this.getNextABRAutoLevel();\n          return -1 !== t && (r = Math.min(t, r)), r;\n        },\n        set: function (t) {\n          this._nextAutoLevel = t;\n        }\n      }]) && $t(e.prototype, r), i && $t(e, i), t;\n    }(),\n        Jt = r(10),\n        te = r.n(Jt),\n        ee = function () {\n      function t(t) {\n        this.buffers = void 0, this.queues = {\n          video: [],\n          audio: [],\n          audiovideo: []\n        }, this.buffers = t;\n      }\n\n      var e = t.prototype;\n      return e.append = function (t, e) {\n        var r = this.queues[e];\n        r.push(t), 1 === r.length && this.buffers[e] && this.executeNext(e);\n      }, e.insertAbort = function (t, e) {\n        this.queues[e].unshift(t), this.executeNext(e);\n      }, e.appendBlocker = function (t) {\n        var e,\n            r = new Promise(function (t) {\n          e = t;\n        }),\n            i = {\n          execute: e,\n          onStart: function () {},\n          onComplete: function () {},\n          onError: function () {}\n        };\n        return this.append(i, t), r;\n      }, e.executeNext = function (t) {\n        var e = this.buffers,\n            r = this.queues,\n            i = e[t],\n            a = r[t];\n\n        if (a.length) {\n          var n = a[0];\n\n          try {\n            n.execute();\n          } catch (e) {\n            o.b.warn(\"[buffer-operation-queue]: Unhandled exception executing the current operation\"), n.onError(e), i && i.updating || (a.shift(), this.executeNext(t));\n          }\n        }\n      }, e.shiftAndExecuteNext = function (t) {\n        this.queues[t].shift(), this.executeNext(t);\n      }, e.current = function (t) {\n        return this.queues[t][0];\n      }, t;\n    }(),\n        re = Bt(),\n        ie = /([ha]vc.)(?:\\.[^.,]+)+/,\n        ae = function () {\n      function t(t) {\n        var e = this;\n        this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = function () {\n          var t = e.hls,\n              r = e.media,\n              i = e.mediaSource;\n          o.b.log(\"[buffer-controller]: Media source opened\"), r && (e.updateMediaElementDuration(), t.trigger(n.a.MEDIA_ATTACHED, {\n            media: r\n          })), i && i.removeEventListener(\"sourceopen\", e._onMediaSourceOpen), e.checkPendingTracks();\n        }, this._onMediaSourceClose = function () {\n          o.b.log(\"[buffer-controller]: Media source closed\");\n        }, this._onMediaSourceEnded = function () {\n          o.b.log(\"[buffer-controller]: Media source ended\");\n        }, this.hls = t, this._initSourceBuffer(), this.registerListeners();\n      }\n\n      var e = t.prototype;\n      return e.hasSourceTypes = function () {\n        return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n      }, e.destroy = function () {\n        this.unregisterListeners(), this.details = null;\n      }, e.registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(n.a.MANIFEST_PARSED, this.onManifestParsed, this), t.on(n.a.BUFFER_RESET, this.onBufferReset, this), t.on(n.a.BUFFER_APPENDING, this.onBufferAppending, this), t.on(n.a.BUFFER_CODECS, this.onBufferCodecs, this), t.on(n.a.BUFFER_EOS, this.onBufferEos, this), t.on(n.a.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(n.a.LEVEL_UPDATED, this.onLevelUpdated, this), t.on(n.a.FRAG_PARSED, this.onFragParsed, this), t.on(n.a.FRAG_CHANGED, this.onFragChanged, this);\n      }, e.unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(n.a.MANIFEST_PARSED, this.onManifestParsed, this), t.off(n.a.BUFFER_RESET, this.onBufferReset, this), t.off(n.a.BUFFER_APPENDING, this.onBufferAppending, this), t.off(n.a.BUFFER_CODECS, this.onBufferCodecs, this), t.off(n.a.BUFFER_EOS, this.onBufferEos, this), t.off(n.a.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(n.a.LEVEL_UPDATED, this.onLevelUpdated, this), t.off(n.a.FRAG_PARSED, this.onFragParsed, this), t.off(n.a.FRAG_CHANGED, this.onFragChanged, this);\n      }, e._initSourceBuffer = function () {\n        this.sourceBuffer = {}, this.operationQueue = new ee(this.sourceBuffer), this.listeners = {\n          audio: [],\n          video: [],\n          audiovideo: []\n        };\n      }, e.onManifestParsed = function (t, e) {\n        var r = 2;\n        (e.audio && !e.video || !e.altAudio) && (r = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = r, this.details = null, o.b.log(this.bufferCodecEventsExpected + \" bufferCodec event(s) expected\");\n      }, e.onMediaAttaching = function (t, e) {\n        var r = this.media = e.media;\n\n        if (r && re) {\n          var i = this.mediaSource = new re();\n          i.addEventListener(\"sourceopen\", this._onMediaSourceOpen), i.addEventListener(\"sourceended\", this._onMediaSourceEnded), i.addEventListener(\"sourceclose\", this._onMediaSourceClose), r.src = self.URL.createObjectURL(i), this._objectUrl = r.src;\n        }\n      }, e.onMediaDetaching = function () {\n        var t = this.media,\n            e = this.mediaSource,\n            r = this._objectUrl;\n\n        if (e) {\n          if (o.b.log(\"[buffer-controller]: media source detaching\"), \"open\" === e.readyState) try {\n            e.endOfStream();\n          } catch (t) {\n            o.b.warn(\"[buffer-controller]: onMediaDetaching: \" + t.message + \" while calling endOfStream\");\n          }\n          this.onBufferReset(), e.removeEventListener(\"sourceopen\", this._onMediaSourceOpen), e.removeEventListener(\"sourceended\", this._onMediaSourceEnded), e.removeEventListener(\"sourceclose\", this._onMediaSourceClose), t && (r && self.URL.revokeObjectURL(r), t.src === r ? (t.removeAttribute(\"src\"), t.load()) : o.b.warn(\"[buffer-controller]: media.src was changed by a third party - skip cleanup\")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {};\n        }\n\n        this.hls.trigger(n.a.MEDIA_DETACHED, void 0);\n      }, e.onBufferReset = function () {\n        var t = this;\n        this.getSourceBufferTypes().forEach(function (e) {\n          var r = t.sourceBuffer[e];\n\n          try {\n            r && (t.removeBufferListeners(e), t.mediaSource && t.mediaSource.removeSourceBuffer(r), t.sourceBuffer[e] = void 0);\n          } catch (t) {\n            o.b.warn(\"[buffer-controller]: Failed to reset the \" + e + \" buffer\", t);\n          }\n        }), this._initSourceBuffer();\n      }, e.onBufferCodecs = function (t, e) {\n        var r = this,\n            i = this.getSourceBufferTypes().length;\n        Object.keys(e).forEach(function (t) {\n          if (i) {\n            var a = r.tracks[t];\n\n            if (a && \"function\" == typeof a.buffer.changeType) {\n              var n = e[t],\n                  s = n.codec,\n                  o = n.levelCodec,\n                  l = n.container;\n\n              if ((a.levelCodec || a.codec).replace(ie, \"$1\") !== (o || s).replace(ie, \"$1\")) {\n                var u = l + \";codecs=\" + (o || s);\n                r.appendChangeType(t, u);\n              }\n            }\n          } else r.pendingTracks[t] = e[t];\n        }), i || (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && \"open\" === this.mediaSource.readyState && this.checkPendingTracks());\n      }, e.appendChangeType = function (t, e) {\n        var r = this,\n            i = this.operationQueue,\n            a = {\n          execute: function () {\n            var a = r.sourceBuffer[t];\n            a && (o.b.log(\"[buffer-controller]: changing \" + t + \" sourceBuffer type to \" + e), a.changeType(e)), i.shiftAndExecuteNext(t);\n          },\n          onStart: function () {},\n          onComplete: function () {},\n          onError: function (e) {\n            o.b.warn(\"[buffer-controller]: Failed to change \" + t + \" SourceBuffer type\", e);\n          }\n        };\n        i.append(a, t);\n      }, e.onBufferAppending = function (t, e) {\n        var r = this,\n            i = this.hls,\n            a = this.operationQueue,\n            l = this.tracks,\n            u = e.data,\n            d = e.type,\n            h = e.frag,\n            f = e.part,\n            c = e.chunkMeta,\n            v = c.buffering[d],\n            g = self.performance.now();\n        v.start = g;\n        var p = h.stats.buffering,\n            m = f ? f.stats.buffering : null;\n        0 === p.start && (p.start = g), m && 0 === m.start && (m.start = g);\n        var y = l.audio,\n            b = \"audio\" === d && 1 === c.id && \"audio/mpeg\" === (null == y ? void 0 : y.container),\n            T = {\n          execute: function () {\n            if (v.executeStart = self.performance.now(), b) {\n              var t = r.sourceBuffer[d];\n\n              if (t) {\n                var e = h.start - t.timestampOffset;\n                Math.abs(e) >= .1 && (o.b.log(\"[buffer-controller]: Updating audio SourceBuffer timestampOffset to \" + h.start + \" (delta: \" + e + \") sn: \" + h.sn + \")\"), t.timestampOffset = h.start);\n              }\n            }\n\n            r.appendExecutor(u, d);\n          },\n          onStart: function () {},\n          onComplete: function () {\n            var t = self.performance.now();\n            v.executeEnd = v.end = t, 0 === p.first && (p.first = t), m && 0 === m.first && (m.first = t);\n            var e = r.sourceBuffer,\n                i = {};\n\n            for (var a in e) i[a] = nt.getBuffered(e[a]);\n\n            r.appendError = 0, r.hls.trigger(n.a.BUFFER_APPENDED, {\n              type: d,\n              frag: h,\n              part: f,\n              chunkMeta: c,\n              parent: h.type,\n              timeRanges: i\n            });\n          },\n          onError: function (t) {\n            o.b.error(\"[buffer-controller]: Error encountered while trying to append to the \" + d + \" SourceBuffer\", t);\n            var e = {\n              type: s.b.MEDIA_ERROR,\n              parent: h.type,\n              details: s.a.BUFFER_APPEND_ERROR,\n              err: t,\n              fatal: !1\n            };\n            t.code === DOMException.QUOTA_EXCEEDED_ERR ? e.details = s.a.BUFFER_FULL_ERROR : (r.appendError++, e.details = s.a.BUFFER_APPEND_ERROR, r.appendError > i.config.appendErrorMaxRetry && (o.b.error(\"[buffer-controller]: Failed \" + i.config.appendErrorMaxRetry + \" times to append segment in sourceBuffer\"), e.fatal = !0)), i.trigger(n.a.ERROR, e);\n          }\n        };\n        a.append(T, d);\n      }, e.onBufferFlushing = function (t, e) {\n        var r = this,\n            i = this.operationQueue,\n            a = function (t) {\n          return {\n            execute: r.removeExecutor.bind(r, t, e.startOffset, e.endOffset),\n            onStart: function () {},\n            onComplete: function () {\n              r.hls.trigger(n.a.BUFFER_FLUSHED, {\n                type: t\n              });\n            },\n            onError: function (e) {\n              o.b.warn(\"[buffer-controller]: Failed to remove from \" + t + \" SourceBuffer\", e);\n            }\n          };\n        };\n\n        e.type ? i.append(a(e.type), e.type) : this.getSourceBufferTypes().forEach(function (t) {\n          i.append(a(t), t);\n        });\n      }, e.onFragParsed = function (t, e) {\n        var r = this,\n            i = e.frag,\n            a = e.part,\n            s = [],\n            l = a ? a.elementaryStreams : i.elementaryStreams;\n        l[u.a.AUDIOVIDEO] ? s.push(\"audiovideo\") : (l[u.a.AUDIO] && s.push(\"audio\"), l[u.a.VIDEO] && s.push(\"video\"));\n        0 === s.length && o.b.warn(\"Fragments must have at least one ElementaryStreamType set. type: \" + i.type + \" level: \" + i.level + \" sn: \" + i.sn), this.blockBuffers(function () {\n          var t = self.performance.now();\n          i.stats.buffering.end = t, a && (a.stats.buffering.end = t);\n          var e = a ? a.stats : i.stats;\n          r.hls.trigger(n.a.FRAG_BUFFERED, {\n            frag: i,\n            part: a,\n            stats: e,\n            id: i.type\n          });\n        }, s);\n      }, e.onFragChanged = function (t, e) {\n        this.flushBackBuffer();\n      }, e.onBufferEos = function (t, e) {\n        var r = this;\n        this.getSourceBufferTypes().reduce(function (t, i) {\n          var a = r.sourceBuffer[i];\n          return e.type && e.type !== i || a && !a.ended && (a.ended = !0, o.b.log(\"[buffer-controller]: \" + i + \" sourceBuffer now EOS\")), t && !(a && !a.ended);\n        }, !0) && this.blockBuffers(function () {\n          var t = r.mediaSource;\n          t && \"open\" === t.readyState && t.endOfStream();\n        });\n      }, e.onLevelUpdated = function (t, e) {\n        var r = e.details;\n        r.fragments.length && (this.details = r, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration());\n      }, e.flushBackBuffer = function () {\n        var t = this.hls,\n            e = this.details,\n            r = this.media,\n            i = this.sourceBuffer;\n\n        if (r && null !== e) {\n          var s = this.getSourceBufferTypes();\n\n          if (s.length) {\n            var o = e.live && null !== t.config.liveBackBufferLength ? t.config.liveBackBufferLength : t.config.backBufferLength;\n\n            if (Object(a.a)(o) && !(o < 0)) {\n              var l = r.currentTime,\n                  u = e.levelTargetDuration,\n                  d = Math.max(o, u),\n                  h = Math.floor(l / u) * u - d;\n              s.forEach(function (r) {\n                var a = i[r];\n\n                if (a) {\n                  var s = nt.getBuffered(a);\n                  s.length > 0 && h > s.start(0) && (t.trigger(n.a.BACK_BUFFER_REACHED, {\n                    bufferEnd: h\n                  }), e.live && t.trigger(n.a.LIVE_BACK_BUFFER_REACHED, {\n                    bufferEnd: h\n                  }), t.trigger(n.a.BUFFER_FLUSHING, {\n                    startOffset: 0,\n                    endOffset: h,\n                    type: r\n                  }));\n                }\n              });\n            }\n          }\n        }\n      }, e.updateMediaElementDuration = function () {\n        if (this.details && this.media && this.mediaSource && \"open\" === this.mediaSource.readyState) {\n          var t = this.details,\n              e = this.hls,\n              r = this.media,\n              i = this.mediaSource,\n              n = t.fragments[0].start + t.totalduration,\n              s = r.duration,\n              l = Object(a.a)(i.duration) ? i.duration : 0;\n          t.live && e.config.liveDurationInfinity ? (o.b.log(\"[buffer-controller]: Media Source duration is set to Infinity\"), i.duration = 1 / 0, this.updateSeekableRange(t)) : (n > l && n > s || !Object(a.a)(s)) && (o.b.log(\"[buffer-controller]: Updating Media Source duration to \" + n.toFixed(3)), i.duration = n);\n        }\n      }, e.updateSeekableRange = function (t) {\n        var e = this.mediaSource,\n            r = t.fragments;\n\n        if (r.length && t.live && null != e && e.setLiveSeekableRange) {\n          var i = Math.max(0, r[0].start),\n              a = Math.max(i, i + t.totalduration);\n          e.setLiveSeekableRange(i, a);\n        }\n      }, e.checkPendingTracks = function () {\n        var t = this.bufferCodecEventsExpected,\n            e = this.operationQueue,\n            r = this.pendingTracks,\n            i = Object.keys(r).length;\n\n        if (i && !t || 2 === i) {\n          this.createSourceBuffers(r), this.pendingTracks = {};\n          var a = this.getSourceBufferTypes();\n          if (0 === a.length) return void this.hls.trigger(n.a.ERROR, {\n            type: s.b.MEDIA_ERROR,\n            details: s.a.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n            fatal: !0,\n            reason: \"could not create source buffer for media codec(s)\"\n          });\n          a.forEach(function (t) {\n            e.executeNext(t);\n          });\n        }\n      }, e.createSourceBuffers = function (t) {\n        var e = this.sourceBuffer,\n            r = this.mediaSource;\n        if (!r) throw Error(\"createSourceBuffers called when mediaSource was null\");\n        var i = 0;\n\n        for (var a in t) if (!e[a]) {\n          var l = t[a];\n          if (!l) throw Error(\"source buffer exists for track \" + a + \", however track does not\");\n          var u = l.levelCodec || l.codec,\n              d = l.container + \";codecs=\" + u;\n          o.b.log(\"[buffer-controller]: creating sourceBuffer(\" + d + \")\");\n\n          try {\n            var h = e[a] = r.addSourceBuffer(d),\n                f = a;\n            this.addBufferListener(f, \"updatestart\", this._onSBUpdateStart), this.addBufferListener(f, \"updateend\", this._onSBUpdateEnd), this.addBufferListener(f, \"error\", this._onSBUpdateError), this.tracks[a] = {\n              buffer: h,\n              codec: u,\n              container: l.container,\n              levelCodec: l.levelCodec,\n              id: l.id\n            }, i++;\n          } catch (t) {\n            o.b.error(\"[buffer-controller]: error while trying to add sourceBuffer: \" + t.message), this.hls.trigger(n.a.ERROR, {\n              type: s.b.MEDIA_ERROR,\n              details: s.a.BUFFER_ADD_CODEC_ERROR,\n              fatal: !1,\n              error: t,\n              mimeType: d\n            });\n          }\n        }\n\n        i && this.hls.trigger(n.a.BUFFER_CREATED, {\n          tracks: this.tracks\n        });\n      }, e._onSBUpdateStart = function (t) {\n        this.operationQueue.current(t).onStart();\n      }, e._onSBUpdateEnd = function (t) {\n        var e = this.operationQueue;\n        e.current(t).onComplete(), e.shiftAndExecuteNext(t);\n      }, e._onSBUpdateError = function (t, e) {\n        o.b.error(\"[buffer-controller]: \" + t + \" SourceBuffer error\", e), this.hls.trigger(n.a.ERROR, {\n          type: s.b.MEDIA_ERROR,\n          details: s.a.BUFFER_APPENDING_ERROR,\n          fatal: !1\n        });\n        var r = this.operationQueue.current(t);\n        r && r.onError(e);\n      }, e.removeExecutor = function (t, e, r) {\n        var i = this.media,\n            n = this.mediaSource,\n            s = this.operationQueue,\n            l = this.sourceBuffer[t];\n        if (!i || !n || !l) return o.b.warn(\"[buffer-controller]: Attempting to remove from the \" + t + \" SourceBuffer, but it does not exist\"), void s.shiftAndExecuteNext(t);\n        var u = Object(a.a)(i.duration) ? i.duration : 1 / 0,\n            d = Object(a.a)(n.duration) ? n.duration : 1 / 0,\n            h = Math.max(0, e),\n            f = Math.min(r, u, d);\n        f > h ? (o.b.log(\"[buffer-controller]: Removing [\" + h + \",\" + f + \"] from the \" + t + \" SourceBuffer\"), l.remove(h, f)) : s.shiftAndExecuteNext(t);\n      }, e.appendExecutor = function (t, e) {\n        var r = this.operationQueue,\n            i = this.sourceBuffer[e];\n        if (!i) return o.b.warn(\"[buffer-controller]: Attempting to append to the \" + e + \" SourceBuffer, but it does not exist\"), void r.shiftAndExecuteNext(e);\n        i.ended = !1, i.appendBuffer(t);\n      }, e.blockBuffers = function (t, e) {\n        var r = this;\n        if (void 0 === e && (e = this.getSourceBufferTypes()), !e.length) return o.b.log(\"[buffer-controller]: Blocking operation requested, but no SourceBuffers exist\"), void Promise.resolve(t);\n        var i = this.operationQueue,\n            a = e.map(function (t) {\n          return i.appendBlocker(t);\n        });\n        Promise.all(a).then(function () {\n          t(), e.forEach(function (t) {\n            var e = r.sourceBuffer[t];\n            e && e.updating || i.shiftAndExecuteNext(t);\n          });\n        });\n      }, e.getSourceBufferTypes = function () {\n        return Object.keys(this.sourceBuffer);\n      }, e.addBufferListener = function (t, e, r) {\n        var i = this.sourceBuffer[t];\n\n        if (i) {\n          var a = r.bind(this, t);\n          this.listeners[t].push({\n            event: e,\n            listener: a\n          }), i.addEventListener(e, a);\n        }\n      }, e.removeBufferListeners = function (t) {\n        var e = this.sourceBuffer[t];\n        e && this.listeners[t].forEach(function (t) {\n          e.removeEventListener(t.event, t.listener);\n        });\n      }, t;\n    }();\n\n    function ne(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    var se = function () {\n      function t(t) {\n        this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.hls = void 0, this.streamController = void 0, this.clientRect = void 0, this.hls = t, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners();\n      }\n\n      var e,\n          r,\n          i,\n          a = t.prototype;\n      return a.setStreamController = function (t) {\n        this.streamController = t;\n      }, a.destroy = function () {\n        this.unregisterListener(), this.hls.config.capLevelToPlayerSize && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null;\n      }, a.registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), t.on(n.a.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(n.a.MANIFEST_PARSED, this.onManifestParsed, this), t.on(n.a.BUFFER_CODECS, this.onBufferCodecs, this), t.on(n.a.MEDIA_DETACHING, this.onMediaDetaching, this);\n      }, a.unregisterListener = function () {\n        var t = this.hls;\n        t.off(n.a.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), t.off(n.a.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(n.a.MANIFEST_PARSED, this.onManifestParsed, this), t.off(n.a.BUFFER_CODECS, this.onBufferCodecs, this), t.off(n.a.MEDIA_DETACHING, this.onMediaDetaching, this);\n      }, a.onFpsDropLevelCapping = function (e, r) {\n        t.isLevelAllowed(r.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(r.droppedLevel);\n      }, a.onMediaAttaching = function (t, e) {\n        this.media = e.media instanceof HTMLVideoElement ? e.media : null;\n      }, a.onManifestParsed = function (t, e) {\n        var r = this.hls;\n        this.restrictedLevels = [], this.firstLevel = e.firstLevel, r.config.capLevelToPlayerSize && e.video && this.startCapping();\n      }, a.onBufferCodecs = function (t, e) {\n        this.hls.config.capLevelToPlayerSize && e.video && this.startCapping();\n      }, a.onMediaDetaching = function () {\n        this.stopCapping();\n      }, a.detectPlayerSize = function () {\n        if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {\n          var t = this.hls.levels;\n\n          if (t.length) {\n            var e = this.hls;\n            e.autoLevelCapping = this.getMaxLevel(t.length - 1), e.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = e.autoLevelCapping;\n          }\n        }\n      }, a.getMaxLevel = function (e) {\n        var r = this,\n            i = this.hls.levels;\n        if (!i.length) return -1;\n        var a = i.filter(function (i, a) {\n          return t.isLevelAllowed(a, r.restrictedLevels) && a <= e;\n        });\n        return this.clientRect = null, t.getMaxLevelByMediaSize(a, this.mediaWidth, this.mediaHeight);\n      }, a.startCapping = function () {\n        this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());\n      }, a.stopCapping = function () {\n        this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0);\n      }, a.getDimensions = function () {\n        if (this.clientRect) return this.clientRect;\n        var t = this.media,\n            e = {\n          width: 0,\n          height: 0\n        };\n\n        if (t) {\n          var r = t.getBoundingClientRect();\n          e.width = r.width, e.height = r.height, e.width || e.height || (e.width = r.right - r.left || t.width || 0, e.height = r.bottom - r.top || t.height || 0);\n        }\n\n        return this.clientRect = e, e;\n      }, t.isLevelAllowed = function (t, e) {\n        return void 0 === e && (e = []), -1 === e.indexOf(t);\n      }, t.getMaxLevelByMediaSize = function (t, e, r) {\n        if (!t || !t.length) return -1;\n\n        for (var i, a, n = t.length - 1, s = 0; s < t.length; s += 1) {\n          var o = t[s];\n\n          if ((o.width >= e || o.height >= r) && (i = o, !(a = t[s + 1]) || i.width !== a.width || i.height !== a.height)) {\n            n = s;\n            break;\n          }\n        }\n\n        return n;\n      }, e = t, i = [{\n        key: \"contentScaleFactor\",\n        get: function () {\n          var t = 1;\n\n          try {\n            t = self.devicePixelRatio;\n          } catch (t) {}\n\n          return t;\n        }\n      }], (r = [{\n        key: \"mediaWidth\",\n        get: function () {\n          return this.getDimensions().width * t.contentScaleFactor;\n        }\n      }, {\n        key: \"mediaHeight\",\n        get: function () {\n          return this.getDimensions().height * t.contentScaleFactor;\n        }\n      }]) && ne(e.prototype, r), i && ne(e, i), t;\n    }(),\n        oe = function () {\n      function t(t) {\n        this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = t, this.registerListeners();\n      }\n\n      var e = t.prototype;\n      return e.setStreamController = function (t) {\n        this.streamController = t;\n      }, e.registerListeners = function () {\n        this.hls.on(n.a.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      }, e.unregisterListeners = function () {\n        this.hls.off(n.a.MEDIA_ATTACHING, this.onMediaAttaching);\n      }, e.destroy = function () {\n        this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null;\n      }, e.onMediaAttaching = function (t, e) {\n        var r = this.hls.config;\n\n        if (r.capLevelOnFPSDrop) {\n          var i = e.media instanceof self.HTMLVideoElement ? e.media : null;\n          this.media = i, i && \"function\" == typeof i.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod);\n        }\n      }, e.checkFPS = function (t, e, r) {\n        var i = performance.now();\n\n        if (e) {\n          if (this.lastTime) {\n            var a = i - this.lastTime,\n                s = r - this.lastDroppedFrames,\n                l = e - this.lastDecodedFrames,\n                u = 1e3 * s / a,\n                d = this.hls;\n\n            if (d.trigger(n.a.FPS_DROP, {\n              currentDropped: s,\n              currentDecoded: l,\n              totalDroppedFrames: r\n            }), u > 0 && s > d.config.fpsDroppedMonitoringThreshold * l) {\n              var h = d.currentLevel;\n              o.b.warn(\"drop FPS ratio greater than max allowed value for currentLevel: \" + h), h > 0 && (-1 === d.autoLevelCapping || d.autoLevelCapping >= h) && (h -= 1, d.trigger(n.a.FPS_DROP_LEVEL_CAPPING, {\n                level: h,\n                droppedLevel: d.currentLevel\n              }), d.autoLevelCapping = h, this.streamController.nextLevelSwitch());\n            }\n          }\n\n          this.lastTime = i, this.lastDroppedFrames = r, this.lastDecodedFrames = e;\n        }\n      }, e.checkFPSInterval = function () {\n        var t = this.media;\n        if (t) if (this.isVideoPlaybackQualityAvailable) {\n          var e = t.getVideoPlaybackQuality();\n          this.checkFPS(t, e.totalVideoFrames, e.droppedVideoFrames);\n        } else this.checkFPS(t, t.webkitDecodedFrameCount, t.webkitDroppedFrameCount);\n      }, t;\n    }(),\n        le = r(12),\n        ue = /^age:\\s*[\\d.]+\\s*$/m,\n        de = function () {\n      function t(t) {\n        this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = t ? t.xhrSetup : null, this.stats = new le.a(), this.retryDelay = 0;\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null;\n      }, e.abortInternal = function () {\n        var t = this.loader;\n        self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), t && (t.onreadystatechange = null, t.onprogress = null, 4 !== t.readyState && (this.stats.aborted = !0, t.abort()));\n      }, e.abort = function () {\n        var t;\n        this.abortInternal(), null !== (t = this.callbacks) && void 0 !== t && t.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader);\n      }, e.load = function (t, e, r) {\n        if (this.stats.loading.start) throw new Error(\"Loader can only be used once.\");\n        this.stats.loading.start = self.performance.now(), this.context = t, this.config = e, this.callbacks = r, this.retryDelay = e.retryDelay, this.loadInternal();\n      }, e.loadInternal = function () {\n        var t = this.config,\n            e = this.context;\n\n        if (t) {\n          var r = this.loader = new self.XMLHttpRequest(),\n              i = this.stats;\n          i.loading.first = 0, i.loaded = 0;\n          var a = this.xhrSetup;\n\n          try {\n            if (a) try {\n              a(r, e.url);\n            } catch (t) {\n              r.open(\"GET\", e.url, !0), a(r, e.url);\n            }\n            r.readyState || r.open(\"GET\", e.url, !0);\n            var n = this.context.headers;\n            if (n) for (var s in n) r.setRequestHeader(s, n[s]);\n          } catch (t) {\n            return void this.callbacks.onError({\n              code: r.status,\n              text: t.message\n            }, e, r);\n          }\n\n          e.rangeEnd && r.setRequestHeader(\"Range\", \"bytes=\" + e.rangeStart + \"-\" + (e.rangeEnd - 1)), r.onreadystatechange = this.readystatechange.bind(this), r.onprogress = this.loadprogress.bind(this), r.responseType = e.responseType, self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), t.timeout), r.send();\n        }\n      }, e.readystatechange = function () {\n        var t = this.context,\n            e = this.loader,\n            r = this.stats;\n\n        if (t && e) {\n          var i = e.readyState,\n              a = this.config;\n          if (!r.aborted && i >= 2) if (self.clearTimeout(this.requestTimeout), 0 === r.loading.first && (r.loading.first = Math.max(self.performance.now(), r.loading.start)), 4 === i) {\n            e.onreadystatechange = null, e.onprogress = null;\n            var n = e.status;\n\n            if (n >= 200 && n < 300) {\n              var s, l;\n              if (r.loading.end = Math.max(self.performance.now(), r.loading.first), l = \"arraybuffer\" === t.responseType ? (s = e.response).byteLength : (s = e.responseText).length, r.loaded = r.total = l, !this.callbacks) return;\n              var u = this.callbacks.onProgress;\n              if (u && u(r, t, s, e), !this.callbacks) return;\n              var d = {\n                url: e.responseURL,\n                data: s\n              };\n              this.callbacks.onSuccess(d, r, t, e);\n            } else r.retry >= a.maxRetry || n >= 400 && n < 499 ? (o.b.error(n + \" while loading \" + t.url), this.callbacks.onError({\n              code: n,\n              text: e.statusText\n            }, t, e)) : (o.b.warn(n + \" while loading \" + t.url + \", retrying in \" + this.retryDelay + \"...\"), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, a.maxRetryDelay), r.retry++);\n          } else self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), a.timeout);\n        }\n      }, e.loadtimeout = function () {\n        o.b.warn(\"timeout while loading \" + this.context.url);\n        var t = this.callbacks;\n        t && (this.abortInternal(), t.onTimeout(this.stats, this.context, this.loader));\n      }, e.loadprogress = function (t) {\n        var e = this.stats;\n        e.loaded = t.loaded, t.lengthComputable && (e.total = t.total);\n      }, e.getCacheAge = function () {\n        var t = null;\n\n        if (this.loader && ue.test(this.loader.getAllResponseHeaders())) {\n          var e = this.loader.getResponseHeader(\"age\");\n          t = e ? parseFloat(e) : null;\n        }\n\n        return t;\n      }, t;\n    }(),\n        he = r(16);\n\n    function fe(t) {\n      var e = \"function\" == typeof Map ? new Map() : void 0;\n      return (fe = function (t) {\n        if (null === t || (r = t, -1 === Function.toString.call(r).indexOf(\"[native code]\"))) return t;\n        var r;\n        if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n\n        if (void 0 !== e) {\n          if (e.has(t)) return e.get(t);\n          e.set(t, i);\n        }\n\n        function i() {\n          return ce(t, arguments, pe(this).constructor);\n        }\n\n        return i.prototype = Object.create(t.prototype, {\n          constructor: {\n            value: i,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), ge(i, t);\n      })(t);\n    }\n\n    function ce(t, e, r) {\n      return (ce = ve() ? Reflect.construct : function (t, e, r) {\n        var i = [null];\n        i.push.apply(i, e);\n        var a = new (Function.bind.apply(t, i))();\n        return r && ge(a, r.prototype), a;\n      }).apply(null, arguments);\n    }\n\n    function ve() {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n\n    function ge(t, e) {\n      return (ge = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    function pe(t) {\n      return (pe = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n        return t.__proto__ || Object.getPrototypeOf(t);\n      })(t);\n    }\n\n    function me() {\n      return (me = Object.assign || function (t) {\n        for (var e = 1; e < arguments.length; e++) {\n          var r = arguments[e];\n\n          for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);\n        }\n\n        return t;\n      }).apply(this, arguments);\n    }\n\n    var ye = function () {\n      function t(t) {\n        this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = t.fetchSetup || be, this.controller = new self.AbortController(), this.stats = new le.a();\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.loader = this.callbacks = null, this.abortInternal();\n      }, e.abortInternal = function () {\n        var t = this.response;\n        t && t.ok || (this.stats.aborted = !0, this.controller.abort());\n      }, e.abort = function () {\n        var t;\n        this.abortInternal(), null !== (t = this.callbacks) && void 0 !== t && t.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response);\n      }, e.load = function (t, e, r) {\n        var i = this,\n            n = this.stats;\n        if (n.loading.start) throw new Error(\"Loader can only be used once.\");\n        n.loading.start = self.performance.now();\n\n        var s = function (t, e) {\n          var r = {\n            method: \"GET\",\n            mode: \"cors\",\n            credentials: \"same-origin\",\n            signal: e,\n            headers: new self.Headers(me({}, t.headers))\n          };\n          t.rangeEnd && r.headers.set(\"Range\", \"bytes=\" + t.rangeStart + \"-\" + String(t.rangeEnd - 1));\n          return r;\n        }(t, this.controller.signal),\n            o = r.onProgress,\n            l = \"arraybuffer\" === t.responseType,\n            u = l ? \"byteLength\" : \"length\";\n\n        this.context = t, this.config = e, this.callbacks = r, this.request = this.fetchSetup(t, s), self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(function () {\n          i.abortInternal(), r.onTimeout(n, t, i.response);\n        }, e.timeout), self.fetch(this.request).then(function (r) {\n          if (i.response = i.loader = r, !r.ok) {\n            var s = r.status,\n                u = r.statusText;\n            throw new Ee(u || \"fetch, bad network response\", s, r);\n          }\n\n          return n.loading.first = Math.max(self.performance.now(), n.loading.start), n.total = parseInt(r.headers.get(\"Content-Length\") || \"0\"), o && Object(a.a)(e.highWaterMark) ? i.loadProgressively(r, n, t, e.highWaterMark, o) : l ? r.arrayBuffer() : r.text();\n        }).then(function (s) {\n          var l = i.response;\n          self.clearTimeout(i.requestTimeout), n.loading.end = Math.max(self.performance.now(), n.loading.first), n.loaded = n.total = s[u];\n          var d = {\n            url: l.url,\n            data: s\n          };\n          o && !Object(a.a)(e.highWaterMark) && o(n, t, s, l), r.onSuccess(d, n, t, l);\n        }).catch(function (e) {\n          if (self.clearTimeout(i.requestTimeout), !n.aborted) {\n            var a = e.code || 0;\n            r.onError({\n              code: a,\n              text: e.message\n            }, t, e.details);\n          }\n        });\n      }, e.getCacheAge = function () {\n        var t = null;\n\n        if (this.response) {\n          var e = this.response.headers.get(\"age\");\n          t = e ? parseFloat(e) : null;\n        }\n\n        return t;\n      }, e.loadProgressively = function (t, e, r, i, a) {\n        void 0 === i && (i = 0);\n        var n = new he.a(),\n            s = t.body.getReader();\n        return function o() {\n          return s.read().then(function (s) {\n            if (s.done) return n.dataLength && a(e, r, n.flush(), t), Promise.resolve(new ArrayBuffer(0));\n            var l = s.value,\n                u = l.length;\n            return e.loaded += u, u < i || n.dataLength ? (n.push(l), n.dataLength >= i && a(e, r, n.flush(), t)) : a(e, r, l, t), o();\n          }).catch(function () {\n            return Promise.reject();\n          });\n        }();\n      }, t;\n    }();\n\n    function be(t, e) {\n      return new self.Request(t.url, e);\n    }\n\n    var Te,\n        Ee = function (t) {\n      var e, r;\n\n      function i(e, r, i) {\n        var a;\n        return (a = t.call(this, e) || this).code = void 0, a.details = void 0, a.code = r, a.details = i, a;\n      }\n\n      return r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, ge(e, r), i;\n    }(fe(Error)),\n        Se = ye;\n\n    !function (t) {\n      t.WIDEVINE = \"com.widevine.alpha\", t.PLAYREADY = \"com.microsoft.playready\";\n    }(Te || (Te = {}));\n    var Le = \"undefined\" != typeof self && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;\n\n    function Ae() {\n      return (Ae = Object.assign || function (t) {\n        for (var e = 1; e < arguments.length; e++) {\n          var r = arguments[e];\n\n          for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);\n        }\n\n        return t;\n      }).apply(this, arguments);\n    }\n\n    function Re(t, e) {\n      var r = Object.keys(t);\n\n      if (Object.getOwnPropertySymbols) {\n        var i = Object.getOwnPropertySymbols(t);\n        e && (i = i.filter(function (e) {\n          return Object.getOwnPropertyDescriptor(t, e).enumerable;\n        })), r.push.apply(r, i);\n      }\n\n      return r;\n    }\n\n    function De(t) {\n      for (var e = 1; e < arguments.length; e++) {\n        var r = null != arguments[e] ? arguments[e] : {};\n        e % 2 ? Re(Object(r), !0).forEach(function (e) {\n          _e(t, e, r[e]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Re(Object(r)).forEach(function (e) {\n          Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));\n        });\n      }\n\n      return t;\n    }\n\n    function _e(t, e, r) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: r,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = r, t;\n    }\n\n    var ke = De(De({\n      autoStartLoad: !0,\n      startPosition: -1,\n      defaultAudioCodec: void 0,\n      debug: !1,\n      capLevelOnFPSDrop: !1,\n      capLevelToPlayerSize: !1,\n      initialLiveManifestSize: 1,\n      maxBufferLength: 30,\n      backBufferLength: 1 / 0,\n      maxBufferSize: 6e7,\n      maxBufferHole: .1,\n      highBufferWatchdogPeriod: 2,\n      nudgeOffset: .1,\n      nudgeMaxRetry: 3,\n      maxFragLookUpTolerance: .25,\n      liveSyncDurationCount: 3,\n      liveMaxLatencyDurationCount: 1 / 0,\n      liveSyncDuration: void 0,\n      liveMaxLatencyDuration: void 0,\n      maxLiveSyncPlaybackRate: 1,\n      liveDurationInfinity: !1,\n      liveBackBufferLength: null,\n      maxMaxBufferLength: 600,\n      enableWorker: !0,\n      enableSoftwareAES: !0,\n      manifestLoadingTimeOut: 1e4,\n      manifestLoadingMaxRetry: 1,\n      manifestLoadingRetryDelay: 1e3,\n      manifestLoadingMaxRetryTimeout: 64e3,\n      startLevel: void 0,\n      levelLoadingTimeOut: 1e4,\n      levelLoadingMaxRetry: 4,\n      levelLoadingRetryDelay: 1e3,\n      levelLoadingMaxRetryTimeout: 64e3,\n      fragLoadingTimeOut: 2e4,\n      fragLoadingMaxRetry: 6,\n      fragLoadingRetryDelay: 1e3,\n      fragLoadingMaxRetryTimeout: 64e3,\n      startFragPrefetch: !1,\n      fpsDroppedMonitoringPeriod: 5e3,\n      fpsDroppedMonitoringThreshold: .2,\n      appendErrorMaxRetry: 3,\n      loader: de,\n      fLoader: void 0,\n      pLoader: void 0,\n      xhrSetup: void 0,\n      licenseXhrSetup: void 0,\n      licenseResponseCallback: void 0,\n      abrController: Zt,\n      bufferController: ae,\n      capLevelController: se,\n      fpsController: oe,\n      stretchShortVideoTrack: !1,\n      maxAudioFramesDrift: 1,\n      forceKeyFrameOnDiscontinuity: !0,\n      abrEwmaFastLive: 3,\n      abrEwmaSlowLive: 9,\n      abrEwmaFastVoD: 3,\n      abrEwmaSlowVoD: 9,\n      abrEwmaDefaultEstimate: 5e5,\n      abrBandWidthFactor: .95,\n      abrBandWidthUpFactor: .7,\n      abrMaxWithRealBitrate: !1,\n      maxStarvationDelay: 4,\n      maxLoadingDelay: 4,\n      minAutoBitrate: 0,\n      emeEnabled: !1,\n      widevineLicenseUrl: void 0,\n      drmSystemOptions: {},\n      requestMediaKeySystemAccessFunc: Le,\n      testBandwidth: !0,\n      progressive: !1,\n      lowLatencyMode: !0,\n      cmcd: void 0\n    }, {\n      cueHandler: te.a,\n      enableCEA708Captions: !1,\n      enableWebVTT: !1,\n      enableIMSC1: !1,\n      captionsTextTrack1Label: \"English\",\n      captionsTextTrack1LanguageCode: \"en\",\n      captionsTextTrack2Label: \"Spanish\",\n      captionsTextTrack2LanguageCode: \"es\",\n      captionsTextTrack3Label: \"Unknown CC\",\n      captionsTextTrack3LanguageCode: \"\",\n      captionsTextTrack4Label: \"Unknown CC\",\n      captionsTextTrack4LanguageCode: \"\",\n      renderTextTracksNatively: !0\n    }), {}, {\n      subtitleStreamController: void 0,\n      subtitleTrackController: void 0,\n      timelineController: void 0,\n      audioStreamController: void 0,\n      audioTrackController: void 0,\n      emeController: void 0,\n      cmcdController: void 0\n    });\n\n    function xe(t) {\n      var e = t.loader;\n      e !== Se && e !== de ? (o.b.log(\"[config]: Custom loader detected, cannot enable progressive streaming\"), t.progressive = !1) : function () {\n        if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {\n          return new self.ReadableStream({}), !0;\n        } catch (t) {}\n        return !1;\n      }() && (t.loader = Se, t.progressive = !0, t.enableSoftwareAES = !0, o.b.log(\"[config]: Progressive streaming enabled, using FetchLoader\"));\n    }\n\n    function Ce(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    var we = function () {\n      function t(e) {\n        void 0 === e && (e = {}), this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new Ht.EventEmitter(), this._autoLevelCapping = void 0, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null;\n\n        var r = this.config = function (t, e) {\n          if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n          if (void 0 !== e.liveMaxLatencyDurationCount && (void 0 === e.liveSyncDurationCount || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount)) throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n          if (void 0 !== e.liveMaxLatencyDuration && (void 0 === e.liveSyncDuration || e.liveMaxLatencyDuration <= e.liveSyncDuration)) throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n          return Ae({}, t, e);\n        }(t.DefaultConfig, e);\n\n        this.userConfig = e, Object(o.a)(r.debug), this._autoLevelCapping = -1, r.progressive && xe(r);\n        var i = r.abrController,\n            a = r.bufferController,\n            n = r.capLevelController,\n            s = r.fpsController,\n            l = this.abrController = new i(this),\n            u = this.bufferController = new a(this),\n            d = this.capLevelController = new n(this),\n            h = new s(this),\n            f = new x(this),\n            c = new C(this),\n            v = new P(this),\n            g = this.levelController = new J(this),\n            p = new tt(this),\n            m = this.streamController = new qt(this, p);\n        d.setStreamController(m), h.setStreamController(m);\n        var y = [g, m];\n        this.networkControllers = y;\n        var b = [f, c, l, u, d, h, v, p];\n        this.audioTrackController = this.createController(r.audioTrackController, null, y), this.createController(r.audioStreamController, p, y), this.subtitleTrackController = this.createController(r.subtitleTrackController, null, y), this.createController(r.subtitleStreamController, p, y), this.createController(r.timelineController, null, b), this.emeController = this.createController(r.emeController, null, b), this.cmcdController = this.createController(r.cmcdController, null, b), this.latencyController = this.createController(N, null, b), this.coreComponents = b;\n      }\n\n      t.isSupported = function () {\n        return function () {\n          var t = Bt();\n          if (!t) return !1;\n          var e = Ut(),\n              r = t && \"function\" == typeof t.isTypeSupported && t.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"'),\n              i = !e || e.prototype && \"function\" == typeof e.prototype.appendBuffer && \"function\" == typeof e.prototype.remove;\n          return !!r && !!i;\n        }();\n      };\n\n      var e,\n          r,\n          a,\n          l = t.prototype;\n      return l.createController = function (t, e, r) {\n        if (t) {\n          var i = e ? new t(this, e) : new t(this);\n          return r && r.push(i), i;\n        }\n\n        return null;\n      }, l.on = function (t, e, r) {\n        void 0 === r && (r = this), this._emitter.on(t, e, r);\n      }, l.once = function (t, e, r) {\n        void 0 === r && (r = this), this._emitter.once(t, e, r);\n      }, l.removeAllListeners = function (t) {\n        this._emitter.removeAllListeners(t);\n      }, l.off = function (t, e, r, i) {\n        void 0 === r && (r = this), this._emitter.off(t, e, r, i);\n      }, l.listeners = function (t) {\n        return this._emitter.listeners(t);\n      }, l.emit = function (t, e, r) {\n        return this._emitter.emit(t, e, r);\n      }, l.trigger = function (t, e) {\n        if (this.config.debug) return this.emit(t, t, e);\n\n        try {\n          return this.emit(t, t, e);\n        } catch (e) {\n          o.b.error(\"An internal error happened while handling event \" + t + '. Error message: \"' + e.message + '\". Here is a stacktrace:', e), this.trigger(n.a.ERROR, {\n            type: s.b.OTHER_ERROR,\n            details: s.a.INTERNAL_EXCEPTION,\n            fatal: !1,\n            event: t,\n            error: e\n          });\n        }\n\n        return !1;\n      }, l.listenerCount = function (t) {\n        return this._emitter.listenerCount(t);\n      }, l.destroy = function () {\n        o.b.log(\"destroy\"), this.trigger(n.a.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach(function (t) {\n          return t.destroy();\n        }), this.networkControllers.length = 0, this.coreComponents.forEach(function (t) {\n          return t.destroy();\n        }), this.coreComponents.length = 0;\n      }, l.attachMedia = function (t) {\n        o.b.log(\"attachMedia\"), this._media = t, this.trigger(n.a.MEDIA_ATTACHING, {\n          media: t\n        });\n      }, l.detachMedia = function () {\n        o.b.log(\"detachMedia\"), this.trigger(n.a.MEDIA_DETACHING, void 0), this._media = null;\n      }, l.loadSource = function (t) {\n        this.stopLoad();\n        var e = this.media,\n            r = this.url,\n            a = this.url = i.buildAbsoluteURL(self.location.href, t, {\n          alwaysNormalize: !0\n        });\n        o.b.log(\"loadSource:\" + a), e && r && r !== a && this.bufferController.hasSourceTypes() && (this.detachMedia(), this.attachMedia(e)), this.trigger(n.a.MANIFEST_LOADING, {\n          url: t\n        });\n      }, l.startLoad = function (t) {\n        void 0 === t && (t = -1), o.b.log(\"startLoad(\" + t + \")\"), this.networkControllers.forEach(function (e) {\n          e.startLoad(t);\n        });\n      }, l.stopLoad = function () {\n        o.b.log(\"stopLoad\"), this.networkControllers.forEach(function (t) {\n          t.stopLoad();\n        });\n      }, l.swapAudioCodec = function () {\n        o.b.log(\"swapAudioCodec\"), this.streamController.swapAudioCodec();\n      }, l.recoverMediaError = function () {\n        o.b.log(\"recoverMediaError\");\n        var t = this._media;\n        this.detachMedia(), t && this.attachMedia(t);\n      }, l.removeLevel = function (t, e) {\n        void 0 === e && (e = 0), this.levelController.removeLevel(t, e);\n      }, e = t, a = [{\n        key: \"version\",\n        get: function () {\n          return \"1.1.5\";\n        }\n      }, {\n        key: \"Events\",\n        get: function () {\n          return n.a;\n        }\n      }, {\n        key: \"ErrorTypes\",\n        get: function () {\n          return s.b;\n        }\n      }, {\n        key: \"ErrorDetails\",\n        get: function () {\n          return s.a;\n        }\n      }, {\n        key: \"DefaultConfig\",\n        get: function () {\n          return t.defaultConfig ? t.defaultConfig : ke;\n        },\n        set: function (e) {\n          t.defaultConfig = e;\n        }\n      }], (r = [{\n        key: \"levels\",\n        get: function () {\n          var t = this.levelController.levels;\n          return t || [];\n        }\n      }, {\n        key: \"currentLevel\",\n        get: function () {\n          return this.streamController.currentLevel;\n        },\n        set: function (t) {\n          o.b.log(\"set currentLevel:\" + t), this.loadLevel = t, this.abrController.clearTimer(), this.streamController.immediateLevelSwitch();\n        }\n      }, {\n        key: \"nextLevel\",\n        get: function () {\n          return this.streamController.nextLevel;\n        },\n        set: function (t) {\n          o.b.log(\"set nextLevel:\" + t), this.levelController.manualLevel = t, this.streamController.nextLevelSwitch();\n        }\n      }, {\n        key: \"loadLevel\",\n        get: function () {\n          return this.levelController.level;\n        },\n        set: function (t) {\n          o.b.log(\"set loadLevel:\" + t), this.levelController.manualLevel = t;\n        }\n      }, {\n        key: \"nextLoadLevel\",\n        get: function () {\n          return this.levelController.nextLoadLevel;\n        },\n        set: function (t) {\n          this.levelController.nextLoadLevel = t;\n        }\n      }, {\n        key: \"firstLevel\",\n        get: function () {\n          return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n        },\n        set: function (t) {\n          o.b.log(\"set firstLevel:\" + t), this.levelController.firstLevel = t;\n        }\n      }, {\n        key: \"startLevel\",\n        get: function () {\n          return this.levelController.startLevel;\n        },\n        set: function (t) {\n          o.b.log(\"set startLevel:\" + t), -1 !== t && (t = Math.max(t, this.minAutoLevel)), this.levelController.startLevel = t;\n        }\n      }, {\n        key: \"capLevelToPlayerSize\",\n        get: function () {\n          return this.config.capLevelToPlayerSize;\n        },\n        set: function (t) {\n          var e = !!t;\n          e !== this.config.capLevelToPlayerSize && (e ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = e);\n        }\n      }, {\n        key: \"autoLevelCapping\",\n        get: function () {\n          return this._autoLevelCapping;\n        },\n        set: function (t) {\n          this._autoLevelCapping !== t && (o.b.log(\"set autoLevelCapping:\" + t), this._autoLevelCapping = t);\n        }\n      }, {\n        key: \"bandwidthEstimate\",\n        get: function () {\n          var t = this.abrController.bwEstimator;\n          return t ? t.getEstimate() : NaN;\n        }\n      }, {\n        key: \"autoLevelEnabled\",\n        get: function () {\n          return -1 === this.levelController.manualLevel;\n        }\n      }, {\n        key: \"manualLevel\",\n        get: function () {\n          return this.levelController.manualLevel;\n        }\n      }, {\n        key: \"minAutoLevel\",\n        get: function () {\n          var t = this.levels,\n              e = this.config.minAutoBitrate;\n          if (!t) return 0;\n\n          for (var r = t.length, i = 0; i < r; i++) if (t[i].maxBitrate > e) return i;\n\n          return 0;\n        }\n      }, {\n        key: \"maxAutoLevel\",\n        get: function () {\n          var t = this.levels,\n              e = this.autoLevelCapping;\n          return -1 === e && t && t.length ? t.length - 1 : e;\n        }\n      }, {\n        key: \"nextAutoLevel\",\n        get: function () {\n          return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);\n        },\n        set: function (t) {\n          this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, t);\n        }\n      }, {\n        key: \"audioTracks\",\n        get: function () {\n          var t = this.audioTrackController;\n          return t ? t.audioTracks : [];\n        }\n      }, {\n        key: \"audioTrack\",\n        get: function () {\n          var t = this.audioTrackController;\n          return t ? t.audioTrack : -1;\n        },\n        set: function (t) {\n          var e = this.audioTrackController;\n          e && (e.audioTrack = t);\n        }\n      }, {\n        key: \"subtitleTracks\",\n        get: function () {\n          var t = this.subtitleTrackController;\n          return t ? t.subtitleTracks : [];\n        }\n      }, {\n        key: \"subtitleTrack\",\n        get: function () {\n          var t = this.subtitleTrackController;\n          return t ? t.subtitleTrack : -1;\n        },\n        set: function (t) {\n          var e = this.subtitleTrackController;\n          e && (e.subtitleTrack = t);\n        }\n      }, {\n        key: \"media\",\n        get: function () {\n          return this._media;\n        }\n      }, {\n        key: \"subtitleDisplay\",\n        get: function () {\n          var t = this.subtitleTrackController;\n          return !!t && t.subtitleDisplay;\n        },\n        set: function (t) {\n          var e = this.subtitleTrackController;\n          e && (e.subtitleDisplay = t);\n        }\n      }, {\n        key: \"lowLatencyMode\",\n        get: function () {\n          return this.config.lowLatencyMode;\n        },\n        set: function (t) {\n          this.config.lowLatencyMode = t;\n        }\n      }, {\n        key: \"liveSyncPosition\",\n        get: function () {\n          return this.latencyController.liveSyncPosition;\n        }\n      }, {\n        key: \"latency\",\n        get: function () {\n          return this.latencyController.latency;\n        }\n      }, {\n        key: \"maxLatency\",\n        get: function () {\n          return this.latencyController.maxLatency;\n        }\n      }, {\n        key: \"targetLatency\",\n        get: function () {\n          return this.latencyController.targetLatency;\n        }\n      }, {\n        key: \"drift\",\n        get: function () {\n          return this.latencyController.drift;\n        }\n      }, {\n        key: \"forceStartLoad\",\n        get: function () {\n          return this.streamController.forceStartLoad;\n        }\n      }]) && Ce(e.prototype, r), a && Ce(e, a), t;\n    }();\n\n    we.defaultConfig = void 0;\n  }]).default;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGxzLmpzL2Rpc3QvaGxzLmxpZ2h0Lm1pbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9kaXN0L2hscy5saWdodC5taW4uanM/ZGZmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGUpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuSGxzPWUoKTp0Lkhscz1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXt9O2Z1bmN0aW9uIHIoaSl7aWYoZVtpXSlyZXR1cm4gZVtpXS5leHBvcnRzO3ZhciBhPWVbaV09e2k6aSxsOiExLGV4cG9ydHM6e319O3JldHVybiB0W2ldLmNhbGwoYS5leHBvcnRzLGEsYS5leHBvcnRzLHIpLGEubD0hMCxhLmV4cG9ydHN9cmV0dXJuIHIubT10LHIuYz1lLHIuZD1mdW5jdGlvbih0LGUsaSl7ci5vKHQsZSl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsZ2V0Oml9KX0sci5yPWZ1bmN0aW9uKHQpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHIudD1mdW5jdGlvbih0LGUpe2lmKDEmZSYmKHQ9cih0KSksOCZlKXJldHVybiB0O2lmKDQmZSYmXCJvYmplY3RcIj09dHlwZW9mIHQmJnQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHIucihpKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSksMiZlJiZcInN0cmluZ1wiIT10eXBlb2YgdClmb3IodmFyIGEgaW4gdClyLmQoaSxhLGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfS5iaW5kKG51bGwsYSkpO3JldHVybiBpfSxyLm49ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gdH07cmV0dXJuIHIuZChlLFwiYVwiLGUpLGV9LHIubz1mdW5jdGlvbih0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX0sci5wPVwiL2Rpc3QvXCIscihyLnM9MTkpfShbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBpO3IuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBpfSkpLGZ1bmN0aW9uKHQpe3QuTUVESUFfQVRUQUNISU5HPVwiaGxzTWVkaWFBdHRhY2hpbmdcIix0Lk1FRElBX0FUVEFDSEVEPVwiaGxzTWVkaWFBdHRhY2hlZFwiLHQuTUVESUFfREVUQUNISU5HPVwiaGxzTWVkaWFEZXRhY2hpbmdcIix0Lk1FRElBX0RFVEFDSEVEPVwiaGxzTWVkaWFEZXRhY2hlZFwiLHQuQlVGRkVSX1JFU0VUPVwiaGxzQnVmZmVyUmVzZXRcIix0LkJVRkZFUl9DT0RFQ1M9XCJobHNCdWZmZXJDb2RlY3NcIix0LkJVRkZFUl9DUkVBVEVEPVwiaGxzQnVmZmVyQ3JlYXRlZFwiLHQuQlVGRkVSX0FQUEVORElORz1cImhsc0J1ZmZlckFwcGVuZGluZ1wiLHQuQlVGRkVSX0FQUEVOREVEPVwiaGxzQnVmZmVyQXBwZW5kZWRcIix0LkJVRkZFUl9FT1M9XCJobHNCdWZmZXJFb3NcIix0LkJVRkZFUl9GTFVTSElORz1cImhsc0J1ZmZlckZsdXNoaW5nXCIsdC5CVUZGRVJfRkxVU0hFRD1cImhsc0J1ZmZlckZsdXNoZWRcIix0Lk1BTklGRVNUX0xPQURJTkc9XCJobHNNYW5pZmVzdExvYWRpbmdcIix0Lk1BTklGRVNUX0xPQURFRD1cImhsc01hbmlmZXN0TG9hZGVkXCIsdC5NQU5JRkVTVF9QQVJTRUQ9XCJobHNNYW5pZmVzdFBhcnNlZFwiLHQuTEVWRUxfU1dJVENISU5HPVwiaGxzTGV2ZWxTd2l0Y2hpbmdcIix0LkxFVkVMX1NXSVRDSEVEPVwiaGxzTGV2ZWxTd2l0Y2hlZFwiLHQuTEVWRUxfTE9BRElORz1cImhsc0xldmVsTG9hZGluZ1wiLHQuTEVWRUxfTE9BREVEPVwiaGxzTGV2ZWxMb2FkZWRcIix0LkxFVkVMX1VQREFURUQ9XCJobHNMZXZlbFVwZGF0ZWRcIix0LkxFVkVMX1BUU19VUERBVEVEPVwiaGxzTGV2ZWxQdHNVcGRhdGVkXCIsdC5MRVZFTFNfVVBEQVRFRD1cImhsc0xldmVsc1VwZGF0ZWRcIix0LkFVRElPX1RSQUNLU19VUERBVEVEPVwiaGxzQXVkaW9UcmFja3NVcGRhdGVkXCIsdC5BVURJT19UUkFDS19TV0lUQ0hJTkc9XCJobHNBdWRpb1RyYWNrU3dpdGNoaW5nXCIsdC5BVURJT19UUkFDS19TV0lUQ0hFRD1cImhsc0F1ZGlvVHJhY2tTd2l0Y2hlZFwiLHQuQVVESU9fVFJBQ0tfTE9BRElORz1cImhsc0F1ZGlvVHJhY2tMb2FkaW5nXCIsdC5BVURJT19UUkFDS19MT0FERUQ9XCJobHNBdWRpb1RyYWNrTG9hZGVkXCIsdC5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRD1cImhsc1N1YnRpdGxlVHJhY2tzVXBkYXRlZFwiLHQuU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQ9XCJobHNTdWJ0aXRsZVRyYWNrc0NsZWFyZWRcIix0LlNVQlRJVExFX1RSQUNLX1NXSVRDSD1cImhsc1N1YnRpdGxlVHJhY2tTd2l0Y2hcIix0LlNVQlRJVExFX1RSQUNLX0xPQURJTkc9XCJobHNTdWJ0aXRsZVRyYWNrTG9hZGluZ1wiLHQuU1VCVElUTEVfVFJBQ0tfTE9BREVEPVwiaGxzU3VidGl0bGVUcmFja0xvYWRlZFwiLHQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQ9XCJobHNTdWJ0aXRsZUZyYWdQcm9jZXNzZWRcIix0LkNVRVNfUEFSU0VEPVwiaGxzQ3Vlc1BhcnNlZFwiLHQuTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORD1cImhsc05vbk5hdGl2ZVRleHRUcmFja3NGb3VuZFwiLHQuSU5JVF9QVFNfRk9VTkQ9XCJobHNJbml0UHRzRm91bmRcIix0LkZSQUdfTE9BRElORz1cImhsc0ZyYWdMb2FkaW5nXCIsdC5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQ9XCJobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWRcIix0LkZSQUdfTE9BREVEPVwiaGxzRnJhZ0xvYWRlZFwiLHQuRlJBR19ERUNSWVBURUQ9XCJobHNGcmFnRGVjcnlwdGVkXCIsdC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UPVwiaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudFwiLHQuRlJBR19QQVJTSU5HX1VTRVJEQVRBPVwiaGxzRnJhZ1BhcnNpbmdVc2VyZGF0YVwiLHQuRlJBR19QQVJTSU5HX01FVEFEQVRBPVwiaGxzRnJhZ1BhcnNpbmdNZXRhZGF0YVwiLHQuRlJBR19QQVJTRUQ9XCJobHNGcmFnUGFyc2VkXCIsdC5GUkFHX0JVRkZFUkVEPVwiaGxzRnJhZ0J1ZmZlcmVkXCIsdC5GUkFHX0NIQU5HRUQ9XCJobHNGcmFnQ2hhbmdlZFwiLHQuRlBTX0RST1A9XCJobHNGcHNEcm9wXCIsdC5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HPVwiaGxzRnBzRHJvcExldmVsQ2FwcGluZ1wiLHQuRVJST1I9XCJobHNFcnJvclwiLHQuREVTVFJPWUlORz1cImhsc0Rlc3Ryb3lpbmdcIix0LktFWV9MT0FESU5HPVwiaGxzS2V5TG9hZGluZ1wiLHQuS0VZX0xPQURFRD1cImhsc0tleUxvYWRlZFwiLHQuTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVEPVwiaGxzTGl2ZUJhY2tCdWZmZXJSZWFjaGVkXCIsdC5CQUNLX0JVRkZFUl9SRUFDSEVEPVwiaGxzQmFja0J1ZmZlclJlYWNoZWRcIn0oaXx8KGk9e30pKX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3IuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBvfSkpLHIuZChlLFwiYlwiLChmdW5jdGlvbigpe3JldHVybiBsfSkpO3ZhciBpPWZ1bmN0aW9uKCl7fSxhPXt0cmFjZTppLGRlYnVnOmksbG9nOmksd2FybjppLGluZm86aSxlcnJvcjppfSxuPWE7ZnVuY3Rpb24gcyh0KXt2YXIgZT1zZWxmLmNvbnNvbGVbdF07cmV0dXJuIGU/ZS5iaW5kKHNlbGYuY29uc29sZSxcIltcIit0K1wiXSA+XCIpOml9ZnVuY3Rpb24gbyh0KXtpZihzZWxmLmNvbnNvbGUmJiEwPT09dHx8XCJvYmplY3RcIj09dHlwZW9mIHQpeyFmdW5jdGlvbih0KXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheShlPjE/ZS0xOjApLGk9MTtpPGU7aSsrKXJbaS0xXT1hcmd1bWVudHNbaV07ci5mb3JFYWNoKChmdW5jdGlvbihlKXtuW2VdPXRbZV0/dFtlXS5iaW5kKHQpOnMoZSl9KSl9KHQsXCJkZWJ1Z1wiLFwibG9nXCIsXCJpbmZvXCIsXCJ3YXJuXCIsXCJlcnJvclwiKTt0cnl7bi5sb2coKX1jYXRjaCh0KXtuPWF9fWVsc2Ugbj1hfXZhciBsPWF9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgaSxhO3IuZChlLFwiYlwiLChmdW5jdGlvbigpe3JldHVybiBpfSkpLHIuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBhfSkpLGZ1bmN0aW9uKHQpe3QuTkVUV09SS19FUlJPUj1cIm5ldHdvcmtFcnJvclwiLHQuTUVESUFfRVJST1I9XCJtZWRpYUVycm9yXCIsdC5LRVlfU1lTVEVNX0VSUk9SPVwia2V5U3lzdGVtRXJyb3JcIix0Lk1VWF9FUlJPUj1cIm11eEVycm9yXCIsdC5PVEhFUl9FUlJPUj1cIm90aGVyRXJyb3JcIn0oaXx8KGk9e30pKSxmdW5jdGlvbih0KXt0LktFWV9TWVNURU1fTk9fS0VZUz1cImtleVN5c3RlbU5vS2V5c1wiLHQuS0VZX1NZU1RFTV9OT19BQ0NFU1M9XCJrZXlTeXN0ZW1Ob0FjY2Vzc1wiLHQuS0VZX1NZU1RFTV9OT19TRVNTSU9OPVwia2V5U3lzdGVtTm9TZXNzaW9uXCIsdC5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQ9XCJrZXlTeXN0ZW1MaWNlbnNlUmVxdWVzdEZhaWxlZFwiLHQuS0VZX1NZU1RFTV9OT19JTklUX0RBVEE9XCJrZXlTeXN0ZW1Ob0luaXREYXRhXCIsdC5NQU5JRkVTVF9MT0FEX0VSUk9SPVwibWFuaWZlc3RMb2FkRXJyb3JcIix0Lk1BTklGRVNUX0xPQURfVElNRU9VVD1cIm1hbmlmZXN0TG9hZFRpbWVPdXRcIix0Lk1BTklGRVNUX1BBUlNJTkdfRVJST1I9XCJtYW5pZmVzdFBhcnNpbmdFcnJvclwiLHQuTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUj1cIm1hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3JcIix0LkxFVkVMX0VNUFRZX0VSUk9SPVwibGV2ZWxFbXB0eUVycm9yXCIsdC5MRVZFTF9MT0FEX0VSUk9SPVwibGV2ZWxMb2FkRXJyb3JcIix0LkxFVkVMX0xPQURfVElNRU9VVD1cImxldmVsTG9hZFRpbWVPdXRcIix0LkxFVkVMX1NXSVRDSF9FUlJPUj1cImxldmVsU3dpdGNoRXJyb3JcIix0LkFVRElPX1RSQUNLX0xPQURfRVJST1I9XCJhdWRpb1RyYWNrTG9hZEVycm9yXCIsdC5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ9XCJhdWRpb1RyYWNrTG9hZFRpbWVPdXRcIix0LlNVQlRJVExFX0xPQURfRVJST1I9XCJzdWJ0aXRsZVRyYWNrTG9hZEVycm9yXCIsdC5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQ9XCJzdWJ0aXRsZVRyYWNrTG9hZFRpbWVPdXRcIix0LkZSQUdfTE9BRF9FUlJPUj1cImZyYWdMb2FkRXJyb3JcIix0LkZSQUdfTE9BRF9USU1FT1VUPVwiZnJhZ0xvYWRUaW1lT3V0XCIsdC5GUkFHX0RFQ1JZUFRfRVJST1I9XCJmcmFnRGVjcnlwdEVycm9yXCIsdC5GUkFHX1BBUlNJTkdfRVJST1I9XCJmcmFnUGFyc2luZ0Vycm9yXCIsdC5SRU1VWF9BTExPQ19FUlJPUj1cInJlbXV4QWxsb2NFcnJvclwiLHQuS0VZX0xPQURfRVJST1I9XCJrZXlMb2FkRXJyb3JcIix0LktFWV9MT0FEX1RJTUVPVVQ9XCJrZXlMb2FkVGltZU91dFwiLHQuQlVGRkVSX0FERF9DT0RFQ19FUlJPUj1cImJ1ZmZlckFkZENvZGVjRXJyb3JcIix0LkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SPVwiYnVmZmVySW5jb21wYXRpYmxlQ29kZWNzRXJyb3JcIix0LkJVRkZFUl9BUFBFTkRfRVJST1I9XCJidWZmZXJBcHBlbmRFcnJvclwiLHQuQlVGRkVSX0FQUEVORElOR19FUlJPUj1cImJ1ZmZlckFwcGVuZGluZ0Vycm9yXCIsdC5CVUZGRVJfU1RBTExFRF9FUlJPUj1cImJ1ZmZlclN0YWxsZWRFcnJvclwiLHQuQlVGRkVSX0ZVTExfRVJST1I9XCJidWZmZXJGdWxsRXJyb3JcIix0LkJVRkZFUl9TRUVLX09WRVJfSE9MRT1cImJ1ZmZlclNlZWtPdmVySG9sZVwiLHQuQlVGRkVSX05VREdFX09OX1NUQUxMPVwiYnVmZmVyTnVkZ2VPblN0YWxsXCIsdC5JTlRFUk5BTF9FWENFUFRJT049XCJpbnRlcm5hbEV4Y2VwdGlvblwiLHQuSU5URVJOQUxfQUJPUlRFRD1cImFib3J0ZWRcIix0LlVOS05PV049XCJ1bmtub3duXCJ9KGF8fChhPXt9KSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gaX0pKTt2YXIgaT1OdW1iZXIuaXNGaW5pdGV8fGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZpc0Zpbml0ZSh0KX07TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgaSxhO3IuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBpfSkpLHIuZChlLFwiYlwiLChmdW5jdGlvbigpe3JldHVybiBhfSkpLGZ1bmN0aW9uKHQpe3QuTUFOSUZFU1Q9XCJtYW5pZmVzdFwiLHQuTEVWRUw9XCJsZXZlbFwiLHQuQVVESU9fVFJBQ0s9XCJhdWRpb1RyYWNrXCIsdC5TVUJUSVRMRV9UUkFDSz1cInN1YnRpdGxlVHJhY2tcIn0oaXx8KGk9e30pKSxmdW5jdGlvbih0KXt0Lk1BSU49XCJtYWluXCIsdC5BVURJTz1cImF1ZGlvXCIsdC5TVUJUSVRMRT1cInN1YnRpdGxlXCJ9KGF8fChhPXt9KSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gaX0pKSxyLmQoZSxcImJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdn0pKSxyLmQoZSxcImNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZ30pKTt2YXIgaSxhPXIoMyksbj1yKDExKSxzPXIoMSksbz1yKDE1KSxsPXIoMTIpO2Z1bmN0aW9uIHUodCxlKXt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10LGQodCxlKX1mdW5jdGlvbiBkKHQsZSl7cmV0dXJuKGQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfWZ1bmN0aW9uIGgodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaS5rZXksaSl9fWZ1bmN0aW9uIGYodCxlLHIpe3JldHVybiBlJiZoKHQucHJvdG90eXBlLGUpLHImJmgodCxyKSx0fSFmdW5jdGlvbih0KXt0LkFVRElPPVwiYXVkaW9cIix0LlZJREVPPVwidmlkZW9cIix0LkFVRElPVklERU89XCJhdWRpb3ZpZGVvXCJ9KGl8fChpPXt9KSk7dmFyIGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZhciBlO3RoaXMuX2J5dGVSYW5nZT1udWxsLHRoaXMuX3VybD1udWxsLHRoaXMuYmFzZXVybD12b2lkIDAsdGhpcy5yZWx1cmw9dm9pZCAwLHRoaXMuZWxlbWVudGFyeVN0cmVhbXM9KChlPXt9KVtpLkFVRElPXT1udWxsLGVbaS5WSURFT109bnVsbCxlW2kuQVVESU9WSURFT109bnVsbCxlKSx0aGlzLmJhc2V1cmw9dH1yZXR1cm4gdC5wcm90b3R5cGUuc2V0Qnl0ZVJhbmdlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5zcGxpdChcIkBcIiwyKSxpPVtdOzE9PT1yLmxlbmd0aD9pWzBdPWU/ZS5ieXRlUmFuZ2VFbmRPZmZzZXQ6MDppWzBdPXBhcnNlSW50KHJbMV0pLGlbMV09cGFyc2VJbnQoclswXSkraVswXSx0aGlzLl9ieXRlUmFuZ2U9aX0sZih0LFt7a2V5OlwiYnl0ZVJhbmdlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J5dGVSYW5nZT90aGlzLl9ieXRlUmFuZ2U6W119fSx7a2V5OlwiYnl0ZVJhbmdlU3RhcnRPZmZzZXRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMF19fSx7a2V5OlwiYnl0ZVJhbmdlRW5kT2Zmc2V0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzFdfX0se2tleTpcInVybFwiLGdldDpmdW5jdGlvbigpe3JldHVybiF0aGlzLl91cmwmJnRoaXMuYmFzZXVybCYmdGhpcy5yZWx1cmwmJih0aGlzLl91cmw9T2JqZWN0KG4uYnVpbGRBYnNvbHV0ZVVSTCkodGhpcy5iYXNldXJsLHRoaXMucmVsdXJsLHthbHdheXNOb3JtYWxpemU6ITB9KSksdGhpcy5fdXJsfHxcIlwifSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fdXJsPXR9fV0pLHR9KCksdj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIGk7cmV0dXJuKGk9dC5jYWxsKHRoaXMscil8fHRoaXMpLl9kZWNyeXB0ZGF0YT1udWxsLGkucmF3UHJvZ3JhbURhdGVUaW1lPW51bGwsaS5wcm9ncmFtRGF0ZVRpbWU9bnVsbCxpLnRhZ0xpc3Q9W10saS5kdXJhdGlvbj0wLGkuc249MCxpLmxldmVsa2V5PXZvaWQgMCxpLnR5cGU9dm9pZCAwLGkubG9hZGVyPW51bGwsaS5sZXZlbD0tMSxpLmNjPTAsaS5zdGFydFBUUz12b2lkIDAsaS5lbmRQVFM9dm9pZCAwLGkuYXBwZW5kZWRQVFM9dm9pZCAwLGkuc3RhcnREVFM9dm9pZCAwLGkuZW5kRFRTPXZvaWQgMCxpLnN0YXJ0PTAsaS5kZWx0YVBUUz12b2lkIDAsaS5tYXhTdGFydFBUUz12b2lkIDAsaS5taW5FbmRQVFM9dm9pZCAwLGkuc3RhdHM9bmV3IGwuYSxpLnVybElkPTAsaS5kYXRhPXZvaWQgMCxpLmJpdHJhdGVUZXN0PSExLGkudGl0bGU9bnVsbCxpLmluaXRTZWdtZW50PW51bGwsaS50eXBlPWUsaX11KGUsdCk7dmFyIHI9ZS5wcm90b3R5cGU7cmV0dXJuIHIuY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3I9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBVaW50OEFycmF5KDE2KSxyPTEyO3I8MTY7cisrKWVbcl09dD4+OCooMTUtcikmMjU1O3JldHVybiBlfSxyLnNldERlY3J5cHREYXRhRnJvbUxldmVsS2V5PWZ1bmN0aW9uKHQsZSl7dmFyIHI9dDtyZXR1cm5cIkFFUy0xMjhcIj09PShudWxsPT10P3ZvaWQgMDp0Lm1ldGhvZCkmJnQudXJpJiYhdC5pdiYmKChyPW8uYS5mcm9tVVJJKHQudXJpKSkubWV0aG9kPXQubWV0aG9kLHIuaXY9dGhpcy5jcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihlKSxyLmtleUZvcm1hdD1cImlkZW50aXR5XCIpLHJ9LHIuc2V0RWxlbWVudGFyeVN0cmVhbUluZm89ZnVuY3Rpb24odCxlLHIsaSxhLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgcz10aGlzLmVsZW1lbnRhcnlTdHJlYW1zLG89c1t0XTtvPyhvLnN0YXJ0UFRTPU1hdGgubWluKG8uc3RhcnRQVFMsZSksby5lbmRQVFM9TWF0aC5tYXgoby5lbmRQVFMsciksby5zdGFydERUUz1NYXRoLm1pbihvLnN0YXJ0RFRTLGkpLG8uZW5kRFRTPU1hdGgubWF4KG8uZW5kRFRTLGEpKTpzW3RdPXtzdGFydFBUUzplLGVuZFBUUzpyLHN0YXJ0RFRTOmksZW5kRFRTOmEscGFydGlhbDpufX0sci5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lbGVtZW50YXJ5U3RyZWFtczt0W2kuQVVESU9dPW51bGwsdFtpLlZJREVPXT1udWxsLHRbaS5BVURJT1ZJREVPXT1udWxsfSxmKGUsW3trZXk6XCJkZWNyeXB0ZGF0YVwiLGdldDpmdW5jdGlvbigpe2lmKCF0aGlzLmxldmVsa2V5JiYhdGhpcy5fZGVjcnlwdGRhdGEpcmV0dXJuIG51bGw7aWYoIXRoaXMuX2RlY3J5cHRkYXRhJiZ0aGlzLmxldmVsa2V5KXt2YXIgdD10aGlzLnNuO1wibnVtYmVyXCIhPXR5cGVvZiB0JiYodGhpcy5sZXZlbGtleSYmXCJBRVMtMTI4XCI9PT10aGlzLmxldmVsa2V5Lm1ldGhvZCYmIXRoaXMubGV2ZWxrZXkuaXYmJnMuYi53YXJuKCdtaXNzaW5nIElWIGZvciBpbml0aWFsaXphdGlvbiBzZWdtZW50IHdpdGggbWV0aG9kPVwiJyt0aGlzLmxldmVsa2V5Lm1ldGhvZCsnXCIgLSBjb21wbGlhbmNlIGlzc3VlJyksdD0wKSx0aGlzLl9kZWNyeXB0ZGF0YT10aGlzLnNldERlY3J5cHREYXRhRnJvbUxldmVsS2V5KHRoaXMubGV2ZWxrZXksdCl9cmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhfX0se2tleTpcImVuZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0K3RoaXMuZHVyYXRpb259fSx7a2V5OlwiZW5kUHJvZ3JhbURhdGVUaW1lXCIsZ2V0OmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMucHJvZ3JhbURhdGVUaW1lKXJldHVybiBudWxsO2lmKCFPYmplY3QoYS5hKSh0aGlzLnByb2dyYW1EYXRlVGltZSkpcmV0dXJuIG51bGw7dmFyIHQ9T2JqZWN0KGEuYSkodGhpcy5kdXJhdGlvbik/dGhpcy5kdXJhdGlvbjowO3JldHVybiB0aGlzLnByb2dyYW1EYXRlVGltZSsxZTMqdH19LHtrZXk6XCJlbmNyeXB0ZWRcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4hKG51bGw9PT0odD10aGlzLmRlY3J5cHRkYXRhKXx8dm9pZCAwPT09dHx8IXQua2V5Rm9ybWF0fHwhdGhpcy5kZWNyeXB0ZGF0YS51cmkpfX1dKSxlfShjKSxnPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyLGksYSxuKXt2YXIgczsocz10LmNhbGwodGhpcyxpKXx8dGhpcykuZnJhZ09mZnNldD0wLHMuZHVyYXRpb249MCxzLmdhcD0hMSxzLmluZGVwZW5kZW50PSExLHMucmVsdXJsPXZvaWQgMCxzLmZyYWdtZW50PXZvaWQgMCxzLmluZGV4PXZvaWQgMCxzLnN0YXRzPW5ldyBsLmEscy5kdXJhdGlvbj1lLmRlY2ltYWxGbG9hdGluZ1BvaW50KFwiRFVSQVRJT05cIikscy5nYXA9ZS5ib29sKFwiR0FQXCIpLHMuaW5kZXBlbmRlbnQ9ZS5ib29sKFwiSU5ERVBFTkRFTlRcIikscy5yZWx1cmw9ZS5lbnVtZXJhdGVkU3RyaW5nKFwiVVJJXCIpLHMuZnJhZ21lbnQ9cixzLmluZGV4PWE7dmFyIG89ZS5lbnVtZXJhdGVkU3RyaW5nKFwiQllURVJBTkdFXCIpO3JldHVybiBvJiZzLnNldEJ5dGVSYW5nZShvLG4pLG4mJihzLmZyYWdPZmZzZXQ9bi5mcmFnT2Zmc2V0K24uZHVyYXRpb24pLHN9cmV0dXJuIHUoZSx0KSxmKGUsW3trZXk6XCJzdGFydFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZyYWdtZW50LnN0YXJ0K3RoaXMuZnJhZ09mZnNldH19LHtrZXk6XCJlbmRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydCt0aGlzLmR1cmF0aW9ufX0se2tleTpcImxvYWRlZFwiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZWxlbWVudGFyeVN0cmVhbXM7cmV0dXJuISEodC5hdWRpb3x8dC52aWRlb3x8dC5hdWRpb3ZpZGVvKX19XSksZX0oYyl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLmQoZSxcImJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZH0pKSxyLmQoZSxcImdcIiwoZnVuY3Rpb24oKXtyZXR1cm4gaH0pKSxyLmQoZSxcImZcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZn0pKSxyLmQoZSxcImRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gY30pKSxyLmQoZSxcImNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdn0pKSxyLmQoZSxcImVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gcH0pKSxyLmQoZSxcImhcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbX0pKSxyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4geX0pKTt2YXIgaT1yKDgpLGE9cig1KSxuPU1hdGgucG93KDIsMzIpLTEscz1bXS5wdXNoO2Z1bmN0aW9uIG8odCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCx0KX1mdW5jdGlvbiBsKHQsZSl7XCJkYXRhXCJpbiB0JiYoZSs9dC5zdGFydCx0PXQuZGF0YSk7dmFyIHI9dFtlXTw8MjR8dFtlKzFdPDwxNnx0W2UrMl08PDh8dFtlKzNdO3JldHVybiByPDA/NDI5NDk2NzI5NityOnJ9ZnVuY3Rpb24gdSh0LGUscil7XCJkYXRhXCJpbiB0JiYoZSs9dC5zdGFydCx0PXQuZGF0YSksdFtlXT1yPj4yNCx0W2UrMV09cj4+MTYmMjU1LHRbZSsyXT1yPj44JjI1NSx0W2UrM109MjU1JnJ9ZnVuY3Rpb24gZCh0LGUpe3ZhciByLGksYSxuPVtdO2lmKCFlLmxlbmd0aClyZXR1cm4gbjtcImRhdGFcImluIHQ/KHI9dC5kYXRhLGk9dC5zdGFydCxhPXQuZW5kKTooaT0wLGE9KHI9dCkuYnl0ZUxlbmd0aCk7Zm9yKHZhciB1PWk7dTxhOyl7dmFyIGg9bChyLHUpLGY9aD4xP3UraDphO2lmKG8oci5zdWJhcnJheSh1KzQsdSs4KSk9PT1lWzBdKWlmKDE9PT1lLmxlbmd0aCluLnB1c2goe2RhdGE6cixzdGFydDp1KzgsZW5kOmZ9KTtlbHNle3ZhciBjPWQoe2RhdGE6cixzdGFydDp1KzgsZW5kOmZ9LGUuc2xpY2UoMSkpO2MubGVuZ3RoJiZzLmFwcGx5KG4sYyl9dT1mfXJldHVybiBufWZ1bmN0aW9uIGgodCl7dmFyIGU9ZCh0LFtcIm1vb3ZcIl0pWzBdLHI9ZT9lLmVuZDpudWxsLGk9ZCh0LFtcInNpZHhcIl0pO2lmKCFpfHwhaVswXSlyZXR1cm4gbnVsbDt2YXIgYT1bXSxuPWlbMF0scz1uLmRhdGFbMF0sbz0wPT09cz84OjE2LHU9bChuLG8pO28rPTQ7bys9MD09PXM/ODoxNixvKz0yO3ZhciBoPW4uZW5kKzAsZj1mdW5jdGlvbih0LGUpe1wiZGF0YVwiaW4gdCYmKGUrPXQuc3RhcnQsdD10LmRhdGEpO3ZhciByPXRbZV08PDh8dFtlKzFdO3JldHVybiByPDA/NjU1MzYrcjpyfShuLG8pO28rPTI7Zm9yKHZhciBjPTA7YzxmO2MrKyl7dmFyIHY9byxnPWwobix2KTt2Kz00O3ZhciBwPTIxNDc0ODM2NDcmZztpZigxPT09KDIxNDc0ODM2NDgmZyk+Pj4zMSlyZXR1cm4gY29uc29sZS53YXJuKFwiU0lEWCBoYXMgaGllcmFyY2hpY2FsIHJlZmVyZW5jZXMgKG5vdCBzdXBwb3J0ZWQpXCIpLG51bGw7dmFyIG09bChuLHYpO3YrPTQsYS5wdXNoKHtyZWZlcmVuY2VTaXplOnAsc3Vic2VnbWVudER1cmF0aW9uOm0saW5mbzp7ZHVyYXRpb246bS91LHN0YXJ0OmgsZW5kOmgrcC0xfX0pLGgrPXAsbz12Kz00fXJldHVybntlYXJsaWVzdFByZXNlbnRhdGlvblRpbWU6MCx0aW1lc2NhbGU6dSx2ZXJzaW9uOnMscmVmZXJlbmNlc0NvdW50OmYscmVmZXJlbmNlczphLG1vb3ZFbmRPZmZzZXQ6cn19ZnVuY3Rpb24gZih0KXtmb3IodmFyIGU9W10scj1kKHQsW1wibW9vdlwiLFwidHJha1wiXSksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbj1yW2ldLHM9ZChuLFtcInRraGRcIl0pWzBdO2lmKHMpe3ZhciB1PXMuZGF0YVtzLnN0YXJ0XSxoPTA9PT11PzEyOjIwLGY9bChzLGgpLGM9ZChuLFtcIm1kaWFcIixcIm1kaGRcIl0pWzBdO2lmKGMpe3ZhciB2PWwoYyxoPTA9PT0odT1jLmRhdGFbYy5zdGFydF0pPzEyOjIwKSxnPWQobixbXCJtZGlhXCIsXCJoZGxyXCJdKVswXTtpZihnKXt2YXIgcD1vKGcuZGF0YS5zdWJhcnJheShnLnN0YXJ0KzgsZy5zdGFydCsxMikpLG09e3NvdW46YS5hLkFVRElPLHZpZGU6YS5hLlZJREVPfVtwXTtpZihtKXt2YXIgeT1kKG4sW1wibWRpYVwiLFwibWluZlwiLFwic3RibFwiLFwic3RzZFwiXSlbMF0sYj12b2lkIDA7eSYmKGI9byh5LmRhdGEuc3ViYXJyYXkoeS5zdGFydCsxMix5LnN0YXJ0KzE2KSkpLGVbZl09e3RpbWVzY2FsZTp2LHR5cGU6bX0sZVttXT17dGltZXNjYWxlOnYsaWQ6Zixjb2RlYzpifX19fX19cmV0dXJuIGQodCxbXCJtb292XCIsXCJtdmV4XCIsXCJ0cmV4XCJdKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgcj1sKHQsNCksaT1lW3JdO2kmJihpLmRlZmF1bHQ9e2R1cmF0aW9uOmwodCwxMiksZmxhZ3M6bCh0LDIwKX0pfSkpLGV9ZnVuY3Rpb24gYyh0LGUpe3JldHVybiBkKGUsW1wibW9vZlwiLFwidHJhZlwiXSkucmVkdWNlKChmdW5jdGlvbihlLHIpe3ZhciBpPWQocixbXCJ0ZmR0XCJdKVswXSxhPWkuZGF0YVtpLnN0YXJ0XSxuPWQocixbXCJ0ZmhkXCJdKS5yZWR1Y2UoKGZ1bmN0aW9uKGUscil7dmFyIG49bChyLDQpLHM9dFtuXTtpZihzKXt2YXIgbz1sKGksNCk7MT09PWEmJihvKj1NYXRoLnBvdygyLDMyKSxvKz1sKGksOCkpO3ZhciB1PW8vKHMudGltZXNjYWxlfHw5ZTQpO2lmKGlzRmluaXRlKHUpJiYobnVsbD09PWV8fHU8ZSkpcmV0dXJuIHV9cmV0dXJuIGV9KSxudWxsKTtyZXR1cm4gbnVsbCE9PW4mJmlzRmluaXRlKG4pJiYobnVsbD09PWV8fG48ZSk/bjplfSksbnVsbCl8fDB9ZnVuY3Rpb24gdih0LGUpe2Zvcih2YXIgcj0wLGk9MCxuPTAscz1kKHQsW1wibW9vZlwiLFwidHJhZlwiXSksbz0wO288cy5sZW5ndGg7bysrKXt2YXIgdT1zW29dLGY9ZCh1LFtcInRmaGRcIl0pWzBdLGM9ZVtsKGYsNCldO2lmKGMpe3ZhciB2PWMuZGVmYXVsdCxwPWwoZiwwKXwobnVsbD09dj92b2lkIDA6di5mbGFncyksbT1udWxsPT12P3ZvaWQgMDp2LmR1cmF0aW9uOzgmcCYmKG09bChmLDImcD8xMjo4KSk7Zm9yKHZhciB5PWMudGltZXNjYWxlfHw5ZTQsYj1kKHUsW1widHJ1blwiXSksVD0wO1Q8Yi5sZW5ndGg7VCsrKXtpZighKHI9ZyhiW1RdKSkmJm0pcj1tKmwoYltUXSw0KTtjLnR5cGU9PT1hLmEuVklERU8/aSs9ci95OmMudHlwZT09PWEuYS5BVURJTyYmKG4rPXIveSl9fX1pZigwPT09aSYmMD09PW4pe3ZhciBFPWgodCk7aWYobnVsbCE9RSYmRS5yZWZlcmVuY2VzKXJldHVybiBFLnJlZmVyZW5jZXMucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0K2UuaW5mby5kdXJhdGlvbnx8MH0pLDApfXJldHVybiBpfHxufWZ1bmN0aW9uIGcodCl7dmFyIGU9bCh0LDApLHI9ODsxJmUmJihyKz00KSw0JmUmJihyKz00KTtmb3IodmFyIGk9MCxhPWwodCw0KSxuPTA7bjxhO24rKyl7aWYoMjU2JmUpaSs9bCh0LHIpLHIrPTQ7NTEyJmUmJihyKz00KSwxMDI0JmUmJihyKz00KSwyMDQ4JmUmJihyKz00KX1yZXR1cm4gaX1mdW5jdGlvbiBwKHQsZSxyKXtkKGUsW1wibW9vZlwiLFwidHJhZlwiXSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZChlLFtcInRmaGRcIl0pLmZvckVhY2goKGZ1bmN0aW9uKGkpe3ZhciBhPWwoaSw0KSxzPXRbYV07aWYocyl7dmFyIG89cy50aW1lc2NhbGV8fDllNDtkKGUsW1widGZkdFwiXSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9dC5kYXRhW3Quc3RhcnRdLGk9bCh0LDQpO2lmKDA9PT1lKXUodCw0LGktcipvKTtlbHNle2kqPU1hdGgucG93KDIsMzIpLGkrPWwodCw4KSxpLT1yKm8saT1NYXRoLm1heChpLDApO3ZhciBhPU1hdGguZmxvb3IoaS8obisxKSkscz1NYXRoLmZsb29yKGklKG4rMSkpO3UodCw0LGEpLHUodCw4LHMpfX0pKX19KSl9KSl9ZnVuY3Rpb24gbSh0KXt2YXIgZT17dmFsaWQ6bnVsbCxyZW1haW5kZXI6bnVsbH0scj1kKHQsW1wibW9vZlwiXSk7aWYoIXIpcmV0dXJuIGU7aWYoci5sZW5ndGg8MilyZXR1cm4gZS5yZW1haW5kZXI9dCxlO3ZhciBhPXJbci5sZW5ndGgtMV07cmV0dXJuIGUudmFsaWQ9T2JqZWN0KGkuYSkodCwwLGEuc3RhcnQtOCksZS5yZW1haW5kZXI9T2JqZWN0KGkuYSkodCxhLnN0YXJ0LTgpLGV9ZnVuY3Rpb24geSh0LGUpe3ZhciByPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoK2UubGVuZ3RoKTtyZXR1cm4gci5zZXQodCksci5zZXQoZSx0Lmxlbmd0aCkscn19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLmQoZSxcImJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gc30pKSxyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbH0pKSxyLmQoZSxcImRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdX0pKSxyLmQoZSxcImVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZH0pKSxyLmQoZSxcImNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZn0pKSxyLmQoZSxcImZcIiwoZnVuY3Rpb24oKXtyZXR1cm4geX0pKTt2YXIgaSxhPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUrMTA8PXQubGVuZ3RoJiY3Mz09PXRbZV0mJjY4PT09dFtlKzFdJiY1MT09PXRbZSsyXSYmdFtlKzNdPDI1NSYmdFtlKzRdPDI1NSYmdFtlKzZdPDEyOCYmdFtlKzddPDEyOCYmdFtlKzhdPDEyOCYmdFtlKzldPDEyOH0sbj1mdW5jdGlvbih0LGUpe3JldHVybiBlKzEwPD10Lmxlbmd0aCYmNTE9PT10W2VdJiY2OD09PXRbZSsxXSYmNzM9PT10W2UrMl0mJnRbZSszXTwyNTUmJnRbZSs0XTwyNTUmJnRbZSs2XTwxMjgmJnRbZSs3XTwxMjgmJnRbZSs4XTwxMjgmJnRbZSs5XTwxMjh9LHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9ZSxpPTA7YSh0LGUpOyl7aSs9MTAsaSs9byh0LGUrNiksbih0LGUrMTApJiYoaSs9MTApLGUrPWl9aWYoaT4wKXJldHVybiB0LnN1YmFycmF5KHIscitpKX0sbz1mdW5jdGlvbih0LGUpe3ZhciByPTA7cmV0dXJuIHI9KDEyNyZ0W2VdKTw8MjEscnw9KDEyNyZ0W2UrMV0pPDwxNCxyfD0oMTI3JnRbZSsyXSk8PDcscnw9MTI3JnRbZSszXX0sbD1mdW5jdGlvbih0LGUpe3JldHVybiBhKHQsZSkmJm8odCxlKzYpKzEwPD10Lmxlbmd0aC1lfSx1PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1mKHQpLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpZihkKGkpKXJldHVybiBtKGkpfX0sZD1mdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJQUklWXCI9PT10LmtleSYmXCJjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcFwiPT09dC5pbmZvfSxoPWZ1bmN0aW9uKHQpe3ZhciBlPVN0cmluZy5mcm9tQ2hhckNvZGUodFswXSx0WzFdLHRbMl0sdFszXSkscj1vKHQsNCk7cmV0dXJue3R5cGU6ZSxzaXplOnIsZGF0YTp0LnN1YmFycmF5KDEwLDEwK3IpfX0sZj1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxyPVtdO2EodCxlKTspe2Zvcih2YXIgaT1vKHQsZSs2KSxzPShlKz0xMCkraTtlKzg8czspe3ZhciBsPWgodC5zdWJhcnJheShlKSksdT1jKGwpO3UmJnIucHVzaCh1KSxlKz1sLnNpemUrMTB9bih0LGUpJiYoZSs9MTApfXJldHVybiByfSxjPWZ1bmN0aW9uKHQpe3JldHVyblwiUFJJVlwiPT09dC50eXBlP3YodCk6XCJXXCI9PT10LnR5cGVbMF0/cCh0KTpnKHQpfSx2PWZ1bmN0aW9uKHQpe2lmKCEodC5zaXplPDIpKXt2YXIgZT15KHQuZGF0YSwhMCkscj1uZXcgVWludDhBcnJheSh0LmRhdGEuc3ViYXJyYXkoZS5sZW5ndGgrMSkpO3JldHVybntrZXk6dC50eXBlLGluZm86ZSxkYXRhOnIuYnVmZmVyfX19LGc9ZnVuY3Rpb24odCl7aWYoISh0LnNpemU8Mikpe2lmKFwiVFhYWFwiPT09dC50eXBlKXt2YXIgZT0xLHI9eSh0LmRhdGEuc3ViYXJyYXkoZSksITApO2UrPXIubGVuZ3RoKzE7dmFyIGk9eSh0LmRhdGEuc3ViYXJyYXkoZSkpO3JldHVybntrZXk6dC50eXBlLGluZm86cixkYXRhOml9fXZhciBhPXkodC5kYXRhLnN1YmFycmF5KDEpKTtyZXR1cm57a2V5OnQudHlwZSxkYXRhOmF9fX0scD1mdW5jdGlvbih0KXtpZihcIldYWFhcIj09PXQudHlwZSl7aWYodC5zaXplPDIpcmV0dXJuO3ZhciBlPTEscj15KHQuZGF0YS5zdWJhcnJheShlKSwhMCk7ZSs9ci5sZW5ndGgrMTt2YXIgaT15KHQuZGF0YS5zdWJhcnJheShlKSk7cmV0dXJue2tleTp0LnR5cGUsaW5mbzpyLGRhdGE6aX19dmFyIGE9eSh0LmRhdGEpO3JldHVybntrZXk6dC50eXBlLGRhdGE6YX19LG09ZnVuY3Rpb24odCl7aWYoOD09PXQuZGF0YS5ieXRlTGVuZ3RoKXt2YXIgZT1uZXcgVWludDhBcnJheSh0LmRhdGEpLHI9MSZlWzNdLGk9KGVbNF08PDIzKSsoZVs1XTw8MTUpKyhlWzZdPDw3KStlWzddO3JldHVybiBpLz00NSxyJiYoaSs9NDc3MjE4NTguODQpLE1hdGgucm91bmQoaSl9fSx5PWZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9ITEpO3ZhciByPWIoKTtpZihyKXt2YXIgaT1yLmRlY29kZSh0KTtpZihlKXt2YXIgYT1pLmluZGV4T2YoXCJcXDBcIik7cmV0dXJuLTEhPT1hP2kuc3Vic3RyaW5nKDAsYSk6aX1yZXR1cm4gaS5yZXBsYWNlKC9cXDAvZyxcIlwiKX1mb3IodmFyIG4scyxvLGw9dC5sZW5ndGgsdT1cIlwiLGQ9MDtkPGw7KXtpZigwPT09KG49dFtkKytdKSYmZSlyZXR1cm4gdTtpZigwIT09biYmMyE9PW4pc3dpdGNoKG4+PjQpe2Nhc2UgMDpjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmNhc2UgNjpjYXNlIDc6dSs9U3RyaW5nLmZyb21DaGFyQ29kZShuKTticmVhaztjYXNlIDEyOmNhc2UgMTM6cz10W2QrK10sdSs9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmbik8PDZ8NjMmcyk7YnJlYWs7Y2FzZSAxNDpzPXRbZCsrXSxvPXRbZCsrXSx1Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgxNSZuKTw8MTJ8KDYzJnMpPDw2fCg2MyZvKTw8MCl9fXJldHVybiB1fTtmdW5jdGlvbiBiKCl7cmV0dXJuIGl8fHZvaWQgMD09PXNlbGYuVGV4dERlY29kZXJ8fChpPW5ldyBzZWxmLlRleHREZWNvZGVyKFwidXRmLThcIikpLGl9fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaSh0LGUscil7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlP3Quc2xpY2UoZSxyKTpuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LGUscikpfXIuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBpfSkpfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ci5kKGUsXCJjXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFN0fSkpLHIuZChlLFwiZFwiLChmdW5jdGlvbigpe3JldHVybiBBdH0pKSxyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gUnR9KSksci5kKGUsXCJiXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIER0fSkpO3ZhciBpPXIoMCksYT1yKDIpLG49cigxNCkscz1yKDMpLG89cig3KTt2YXIgbD1yKDYpLHU9cig4KSxkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuX2F1ZGlvVHJhY2s9dm9pZCAwLHRoaXMuX2lkM1RyYWNrPXZvaWQgMCx0aGlzLmZyYW1lSW5kZXg9MCx0aGlzLmNhY2hlZERhdGE9bnVsbCx0aGlzLmluaXRQVFM9bnVsbH12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5yZXNldEluaXRTZWdtZW50PWZ1bmN0aW9uKHQsZSxyKXt0aGlzLl9pZDNUcmFjaz17dHlwZTpcImlkM1wiLGlkOjMscGlkOi0xLGlucHV0VGltZVNjYWxlOjllNCxzZXF1ZW5jZU51bWJlcjowLHNhbXBsZXM6W10sZHJvcHBlZDowfX0sZS5yZXNldFRpbWVTdGFtcD1mdW5jdGlvbigpe30sZS5yZXNldENvbnRpZ3VpdHk9ZnVuY3Rpb24oKXt9LGUuY2FuUGFyc2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4hMX0sZS5hcHBlbmRGcmFtZT1mdW5jdGlvbih0LGUscil7fSxlLmRlbXV4PWZ1bmN0aW9uKHQsZSl7dGhpcy5jYWNoZWREYXRhJiYodD1PYmplY3QobC5hKSh0aGlzLmNhY2hlZERhdGEsdCksdGhpcy5jYWNoZWREYXRhPW51bGwpO3ZhciByLGksYT1vLmIodCwwKSxuPWE/YS5sZW5ndGg6MCxzPXRoaXMuX2F1ZGlvVHJhY2ssZD10aGlzLl9pZDNUcmFjayxmPWE/by5kKGEpOnZvaWQgMCxjPXQubGVuZ3RoO2ZvcigwIT09dGhpcy5mcmFtZUluZGV4JiZudWxsIT09dGhpcy5pbml0UFRTfHwodGhpcy5pbml0UFRTPWgoZixlKSksYSYmYS5sZW5ndGg+MCYmZC5zYW1wbGVzLnB1c2goe3B0czp0aGlzLmluaXRQVFMsZHRzOnRoaXMuaW5pdFBUUyxkYXRhOmF9KSxpPXRoaXMuaW5pdFBUUztuPGM7KXtpZih0aGlzLmNhblBhcnNlKHQsbikpe3ZhciB2PXRoaXMuYXBwZW5kRnJhbWUocyx0LG4pO3Y/KHRoaXMuZnJhbWVJbmRleCsrLGk9di5zYW1wbGUucHRzLHI9bis9di5sZW5ndGgpOm49Y31lbHNlIG8uYSh0LG4pPyhhPW8uYih0LG4pLGQuc2FtcGxlcy5wdXNoKHtwdHM6aSxkdHM6aSxkYXRhOmF9KSxyPW4rPWEubGVuZ3RoKTpuKys7aWYobj09PWMmJnIhPT1jKXt2YXIgZz1PYmplY3QodS5hKSh0LHIpO3RoaXMuY2FjaGVkRGF0YT90aGlzLmNhY2hlZERhdGE9T2JqZWN0KGwuYSkodGhpcy5jYWNoZWREYXRhLGcpOnRoaXMuY2FjaGVkRGF0YT1nfX1yZXR1cm57YXVkaW9UcmFjazpzLGF2Y1RyYWNrOnt0eXBlOlwiXCIsaWQ6LTEscGlkOi0xLGlucHV0VGltZVNjYWxlOjllNCxzZXF1ZW5jZU51bWJlcjotMSxzYW1wbGVzOltdLGRyb3BwZWQ6MH0saWQzVHJhY2s6ZCx0ZXh0VHJhY2s6e3R5cGU6XCJcIixpZDotMSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOi0xLHNhbXBsZXM6W10sZHJvcHBlZDowfX19LGUuZGVtdXhTYW1wbGVBZXM9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJbXCIrdGhpcytcIl0gVGhpcyBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU2FtcGxlLUFFUyBkZWNyeXB0aW9uXCIpKX0sZS5mbHVzaD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmNhY2hlZERhdGE7cmV0dXJuIGUmJih0aGlzLmNhY2hlZERhdGE9bnVsbCx0aGlzLmRlbXV4KGUsMCkpLHRoaXMuZnJhbWVJbmRleD0wLHthdWRpb1RyYWNrOnRoaXMuX2F1ZGlvVHJhY2ssYXZjVHJhY2s6e3R5cGU6XCJcIixpZDotMSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOi0xLHNhbXBsZXM6W10sZHJvcHBlZDowfSxpZDNUcmFjazp0aGlzLl9pZDNUcmFjayx0ZXh0VHJhY2s6e3R5cGU6XCJcIixpZDotMSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOi0xLHNhbXBsZXM6W10sZHJvcHBlZDowfX19LGUuZGVzdHJveT1mdW5jdGlvbigpe30sdH0oKSxoPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE9iamVjdChzLmEpKHQpPzkwKnQ6OWU0KmV9LGY9ZCxjPXIoMSk7ZnVuY3Rpb24gdih0LGUpe3JldHVybiAyNTU9PT10W2VdJiYyNDA9PSgyNDYmdFtlKzFdKX1mdW5jdGlvbiBnKHQsZSl7cmV0dXJuIDEmdFtlKzFdPzc6OX1mdW5jdGlvbiBwKHQsZSl7cmV0dXJuKDMmdFtlKzNdKTw8MTF8dFtlKzRdPDwzfCgyMjQmdFtlKzVdKT4+PjV9ZnVuY3Rpb24gbSh0LGUpe3JldHVybiBlKzE8dC5sZW5ndGgmJnYodCxlKX1mdW5jdGlvbiB5KHQsZSl7aWYobSh0LGUpKXt2YXIgcj1nKHQsZSk7aWYoZStyPj10Lmxlbmd0aClyZXR1cm4hMTt2YXIgaT1wKHQsZSk7aWYoaTw9cilyZXR1cm4hMTt2YXIgYT1lK2k7cmV0dXJuIGE9PT10Lmxlbmd0aHx8bSh0LGEpfXJldHVybiExfWZ1bmN0aW9uIGIodCxlLHIsbixzKXtpZighdC5zYW1wbGVyYXRlKXt2YXIgbz1mdW5jdGlvbih0LGUscixuKXt2YXIgcyxvLGwsdSxkPW5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxoPW4sZj1bOTZlMyw4ODIwMCw2NGUzLDQ4ZTMsNDQxMDAsMzJlMywyNGUzLDIyMDUwLDE2ZTMsMTJlMywxMTAyNSw4ZTMsNzM1MF07cz0xKygoMTkyJmVbcisyXSk+Pj42KTt2YXIgdj0oNjAmZVtyKzJdKT4+PjI7aWYoISh2PmYubGVuZ3RoLTEpKXJldHVybiBsPSgxJmVbcisyXSk8PDIsbHw9KDE5MiZlW3IrM10pPj4+NixjLmIubG9nKFwibWFuaWZlc3QgY29kZWM6XCIrbitcIiwgQURUUyB0eXBlOlwiK3MrXCIsIHNhbXBsaW5nSW5kZXg6XCIrdiksL2ZpcmVmb3gvaS50ZXN0KGQpP3Y+PTY/KHM9NSx1PW5ldyBBcnJheSg0KSxvPXYtMyk6KHM9Mix1PW5ldyBBcnJheSgyKSxvPXYpOi0xIT09ZC5pbmRleE9mKFwiYW5kcm9pZFwiKT8ocz0yLHU9bmV3IEFycmF5KDIpLG89dik6KHM9NSx1PW5ldyBBcnJheSg0KSxuJiYoLTEhPT1uLmluZGV4T2YoXCJtcDRhLjQwLjI5XCIpfHwtMSE9PW4uaW5kZXhPZihcIm1wNGEuNDAuNVwiKSl8fCFuJiZ2Pj02P289di0zOigobiYmLTEhPT1uLmluZGV4T2YoXCJtcDRhLjQwLjJcIikmJih2Pj02JiYxPT09bHx8L3ZpdmFsZGkvaS50ZXN0KGQpKXx8IW4mJjE9PT1sKSYmKHM9Mix1PW5ldyBBcnJheSgyKSksbz12KSksdVswXT1zPDwzLHVbMF18PSgxNCZ2KT4+MSx1WzFdfD0oMSZ2KTw8Nyx1WzFdfD1sPDwzLDU9PT1zJiYodVsxXXw9KDE0Jm8pPj4xLHVbMl09KDEmbyk8PDcsdVsyXXw9OCx1WzNdPTApLHtjb25maWc6dSxzYW1wbGVyYXRlOmZbdl0sY2hhbm5lbENvdW50OmwsY29kZWM6XCJtcDRhLjQwLlwiK3MsbWFuaWZlc3RDb2RlYzpofTt0LnRyaWdnZXIoaS5hLkVSUk9SLHt0eXBlOmEuYi5NRURJQV9FUlJPUixkZXRhaWxzOmEuYS5GUkFHX1BBUlNJTkdfRVJST1IsZmF0YWw6ITAscmVhc29uOlwiaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OlwiK3Z9KX0oZSxyLG4scyk7aWYoIW8pcmV0dXJuO3QuY29uZmlnPW8uY29uZmlnLHQuc2FtcGxlcmF0ZT1vLnNhbXBsZXJhdGUsdC5jaGFubmVsQ291bnQ9by5jaGFubmVsQ291bnQsdC5jb2RlYz1vLmNvZGVjLHQubWFuaWZlc3RDb2RlYz1vLm1hbmlmZXN0Q29kZWMsYy5iLmxvZyhcInBhcnNlZCBjb2RlYzpcIit0LmNvZGVjK1wiLCByYXRlOlwiK28uc2FtcGxlcmF0ZStcIiwgY2hhbm5lbHM6XCIrby5jaGFubmVsQ291bnQpfX1mdW5jdGlvbiBUKHQpe3JldHVybiA5MjE2ZTQvdH1mdW5jdGlvbiBFKHQsZSxyLGksYSl7dmFyIG49ZnVuY3Rpb24odCxlLHIsaSxhKXt2YXIgbj1nKHQsZSkscz1wKHQsZSk7aWYoKHMtPW4pPjApcmV0dXJue2hlYWRlckxlbmd0aDpuLGZyYW1lTGVuZ3RoOnMsc3RhbXA6citpKmF9fShlLHIsaSxhLFQodC5zYW1wbGVyYXRlKSk7aWYobil7dmFyIHMsbz1uLmZyYW1lTGVuZ3RoLGw9bi5oZWFkZXJMZW5ndGgsdT1uLnN0YW1wLGQ9bCtvLGg9TWF0aC5tYXgoMCxyK2QtZS5sZW5ndGgpO2g/KHM9bmV3IFVpbnQ4QXJyYXkoZC1sKSkuc2V0KGUuc3ViYXJyYXkocitsLGUubGVuZ3RoKSwwKTpzPWUuc3ViYXJyYXkocitsLHIrZCk7dmFyIGY9e3VuaXQ6cyxwdHM6dX07cmV0dXJuIGh8fHQuc2FtcGxlcy5wdXNoKGYpLHtzYW1wbGU6ZixsZW5ndGg6ZCxtaXNzaW5nOmh9fX1mdW5jdGlvbiBTKHQsZSl7cmV0dXJuKFM9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfXZhciBMPWZ1bmN0aW9uKHQpe3ZhciBlLHI7ZnVuY3Rpb24gaShlLHIpe3ZhciBpO3JldHVybihpPXQuY2FsbCh0aGlzKXx8dGhpcykub2JzZXJ2ZXI9dm9pZCAwLGkuY29uZmlnPXZvaWQgMCxpLm9ic2VydmVyPWUsaS5jb25maWc9cixpfXI9dCwoZT1pKS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSxTKGUscik7dmFyIGE9aS5wcm90b3R5cGU7cmV0dXJuIGEucmVzZXRJbml0U2VnbWVudD1mdW5jdGlvbihlLHIsaSl7dC5wcm90b3R5cGUucmVzZXRJbml0U2VnbWVudC5jYWxsKHRoaXMsZSxyLGkpLHRoaXMuX2F1ZGlvVHJhY2s9e2NvbnRhaW5lcjpcImF1ZGlvL2FkdHNcIix0eXBlOlwiYXVkaW9cIixpZDoyLHBpZDotMSxzZXF1ZW5jZU51bWJlcjowLGlzQUFDOiEwLHNhbXBsZXM6W10sbWFuaWZlc3RDb2RlYzplLGR1cmF0aW9uOmksaW5wdXRUaW1lU2NhbGU6OWU0LGRyb3BwZWQ6MH19LGkucHJvYmU9ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuITE7Zm9yKHZhciBlPShvLmIodCwwKXx8W10pLmxlbmd0aCxyPXQubGVuZ3RoO2U8cjtlKyspaWYoeSh0LGUpKXJldHVybiBjLmIubG9nKFwiQURUUyBzeW5jIHdvcmQgZm91bmQgIVwiKSwhMDtyZXR1cm4hMX0sYS5jYW5QYXJzZT1mdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbih0LGUpe3JldHVybiBlKzU8dC5sZW5ndGh9KHQsZSkmJnYodCxlKSYmcCh0LGUpPD10Lmxlbmd0aC1lfSh0LGUpfSxhLmFwcGVuZEZyYW1lPWZ1bmN0aW9uKHQsZSxyKXtiKHQsdGhpcy5vYnNlcnZlcixlLHIsdC5tYW5pZmVzdENvZGVjKTt2YXIgaT1FKHQsZSxyLHRoaXMuaW5pdFBUUyx0aGlzLmZyYW1lSW5kZXgpO2lmKGkmJjA9PT1pLm1pc3NpbmcpcmV0dXJuIGl9LGl9KGYpO0wubWluUHJvYmVCeXRlTGVuZ3RoPTk7dmFyIEE9TCxSPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMucmVtYWluZGVyRGF0YT1udWxsLHRoaXMuY29uZmlnPXZvaWQgMCx0aGlzLmNvbmZpZz1lfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnJlc2V0VGltZVN0YW1wPWZ1bmN0aW9uKCl7fSxlLnJlc2V0SW5pdFNlZ21lbnQ9ZnVuY3Rpb24oKXt9LGUucmVzZXRDb250aWd1aXR5PWZ1bmN0aW9uKCl7fSx0LnByb2JlPWZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QobC5iKSh7ZGF0YTp0LHN0YXJ0OjAsZW5kOk1hdGgubWluKHQubGVuZ3RoLDE2Mzg0KX0sW1wibW9vZlwiXSkubGVuZ3RoPjB9LGUuZGVtdXg9ZnVuY3Rpb24odCl7dmFyIGU9dCxyPXt0eXBlOlwiXCIsaWQ6LTEscGlkOi0xLGlucHV0VGltZVNjYWxlOjllNCxzZXF1ZW5jZU51bWJlcjotMSxzYW1wbGVzOltdLGRyb3BwZWQ6MH07aWYodGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpe3RoaXMucmVtYWluZGVyRGF0YSYmKGU9T2JqZWN0KGwuYSkodGhpcy5yZW1haW5kZXJEYXRhLHQpKTt2YXIgaT1PYmplY3QobC5oKShlKTt0aGlzLnJlbWFpbmRlckRhdGE9aS5yZW1haW5kZXIsci5zYW1wbGVzPWkudmFsaWR8fG5ldyBVaW50OEFycmF5fWVsc2Ugci5zYW1wbGVzPWU7cmV0dXJue2F1ZGlvVHJhY2s6e3R5cGU6XCJcIixpZDotMSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOi0xLHNhbXBsZXM6W10sZHJvcHBlZDowfSxhdmNUcmFjazpyLGlkM1RyYWNrOnt0eXBlOlwiXCIsaWQ6LTEscGlkOi0xLGlucHV0VGltZVNjYWxlOjllNCxzZXF1ZW5jZU51bWJlcjotMSxzYW1wbGVzOltdLGRyb3BwZWQ6MH0sdGV4dFRyYWNrOnt0eXBlOlwiXCIsaWQ6LTEscGlkOi0xLGlucHV0VGltZVNjYWxlOjllNCxzZXF1ZW5jZU51bWJlcjotMSxzYW1wbGVzOltdLGRyb3BwZWQ6MH19fSxlLmZsdXNoPWZ1bmN0aW9uKCl7dmFyIHQ9e3R5cGU6XCJcIixpZDotMSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOi0xLHNhbXBsZXM6W10sZHJvcHBlZDowfTtyZXR1cm4gdC5zYW1wbGVzPXRoaXMucmVtYWluZGVyRGF0YXx8bmV3IFVpbnQ4QXJyYXksdGhpcy5yZW1haW5kZXJEYXRhPW51bGwse2F1ZGlvVHJhY2s6e3R5cGU6XCJcIixpZDotMSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOi0xLHNhbXBsZXM6W10sZHJvcHBlZDowfSxhdmNUcmFjazp0LGlkM1RyYWNrOnt0eXBlOlwiXCIsaWQ6LTEscGlkOi0xLGlucHV0VGltZVNjYWxlOjllNCxzZXF1ZW5jZU51bWJlcjotMSxzYW1wbGVzOltdLGRyb3BwZWQ6MH0sdGV4dFRyYWNrOnt0eXBlOlwiXCIsaWQ6LTEscGlkOi0xLGlucHV0VGltZVNjYWxlOjllNCxzZXF1ZW5jZU51bWJlcjotMSxzYW1wbGVzOltdLGRyb3BwZWQ6MH19fSxlLmRlbXV4U2FtcGxlQWVzPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiVGhlIE1QNCBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU0FNUExFLUFFUyBkZWNyeXB0aW9uXCIpKX0sZS5kZXN0cm95PWZ1bmN0aW9uKCl7fSx0fSgpO1IubWluUHJvYmVCeXRlTGVuZ3RoPTEwMjQ7dmFyIEQ9UixfPW51bGwsaz1bMzIsNjQsOTYsMTI4LDE2MCwxOTIsMjI0LDI1NiwyODgsMzIwLDM1MiwzODQsNDE2LDQ0OCwzMiw0OCw1Niw2NCw4MCw5NiwxMTIsMTI4LDE2MCwxOTIsMjI0LDI1NiwzMjAsMzg0LDMyLDQwLDQ4LDU2LDY0LDgwLDk2LDExMiwxMjgsMTYwLDE5MiwyMjQsMjU2LDMyMCwzMiw0OCw1Niw2NCw4MCw5NiwxMTIsMTI4LDE0NCwxNjAsMTc2LDE5MiwyMjQsMjU2LDgsMTYsMjQsMzIsNDAsNDgsNTYsNjQsODAsOTYsMTEyLDEyOCwxNDQsMTYwXSx4PVs0NDEwMCw0OGUzLDMyZTMsMjIwNTAsMjRlMywxNmUzLDExMDI1LDEyZTMsOGUzXSxDPVtbMCw3MiwxNDQsMTJdLFswLDAsMCwwXSxbMCw3MiwxNDQsMTJdLFswLDE0NCwxNDQsMTJdXSx3PVswLDEsMSw0XTtmdW5jdGlvbiBPKHQsZSxyLGksYSl7aWYoIShyKzI0PmUubGVuZ3RoKSl7dmFyIG49SShlLHIpO2lmKG4mJnIrbi5mcmFtZUxlbmd0aDw9ZS5sZW5ndGgpe3ZhciBzPWkrYSooOWU0Km4uc2FtcGxlc1BlckZyYW1lL24uc2FtcGxlUmF0ZSksbz17dW5pdDplLnN1YmFycmF5KHIscituLmZyYW1lTGVuZ3RoKSxwdHM6cyxkdHM6c307cmV0dXJuIHQuY29uZmlnPVtdLHQuY2hhbm5lbENvdW50PW4uY2hhbm5lbENvdW50LHQuc2FtcGxlcmF0ZT1uLnNhbXBsZVJhdGUsdC5zYW1wbGVzLnB1c2gobykse3NhbXBsZTpvLGxlbmd0aDpuLmZyYW1lTGVuZ3RoLG1pc3Npbmc6MH19fX1mdW5jdGlvbiBJKHQsZSl7dmFyIHI9dFtlKzFdPj4zJjMsaT10W2UrMV0+PjEmMyxhPXRbZSsyXT4+NCYxNSxuPXRbZSsyXT4+MiYzO2lmKDEhPT1yJiYwIT09YSYmMTUhPT1hJiYzIT09bil7dmFyIHM9dFtlKzJdPj4xJjEsbz10W2UrM10+PjYsbD0xZTMqa1sxNCooMz09PXI/My1pOjM9PT1pPzM6NCkrYS0xXSx1PXhbMyooMz09PXI/MDoyPT09cj8xOjIpK25dLGQ9Mz09PW8/MToyLGg9Q1tyXVtpXSxmPXdbaV0sYz04KmgqZix2PU1hdGguZmxvb3IoaCpsL3UrcykqZjtpZihudWxsPT09Xyl7dmFyIGc9KG5hdmlnYXRvci51c2VyQWdlbnR8fFwiXCIpLm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvaSk7Xz1nP3BhcnNlSW50KGdbMV0pOjB9cmV0dXJuISFfJiZfPD04NyYmMj09PWkmJmw+PTIyNGUzJiYwPT09byYmKHRbZSszXT0xMjh8dFtlKzNdKSx7c2FtcGxlUmF0ZTp1LGNoYW5uZWxDb3VudDpkLGZyYW1lTGVuZ3RoOnYsc2FtcGxlc1BlckZyYW1lOmN9fX1mdW5jdGlvbiBQKHQsZSl7cmV0dXJuIDI1NT09PXRbZV0mJjIyND09KDIyNCZ0W2UrMV0pJiYwIT0oNiZ0W2UrMV0pfWZ1bmN0aW9uIEYodCxlKXtyZXR1cm4gZSsxPHQubGVuZ3RoJiZQKHQsZSl9ZnVuY3Rpb24gTSh0LGUpe2lmKGUrMTx0Lmxlbmd0aCYmUCh0LGUpKXt2YXIgcj1JKHQsZSksaT00O251bGwhPXImJnIuZnJhbWVMZW5ndGgmJihpPXIuZnJhbWVMZW5ndGgpO3ZhciBhPWUraTtyZXR1cm4gYT09PXQubGVuZ3RofHxGKHQsYSl9cmV0dXJuITF9dmFyIE49ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuZGF0YT12b2lkIDAsdGhpcy5ieXRlc0F2YWlsYWJsZT12b2lkIDAsdGhpcy53b3JkPXZvaWQgMCx0aGlzLmJpdHNBdmFpbGFibGU9dm9pZCAwLHRoaXMuZGF0YT10LHRoaXMuYnl0ZXNBdmFpbGFibGU9dC5ieXRlTGVuZ3RoLHRoaXMud29yZD0wLHRoaXMuYml0c0F2YWlsYWJsZT0wfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmxvYWRXb3JkPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5kYXRhLGU9dGhpcy5ieXRlc0F2YWlsYWJsZSxyPXQuYnl0ZUxlbmd0aC1lLGk9bmV3IFVpbnQ4QXJyYXkoNCksYT1NYXRoLm1pbig0LGUpO2lmKDA9PT1hKXRocm93IG5ldyBFcnJvcihcIm5vIGJ5dGVzIGF2YWlsYWJsZVwiKTtpLnNldCh0LnN1YmFycmF5KHIscithKSksdGhpcy53b3JkPW5ldyBEYXRhVmlldyhpLmJ1ZmZlcikuZ2V0VWludDMyKDApLHRoaXMuYml0c0F2YWlsYWJsZT04KmEsdGhpcy5ieXRlc0F2YWlsYWJsZS09YX0sZS5za2lwQml0cz1mdW5jdGlvbih0KXt2YXIgZTt0aGlzLmJpdHNBdmFpbGFibGU+dD8odGhpcy53b3JkPDw9dCx0aGlzLmJpdHNBdmFpbGFibGUtPXQpOih0LT10aGlzLmJpdHNBdmFpbGFibGUsdC09KGU9dD4+Myk+PjMsdGhpcy5ieXRlc0F2YWlsYWJsZS09ZSx0aGlzLmxvYWRXb3JkKCksdGhpcy53b3JkPDw9dCx0aGlzLmJpdHNBdmFpbGFibGUtPXQpfSxlLnJlYWRCaXRzPWZ1bmN0aW9uKHQpe3ZhciBlPU1hdGgubWluKHRoaXMuYml0c0F2YWlsYWJsZSx0KSxyPXRoaXMud29yZD4+PjMyLWU7cmV0dXJuIHQ+MzImJmMuYi5lcnJvcihcIkNhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZVwiKSx0aGlzLmJpdHNBdmFpbGFibGUtPWUsdGhpcy5iaXRzQXZhaWxhYmxlPjA/dGhpcy53b3JkPDw9ZTp0aGlzLmJ5dGVzQXZhaWxhYmxlPjAmJnRoaXMubG9hZFdvcmQoKSwoZT10LWUpPjAmJnRoaXMuYml0c0F2YWlsYWJsZT9yPDxlfHRoaXMucmVhZEJpdHMoZSk6cn0sZS5za2lwTFo9ZnVuY3Rpb24oKXt2YXIgdDtmb3IodD0wO3Q8dGhpcy5iaXRzQXZhaWxhYmxlOysrdClpZigwIT0odGhpcy53b3JkJjIxNDc0ODM2NDg+Pj50KSlyZXR1cm4gdGhpcy53b3JkPDw9dCx0aGlzLmJpdHNBdmFpbGFibGUtPXQsdDtyZXR1cm4gdGhpcy5sb2FkV29yZCgpLHQrdGhpcy5za2lwTFooKX0sZS5za2lwVUVHPWZ1bmN0aW9uKCl7dGhpcy5za2lwQml0cygxK3RoaXMuc2tpcExaKCkpfSxlLnNraXBFRz1mdW5jdGlvbigpe3RoaXMuc2tpcEJpdHMoMSt0aGlzLnNraXBMWigpKX0sZS5yZWFkVUVHPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5za2lwTFooKTtyZXR1cm4gdGhpcy5yZWFkQml0cyh0KzEpLTF9LGUucmVhZEVHPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5yZWFkVUVHKCk7cmV0dXJuIDEmdD8xK3Q+Pj4xOi0xKih0Pj4+MSl9LGUucmVhZEJvb2xlYW49ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMucmVhZEJpdHMoMSl9LGUucmVhZFVCeXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVhZEJpdHMoOCl9LGUucmVhZFVTaG9ydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlYWRCaXRzKDE2KX0sZS5yZWFkVUludD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlYWRCaXRzKDMyKX0sZS5za2lwU2NhbGluZ0xpc3Q9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTgscj04LGk9MDtpPHQ7aSsrKTAhPT1yJiYocj0oZSt0aGlzLnJlYWRFRygpKzI1NiklMjU2KSxlPTA9PT1yP2U6cn0sZS5yZWFkU1BTPWZ1bmN0aW9uKCl7dmFyIHQsZSxyLGk9MCxhPTAsbj0wLHM9MCxvPXRoaXMucmVhZFVCeXRlLmJpbmQodGhpcyksbD10aGlzLnJlYWRCaXRzLmJpbmQodGhpcyksdT10aGlzLnJlYWRVRUcuYmluZCh0aGlzKSxkPXRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKSxoPXRoaXMuc2tpcEJpdHMuYmluZCh0aGlzKSxmPXRoaXMuc2tpcEVHLmJpbmQodGhpcyksYz10aGlzLnNraXBVRUcuYmluZCh0aGlzKSx2PXRoaXMuc2tpcFNjYWxpbmdMaXN0LmJpbmQodGhpcyk7bygpO3ZhciBnPW8oKTtpZihsKDUpLGgoMyksbygpLGMoKSwxMDA9PT1nfHwxMTA9PT1nfHwxMjI9PT1nfHwyNDQ9PT1nfHw0ND09PWd8fDgzPT09Z3x8ODY9PT1nfHwxMTg9PT1nfHwxMjg9PT1nKXt2YXIgcD11KCk7aWYoMz09PXAmJmgoMSksYygpLGMoKSxoKDEpLGQoKSlmb3IoZT0zIT09cD84OjEyLHI9MDtyPGU7cisrKWQoKSYmdihyPDY/MTY6NjQpfWMoKTt2YXIgbT11KCk7aWYoMD09PW0pdSgpO2Vsc2UgaWYoMT09PW0pZm9yKGgoMSksZigpLGYoKSx0PXUoKSxyPTA7cjx0O3IrKylmKCk7YygpLGgoMSk7dmFyIHk9dSgpLGI9dSgpLFQ9bCgxKTswPT09VCYmaCgxKSxoKDEpLGQoKSYmKGk9dSgpLGE9dSgpLG49dSgpLHM9dSgpKTt2YXIgRT1bMSwxXTtpZihkKCkmJmQoKSlzd2l0Y2gobygpKXtjYXNlIDE6RT1bMSwxXTticmVhaztjYXNlIDI6RT1bMTIsMTFdO2JyZWFrO2Nhc2UgMzpFPVsxMCwxMV07YnJlYWs7Y2FzZSA0OkU9WzE2LDExXTticmVhaztjYXNlIDU6RT1bNDAsMzNdO2JyZWFrO2Nhc2UgNjpFPVsyNCwxMV07YnJlYWs7Y2FzZSA3OkU9WzIwLDExXTticmVhaztjYXNlIDg6RT1bMzIsMTFdO2JyZWFrO2Nhc2UgOTpFPVs4MCwzM107YnJlYWs7Y2FzZSAxMDpFPVsxOCwxMV07YnJlYWs7Y2FzZSAxMTpFPVsxNSwxMV07YnJlYWs7Y2FzZSAxMjpFPVs2NCwzM107YnJlYWs7Y2FzZSAxMzpFPVsxNjAsOTldO2JyZWFrO2Nhc2UgMTQ6RT1bNCwzXTticmVhaztjYXNlIDE1OkU9WzMsMl07YnJlYWs7Y2FzZSAxNjpFPVsyLDFdO2JyZWFrO2Nhc2UgMjU1OkU9W28oKTw8OHxvKCksbygpPDw4fG8oKV19cmV0dXJue3dpZHRoOk1hdGguY2VpbCgxNiooeSsxKS0yKmktMiphKSxoZWlnaHQ6KDItVCkqKGIrMSkqMTYtKFQ/Mjo0KSoobitzKSxwaXhlbFJhdGlvOkV9fSxlLnJlYWRTbGljZVR5cGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWFkVUJ5dGUoKSx0aGlzLnJlYWRVRUcoKSx0aGlzLnJlYWRVRUcoKX0sdH0oKSxCPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscil7dGhpcy5rZXlEYXRhPXZvaWQgMCx0aGlzLmRlY3J5cHRlcj12b2lkIDAsdGhpcy5rZXlEYXRhPXIsdGhpcy5kZWNyeXB0ZXI9bmV3IG4uYSh0LGUse3JlbW92ZVBLQ1M3UGFkZGluZzohMX0pfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmRlY3J5cHRCdWZmZXI9ZnVuY3Rpb24odCxlKXt0aGlzLmRlY3J5cHRlci5kZWNyeXB0KHQsdGhpcy5rZXlEYXRhLmtleS5idWZmZXIsdGhpcy5rZXlEYXRhLml2LmJ1ZmZlcixlKX0sZS5kZWNyeXB0QWFjU2FtcGxlPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPXRbZV0udW5pdCxuPWEuc3ViYXJyYXkoMTYsYS5sZW5ndGgtYS5sZW5ndGglMTYpLHM9bi5idWZmZXIuc2xpY2Uobi5ieXRlT2Zmc2V0LG4uYnl0ZU9mZnNldCtuLmxlbmd0aCksbz10aGlzO3RoaXMuZGVjcnlwdEJ1ZmZlcihzLChmdW5jdGlvbihuKXt2YXIgcz1uZXcgVWludDhBcnJheShuKTthLnNldChzLDE2KSxpfHxvLmRlY3J5cHRBYWNTYW1wbGVzKHQsZSsxLHIpfSkpfSxlLmRlY3J5cHRBYWNTYW1wbGVzPWZ1bmN0aW9uKHQsZSxyKXtmb3IoOztlKyspe2lmKGU+PXQubGVuZ3RoKXJldHVybiB2b2lkIHIoKTtpZighKHRbZV0udW5pdC5sZW5ndGg8MzIpKXt2YXIgaT10aGlzLmRlY3J5cHRlci5pc1N5bmMoKTtpZih0aGlzLmRlY3J5cHRBYWNTYW1wbGUodCxlLHIsaSksIWkpcmV0dXJufX19LGUuZ2V0QXZjRW5jcnlwdGVkRGF0YT1mdW5jdGlvbih0KXtmb3IodmFyIGU9MTYqTWF0aC5mbG9vcigodC5sZW5ndGgtNDgpLzE2MCkrMTYscj1uZXcgSW50OEFycmF5KGUpLGk9MCxhPTMyO2E8dC5sZW5ndGgtMTY7YSs9MTYwLGkrPTE2KXIuc2V0KHQuc3ViYXJyYXkoYSxhKzE2KSxpKTtyZXR1cm4gcn0sZS5nZXRBdmNEZWNyeXB0ZWRVbml0PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPW5ldyBVaW50OEFycmF5KGUpLGk9MCxhPTMyO2E8dC5sZW5ndGgtMTY7YSs9MTYwLGkrPTE2KXQuc2V0KHIuc3ViYXJyYXkoaSxpKzE2KSxhKTtyZXR1cm4gdH0sZS5kZWNyeXB0QXZjU2FtcGxlPWZ1bmN0aW9uKHQsZSxyLGksYSxuKXt2YXIgcz1YKGEuZGF0YSksbz10aGlzLmdldEF2Y0VuY3J5cHRlZERhdGEocyksbD10aGlzO3RoaXMuZGVjcnlwdEJ1ZmZlcihvLmJ1ZmZlciwoZnVuY3Rpb24obyl7YS5kYXRhPWwuZ2V0QXZjRGVjcnlwdGVkVW5pdChzLG8pLG58fGwuZGVjcnlwdEF2Y1NhbXBsZXModCxlLHIrMSxpKX0pKX0sZS5kZWNyeXB0QXZjU2FtcGxlcz1mdW5jdGlvbih0LGUscixpKXtpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGVjcnlwdCBzYW1wbGVzIG9mIHR5cGUgVWludDhBcnJheVwiKTtmb3IoOztlKysscj0wKXtpZihlPj10Lmxlbmd0aClyZXR1cm4gdm9pZCBpKCk7Zm9yKHZhciBhPXRbZV0udW5pdHM7IShyPj1hLmxlbmd0aCk7cisrKXt2YXIgbj1hW3JdO2lmKCEobi5kYXRhLmxlbmd0aDw9NDh8fDEhPT1uLnR5cGUmJjUhPT1uLnR5cGUpKXt2YXIgcz10aGlzLmRlY3J5cHRlci5pc1N5bmMoKTtpZih0aGlzLmRlY3J5cHRBdmNTYW1wbGUodCxlLHIsaSxuLHMpLCFzKXJldHVybn19fX0sdH0oKSxVPXt2aWRlbzoxLGF1ZGlvOjIsaWQzOjMsdGV4dDo0fSxHPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscil7dGhpcy5vYnNlcnZlcj12b2lkIDAsdGhpcy5jb25maWc9dm9pZCAwLHRoaXMudHlwZVN1cHBvcnRlZD12b2lkIDAsdGhpcy5zYW1wbGVBZXM9bnVsbCx0aGlzLnBtdFBhcnNlZD0hMSx0aGlzLmF1ZGlvQ29kZWM9dm9pZCAwLHRoaXMudmlkZW9Db2RlYz12b2lkIDAsdGhpcy5fZHVyYXRpb249MCx0aGlzLmFhY0xhc3RQVFM9bnVsbCx0aGlzLl9pbml0UFRTPW51bGwsdGhpcy5faW5pdERUUz1udWxsLHRoaXMuX3BtdElkPS0xLHRoaXMuX2F2Y1RyYWNrPXZvaWQgMCx0aGlzLl9hdWRpb1RyYWNrPXZvaWQgMCx0aGlzLl9pZDNUcmFjaz12b2lkIDAsdGhpcy5fdHh0VHJhY2s9dm9pZCAwLHRoaXMuYWFjT3ZlckZsb3c9bnVsbCx0aGlzLmF2Y1NhbXBsZT1udWxsLHRoaXMucmVtYWluZGVyRGF0YT1udWxsLHRoaXMub2JzZXJ2ZXI9dCx0aGlzLmNvbmZpZz1lLHRoaXMudHlwZVN1cHBvcnRlZD1yfXQucHJvYmU9ZnVuY3Rpb24oZSl7dmFyIHI9dC5zeW5jT2Zmc2V0KGUpO3JldHVybiEocjwwKSYmKHImJmMuYi53YXJuKFwiTVBFRzItVFMgZGV0ZWN0ZWQgYnV0IGZpcnN0IHN5bmMgd29yZCBmb3VuZCBAIG9mZnNldCBcIityK1wiLCBqdW5rIGFoZWFkID9cIiksITApfSx0LnN5bmNPZmZzZXQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPU1hdGgubWluKDFlMyx0Lmxlbmd0aC01NjQpLHI9MDtyPGU7KXtpZig3MT09PXRbcl0mJjcxPT09dFtyKzE4OF0mJjcxPT09dFtyKzM3Nl0pcmV0dXJuIHI7cisrfXJldHVybi0xfSx0LmNyZWF0ZVRyYWNrPWZ1bmN0aW9uKHQsZSl7cmV0dXJue2NvbnRhaW5lcjpcInZpZGVvXCI9PT10fHxcImF1ZGlvXCI9PT10P1widmlkZW8vbXAydFwiOnZvaWQgMCx0eXBlOnQsaWQ6VVt0XSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOjAsc2FtcGxlczpbXSxkcm9wcGVkOjAsZHVyYXRpb246XCJhdWRpb1wiPT09dD9lOnZvaWQgMH19O3ZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnJlc2V0SW5pdFNlZ21lbnQ9ZnVuY3Rpb24oZSxyLGkpe3RoaXMucG10UGFyc2VkPSExLHRoaXMuX3BtdElkPS0xLHRoaXMuX2F2Y1RyYWNrPXQuY3JlYXRlVHJhY2soXCJ2aWRlb1wiLGkpLHRoaXMuX2F1ZGlvVHJhY2s9dC5jcmVhdGVUcmFjayhcImF1ZGlvXCIsaSksdGhpcy5faWQzVHJhY2s9dC5jcmVhdGVUcmFjayhcImlkM1wiLGkpLHRoaXMuX3R4dFRyYWNrPXQuY3JlYXRlVHJhY2soXCJ0ZXh0XCIsaSksdGhpcy5fYXVkaW9UcmFjay5pc0FBQz0hMCx0aGlzLmFhY092ZXJGbG93PW51bGwsdGhpcy5hYWNMYXN0UFRTPW51bGwsdGhpcy5hdmNTYW1wbGU9bnVsbCx0aGlzLmF1ZGlvQ29kZWM9ZSx0aGlzLnZpZGVvQ29kZWM9cix0aGlzLl9kdXJhdGlvbj1pfSxlLnJlc2V0VGltZVN0YW1wPWZ1bmN0aW9uKCl7fSxlLnJlc2V0Q29udGlndWl0eT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX2F1ZGlvVHJhY2ssZT10aGlzLl9hdmNUcmFjayxyPXRoaXMuX2lkM1RyYWNrO3QmJih0LnBlc0RhdGE9bnVsbCksZSYmKGUucGVzRGF0YT1udWxsKSxyJiYoci5wZXNEYXRhPW51bGwpLHRoaXMuYWFjT3ZlckZsb3c9bnVsbCx0aGlzLmFhY0xhc3RQVFM9bnVsbH0sZS5kZW11eD1mdW5jdGlvbihlLHIsbixzKXt2YXIgbzt2b2lkIDA9PT1uJiYobj0hMSksdm9pZCAwPT09cyYmKHM9ITEpLG58fCh0aGlzLnNhbXBsZUFlcz1udWxsKTt2YXIgdT10aGlzLl9hdmNUcmFjayxkPXRoaXMuX2F1ZGlvVHJhY2ssaD10aGlzLl9pZDNUcmFjayxmPXUucGlkLHY9dS5wZXNEYXRhLGc9ZC5waWQscD1oLnBpZCxtPWQucGVzRGF0YSx5PWgucGVzRGF0YSxiPSExLFQ9dGhpcy5wbXRQYXJzZWQsRT10aGlzLl9wbXRJZCxTPWUubGVuZ3RoO2lmKHRoaXMucmVtYWluZGVyRGF0YSYmKFM9KGU9T2JqZWN0KGwuYSkodGhpcy5yZW1haW5kZXJEYXRhLGUpKS5sZW5ndGgsdGhpcy5yZW1haW5kZXJEYXRhPW51bGwpLFM8MTg4JiYhcylyZXR1cm4gdGhpcy5yZW1haW5kZXJEYXRhPWUse2F1ZGlvVHJhY2s6ZCxhdmNUcmFjazp1LGlkM1RyYWNrOmgsdGV4dFRyYWNrOnRoaXMuX3R4dFRyYWNrfTt2YXIgTD1NYXRoLm1heCgwLHQuc3luY09mZnNldChlKSk7KFMtPShTK0wpJTE4OCk8ZS5ieXRlTGVuZ3RoJiYhcyYmKHRoaXMucmVtYWluZGVyRGF0YT1uZXcgVWludDhBcnJheShlLmJ1ZmZlcixTLGUuYnVmZmVyLmJ5dGVMZW5ndGgtUykpO2Zvcih2YXIgQT0wLFI9TDtSPFM7Uis9MTg4KWlmKDcxPT09ZVtSXSl7dmFyIEQ9ISEoNjQmZVtSKzFdKSxfPSgoMzEmZVtSKzFdKTw8OCkrZVtSKzJdLGs9dm9pZCAwO2lmKCg0OCZlW1IrM10pPj40PjEpe2lmKChrPVIrNStlW1IrNF0pPT09UisxODgpY29udGludWV9ZWxzZSBrPVIrNDtzd2l0Y2goXyl7Y2FzZSBmOkQmJih2JiYobz1WKHYpKSYmdGhpcy5wYXJzZUFWQ1BFUyhvLCExKSx2PXtkYXRhOltdLHNpemU6MH0pLHYmJih2LmRhdGEucHVzaChlLnN1YmFycmF5KGssUisxODgpKSx2LnNpemUrPVIrMTg4LWspO2JyZWFrO2Nhc2UgZzpEJiYobSYmKG89VihtKSkmJihkLmlzQUFDP3RoaXMucGFyc2VBQUNQRVMobyk6dGhpcy5wYXJzZU1QRUdQRVMobykpLG09e2RhdGE6W10sc2l6ZTowfSksbSYmKG0uZGF0YS5wdXNoKGUuc3ViYXJyYXkoayxSKzE4OCkpLG0uc2l6ZSs9UisxODgtayk7YnJlYWs7Y2FzZSBwOkQmJih5JiYobz1WKHkpKSYmdGhpcy5wYXJzZUlEM1BFUyhvKSx5PXtkYXRhOltdLHNpemU6MH0pLHkmJih5LmRhdGEucHVzaChlLnN1YmFycmF5KGssUisxODgpKSx5LnNpemUrPVIrMTg4LWspO2JyZWFrO2Nhc2UgMDpEJiYoays9ZVtrXSsxKSxFPXRoaXMuX3BtdElkPUgoZSxrKTticmVhaztjYXNlIEU6RCYmKGsrPWVba10rMSk7dmFyIHg9SyhlLGssITA9PT10aGlzLnR5cGVTdXBwb3J0ZWQubXBlZ3x8ITA9PT10aGlzLnR5cGVTdXBwb3J0ZWQubXAzLG4pOyhmPXguYXZjKT4wJiYodS5waWQ9ZiksKGc9eC5hdWRpbyk+MCYmKGQucGlkPWcsZC5pc0FBQz14LmlzQUFDKSwocD14LmlkMyk+MCYmKGgucGlkPXApLGImJiFUJiYoYy5iLmxvZyhcInJlcGFyc2UgZnJvbSBiZWdpbm5pbmdcIiksYj0hMSxSPUwtMTg4KSxUPXRoaXMucG10UGFyc2VkPSEwO2JyZWFrO2Nhc2UgMTc6Y2FzZSA4MTkxOmJyZWFrO2RlZmF1bHQ6Yj0hMH19ZWxzZSBBKys7QT4wJiZ0aGlzLm9ic2VydmVyLmVtaXQoaS5hLkVSUk9SLGkuYS5FUlJPUix7dHlwZTphLmIuTUVESUFfRVJST1IsZGV0YWlsczphLmEuRlJBR19QQVJTSU5HX0VSUk9SLGZhdGFsOiExLHJlYXNvbjpcIkZvdW5kIFwiK0ErXCIgVFMgcGFja2V0L3MgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCAweDQ3XCJ9KSx1LnBlc0RhdGE9dixkLnBlc0RhdGE9bSxoLnBlc0RhdGE9eTt2YXIgQz17YXVkaW9UcmFjazpkLGF2Y1RyYWNrOnUsaWQzVHJhY2s6aCx0ZXh0VHJhY2s6dGhpcy5fdHh0VHJhY2t9O3JldHVybiBzJiZ0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKEMpLEN9LGUuZmx1c2g9ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXMucmVtYWluZGVyRGF0YTtyZXR1cm4gdGhpcy5yZW1haW5kZXJEYXRhPW51bGwsdD1lP3RoaXMuZGVtdXgoZSwtMSwhMSwhMCk6e2F1ZGlvVHJhY2s6dGhpcy5fYXVkaW9UcmFjayxhdmNUcmFjazp0aGlzLl9hdmNUcmFjayx0ZXh0VHJhY2s6dGhpcy5fdHh0VHJhY2ssaWQzVHJhY2s6dGhpcy5faWQzVHJhY2t9LHRoaXMuZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXModCksdGhpcy5zYW1wbGVBZXM/dGhpcy5kZWNyeXB0KHQsdGhpcy5zYW1wbGVBZXMpOnR9LGUuZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXM9ZnVuY3Rpb24odCl7dmFyIGUscj10LmF1ZGlvVHJhY2ssaT10LmF2Y1RyYWNrLGE9dC5pZDNUcmFjayxuPWkucGVzRGF0YSxzPXIucGVzRGF0YSxvPWEucGVzRGF0YTtuJiYoZT1WKG4pKT8odGhpcy5wYXJzZUFWQ1BFUyhlLCEwKSxpLnBlc0RhdGE9bnVsbCk6aS5wZXNEYXRhPW4scyYmKGU9VihzKSk/KHIuaXNBQUM/dGhpcy5wYXJzZUFBQ1BFUyhlKTp0aGlzLnBhcnNlTVBFR1BFUyhlKSxyLnBlc0RhdGE9bnVsbCk6KG51bGwhPXMmJnMuc2l6ZSYmYy5iLmxvZyhcImxhc3QgQUFDIFBFUyBwYWNrZXQgdHJ1bmNhdGVkLG1pZ2h0IG92ZXJsYXAgYmV0d2VlbiBmcmFnbWVudHNcIiksci5wZXNEYXRhPXMpLG8mJihlPVYobykpPyh0aGlzLnBhcnNlSUQzUEVTKGUpLGEucGVzRGF0YT1udWxsKTphLnBlc0RhdGE9b30sZS5kZW11eFNhbXBsZUFlcz1mdW5jdGlvbih0LGUscil7dmFyIGk9dGhpcy5kZW11eCh0LHIsITAsIXRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSxhPXRoaXMuc2FtcGxlQWVzPW5ldyBCKHRoaXMub2JzZXJ2ZXIsdGhpcy5jb25maWcsZSk7cmV0dXJuIHRoaXMuZGVjcnlwdChpLGEpfSxlLmRlY3J5cHQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHIpe3ZhciBpPXQuYXVkaW9UcmFjayxhPXQuYXZjVHJhY2s7aS5zYW1wbGVzJiZpLmlzQUFDP2UuZGVjcnlwdEFhY1NhbXBsZXMoaS5zYW1wbGVzLDAsKGZ1bmN0aW9uKCl7YS5zYW1wbGVzP2UuZGVjcnlwdEF2Y1NhbXBsZXMoYS5zYW1wbGVzLDAsMCwoZnVuY3Rpb24oKXtyKHQpfSkpOnIodCl9KSk6YS5zYW1wbGVzJiZlLmRlY3J5cHRBdmNTYW1wbGVzKGEuc2FtcGxlcywwLDAsKGZ1bmN0aW9uKCl7cih0KX0pKX0pKX0sZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5faW5pdFBUUz10aGlzLl9pbml0RFRTPW51bGwsdGhpcy5fZHVyYXRpb249MH0sZS5wYXJzZUFWQ1BFUz1mdW5jdGlvbih0LGUpe3ZhciByLGk9dGhpcyxhPXRoaXMuX2F2Y1RyYWNrLG49dGhpcy5wYXJzZUFWQ05BTHUodC5kYXRhKSxzPXRoaXMuYXZjU2FtcGxlLGw9ITE7dC5kYXRhPW51bGwscyYmbi5sZW5ndGgmJiFhLmF1ZEZvdW5kJiYoVyhzLGEpLHM9dGhpcy5hdmNTYW1wbGU9aighMSx0LnB0cyx0LmR0cyxcIlwiKSksbi5mb3JFYWNoKChmdW5jdGlvbihlKXtzd2l0Y2goZS50eXBlKXtjYXNlIDE6cj0hMCxzfHwocz1pLmF2Y1NhbXBsZT1qKCEwLHQucHRzLHQuZHRzLFwiXCIpKSxzLmZyYW1lPSEwO3ZhciBuPWUuZGF0YTtpZihsJiZuLmxlbmd0aD40KXt2YXIgdT1uZXcgTihuKS5yZWFkU2xpY2VUeXBlKCk7MiE9PXUmJjQhPT11JiY3IT09dSYmOSE9PXV8fChzLmtleT0hMCl9YnJlYWs7Y2FzZSA1OnI9ITAsc3x8KHM9aS5hdmNTYW1wbGU9aighMCx0LnB0cyx0LmR0cyxcIlwiKSkscy5rZXk9ITAscy5mcmFtZT0hMDticmVhaztjYXNlIDY6cj0hMDt2YXIgZD1uZXcgTihYKGUuZGF0YSkpO2QucmVhZFVCeXRlKCk7Zm9yKHZhciBoPTAsZj0wLGM9ITEsdj0wOyFjJiZkLmJ5dGVzQXZhaWxhYmxlPjE7KXtoPTA7ZG97aCs9dj1kLnJlYWRVQnl0ZSgpfXdoaWxlKDI1NT09PXYpO2Y9MDtkb3tmKz12PWQucmVhZFVCeXRlKCl9d2hpbGUoMjU1PT09dik7aWYoND09PWgmJjAhPT1kLmJ5dGVzQXZhaWxhYmxlKXtpZihjPSEwLDE4MT09PWQucmVhZFVCeXRlKCkpaWYoNDk9PT1kLnJlYWRVU2hvcnQoKSlpZigxMTk1NDU2ODIwPT09ZC5yZWFkVUludCgpKWlmKDM9PT1kLnJlYWRVQnl0ZSgpKXtmb3IodmFyIGc9ZC5yZWFkVUJ5dGUoKSxwPTMxJmcsbT1bZyxkLnJlYWRVQnl0ZSgpXSx5PTA7eTxwO3krKyltLnB1c2goZC5yZWFkVUJ5dGUoKSksbS5wdXNoKGQucmVhZFVCeXRlKCkpLG0ucHVzaChkLnJlYWRVQnl0ZSgpKTtZKGkuX3R4dFRyYWNrLnNhbXBsZXMse3R5cGU6MyxwdHM6dC5wdHMsYnl0ZXM6bX0pfX1lbHNlIGlmKDU9PT1oJiYwIT09ZC5ieXRlc0F2YWlsYWJsZSl7aWYoYz0hMCxmPjE2KXtmb3IodmFyIGI9W10sVD0wO1Q8MTY7VCsrKWIucHVzaChkLnJlYWRVQnl0ZSgpLnRvU3RyaW5nKDE2KSksMyE9PVQmJjUhPT1UJiY3IT09VCYmOSE9PVR8fGIucHVzaChcIi1cIik7Zm9yKHZhciBFPWYtMTYsUz1uZXcgVWludDhBcnJheShFKSxMPTA7TDxFO0wrKylTW0xdPWQucmVhZFVCeXRlKCk7WShpLl90eHRUcmFjay5zYW1wbGVzLHtwdHM6dC5wdHMscGF5bG9hZFR5cGU6aCx1dWlkOmIuam9pbihcIlwiKSx1c2VyRGF0YTpPYmplY3Qoby5mKShTKSx1c2VyRGF0YUJ5dGVzOlN9KX19ZWxzZSBpZihmPGQuYnl0ZXNBdmFpbGFibGUpZm9yKHZhciBBPTA7QTxmO0ErKylkLnJlYWRVQnl0ZSgpfWJyZWFrO2Nhc2UgNzppZihyPSEwLGw9ITAsIWEuc3BzKXt2YXIgUj1uZXcgTihlLmRhdGEpLnJlYWRTUFMoKTthLndpZHRoPVIud2lkdGgsYS5oZWlnaHQ9Ui5oZWlnaHQsYS5waXhlbFJhdGlvPVIucGl4ZWxSYXRpbyxhLnNwcz1bZS5kYXRhXSxhLmR1cmF0aW9uPWkuX2R1cmF0aW9uO2Zvcih2YXIgRD1lLmRhdGEuc3ViYXJyYXkoMSw0KSxfPVwiYXZjMS5cIixrPTA7azwzO2srKyl7dmFyIHg9RFtrXS50b1N0cmluZygxNik7eC5sZW5ndGg8MiYmKHg9XCIwXCIreCksXys9eH1hLmNvZGVjPV99YnJlYWs7Y2FzZSA4OnI9ITAsYS5wcHN8fChhLnBwcz1bZS5kYXRhXSk7YnJlYWs7Y2FzZSA5OnI9ITEsYS5hdWRGb3VuZD0hMCxzJiZXKHMsYSkscz1pLmF2Y1NhbXBsZT1qKCExLHQucHRzLHQuZHRzLFwiXCIpO2JyZWFrO2Nhc2UgMTI6cj0hMTticmVhaztkZWZhdWx0OnI9ITEscyYmKHMuZGVidWcrPVwidW5rbm93biBOQUwgXCIrZS50eXBlK1wiIFwiKX1zJiZyJiZzLnVuaXRzLnB1c2goZSl9KSksZSYmcyYmKFcocyxhKSx0aGlzLmF2Y1NhbXBsZT1udWxsKX0sZS5nZXRMYXN0TmFsVW5pdD1mdW5jdGlvbigpe3ZhciB0LGUscj10aGlzLmF2Y1NhbXBsZTtpZighcnx8MD09PXIudW5pdHMubGVuZ3RoKXt2YXIgaT10aGlzLl9hdmNUcmFjay5zYW1wbGVzO3I9aVtpLmxlbmd0aC0xXX1pZihudWxsIT09KHQ9cikmJnZvaWQgMCE9PXQmJnQudW5pdHMpe3ZhciBhPXIudW5pdHM7ZT1hW2EubGVuZ3RoLTFdfXJldHVybiBlfSxlLnBhcnNlQVZDTkFMdT1mdW5jdGlvbih0KXt2YXIgZSxyLGk9dC5ieXRlTGVuZ3RoLGE9dGhpcy5fYXZjVHJhY2ssbj1hLm5hbHVTdGF0ZXx8MCxzPW4sbz1bXSxsPTAsdT0tMSxkPTA7Zm9yKC0xPT09biYmKHU9MCxkPTMxJnRbMF0sbj0wLGw9MSk7bDxpOylpZihlPXRbbCsrXSxuKWlmKDEhPT1uKWlmKGUpaWYoMT09PWUpe2lmKHU+PTApe3ZhciBoPXtkYXRhOnQuc3ViYXJyYXkodSxsLW4tMSksdHlwZTpkfTtvLnB1c2goaCl9ZWxzZXt2YXIgZj10aGlzLmdldExhc3ROYWxVbml0KCk7aWYoZiYmKHMmJmw8PTQtcyYmZi5zdGF0ZSYmKGYuZGF0YT1mLmRhdGEuc3ViYXJyYXkoMCxmLmRhdGEuYnl0ZUxlbmd0aC1zKSksKHI9bC1uLTEpPjApKXt2YXIgYz1uZXcgVWludDhBcnJheShmLmRhdGEuYnl0ZUxlbmd0aCtyKTtjLnNldChmLmRhdGEsMCksYy5zZXQodC5zdWJhcnJheSgwLHIpLGYuZGF0YS5ieXRlTGVuZ3RoKSxmLmRhdGE9YyxmLnN0YXRlPTB9fWw8aT8odT1sLGQ9MzEmdFtsXSxuPTApOm49LTF9ZWxzZSBuPTA7ZWxzZSBuPTM7ZWxzZSBuPWU/MDoyO2Vsc2Ugbj1lPzA6MTtpZih1Pj0wJiZuPj0wKXt2YXIgdj17ZGF0YTp0LnN1YmFycmF5KHUsaSksdHlwZTpkLHN0YXRlOm59O28ucHVzaCh2KX1pZigwPT09by5sZW5ndGgpe3ZhciBnPXRoaXMuZ2V0TGFzdE5hbFVuaXQoKTtpZihnKXt2YXIgcD1uZXcgVWludDhBcnJheShnLmRhdGEuYnl0ZUxlbmd0aCt0LmJ5dGVMZW5ndGgpO3Auc2V0KGcuZGF0YSwwKSxwLnNldCh0LGcuZGF0YS5ieXRlTGVuZ3RoKSxnLmRhdGE9cH19cmV0dXJuIGEubmFsdVN0YXRlPW4sb30sZS5wYXJzZUFBQ1BFUz1mdW5jdGlvbih0KXt2YXIgZSxyLG4scyxvLGw9MCx1PXRoaXMuX2F1ZGlvVHJhY2ssZD10aGlzLmFhY092ZXJGbG93LGg9dC5kYXRhO2lmKGQpe3RoaXMuYWFjT3ZlckZsb3c9bnVsbDt2YXIgZj1kLnNhbXBsZS51bml0LmJ5dGVMZW5ndGgsdj1NYXRoLm1pbihkLm1pc3NpbmcsZiksZz1mLXY7ZC5zYW1wbGUudW5pdC5zZXQoaC5zdWJhcnJheSgwLHYpLGcpLHUuc2FtcGxlcy5wdXNoKGQuc2FtcGxlKSxsPWQubWlzc2luZ31mb3IoZT1sLHI9aC5sZW5ndGg7ZTxyLTEmJiFtKGgsZSk7ZSsrKTtpZihlIT09bCYmKGU8ci0xPyhuPVwiQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OlwiK2Uscz0hMSk6KG49XCJubyBBRFRTIGhlYWRlciBmb3VuZCBpbiBBQUMgUEVTXCIscz0hMCksYy5iLndhcm4oXCJwYXJzaW5nIGVycm9yOlwiK24pLHRoaXMub2JzZXJ2ZXIuZW1pdChpLmEuRVJST1IsaS5hLkVSUk9SLHt0eXBlOmEuYi5NRURJQV9FUlJPUixkZXRhaWxzOmEuYS5GUkFHX1BBUlNJTkdfRVJST1IsZmF0YWw6cyxyZWFzb246bn0pLHMpKXJldHVybjtpZihiKHUsdGhpcy5vYnNlcnZlcixoLGUsdGhpcy5hdWRpb0NvZGVjKSx2b2lkIDAhPT10LnB0cylvPXQucHRzO2Vsc2V7aWYoIWQpcmV0dXJuIHZvaWQgYy5iLndhcm4oXCJbdHNkZW11eGVyXTogQUFDIFBFUyB1bmtub3duIFBUU1wiKTt2YXIgcD1UKHUuc2FtcGxlcmF0ZSk7bz1kLnNhbXBsZS5wdHMrcH1mb3IodmFyIHk9MDtlPHI7KXtpZihtKGgsZSkpe2lmKGUrNTxyKXt2YXIgUz1FKHUsaCxlLG8seSk7aWYoUyl7aWYoIVMubWlzc2luZyl7ZSs9Uy5sZW5ndGgseSsrO2NvbnRpbnVlfXRoaXMuYWFjT3ZlckZsb3c9U319YnJlYWt9ZSsrfX0sZS5wYXJzZU1QRUdQRVM9ZnVuY3Rpb24odCl7dmFyIGU9dC5kYXRhLHI9ZS5sZW5ndGgsaT0wLGE9MCxuPXQucHRzO2lmKHZvaWQgMCE9PW4pZm9yKDthPHI7KWlmKEYoZSxhKSl7dmFyIHM9Tyh0aGlzLl9hdWRpb1RyYWNrLGUsYSxuLGkpO2lmKCFzKWJyZWFrO2ErPXMubGVuZ3RoLGkrK31lbHNlIGErKztlbHNlIGMuYi53YXJuKFwiW3RzZGVtdXhlcl06IE1QRUcgUEVTIHVua25vd24gUFRTXCIpfSxlLnBhcnNlSUQzUEVTPWZ1bmN0aW9uKHQpe3ZvaWQgMCE9PXQucHRzP3RoaXMuX2lkM1RyYWNrLnNhbXBsZXMucHVzaCh0KTpjLmIud2FybihcIlt0c2RlbXV4ZXJdOiBJRDMgUEVTIHVua25vd24gUFRTXCIpfSx0fSgpO2Z1bmN0aW9uIGoodCxlLHIsaSl7cmV0dXJue2tleTp0LGZyYW1lOiExLHB0czplLGR0czpyLHVuaXRzOltdLGRlYnVnOmksbGVuZ3RoOjB9fWZ1bmN0aW9uIEgodCxlKXtyZXR1cm4oMzEmdFtlKzEwXSk8PDh8dFtlKzExXX1mdW5jdGlvbiBLKHQsZSxyLGkpe3ZhciBhPXthdWRpbzotMSxhdmM6LTEsaWQzOi0xLGlzQUFDOiEwfSxuPWUrMysoKDE1JnRbZSsxXSk8PDh8dFtlKzJdKS00O2ZvcihlKz0xMisoKDE1JnRbZSsxMF0pPDw4fHRbZSsxMV0pO2U8bjspe3ZhciBzPSgzMSZ0W2UrMV0pPDw4fHRbZSsyXTtzd2l0Y2godFtlXSl7Y2FzZSAyMDc6aWYoIWkpe2MuYi5sb2coXCJBRFRTIEFBQyB3aXRoIEFFUy0xMjgtQ0JDIGZyYW1lIGVuY3J5cHRpb24gZm91bmQgaW4gdW5lbmNyeXB0ZWQgc3RyZWFtXCIpO2JyZWFrfWNhc2UgMTU6LTE9PT1hLmF1ZGlvJiYoYS5hdWRpbz1zKTticmVhaztjYXNlIDIxOi0xPT09YS5pZDMmJihhLmlkMz1zKTticmVhaztjYXNlIDIxOTppZighaSl7Yy5iLmxvZyhcIkguMjY0IHdpdGggQUVTLTEyOC1DQkMgc2xpY2UgZW5jcnlwdGlvbiBmb3VuZCBpbiB1bmVuY3J5cHRlZCBzdHJlYW1cIik7YnJlYWt9Y2FzZSAyNzotMT09PWEuYXZjJiYoYS5hdmM9cyk7YnJlYWs7Y2FzZSAzOmNhc2UgNDpyPy0xPT09YS5hdWRpbyYmKGEuYXVkaW89cyxhLmlzQUFDPSExKTpjLmIubG9nKFwiTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7YnJlYWs7Y2FzZSAzNjpjLmIud2FybihcIlVuc3VwcG9ydGVkIEhFVkMgc3RyZWFtIHR5cGUgZm91bmRcIil9ZSs9NSsoKDE1JnRbZSszXSk8PDh8dFtlKzRdKX1yZXR1cm4gYX1mdW5jdGlvbiBWKHQpe3ZhciBlLHIsaSxhLG4scz0wLG89dC5kYXRhO2lmKCF0fHwwPT09dC5zaXplKXJldHVybiBudWxsO2Zvcig7b1swXS5sZW5ndGg8MTkmJm8ubGVuZ3RoPjE7KXt2YXIgbD1uZXcgVWludDhBcnJheShvWzBdLmxlbmd0aCtvWzFdLmxlbmd0aCk7bC5zZXQob1swXSksbC5zZXQob1sxXSxvWzBdLmxlbmd0aCksb1swXT1sLG8uc3BsaWNlKDEsMSl9aWYoMT09PSgoZT1vWzBdKVswXTw8MTYpKyhlWzFdPDw4KStlWzJdKXtpZigocj0oZVs0XTw8OCkrZVs1XSkmJnI+dC5zaXplLTYpcmV0dXJuIG51bGw7dmFyIHU9ZVs3XTsxOTImdSYmKGE9NTM2ODcwOTEyKigxNCZlWzldKSs0MTk0MzA0KigyNTUmZVsxMF0pKzE2Mzg0KigyNTQmZVsxMV0pKzEyOCooMjU1JmVbMTJdKSsoMjU0JmVbMTNdKS8yLDY0JnU/YS0obj01MzY4NzA5MTIqKDE0JmVbMTRdKSs0MTk0MzA0KigyNTUmZVsxNV0pKzE2Mzg0KigyNTQmZVsxNl0pKzEyOCooMjU1JmVbMTddKSsoMjU0JmVbMThdKS8yKT41NGU1JiYoYy5iLndhcm4oTWF0aC5yb3VuZCgoYS1uKS85ZTQpK1wicyBkZWx0YSBiZXR3ZWVuIFBUUyBhbmQgRFRTLCBhbGlnbiB0aGVtXCIpLGE9bik6bj1hKTt2YXIgZD0oaT1lWzhdKSs5O2lmKHQuc2l6ZTw9ZClyZXR1cm4gbnVsbDt0LnNpemUtPWQ7Zm9yKHZhciBoPW5ldyBVaW50OEFycmF5KHQuc2l6ZSksZj0wLHY9by5sZW5ndGg7Zjx2O2YrKyl7dmFyIGc9KGU9b1tmXSkuYnl0ZUxlbmd0aDtpZihkKXtpZihkPmcpe2QtPWc7Y29udGludWV9ZT1lLnN1YmFycmF5KGQpLGctPWQsZD0wfWguc2V0KGUscykscys9Z31yZXR1cm4gciYmKHItPWkrMykse2RhdGE6aCxwdHM6YSxkdHM6bixsZW46cn19cmV0dXJuIG51bGx9ZnVuY3Rpb24gVyh0LGUpe2lmKHQudW5pdHMubGVuZ3RoJiZ0LmZyYW1lKXtpZih2b2lkIDA9PT10LnB0cyl7dmFyIHI9ZS5zYW1wbGVzLGk9ci5sZW5ndGg7aWYoIWkpcmV0dXJuIHZvaWQgZS5kcm9wcGVkKys7dmFyIGE9cltpLTFdO3QucHRzPWEucHRzLHQuZHRzPWEuZHRzfWUuc2FtcGxlcy5wdXNoKHQpfXQuZGVidWcubGVuZ3RoJiZjLmIubG9nKHQucHRzK1wiL1wiK3QuZHRzK1wiOlwiK3QuZGVidWcpfWZ1bmN0aW9uIFkodCxlKXt2YXIgcj10Lmxlbmd0aDtpZihyPjApe2lmKGUucHRzPj10W3ItMV0ucHRzKXQucHVzaChlKTtlbHNlIGZvcih2YXIgaT1yLTE7aT49MDtpLS0paWYoZS5wdHM8dFtpXS5wdHMpe3Quc3BsaWNlKGksMCxlKTticmVha319ZWxzZSB0LnB1c2goZSl9ZnVuY3Rpb24gWCh0KXtmb3IodmFyIGU9dC5ieXRlTGVuZ3RoLHI9W10saT0xO2k8ZS0yOykwPT09dFtpXSYmMD09PXRbaSsxXSYmMz09PXRbaSsyXT8oci5wdXNoKGkrMiksaSs9Mik6aSsrO2lmKDA9PT1yLmxlbmd0aClyZXR1cm4gdDt2YXIgYT1lLXIubGVuZ3RoLG49bmV3IFVpbnQ4QXJyYXkoYSkscz0wO2ZvcihpPTA7aTxhO3MrKyxpKyspcz09PXJbMF0mJihzKyssci5zaGlmdCgpKSxuW2ldPXRbc107cmV0dXJuIG59Ry5taW5Qcm9iZUJ5dGVMZW5ndGg9MTg4O3ZhciBxPUc7ZnVuY3Rpb24geih0LGUpe3JldHVybih6PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fX3Byb3RvX189ZSx0fSkodCxlKX12YXIgUT1mdW5jdGlvbih0KXt2YXIgZSxyO2Z1bmN0aW9uIGkoKXtyZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cj10LChlPWkpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHIucHJvdG90eXBlKSxlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lLHooZSxyKTt2YXIgYT1pLnByb3RvdHlwZTtyZXR1cm4gYS5yZXNldEluaXRTZWdtZW50PWZ1bmN0aW9uKGUscixpKXt0LnByb3RvdHlwZS5yZXNldEluaXRTZWdtZW50LmNhbGwodGhpcyxlLHIsaSksdGhpcy5fYXVkaW9UcmFjaz17Y29udGFpbmVyOlwiYXVkaW8vbXBlZ1wiLHR5cGU6XCJhdWRpb1wiLGlkOjIscGlkOi0xLHNlcXVlbmNlTnVtYmVyOjAsaXNBQUM6ITEsc2FtcGxlczpbXSxtYW5pZmVzdENvZGVjOmUsZHVyYXRpb246aSxpbnB1dFRpbWVTY2FsZTo5ZTQsZHJvcHBlZDowfX0saS5wcm9iZT1mdW5jdGlvbih0KXtpZighdClyZXR1cm4hMTtmb3IodmFyIGU9KG8uYih0LDApfHxbXSkubGVuZ3RoLHI9dC5sZW5ndGg7ZTxyO2UrKylpZihNKHQsZSkpcmV0dXJuIGMuYi5sb2coXCJNUEVHIEF1ZGlvIHN5bmMgd29yZCBmb3VuZCAhXCIpLCEwO3JldHVybiExfSxhLmNhblBhcnNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7cmV0dXJuIFAodCxlKSYmNDw9dC5sZW5ndGgtZX0odCxlKX0sYS5hcHBlbmRGcmFtZT1mdW5jdGlvbih0LGUscil7aWYobnVsbCE9PXRoaXMuaW5pdFBUUylyZXR1cm4gTyh0LGUscix0aGlzLmluaXRQVFMsdGhpcy5mcmFtZUluZGV4KX0saX0oZik7US5taW5Qcm9iZUJ5dGVMZW5ndGg9NDt2YXIgJD1RLFo9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LmdldFNpbGVudEZyYW1lPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQpe2Nhc2VcIm1wNGEuNDAuMlwiOmlmKDE9PT1lKXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzUsMTI4XSk7aWYoMj09PWUpcmV0dXJuIG5ldyBVaW50OEFycmF5KFszMywwLDczLDE0NCwyLDI1LDAsMzUsMTI4XSk7aWYoMz09PWUpcmV0dXJuIG5ldyBVaW50OEFycmF5KFswLDIwMCwwLDEyOCwzMiwxMzIsMSwzOCw2NCw4LDEwMCwwLDE0Ml0pO2lmKDQ9PT1lKXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxMjgsNDQsMTI4LDgsMiw1Nl0pO2lmKDU9PT1lKXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxMzAsNDgsNCwxNTMsMCwzMywxNDQsMiw1Nl0pO2lmKDY9PT1lKXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxMzAsNDgsNCwxNTMsMCwzMywxNDQsMiwwLDE3OCwwLDMyLDgsMjI0XSk7YnJlYWs7ZGVmYXVsdDppZigxPT09ZSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzEsNjQsMzQsMTI4LDE2Myw3OCwyMzAsMTI4LDE4Niw4LDAsMCwwLDI4LDYsMjQxLDE5MywxMCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5NF0pO2lmKDI9PT1lKXJldHVybiBuZXcgVWludDhBcnJheShbMSw2NCwzNCwxMjgsMTYzLDk0LDIzMCwxMjgsMTg2LDgsMCwwLDAsMCwxNDksMCw2LDI0MSwxNjEsMTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTRdKTtpZigzPT09ZSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzEsNjQsMzQsMTI4LDE2Myw5NCwyMzAsMTI4LDE4Niw4LDAsMCwwLDAsMTQ5LDAsNiwyNDEsMTYxLDEwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDk0XSl9fSx0fSgpLEo9TWF0aC5wb3coMiwzMiktMSx0dD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQuaW5pdD1mdW5jdGlvbigpe3ZhciBlO2ZvcihlIGluIHQudHlwZXM9e2F2YzE6W10sYXZjQzpbXSxidHJ0OltdLGRpbmY6W10sZHJlZjpbXSxlc2RzOltdLGZ0eXA6W10saGRscjpbXSxtZGF0OltdLG1kaGQ6W10sbWRpYTpbXSxtZmhkOltdLG1pbmY6W10sbW9vZjpbXSxtb292OltdLG1wNGE6W10sXCIubXAzXCI6W10sbXZleDpbXSxtdmhkOltdLHBhc3A6W10sc2R0cDpbXSxzdGJsOltdLHN0Y286W10sc3RzYzpbXSxzdHNkOltdLHN0c3o6W10sc3R0czpbXSx0ZmR0OltdLHRmaGQ6W10sdHJhZjpbXSx0cmFrOltdLHRydW46W10sdHJleDpbXSx0a2hkOltdLHZtaGQ6W10sc21oZDpbXX0sdC50eXBlcyl0LnR5cGVzLmhhc093blByb3BlcnR5KGUpJiYodC50eXBlc1tlXT1bZS5jaGFyQ29kZUF0KDApLGUuY2hhckNvZGVBdCgxKSxlLmNoYXJDb2RlQXQoMiksZS5jaGFyQ29kZUF0KDMpXSk7dmFyIHI9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwxMTgsMTA1LDEwMCwxMDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsODYsMTA1LDEwMCwxMDEsMTExLDcyLDk3LDExMCwxMDAsMTA4LDEwMSwxMTQsMF0pLGk9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwxMTUsMTExLDExNywxMTAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsODMsMTExLDExNywxMTAsMTAwLDcyLDk3LDExMCwxMDAsMTA4LDEwMSwxMTQsMF0pO3QuSERMUl9UWVBFUz17dmlkZW86cixhdWRpbzppfTt2YXIgYT1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDEyLDExNywxMTQsMTA4LDMyLDAsMCwwLDFdKSxuPW5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDBdKTt0LlNUVFM9dC5TVFNDPXQuU1RDTz1uLHQuU1RTWj1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdKSx0LlZNSEQ9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwXSksdC5TTUhEPW5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDBdKSx0LlNUU0Q9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMV0pO3ZhciBzPW5ldyBVaW50OEFycmF5KFsxMDUsMTE1LDExMSwxMDldKSxvPW5ldyBVaW50OEFycmF5KFs5NywxMTgsOTksNDldKSxsPW5ldyBVaW50OEFycmF5KFswLDAsMCwxXSk7dC5GVFlQPXQuYm94KHQudHlwZXMuZnR5cCxzLGwscyxvKSx0LkRJTkY9dC5ib3godC50eXBlcy5kaW5mLHQuYm94KHQudHlwZXMuZHJlZixhKSl9LHQuYm94PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT04LHI9YXJndW1lbnRzLmxlbmd0aCxpPW5ldyBBcnJheShyPjE/ci0xOjApLGE9MTthPHI7YSsrKWlbYS0xXT1hcmd1bWVudHNbYV07Zm9yKHZhciBuPWkubGVuZ3RoLHM9bjtuLS07KWUrPWlbbl0uYnl0ZUxlbmd0aDt2YXIgbz1uZXcgVWludDhBcnJheShlKTtmb3Iob1swXT1lPj4yNCYyNTUsb1sxXT1lPj4xNiYyNTUsb1syXT1lPj44JjI1NSxvWzNdPTI1NSZlLG8uc2V0KHQsNCksbj0wLGU9ODtuPHM7bisrKW8uc2V0KGlbbl0sZSksZSs9aVtuXS5ieXRlTGVuZ3RoO3JldHVybiBvfSx0LmhkbHI9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuYm94KHQudHlwZXMuaGRscix0LkhETFJfVFlQRVNbZV0pfSx0Lm1kYXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuYm94KHQudHlwZXMubWRhdCxlKX0sdC5tZGhkPWZ1bmN0aW9uKGUscil7cio9ZTt2YXIgaT1NYXRoLmZsb29yKHIvKEorMSkpLGE9TWF0aC5mbG9vcihyJShKKzEpKTtyZXR1cm4gdC5ib3godC50eXBlcy5tZGhkLG5ldyBVaW50OEFycmF5KFsxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwwLDAsMCwwLDAsMCwwLDMsZT4+MjQmMjU1LGU+PjE2JjI1NSxlPj44JjI1NSwyNTUmZSxpPj4yNCxpPj4xNiYyNTUsaT4+OCYyNTUsMjU1JmksYT4+MjQsYT4+MTYmMjU1LGE+PjgmMjU1LDI1NSZhLDg1LDE5NiwwLDBdKSl9LHQubWRpYT1mdW5jdGlvbihlKXtyZXR1cm4gdC5ib3godC50eXBlcy5tZGlhLHQubWRoZChlLnRpbWVzY2FsZSxlLmR1cmF0aW9uKSx0LmhkbHIoZS50eXBlKSx0Lm1pbmYoZSkpfSx0Lm1maGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuYm94KHQudHlwZXMubWZoZCxuZXcgVWludDhBcnJheShbMCwwLDAsMCxlPj4yNCxlPj4xNiYyNTUsZT4+OCYyNTUsMjU1JmVdKSl9LHQubWluZj1mdW5jdGlvbihlKXtyZXR1cm5cImF1ZGlvXCI9PT1lLnR5cGU/dC5ib3godC50eXBlcy5taW5mLHQuYm94KHQudHlwZXMuc21oZCx0LlNNSEQpLHQuRElORix0LnN0YmwoZSkpOnQuYm94KHQudHlwZXMubWluZix0LmJveCh0LnR5cGVzLnZtaGQsdC5WTUhEKSx0LkRJTkYsdC5zdGJsKGUpKX0sdC5tb29mPWZ1bmN0aW9uKGUscixpKXtyZXR1cm4gdC5ib3godC50eXBlcy5tb29mLHQubWZoZChlKSx0LnRyYWYoaSxyKSl9LHQubW9vdj1mdW5jdGlvbihlKXtmb3IodmFyIHI9ZS5sZW5ndGgsaT1bXTtyLS07KWlbcl09dC50cmFrKGVbcl0pO3JldHVybiB0LmJveC5hcHBseShudWxsLFt0LnR5cGVzLm1vb3YsdC5tdmhkKGVbMF0udGltZXNjYWxlLGVbMF0uZHVyYXRpb24pXS5jb25jYXQoaSkuY29uY2F0KHQubXZleChlKSkpfSx0Lm12ZXg9ZnVuY3Rpb24oZSl7Zm9yKHZhciByPWUubGVuZ3RoLGk9W107ci0tOylpW3JdPXQudHJleChlW3JdKTtyZXR1cm4gdC5ib3guYXBwbHkobnVsbCxbdC50eXBlcy5tdmV4XS5jb25jYXQoaSkpfSx0Lm12aGQ9ZnVuY3Rpb24oZSxyKXtyKj1lO3ZhciBpPU1hdGguZmxvb3Ioci8oSisxKSksYT1NYXRoLmZsb29yKHIlKEorMSkpLG49bmV3IFVpbnQ4QXJyYXkoWzEsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDAsMCwwLDAsMCwwLDAsMyxlPj4yNCYyNTUsZT4+MTYmMjU1LGU+PjgmMjU1LDI1NSZlLGk+PjI0LGk+PjE2JjI1NSxpPj44JjI1NSwyNTUmaSxhPj4yNCxhPj4xNiYyNTUsYT4+OCYyNTUsMjU1JmEsMCwxLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsNjQsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjU1LDI1NSwyNTUsMjU1XSk7cmV0dXJuIHQuYm94KHQudHlwZXMubXZoZCxuKX0sdC5zZHRwPWZ1bmN0aW9uKGUpe3ZhciByLGksYT1lLnNhbXBsZXN8fFtdLG49bmV3IFVpbnQ4QXJyYXkoNCthLmxlbmd0aCk7Zm9yKHI9MDtyPGEubGVuZ3RoO3IrKylpPWFbcl0uZmxhZ3MsbltyKzRdPWkuZGVwZW5kc09uPDw0fGkuaXNEZXBlbmRlZE9uPDwyfGkuaGFzUmVkdW5kYW5jeTtyZXR1cm4gdC5ib3godC50eXBlcy5zZHRwLG4pfSx0LnN0Ymw9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuYm94KHQudHlwZXMuc3RibCx0LnN0c2QoZSksdC5ib3godC50eXBlcy5zdHRzLHQuU1RUUyksdC5ib3godC50eXBlcy5zdHNjLHQuU1RTQyksdC5ib3godC50eXBlcy5zdHN6LHQuU1RTWiksdC5ib3godC50eXBlcy5zdGNvLHQuU1RDTykpfSx0LmF2YzE9ZnVuY3Rpb24oZSl7dmFyIHIsaSxhLG49W10scz1bXTtmb3Iocj0wO3I8ZS5zcHMubGVuZ3RoO3IrKylhPShpPWUuc3BzW3JdKS5ieXRlTGVuZ3RoLG4ucHVzaChhPj4+OCYyNTUpLG4ucHVzaCgyNTUmYSksbj1uLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpKSk7Zm9yKHI9MDtyPGUucHBzLmxlbmd0aDtyKyspYT0oaT1lLnBwc1tyXSkuYnl0ZUxlbmd0aCxzLnB1c2goYT4+PjgmMjU1KSxzLnB1c2goMjU1JmEpLHM9cy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaSkpO3ZhciBvPXQuYm94KHQudHlwZXMuYXZjQyxuZXcgVWludDhBcnJheShbMSxuWzNdLG5bNF0sbls1XSwyNTUsMjI0fGUuc3BzLmxlbmd0aF0uY29uY2F0KG4pLmNvbmNhdChbZS5wcHMubGVuZ3RoXSkuY29uY2F0KHMpKSksbD1lLndpZHRoLHU9ZS5oZWlnaHQsZD1lLnBpeGVsUmF0aW9bMF0saD1lLnBpeGVsUmF0aW9bMV07cmV0dXJuIHQuYm94KHQudHlwZXMuYXZjMSxuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsbD4+OCYyNTUsMjU1JmwsdT4+OCYyNTUsMjU1JnUsMCw3MiwwLDAsMCw3MiwwLDAsMCwwLDAsMCwwLDEsMTgsMTAwLDk3LDEwNSwxMDgsMTIxLDEwOSwxMTEsMTE2LDEwNSwxMTEsMTEwLDQ3LDEwNCwxMDgsMTE1LDQ2LDEwNiwxMTUsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI0LDE3LDE3XSksbyx0LmJveCh0LnR5cGVzLmJ0cnQsbmV3IFVpbnQ4QXJyYXkoWzAsMjgsMTU2LDEyOCwwLDQ1LDE5OCwxOTIsMCw0NSwxOTgsMTkyXSkpLHQuYm94KHQudHlwZXMucGFzcCxuZXcgVWludDhBcnJheShbZD4+MjQsZD4+MTYmMjU1LGQ+PjgmMjU1LDI1NSZkLGg+PjI0LGg+PjE2JjI1NSxoPj44JjI1NSwyNTUmaF0pKSl9LHQuZXNkcz1mdW5jdGlvbih0KXt2YXIgZT10LmNvbmZpZy5sZW5ndGg7cmV0dXJuIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDMsMjMrZSwwLDEsMCw0LDE1K2UsNjQsMjEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDVdLmNvbmNhdChbZV0pLmNvbmNhdCh0LmNvbmZpZykuY29uY2F0KFs2LDEsMl0pKX0sdC5tcDRhPWZ1bmN0aW9uKGUpe3ZhciByPWUuc2FtcGxlcmF0ZTtyZXR1cm4gdC5ib3godC50eXBlcy5tcDRhLG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsZS5jaGFubmVsQ291bnQsMCwxNiwwLDAsMCwwLHI+PjgmMjU1LDI1NSZyLDAsMF0pLHQuYm94KHQudHlwZXMuZXNkcyx0LmVzZHMoZSkpKX0sdC5tcDM9ZnVuY3Rpb24oZSl7dmFyIHI9ZS5zYW1wbGVyYXRlO3JldHVybiB0LmJveCh0LnR5cGVzW1wiLm1wM1wiXSxuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLGUuY2hhbm5lbENvdW50LDAsMTYsMCwwLDAsMCxyPj44JjI1NSwyNTUmciwwLDBdKSl9LHQuc3RzZD1mdW5jdGlvbihlKXtyZXR1cm5cImF1ZGlvXCI9PT1lLnR5cGU/ZS5pc0FBQ3x8XCJtcDNcIiE9PWUuY29kZWM/dC5ib3godC50eXBlcy5zdHNkLHQuU1RTRCx0Lm1wNGEoZSkpOnQuYm94KHQudHlwZXMuc3RzZCx0LlNUU0QsdC5tcDMoZSkpOnQuYm94KHQudHlwZXMuc3RzZCx0LlNUU0QsdC5hdmMxKGUpKX0sdC50a2hkPWZ1bmN0aW9uKGUpe3ZhciByPWUuaWQsaT1lLmR1cmF0aW9uKmUudGltZXNjYWxlLGE9ZS53aWR0aCxuPWUuaGVpZ2h0LHM9TWF0aC5mbG9vcihpLyhKKzEpKSxvPU1hdGguZmxvb3IoaSUoSisxKSk7cmV0dXJuIHQuYm94KHQudHlwZXMudGtoZCxuZXcgVWludDhBcnJheShbMSwwLDAsNywwLDAsMCwwLDAsMCwwLDIsMCwwLDAsMCwwLDAsMCwzLHI+PjI0JjI1NSxyPj4xNiYyNTUscj4+OCYyNTUsMjU1JnIsMCwwLDAsMCxzPj4yNCxzPj4xNiYyNTUscz4+OCYyNTUsMjU1JnMsbz4+MjQsbz4+MTYmMjU1LG8+PjgmMjU1LDI1NSZvLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDY0LDAsMCwwLGE+PjgmMjU1LDI1NSZhLDAsMCxuPj44JjI1NSwyNTUmbiwwLDBdKSl9LHQudHJhZj1mdW5jdGlvbihlLHIpe3ZhciBpPXQuc2R0cChlKSxhPWUuaWQsbj1NYXRoLmZsb29yKHIvKEorMSkpLHM9TWF0aC5mbG9vcihyJShKKzEpKTtyZXR1cm4gdC5ib3godC50eXBlcy50cmFmLHQuYm94KHQudHlwZXMudGZoZCxuZXcgVWludDhBcnJheShbMCwwLDAsMCxhPj4yNCxhPj4xNiYyNTUsYT4+OCYyNTUsMjU1JmFdKSksdC5ib3godC50eXBlcy50ZmR0LG5ldyBVaW50OEFycmF5KFsxLDAsMCwwLG4+PjI0LG4+PjE2JjI1NSxuPj44JjI1NSwyNTUmbixzPj4yNCxzPj4xNiYyNTUscz4+OCYyNTUsMjU1JnNdKSksdC50cnVuKGUsaS5sZW5ndGgrMTYrMjArOCsxNis4KzgpLGkpfSx0LnRyYWs9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZHVyYXRpb249ZS5kdXJhdGlvbnx8NDI5NDk2NzI5NSx0LmJveCh0LnR5cGVzLnRyYWssdC50a2hkKGUpLHQubWRpYShlKSl9LHQudHJleD1mdW5jdGlvbihlKXt2YXIgcj1lLmlkO3JldHVybiB0LmJveCh0LnR5cGVzLnRyZXgsbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAscj4+MjQscj4+MTYmMjU1LHI+PjgmMjU1LDI1NSZyLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMSwwLDFdKSl9LHQudHJ1bj1mdW5jdGlvbihlLHIpe3ZhciBpLGEsbixzLG8sbCx1PWUuc2FtcGxlc3x8W10sZD11Lmxlbmd0aCxoPTEyKzE2KmQsZj1uZXcgVWludDhBcnJheShoKTtmb3Iocis9OCtoLGYuc2V0KFswLDAsMTUsMSxkPj4+MjQmMjU1LGQ+Pj4xNiYyNTUsZD4+PjgmMjU1LDI1NSZkLHI+Pj4yNCYyNTUscj4+PjE2JjI1NSxyPj4+OCYyNTUsMjU1JnJdLDApLGk9MDtpPGQ7aSsrKW49KGE9dVtpXSkuZHVyYXRpb24scz1hLnNpemUsbz1hLmZsYWdzLGw9YS5jdHMsZi5zZXQoW24+Pj4yNCYyNTUsbj4+PjE2JjI1NSxuPj4+OCYyNTUsMjU1Jm4scz4+PjI0JjI1NSxzPj4+MTYmMjU1LHM+Pj44JjI1NSwyNTUmcyxvLmlzTGVhZGluZzw8MnxvLmRlcGVuZHNPbixvLmlzRGVwZW5kZWRPbjw8NnxvLmhhc1JlZHVuZGFuY3k8PDR8by5wYWRkaW5nVmFsdWU8PDF8by5pc05vblN5bmMsNjE0NDAmby5kZWdyYWRQcmlvLDE1Jm8uZGVncmFkUHJpbyxsPj4+MjQmMjU1LGw+Pj4xNiYyNTUsbD4+PjgmMjU1LDI1NSZsXSwxMisxNippKTtyZXR1cm4gdC5ib3godC50eXBlcy50cnVuLGYpfSx0LmluaXRTZWdtZW50PWZ1bmN0aW9uKGUpe3QudHlwZXN8fHQuaW5pdCgpO3ZhciByPXQubW9vdihlKSxpPW5ldyBVaW50OEFycmF5KHQuRlRZUC5ieXRlTGVuZ3RoK3IuYnl0ZUxlbmd0aCk7cmV0dXJuIGkuc2V0KHQuRlRZUCksaS5zZXQocix0LkZUWVAuYnl0ZUxlbmd0aCksaX0sdH0oKTt0dC50eXBlcz12b2lkIDAsdHQuSERMUl9UWVBFUz12b2lkIDAsdHQuU1RUUz12b2lkIDAsdHQuU1RTQz12b2lkIDAsdHQuU1RDTz12b2lkIDAsdHQuU1RTWj12b2lkIDAsdHQuVk1IRD12b2lkIDAsdHQuU01IRD12b2lkIDAsdHQuU1RTRD12b2lkIDAsdHQuRlRZUD12b2lkIDAsdHQuRElORj12b2lkIDA7dmFyIGV0PXR0LHJ0PXIoNCk7ZnVuY3Rpb24gaXQodCxlLHIsaSl7dm9pZCAwPT09ciYmKHI9MSksdm9pZCAwPT09aSYmKGk9ITEpO3ZhciBhPXQqZSpyO3JldHVybiBpP01hdGgucm91bmQoYSk6YX1mdW5jdGlvbiBhdCh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksaXQodCwxZTMsMS85ZTQsZSl9ZnVuY3Rpb24gbnQoKXtyZXR1cm4obnQ9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIHI9YXJndW1lbnRzW2VdO2Zvcih2YXIgaSBpbiByKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLGkpJiYodFtpXT1yW2ldKX1yZXR1cm4gdH0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgc3Q9bnVsbCxvdD1udWxsLGx0PSExLHV0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscixpKXtpZih2b2lkIDA9PT1pJiYoaT1cIlwiKSx0aGlzLm9ic2VydmVyPXZvaWQgMCx0aGlzLmNvbmZpZz12b2lkIDAsdGhpcy50eXBlU3VwcG9ydGVkPXZvaWQgMCx0aGlzLklTR2VuZXJhdGVkPSExLHRoaXMuX2luaXRQVFM9dm9pZCAwLHRoaXMuX2luaXREVFM9dm9pZCAwLHRoaXMubmV4dEF2Y0R0cz1udWxsLHRoaXMubmV4dEF1ZGlvUHRzPW51bGwsdGhpcy5pc0F1ZGlvQ29udGlndW91cz0hMSx0aGlzLmlzVmlkZW9Db250aWd1b3VzPSExLHRoaXMub2JzZXJ2ZXI9dCx0aGlzLmNvbmZpZz1lLHRoaXMudHlwZVN1cHBvcnRlZD1yLHRoaXMuSVNHZW5lcmF0ZWQ9ITEsbnVsbD09PXN0KXt2YXIgYT0obmF2aWdhdG9yLnVzZXJBZ2VudHx8XCJcIikubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS9pKTtzdD1hP3BhcnNlSW50KGFbMV0pOjB9aWYobnVsbD09PW90KXt2YXIgbj1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKykvaSk7b3Q9bj9wYXJzZUludChuWzFdKTowfWx0PSEhc3QmJnN0PDc1fHwhIW90JiZvdDw2MDB9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuZGVzdHJveT1mdW5jdGlvbigpe30sZS5yZXNldFRpbWVTdGFtcD1mdW5jdGlvbih0KXtjLmIubG9nKFwiW21wNC1yZW11eGVyXTogaW5pdFBUUyAmIGluaXREVFMgcmVzZXRcIiksdGhpcy5faW5pdFBUUz10aGlzLl9pbml0RFRTPXR9LGUucmVzZXROZXh0VGltZXN0YW1wPWZ1bmN0aW9uKCl7Yy5iLmxvZyhcIlttcDQtcmVtdXhlcl06IHJlc2V0IG5leHQgdGltZXN0YW1wXCIpLHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXM9ITEsdGhpcy5pc0F1ZGlvQ29udGlndW91cz0hMX0sZS5yZXNldEluaXRTZWdtZW50PWZ1bmN0aW9uKCl7Yy5iLmxvZyhcIlttcDQtcmVtdXhlcl06IElTR2VuZXJhdGVkIGZsYWcgcmVzZXRcIiksdGhpcy5JU0dlbmVyYXRlZD0hMX0sZS5nZXRWaWRlb1N0YXJ0UHRzPWZ1bmN0aW9uKHQpe3ZhciBlPSExLHI9dC5yZWR1Y2UoKGZ1bmN0aW9uKHQscil7dmFyIGk9ci5wdHMtdDtyZXR1cm4gaTwtNDI5NDk2NzI5Nj8oZT0hMCxkdCh0LHIucHRzKSk6aT4wP3Q6ci5wdHN9KSx0WzBdLnB0cyk7cmV0dXJuIGUmJmMuYi5kZWJ1ZyhcIlBUUyByb2xsb3ZlciBkZXRlY3RlZFwiKSxyfSxlLnJlbXV4PWZ1bmN0aW9uKHQsZSxyLGksYSxuLHMsbyl7dmFyIGwsdSxkLGgsZix2LGc9YSxwPWEsbT10LnBpZD4tMSx5PWUucGlkPi0xLGI9ZS5zYW1wbGVzLmxlbmd0aCxUPXQuc2FtcGxlcy5sZW5ndGg+MCxFPWI+MTtpZigoIW18fFQpJiYoIXl8fEUpfHx0aGlzLklTR2VuZXJhdGVkfHxzKXt0aGlzLklTR2VuZXJhdGVkfHwoZD10aGlzLmdlbmVyYXRlSVModCxlLGEpKTt2YXIgUz10aGlzLmlzVmlkZW9Db250aWd1b3VzLEw9LTE7aWYoRSYmKEw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYodFtlXS5rZXkpcmV0dXJuIGU7cmV0dXJuLTF9KGUuc2FtcGxlcyksIVMmJnRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkpKWlmKHY9ITAsTD4wKXtjLmIud2FybihcIlttcDQtcmVtdXhlcl06IERyb3BwZWQgXCIrTCtcIiBvdXQgb2YgXCIrYitcIiB2aWRlbyBzYW1wbGVzIGR1ZSB0byBhIG1pc3Npbmcga2V5ZnJhbWVcIik7dmFyIEE9dGhpcy5nZXRWaWRlb1N0YXJ0UHRzKGUuc2FtcGxlcyk7ZS5zYW1wbGVzPWUuc2FtcGxlcy5zbGljZShMKSxlLmRyb3BwZWQrPUwscCs9KGUuc2FtcGxlc1swXS5wdHMtQSkvKGUudGltZXNjYWxlfHw5ZTQpfWVsc2UtMT09PUwmJihjLmIud2FybihcIlttcDQtcmVtdXhlcl06IE5vIGtleWZyYW1lIGZvdW5kIG91dCBvZiBcIitiK1wiIHZpZGVvIHNhbXBsZXNcIiksdj0hMSk7aWYodGhpcy5JU0dlbmVyYXRlZCl7aWYoVCYmRSl7dmFyIFI9dGhpcy5nZXRWaWRlb1N0YXJ0UHRzKGUuc2FtcGxlcyksRD0oZHQodC5zYW1wbGVzWzBdLnB0cyxSKS1SKS9lLmlucHV0VGltZVNjYWxlO2crPU1hdGgubWF4KDAsRCkscCs9TWF0aC5tYXgoMCwtRCl9aWYoVCl7aWYodC5zYW1wbGVyYXRlfHwoYy5iLndhcm4oXCJbbXA0LXJlbXV4ZXJdOiByZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkXCIpLGQ9dGhpcy5nZW5lcmF0ZUlTKHQsZSxhKSksdT10aGlzLnJlbXV4QXVkaW8odCxnLHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMsbix5fHxFfHxvPT09cnQuYi5BVURJTz9wOnZvaWQgMCksRSl7dmFyIF89dT91LmVuZFBUUy11LnN0YXJ0UFRTOjA7ZS5pbnB1dFRpbWVTY2FsZXx8KGMuYi53YXJuKFwiW21wNC1yZW11eGVyXTogcmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZFwiKSxkPXRoaXMuZ2VuZXJhdGVJUyh0LGUsYSkpLGw9dGhpcy5yZW11eFZpZGVvKGUscCxTLF8pfX1lbHNlIEUmJihsPXRoaXMucmVtdXhWaWRlbyhlLHAsUywwKSk7bCYmKGwuZmlyc3RLZXlGcmFtZT1MLGwuaW5kZXBlbmRlbnQ9LTEhPT1MKX19cmV0dXJuIHRoaXMuSVNHZW5lcmF0ZWQmJihyLnNhbXBsZXMubGVuZ3RoJiYoZj10aGlzLnJlbXV4SUQzKHIsYSkpLGkuc2FtcGxlcy5sZW5ndGgmJihoPXRoaXMucmVtdXhUZXh0KGksYSkpKSx7YXVkaW86dSx2aWRlbzpsLGluaXRTZWdtZW50OmQsaW5kZXBlbmRlbnQ6dix0ZXh0OmgsaWQzOmZ9fSxlLmdlbmVyYXRlSVM9ZnVuY3Rpb24odCxlLHIpe3ZhciBpLGEsbixvPXQuc2FtcGxlcyxsPWUuc2FtcGxlcyx1PXRoaXMudHlwZVN1cHBvcnRlZCxkPXt9LGg9IU9iamVjdChzLmEpKHRoaXMuX2luaXRQVFMpLGY9XCJhdWRpby9tcDRcIjtpZihoJiYoaT1hPTEvMCksdC5jb25maWcmJm8ubGVuZ3RoJiYodC50aW1lc2NhbGU9dC5zYW1wbGVyYXRlLHQuaXNBQUN8fCh1Lm1wZWc/KGY9XCJhdWRpby9tcGVnXCIsdC5jb2RlYz1cIlwiKTp1Lm1wMyYmKHQuY29kZWM9XCJtcDNcIikpLGQuYXVkaW89e2lkOlwiYXVkaW9cIixjb250YWluZXI6Zixjb2RlYzp0LmNvZGVjLGluaXRTZWdtZW50OiF0LmlzQUFDJiZ1Lm1wZWc/bmV3IFVpbnQ4QXJyYXkoMCk6ZXQuaW5pdFNlZ21lbnQoW3RdKSxtZXRhZGF0YTp7Y2hhbm5lbENvdW50OnQuY2hhbm5lbENvdW50fX0saCYmKG49dC5pbnB1dFRpbWVTY2FsZSxpPWE9b1swXS5wdHMtTWF0aC5yb3VuZChuKnIpKSksZS5zcHMmJmUucHBzJiZsLmxlbmd0aCYmKGUudGltZXNjYWxlPWUuaW5wdXRUaW1lU2NhbGUsZC52aWRlbz17aWQ6XCJtYWluXCIsY29udGFpbmVyOlwidmlkZW8vbXA0XCIsY29kZWM6ZS5jb2RlYyxpbml0U2VnbWVudDpldC5pbml0U2VnbWVudChbZV0pLG1ldGFkYXRhOnt3aWR0aDplLndpZHRoLGhlaWdodDplLmhlaWdodH19LGgpKXtuPWUuaW5wdXRUaW1lU2NhbGU7dmFyIGM9dGhpcy5nZXRWaWRlb1N0YXJ0UHRzKGwpLHY9TWF0aC5yb3VuZChuKnIpO2E9TWF0aC5taW4oYSxkdChsWzBdLmR0cyxjKS12KSxpPU1hdGgubWluKGksYy12KX1pZihPYmplY3Qua2V5cyhkKS5sZW5ndGgpcmV0dXJuIHRoaXMuSVNHZW5lcmF0ZWQ9ITAsaCYmKHRoaXMuX2luaXRQVFM9aSx0aGlzLl9pbml0RFRTPWEpLHt0cmFja3M6ZCxpbml0UFRTOmksdGltZXNjYWxlOm59fSxlLnJlbXV4VmlkZW89ZnVuY3Rpb24odCxlLHIsbil7dmFyIHMsbyxsLHU9dC5pbnB1dFRpbWVTY2FsZSxkPXQuc2FtcGxlcyxoPVtdLGY9ZC5sZW5ndGgsdj10aGlzLl9pbml0UFRTLGc9dGhpcy5uZXh0QXZjRHRzLHA9OCxtPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSx5PU51bWJlci5ORUdBVElWRV9JTkZJTklUWSxiPTAsVD0hMTtyJiZudWxsIT09Z3x8KGc9ZSp1LShkWzBdLnB0cy1kdChkWzBdLmR0cyxkWzBdLnB0cykpKTtmb3IodmFyIEU9MDtFPGY7RSsrKXt2YXIgUz1kW0VdO2lmKFMucHRzPWR0KFMucHRzLXYsZyksUy5kdHM9ZHQoUy5kdHMtdixnKSxTLmR0cz5TLnB0cyl7Yj1NYXRoLm1heChNYXRoLm1pbihiLFMucHRzLVMuZHRzKSwtMThlMyl9Uy5kdHM8ZFtFPjA/RS0xOkVdLmR0cyYmKFQ9ITApfVQmJmQuc29ydCgoZnVuY3Rpb24odCxlKXt2YXIgcj10LmR0cy1lLmR0cyxpPXQucHRzLWUucHRzO3JldHVybiByfHxpfSkpLG89ZFswXS5kdHMsbD1kW2QubGVuZ3RoLTFdLmR0czt2YXIgTD1NYXRoLnJvdW5kKChsLW8pLyhmLTEpKTtpZihiPDApe2lmKGI8LTIqTCl7Yy5iLndhcm4oXCJQVFMgPCBEVFMgZGV0ZWN0ZWQgaW4gdmlkZW8gc2FtcGxlcywgb2Zmc2V0dGluZyBEVFMgZnJvbSBQVFMgYnkgXCIrYXQoLUwsITApK1wiIG1zXCIpO2Zvcih2YXIgQT1iLFI9MDtSPGY7UisrKWRbUl0uZHRzPUE9TWF0aC5tYXgoQSxkW1JdLnB0cy1MKSxkW1JdLnB0cz1NYXRoLm1heChBLGRbUl0ucHRzKX1lbHNle2MuYi53YXJuKFwiUFRTIDwgRFRTIGRldGVjdGVkIGluIHZpZGVvIHNhbXBsZXMsIHNoaWZ0aW5nIERUUyBieSBcIithdChiLCEwKStcIiBtcyB0byBvdmVyY29tZSB0aGlzIGlzc3VlXCIpO2Zvcih2YXIgRD0wO0Q8ZjtEKyspZFtEXS5kdHM9ZFtEXS5kdHMrYn1vPWRbMF0uZHRzfWlmKHIpe3ZhciBfPW8tZyxrPV8+TDtpZihrfHxfPC0xKXtrP2MuYi53YXJuKFwiQVZDOiBcIithdChfLCEwKStcIiBtcyAoXCIrXytcImR0cykgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCwgZmlsbGluZyBpdFwiKTpjLmIud2FybihcIkFWQzogXCIrYXQoLV8sITApK1wiIG1zIChcIitfK1wiZHRzKSBvdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZFwiKSxvPWc7dmFyIHg9ZFswXS5wdHMtXztkWzBdLmR0cz1vLGRbMF0ucHRzPXgsYy5iLmxvZyhcIlZpZGVvOiBGaXJzdCBQVFMvRFRTIGFkanVzdGVkOiBcIithdCh4LCEwKStcIi9cIithdChvLCEwKStcIiwgZGVsdGE6IFwiK2F0KF8sITApK1wiIG1zXCIpfX1sdCYmKG89TWF0aC5tYXgoMCxvKSk7Zm9yKHZhciBDPTAsdz0wLE89MDtPPGY7TysrKXtmb3IodmFyIEk9ZFtPXSxQPUkudW5pdHMsRj1QLmxlbmd0aCxNPTAsTj0wO048RjtOKyspTSs9UFtOXS5kYXRhLmxlbmd0aDt3Kz1NLEMrPUYsSS5sZW5ndGg9TSxJLmR0cz1NYXRoLm1heChJLmR0cyxvKSxJLnB0cz1NYXRoLm1heChJLnB0cyxJLmR0cywwKSxtPU1hdGgubWluKEkucHRzLG0pLHk9TWF0aC5tYXgoSS5wdHMseSl9bD1kW2YtMV0uZHRzO3ZhciBCLFU9dys0KkMrODt0cnl7Qj1uZXcgVWludDhBcnJheShVKX1jYXRjaCh0KXtyZXR1cm4gdm9pZCB0aGlzLm9ic2VydmVyLmVtaXQoaS5hLkVSUk9SLGkuYS5FUlJPUix7dHlwZTphLmIuTVVYX0VSUk9SLGRldGFpbHM6YS5hLlJFTVVYX0FMTE9DX0VSUk9SLGZhdGFsOiExLGJ5dGVzOlUscmVhc29uOlwiZmFpbCBhbGxvY2F0aW5nIHZpZGVvIG1kYXQgXCIrVX0pfXZhciBHPW5ldyBEYXRhVmlldyhCLmJ1ZmZlcik7Ry5zZXRVaW50MzIoMCxVKSxCLnNldChldC50eXBlcy5tZGF0LDQpO2Zvcih2YXIgaj0wO2o8ZjtqKyspe2Zvcih2YXIgSD1kW2pdLEs9SC51bml0cyxWPTAsVz0wLFk9Sy5sZW5ndGg7VzxZO1crKyl7dmFyIFg9S1tXXSxxPVguZGF0YSx6PVguZGF0YS5ieXRlTGVuZ3RoO0cuc2V0VWludDMyKHAseikscCs9NCxCLnNldChxLHApLHArPXosVis9NCt6fWlmKGo8Zi0xKXM9ZFtqKzFdLmR0cy1ILmR0cztlbHNle3ZhciBRPXRoaXMuY29uZmlnLCQ9SC5kdHMtZFtqPjA/ai0xOmpdLmR0cztpZihRLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2smJm51bGwhPT10aGlzLm5leHRBdWRpb1B0cyl7dmFyIFo9TWF0aC5mbG9vcihRLm1heEJ1ZmZlckhvbGUqdSksSj0obj9tK24qdTp0aGlzLm5leHRBdWRpb1B0cyktSC5wdHM7Sj5aPygocz1KLSQpPDAmJihzPSQpLGMuYi5sb2coXCJbbXA0LXJlbXV4ZXJdOiBJdCBpcyBhcHByb3hpbWF0ZWx5IFwiK0ovOTArXCIgbXMgdG8gdGhlIG5leHQgc2VnbWVudDsgdXNpbmcgZHVyYXRpb24gXCIrcy85MCtcIiBtcyBmb3IgdGhlIGxhc3QgdmlkZW8gZnJhbWUuXCIpKTpzPSR9ZWxzZSBzPSR9dmFyIHR0PU1hdGgucm91bmQoSC5wdHMtSC5kdHMpO2gucHVzaChuZXcgaHQoSC5rZXkscyxWLHR0KSl9aWYoaC5sZW5ndGgmJnN0JiZzdDw3MCl7dmFyIHJ0PWhbMF0uZmxhZ3M7cnQuZGVwZW5kc09uPTIscnQuaXNOb25TeW5jPTB9dGhpcy5uZXh0QXZjRHRzPWc9bCtzLHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXM9ITA7dmFyIGl0PXtkYXRhMTpldC5tb29mKHQuc2VxdWVuY2VOdW1iZXIrKyxvLG50KHt9LHQse3NhbXBsZXM6aH0pKSxkYXRhMjpCLHN0YXJ0UFRTOm0vdSxlbmRQVFM6KHkrcykvdSxzdGFydERUUzpvL3UsZW5kRFRTOmcvdSx0eXBlOlwidmlkZW9cIixoYXNBdWRpbzohMSxoYXNWaWRlbzohMCxuYjpoLmxlbmd0aCxkcm9wcGVkOnQuZHJvcHBlZH07cmV0dXJuIHQuc2FtcGxlcz1bXSx0LmRyb3BwZWQ9MCxpdH0sZS5yZW11eEF1ZGlvPWZ1bmN0aW9uKHQsZSxyLG4scyl7dmFyIG89dC5pbnB1dFRpbWVTY2FsZSxsPW8vKHQuc2FtcGxlcmF0ZT90LnNhbXBsZXJhdGU6byksdT10LmlzQUFDPzEwMjQ6MTE1MixkPXUqbCxoPXRoaXMuX2luaXRQVFMsZj0hdC5pc0FBQyYmdGhpcy50eXBlU3VwcG9ydGVkLm1wZWcsdj1bXSxnPXQuc2FtcGxlcyxwPWY/MDo4LG09dGhpcy5uZXh0QXVkaW9QdHN8fC0xLHk9ZSpvO2lmKHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXM9cj1yfHxnLmxlbmd0aCYmbT4wJiYobiYmTWF0aC5hYnMoeS1tKTw5ZTN8fE1hdGguYWJzKGR0KGdbMF0ucHRzLWgseSktbSk8MjAqZCksZy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnB0cz1kdCh0LnB0cy1oLHkpfSkpLCFyfHxtPDApe2lmKCEoZz1nLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQucHRzPj0wfSkpKS5sZW5ndGgpcmV0dXJuO209MD09PXM/MDpuP01hdGgubWF4KDAseSk6Z1swXS5wdHN9aWYodC5pc0FBQylmb3IodmFyIGI9dm9pZCAwIT09cyxUPXRoaXMuY29uZmlnLm1heEF1ZGlvRnJhbWVzRHJpZnQsRT0wLFM9bTtFPGcubGVuZ3RoO0UrKyl7dmFyIEw9Z1tFXSxBPUwucHRzLFI9QS1TLEQ9TWF0aC5hYnMoMWUzKlIvbyk7aWYoUjw9LVQqZCYmYikwPT09RSYmKGMuYi53YXJuKFwiQXVkaW8gZnJhbWUgQCBcIisoQS9vKS50b0ZpeGVkKDMpK1wicyBvdmVybGFwcyBuZXh0QXVkaW9QdHMgYnkgXCIrTWF0aC5yb3VuZCgxZTMqUi9vKStcIiBtcy5cIiksdGhpcy5uZXh0QXVkaW9QdHM9bT1TPUEpO2Vsc2UgaWYoUj49VCpkJiZEPDFlNCYmYil7dmFyIF89TWF0aC5yb3VuZChSL2QpOyhTPUEtXypkKTwwJiYoXy0tLFMrPWQpLDA9PT1FJiYodGhpcy5uZXh0QXVkaW9QdHM9bT1TKSxjLmIud2FybihcIlttcDQtcmVtdXhlcl06IEluamVjdGluZyBcIitfK1wiIGF1ZGlvIGZyYW1lIEAgXCIrKFMvbykudG9GaXhlZCgzKStcInMgZHVlIHRvIFwiK01hdGgucm91bmQoMWUzKlIvbykrXCIgbXMgZ2FwLlwiKTtmb3IodmFyIGs9MDtrPF87aysrKXt2YXIgeD1NYXRoLm1heChTLDApLEM9Wi5nZXRTaWxlbnRGcmFtZSh0Lm1hbmlmZXN0Q29kZWN8fHQuY29kZWMsdC5jaGFubmVsQ291bnQpO0N8fChjLmIubG9nKFwiW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuXCIpLEM9TC51bml0LnN1YmFycmF5KCkpLGcuc3BsaWNlKEUsMCx7dW5pdDpDLHB0czp4fSksUys9ZCxFKyt9fUwucHRzPVMsUys9ZH1mb3IodmFyIHcsTz1udWxsLEk9bnVsbCxQPTAsRj1nLmxlbmd0aDtGLS07KVArPWdbRl0udW5pdC5ieXRlTGVuZ3RoO2Zvcih2YXIgTT0wLE49Zy5sZW5ndGg7TTxOO00rKyl7dmFyIEI9Z1tNXSxVPUIudW5pdCxHPUIucHRzO2lmKG51bGwhPT1JKXt2W00tMV0uZHVyYXRpb249TWF0aC5yb3VuZCgoRy1JKS9sKX1lbHNle2lmKHImJnQuaXNBQUMmJihHPW0pLE89RywhKFA+MCkpcmV0dXJuO1ArPXA7dHJ5e3c9bmV3IFVpbnQ4QXJyYXkoUCl9Y2F0Y2godCl7cmV0dXJuIHZvaWQgdGhpcy5vYnNlcnZlci5lbWl0KGkuYS5FUlJPUixpLmEuRVJST1Ise3R5cGU6YS5iLk1VWF9FUlJPUixkZXRhaWxzOmEuYS5SRU1VWF9BTExPQ19FUlJPUixmYXRhbDohMSxieXRlczpQLHJlYXNvbjpcImZhaWwgYWxsb2NhdGluZyBhdWRpbyBtZGF0IFwiK1B9KX1mfHwobmV3IERhdGFWaWV3KHcuYnVmZmVyKS5zZXRVaW50MzIoMCxQKSx3LnNldChldC50eXBlcy5tZGF0LDQpKX13LnNldChVLHApO3ZhciBqPVUuYnl0ZUxlbmd0aDtwKz1qLHYucHVzaChuZXcgaHQoITAsdSxqLDApKSxJPUd9dmFyIEg9di5sZW5ndGg7aWYoSCl7dmFyIEs9dlt2Lmxlbmd0aC0xXTt0aGlzLm5leHRBdWRpb1B0cz1tPUkrbCpLLmR1cmF0aW9uO3ZhciBWPWY/bmV3IFVpbnQ4QXJyYXkoMCk6ZXQubW9vZih0LnNlcXVlbmNlTnVtYmVyKyssTy9sLG50KHt9LHQse3NhbXBsZXM6dn0pKTt0LnNhbXBsZXM9W107dmFyIFc9Ty9vLFk9bS9vLFg9e2RhdGExOlYsZGF0YTI6dyxzdGFydFBUUzpXLGVuZFBUUzpZLHN0YXJ0RFRTOlcsZW5kRFRTOlksdHlwZTpcImF1ZGlvXCIsaGFzQXVkaW86ITAsaGFzVmlkZW86ITEsbmI6SH07cmV0dXJuIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXM9ITAsWH19LGUucmVtdXhFbXB0eUF1ZGlvPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPXQuaW5wdXRUaW1lU2NhbGUsbj1hLyh0LnNhbXBsZXJhdGU/dC5zYW1wbGVyYXRlOmEpLHM9dGhpcy5uZXh0QXVkaW9QdHMsbz0obnVsbCE9PXM/czppLnN0YXJ0RFRTKmEpK3RoaXMuX2luaXREVFMsbD1pLmVuZERUUyphK3RoaXMuX2luaXREVFMsdT0xMDI0Km4sZD1NYXRoLmNlaWwoKGwtbykvdSksaD1aLmdldFNpbGVudEZyYW1lKHQubWFuaWZlc3RDb2RlY3x8dC5jb2RlYyx0LmNoYW5uZWxDb3VudCk7aWYoYy5iLndhcm4oXCJbbXA0LXJlbXV4ZXJdOiByZW11eCBlbXB0eSBBdWRpb1wiKSxoKXtmb3IodmFyIGY9W10sdj0wO3Y8ZDt2Kyspe3ZhciBnPW8rdip1O2YucHVzaCh7dW5pdDpoLHB0czpnLGR0czpnfSl9cmV0dXJuIHQuc2FtcGxlcz1mLHRoaXMucmVtdXhBdWRpbyh0LGUsciwhMSl9Yy5iLnRyYWNlKFwiW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIHJlbXV4RW1wdHlBdWRpbyBzaW5jZSB3ZSB3ZXJlIHVuYWJsZSB0byBnZXQgYSBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjXCIpfSxlLnJlbXV4SUQzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5zYW1wbGVzLmxlbmd0aDtpZihyKXtmb3IodmFyIGk9dC5pbnB1dFRpbWVTY2FsZSxhPXRoaXMuX2luaXRQVFMsbj10aGlzLl9pbml0RFRTLHM9MDtzPHI7cysrKXt2YXIgbz10LnNhbXBsZXNbc107by5wdHM9ZHQoby5wdHMtYSxlKmkpL2ksby5kdHM9ZHQoby5kdHMtbixlKmkpL2l9dmFyIGw9dC5zYW1wbGVzO3JldHVybiB0LnNhbXBsZXM9W10se3NhbXBsZXM6bH19fSxlLnJlbXV4VGV4dD1mdW5jdGlvbih0LGUpe3ZhciByPXQuc2FtcGxlcy5sZW5ndGg7aWYocil7Zm9yKHZhciBpPXQuaW5wdXRUaW1lU2NhbGUsYT10aGlzLl9pbml0UFRTLG49MDtuPHI7bisrKXt2YXIgcz10LnNhbXBsZXNbbl07cy5wdHM9ZHQocy5wdHMtYSxlKmkpL2l9dC5zYW1wbGVzLnNvcnQoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQucHRzLWUucHRzfSkpO3ZhciBvPXQuc2FtcGxlcztyZXR1cm4gdC5zYW1wbGVzPVtdLHtzYW1wbGVzOm99fX0sdH0oKTtmdW5jdGlvbiBkdCh0LGUpe3ZhciByO2lmKG51bGw9PT1lKXJldHVybiB0O2ZvcihyPWU8dD8tODU4OTkzNDU5Mjo4NTg5OTM0NTkyO01hdGguYWJzKHQtZSk+NDI5NDk2NzI5NjspdCs9cjtyZXR1cm4gdH12YXIgaHQ9ZnVuY3Rpb24odCxlLHIsaSl7dGhpcy5zaXplPXZvaWQgMCx0aGlzLmR1cmF0aW9uPXZvaWQgMCx0aGlzLmN0cz12b2lkIDAsdGhpcy5mbGFncz12b2lkIDAsdGhpcy5kdXJhdGlvbj1lLHRoaXMuc2l6ZT1yLHRoaXMuY3RzPWksdGhpcy5mbGFncz1uZXcgZnQodCl9LGZ0PWZ1bmN0aW9uKHQpe3RoaXMuaXNMZWFkaW5nPTAsdGhpcy5pc0RlcGVuZGVkT249MCx0aGlzLmhhc1JlZHVuZGFuY3k9MCx0aGlzLmRlZ3JhZFByaW89MCx0aGlzLmRlcGVuZHNPbj0xLHRoaXMuaXNOb25TeW5jPTEsdGhpcy5kZXBlbmRzT249dD8yOjEsdGhpcy5pc05vblN5bmM9dD8wOjF9LGN0PXIoNSksdnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5lbWl0SW5pdFNlZ21lbnQ9ITEsdGhpcy5hdWRpb0NvZGVjPXZvaWQgMCx0aGlzLnZpZGVvQ29kZWM9dm9pZCAwLHRoaXMuaW5pdERhdGE9dm9pZCAwLHRoaXMuaW5pdFBUUz12b2lkIDAsdGhpcy5pbml0VHJhY2tzPXZvaWQgMCx0aGlzLmxhc3RFbmREVFM9bnVsbH12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5kZXN0cm95PWZ1bmN0aW9uKCl7fSxlLnJlc2V0VGltZVN0YW1wPWZ1bmN0aW9uKHQpe3RoaXMuaW5pdFBUUz10LHRoaXMubGFzdEVuZERUUz1udWxsfSxlLnJlc2V0TmV4dFRpbWVzdGFtcD1mdW5jdGlvbigpe3RoaXMubGFzdEVuZERUUz1udWxsfSxlLnJlc2V0SW5pdFNlZ21lbnQ9ZnVuY3Rpb24odCxlLHIpe3RoaXMuYXVkaW9Db2RlYz1lLHRoaXMudmlkZW9Db2RlYz1yLHRoaXMuZ2VuZXJhdGVJbml0U2VnbWVudCh0KSx0aGlzLmVtaXRJbml0U2VnbWVudD0hMH0sZS5nZW5lcmF0ZUluaXRTZWdtZW50PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuYXVkaW9Db2RlYyxyPXRoaXMudmlkZW9Db2RlYztpZighdHx8IXQuYnl0ZUxlbmd0aClyZXR1cm4gdGhpcy5pbml0VHJhY2tzPXZvaWQgMCx2b2lkKHRoaXMuaW5pdERhdGE9dm9pZCAwKTt2YXIgaT10aGlzLmluaXREYXRhPU9iamVjdChsLmYpKHQpO2V8fChlPXB0KGkuYXVkaW8sY3QuYS5BVURJTykpLHJ8fChyPXB0KGkudmlkZW8sY3QuYS5WSURFTykpO3ZhciBhPXt9O2kuYXVkaW8mJmkudmlkZW8/YS5hdWRpb3ZpZGVvPXtjb250YWluZXI6XCJ2aWRlby9tcDRcIixjb2RlYzplK1wiLFwiK3IsaW5pdFNlZ21lbnQ6dCxpZDpcIm1haW5cIn06aS5hdWRpbz9hLmF1ZGlvPXtjb250YWluZXI6XCJhdWRpby9tcDRcIixjb2RlYzplLGluaXRTZWdtZW50OnQsaWQ6XCJhdWRpb1wifTppLnZpZGVvP2EudmlkZW89e2NvbnRhaW5lcjpcInZpZGVvL21wNFwiLGNvZGVjOnIsaW5pdFNlZ21lbnQ6dCxpZDpcIm1haW5cIn06Yy5iLndhcm4oXCJbcGFzc3Rocm91Z2gtcmVtdXhlci50c106IGluaXRTZWdtZW50IGRvZXMgbm90IGNvbnRhaW4gbW9vdiBvciB0cmFrIGJveGVzLlwiKSx0aGlzLmluaXRUcmFja3M9YX0sZS5yZW11eD1mdW5jdGlvbih0LGUscixpLGEpe3ZhciBuPXRoaXMuaW5pdFBUUyxvPXRoaXMubGFzdEVuZERUUyx1PXthdWRpbzp2b2lkIDAsdmlkZW86dm9pZCAwLHRleHQ6aSxpZDM6cixpbml0U2VnbWVudDp2b2lkIDB9O09iamVjdChzLmEpKG8pfHwobz10aGlzLmxhc3RFbmREVFM9YXx8MCk7dmFyIGQ9ZS5zYW1wbGVzO2lmKCFkfHwhZC5sZW5ndGgpcmV0dXJuIHU7dmFyIGg9e2luaXRQVFM6dm9pZCAwLHRpbWVzY2FsZToxfSxmPXRoaXMuaW5pdERhdGE7aWYoZiYmZi5sZW5ndGh8fCh0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQoZCksZj10aGlzLmluaXREYXRhKSwhZnx8IWYubGVuZ3RoKXJldHVybiBjLmIud2FybihcIltwYXNzdGhyb3VnaC1yZW11eGVyLnRzXTogRmFpbGVkIHRvIGdlbmVyYXRlIGluaXRTZWdtZW50LlwiKSx1O3RoaXMuZW1pdEluaXRTZWdtZW50JiYoaC50cmFja3M9dGhpcy5pbml0VHJhY2tzLHRoaXMuZW1pdEluaXRTZWdtZW50PSExKSxPYmplY3Qocy5hKShuKXx8KHRoaXMuaW5pdFBUUz1oLmluaXRQVFM9bj1ndChmLGQsbykpO3ZhciB2PU9iamVjdChsLmMpKGQsZiksZz1vLHA9ditnO09iamVjdChsLmUpKGYsZCxuKSx2PjA/dGhpcy5sYXN0RW5kRFRTPXA6KGMuYi53YXJuKFwiRHVyYXRpb24gcGFyc2VkIGZyb20gbXA0IHNob3VsZCBiZSBncmVhdGVyIHRoYW4gemVyb1wiKSx0aGlzLnJlc2V0TmV4dFRpbWVzdGFtcCgpKTt2YXIgbT0hIWYuYXVkaW8seT0hIWYudmlkZW8sYj1cIlwiO20mJihiKz1cImF1ZGlvXCIpLHkmJihiKz1cInZpZGVvXCIpO3ZhciBUPXtkYXRhMTpkLHN0YXJ0UFRTOmcsc3RhcnREVFM6ZyxlbmRQVFM6cCxlbmREVFM6cCx0eXBlOmIsaGFzQXVkaW86bSxoYXNWaWRlbzp5LG5iOjEsZHJvcHBlZDowfTtyZXR1cm4gdS5hdWRpbz1cImF1ZGlvXCI9PT1ULnR5cGU/VDp2b2lkIDAsdS52aWRlbz1cImF1ZGlvXCIhPT1ULnR5cGU/VDp2b2lkIDAsdS50ZXh0PWksdS5pZDM9cix1LmluaXRTZWdtZW50PWgsdX0sdH0oKSxndD1mdW5jdGlvbih0LGUscil7cmV0dXJuIE9iamVjdChsLmQpKHQsZSktcn07ZnVuY3Rpb24gcHQodCxlKXt2YXIgcj1udWxsPT10P3ZvaWQgMDp0LmNvZGVjO3JldHVybiByJiZyLmxlbmd0aD40P3I6XCJodmMxXCI9PT1yP1wiaHZjMS4xLmMuTDEyMC45MFwiOlwiYXYwMVwiPT09cj9cImF2MDEuMC4wNE0uMDhcIjpcImF2YzFcIj09PXJ8fGU9PT1jdC5hLlZJREVPP1wiYXZjMS40MmUwMWVcIjpcIm1wNGEuNDAuNVwifXZhciBtdCx5dD12dCxidD1yKDE2KTt0cnl7bXQ9c2VsZi5wZXJmb3JtYW5jZS5ub3cuYmluZChzZWxmLnBlcmZvcm1hbmNlKX1jYXRjaCh0KXtjLmIuZGVidWcoXCJVbmFibGUgdG8gdXNlIFBlcmZvcm1hbmNlIEFQSSBvbiB0aGlzIGVudmlyb25tZW50XCIpLG10PXNlbGYuRGF0ZS5ub3d9dmFyIFR0PVt7ZGVtdXg6cSxyZW11eDp1dH0se2RlbXV4OkQscmVtdXg6eXR9LHtkZW11eDpBLHJlbXV4OnV0fSx7ZGVtdXg6JCxyZW11eDp1dH1dLEV0PTEwMjQ7VHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9dC5kZW11eDtFdD1NYXRoLm1heChFdCxlLm1pblByb2JlQnl0ZUxlbmd0aCl9KSk7dmFyIFN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscixpLGEpe3RoaXMub2JzZXJ2ZXI9dm9pZCAwLHRoaXMudHlwZVN1cHBvcnRlZD12b2lkIDAsdGhpcy5jb25maWc9dm9pZCAwLHRoaXMudmVuZG9yPXZvaWQgMCx0aGlzLmlkPXZvaWQgMCx0aGlzLmRlbXV4ZXI9dm9pZCAwLHRoaXMucmVtdXhlcj12b2lkIDAsdGhpcy5kZWNyeXB0ZXI9dm9pZCAwLHRoaXMucHJvYmU9dm9pZCAwLHRoaXMuZGVjcnlwdGlvblByb21pc2U9bnVsbCx0aGlzLnRyYW5zbXV4Q29uZmlnPXZvaWQgMCx0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlPXZvaWQgMCx0aGlzLmNhY2hlPW5ldyBidC5hLHRoaXMub2JzZXJ2ZXI9dCx0aGlzLnR5cGVTdXBwb3J0ZWQ9ZSx0aGlzLmNvbmZpZz1yLHRoaXMudmVuZG9yPWksdGhpcy5pZD1hfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmNvbmZpZ3VyZT1mdW5jdGlvbih0KXt0aGlzLnRyYW5zbXV4Q29uZmlnPXQsdGhpcy5kZWNyeXB0ZXImJnRoaXMuZGVjcnlwdGVyLnJlc2V0KCl9LGUucHVzaD1mdW5jdGlvbih0LGUscixpKXt2YXIgYT10aGlzLG49ci50cmFuc211eGluZztuLmV4ZWN1dGVTdGFydD1tdCgpO3ZhciBzPW5ldyBVaW50OEFycmF5KHQpLG89dGhpcy5jYWNoZSx1PXRoaXMuY29uZmlnLGQ9dGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSxoPXRoaXMudHJhbnNtdXhDb25maWc7aSYmKHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGU9aSk7dmFyIGY9ZnVuY3Rpb24odCxlKXt2YXIgcj1udWxsO3QuYnl0ZUxlbmd0aD4wJiZudWxsIT1lJiZudWxsIT1lLmtleSYmbnVsbCE9PWUuaXYmJm51bGwhPWUubWV0aG9kJiYocj1lKTtyZXR1cm4gcn0ocyxlKTtpZihmJiZcIkFFUy0xMjhcIj09PWYubWV0aG9kKXt2YXIgYz10aGlzLmdldERlY3J5cHRlcigpO2lmKCF1LmVuYWJsZVNvZnR3YXJlQUVTKXJldHVybiB0aGlzLmRlY3J5cHRpb25Qcm9taXNlPWMud2ViQ3J5cHRvRGVjcnlwdChzLGYua2V5LmJ1ZmZlcixmLml2LmJ1ZmZlcikudGhlbigoZnVuY3Rpb24odCl7dmFyIGU9YS5wdXNoKHQsbnVsbCxyKTtyZXR1cm4gYS5kZWNyeXB0aW9uUHJvbWlzZT1udWxsLGV9KSksdGhpcy5kZWNyeXB0aW9uUHJvbWlzZTt2YXIgdj1jLnNvZnR3YXJlRGVjcnlwdChzLGYua2V5LmJ1ZmZlcixmLml2LmJ1ZmZlcik7aWYoIXYpcmV0dXJuIG4uZXhlY3V0ZUVuZD1tdCgpLEx0KHIpO3M9bmV3IFVpbnQ4QXJyYXkodil9dmFyIGc9aXx8ZCxwPWcuY29udGlndW91cyxtPWcuZGlzY29udGludWl0eSx5PWcudHJhY2tTd2l0Y2gsYj1nLmFjY3VyYXRlVGltZU9mZnNldCxUPWcudGltZU9mZnNldCxFPWcuaW5pdFNlZ21lbnRDaGFuZ2UsUz1oLmF1ZGlvQ29kZWMsTD1oLnZpZGVvQ29kZWMsQT1oLmRlZmF1bHRJbml0UHRzLFI9aC5kdXJhdGlvbixEPWguaW5pdFNlZ21lbnREYXRhO2lmKChtfHx5fHxFKSYmdGhpcy5yZXNldEluaXRTZWdtZW50KEQsUyxMLFIpLChtfHxFKSYmdGhpcy5yZXNldEluaXRpYWxUaW1lc3RhbXAoQSkscHx8dGhpcy5yZXNldENvbnRpZ3VpdHkoKSx0aGlzLm5lZWRzUHJvYmluZyhzLG0seSkpe2lmKG8uZGF0YUxlbmd0aCl7dmFyIF89by5mbHVzaCgpO3M9T2JqZWN0KGwuYSkoXyxzKX10aGlzLmNvbmZpZ3VyZVRyYW5zbXV4ZXIocyxoKX12YXIgaz10aGlzLnRyYW5zbXV4KHMsZixULGIscikseD10aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlO3JldHVybiB4LmNvbnRpZ3VvdXM9ITAseC5kaXNjb250aW51aXR5PSExLHgudHJhY2tTd2l0Y2g9ITEsbi5leGVjdXRlRW5kPW10KCksa30sZS5mbHVzaD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9dC50cmFuc211eGluZztyLmV4ZWN1dGVTdGFydD1tdCgpO3ZhciBuPXRoaXMuZGVjcnlwdGVyLHM9dGhpcy5jYWNoZSxvPXRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUsbD10aGlzLmRlY3J5cHRpb25Qcm9taXNlO2lmKGwpcmV0dXJuIGwudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gZS5mbHVzaCh0KX0pKTt2YXIgdT1bXSxkPW8udGltZU9mZnNldDtpZihuKXt2YXIgaD1uLmZsdXNoKCk7aCYmdS5wdXNoKHRoaXMucHVzaChoLG51bGwsdCkpfXZhciBmPXMuZGF0YUxlbmd0aDtzLnJlc2V0KCk7dmFyIGM9dGhpcy5kZW11eGVyLHY9dGhpcy5yZW11eGVyO2lmKCFjfHwhdilyZXR1cm4gZj49RXQmJnRoaXMub2JzZXJ2ZXIuZW1pdChpLmEuRVJST1IsaS5hLkVSUk9SLHt0eXBlOmEuYi5NRURJQV9FUlJPUixkZXRhaWxzOmEuYS5GUkFHX1BBUlNJTkdfRVJST1IsZmF0YWw6ITAscmVhc29uOlwibm8gZGVtdXggbWF0Y2hpbmcgd2l0aCBjb250ZW50IGZvdW5kXCJ9KSxyLmV4ZWN1dGVFbmQ9bXQoKSxbTHQodCldO3ZhciBnPWMuZmx1c2goZCk7cmV0dXJuIEF0KGcpP2cudGhlbigoZnVuY3Rpb24ocil7cmV0dXJuIGUuZmx1c2hSZW11eCh1LHIsdCksdX0pKToodGhpcy5mbHVzaFJlbXV4KHUsZyx0KSx1KX0sZS5mbHVzaFJlbXV4PWZ1bmN0aW9uKHQsZSxyKXt2YXIgaT1lLmF1ZGlvVHJhY2ssYT1lLmF2Y1RyYWNrLG49ZS5pZDNUcmFjayxzPWUudGV4dFRyYWNrLG89dGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSxsPW8uYWNjdXJhdGVUaW1lT2Zmc2V0LHU9by50aW1lT2Zmc2V0O2MuYi5sb2coXCJbdHJhbnNtdXhlci50c106IEZsdXNoZWQgZnJhZ21lbnQgXCIrci5zbisoci5wYXJ0Pi0xP1wiIHA6IFwiK3IucGFydDpcIlwiKStcIiBvZiBsZXZlbCBcIityLmxldmVsKTt2YXIgZD10aGlzLnJlbXV4ZXIucmVtdXgoaSxhLG4scyx1LGwsITAsdGhpcy5pZCk7dC5wdXNoKHtyZW11eFJlc3VsdDpkLGNodW5rTWV0YTpyfSksci50cmFuc211eGluZy5leGVjdXRlRW5kPW10KCl9LGUucmVzZXRJbml0aWFsVGltZXN0YW1wPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZGVtdXhlcixyPXRoaXMucmVtdXhlcjtlJiZyJiYoZS5yZXNldFRpbWVTdGFtcCh0KSxyLnJlc2V0VGltZVN0YW1wKHQpKX0sZS5yZXNldENvbnRpZ3VpdHk9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmRlbXV4ZXIsZT10aGlzLnJlbXV4ZXI7dCYmZSYmKHQucmVzZXRDb250aWd1aXR5KCksZS5yZXNldE5leHRUaW1lc3RhbXAoKSl9LGUucmVzZXRJbml0U2VnbWVudD1mdW5jdGlvbih0LGUscixpKXt2YXIgYT10aGlzLmRlbXV4ZXIsbj10aGlzLnJlbXV4ZXI7YSYmbiYmKGEucmVzZXRJbml0U2VnbWVudChlLHIsaSksbi5yZXNldEluaXRTZWdtZW50KHQsZSxyKSl9LGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZGVtdXhlciYmKHRoaXMuZGVtdXhlci5kZXN0cm95KCksdGhpcy5kZW11eGVyPXZvaWQgMCksdGhpcy5yZW11eGVyJiYodGhpcy5yZW11eGVyLmRlc3Ryb3koKSx0aGlzLnJlbXV4ZXI9dm9pZCAwKX0sZS50cmFuc211eD1mdW5jdGlvbih0LGUscixpLGEpe3JldHVybiBlJiZcIlNBTVBMRS1BRVNcIj09PWUubWV0aG9kP3RoaXMudHJhbnNtdXhTYW1wbGVBZXModCxlLHIsaSxhKTp0aGlzLnRyYW5zbXV4VW5lbmNyeXB0ZWQodCxyLGksYSl9LGUudHJhbnNtdXhVbmVuY3J5cHRlZD1mdW5jdGlvbih0LGUscixpKXt2YXIgYT10aGlzLmRlbXV4ZXIuZGVtdXgodCxlLCExLCF0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSksbj1hLmF1ZGlvVHJhY2sscz1hLmF2Y1RyYWNrLG89YS5pZDNUcmFjayxsPWEudGV4dFRyYWNrO3JldHVybntyZW11eFJlc3VsdDp0aGlzLnJlbXV4ZXIucmVtdXgobixzLG8sbCxlLHIsITEsdGhpcy5pZCksY2h1bmtNZXRhOml9fSxlLnRyYW5zbXV4U2FtcGxlQWVzPWZ1bmN0aW9uKHQsZSxyLGksYSl7dmFyIG49dGhpcztyZXR1cm4gdGhpcy5kZW11eGVyLmRlbXV4U2FtcGxlQWVzKHQsZSxyKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm57cmVtdXhSZXN1bHQ6bi5yZW11eGVyLnJlbXV4KHQuYXVkaW9UcmFjayx0LmF2Y1RyYWNrLHQuaWQzVHJhY2ssdC50ZXh0VHJhY2sscixpLCExLG4uaWQpLGNodW5rTWV0YTphfX0pKX0sZS5jb25maWd1cmVUcmFuc211eGVyPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByLGk9dGhpcy5jb25maWcsYT10aGlzLm9ic2VydmVyLG49dGhpcy50eXBlU3VwcG9ydGVkLHM9dGhpcy52ZW5kb3Isbz1lLmF1ZGlvQ29kZWMsbD1lLmRlZmF1bHRJbml0UHRzLHU9ZS5kdXJhdGlvbixkPWUuaW5pdFNlZ21lbnREYXRhLGg9ZS52aWRlb0NvZGVjLGY9MCx2PVR0Lmxlbmd0aDtmPHY7ZisrKWlmKFR0W2ZdLmRlbXV4LnByb2JlKHQpKXtyPVR0W2ZdO2JyZWFrfXJ8fChjLmIud2FybihcIkZhaWxlZCB0byBmaW5kIGRlbXV4ZXIgYnkgcHJvYmluZyBmcmFnLCB0cmVhdGluZyBhcyBtcDQgcGFzc3Rocm91Z2hcIikscj17ZGVtdXg6RCxyZW11eDp5dH0pO3ZhciBnPXRoaXMuZGVtdXhlcixwPXRoaXMucmVtdXhlcixtPXIucmVtdXgseT1yLmRlbXV4O3AmJnAgaW5zdGFuY2VvZiBtfHwodGhpcy5yZW11eGVyPW5ldyBtKGEsaSxuLHMpKSxnJiZnIGluc3RhbmNlb2YgeXx8KHRoaXMuZGVtdXhlcj1uZXcgeShhLGksbiksdGhpcy5wcm9iZT15LnByb2JlKSx0aGlzLnJlc2V0SW5pdFNlZ21lbnQoZCxvLGgsdSksdGhpcy5yZXNldEluaXRpYWxUaW1lc3RhbXAobCl9LGUubmVlZHNQcm9iaW5nPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4hdGhpcy5kZW11eGVyfHwhdGhpcy5yZW11eGVyfHxlfHxyfSxlLmdldERlY3J5cHRlcj1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZGVjcnlwdGVyO3JldHVybiB0fHwodD10aGlzLmRlY3J5cHRlcj1uZXcgbi5hKHRoaXMub2JzZXJ2ZXIsdGhpcy5jb25maWcpKSx0fSx0fSgpO3ZhciBMdD1mdW5jdGlvbih0KXtyZXR1cm57cmVtdXhSZXN1bHQ6e30sY2h1bmtNZXRhOnR9fTtmdW5jdGlvbiBBdCh0KXtyZXR1cm5cInRoZW5cImluIHQmJnQudGhlbiBpbnN0YW5jZW9mIEZ1bmN0aW9ufXZhciBSdD1mdW5jdGlvbih0LGUscixpLGEpe3RoaXMuYXVkaW9Db2RlYz12b2lkIDAsdGhpcy52aWRlb0NvZGVjPXZvaWQgMCx0aGlzLmluaXRTZWdtZW50RGF0YT12b2lkIDAsdGhpcy5kdXJhdGlvbj12b2lkIDAsdGhpcy5kZWZhdWx0SW5pdFB0cz12b2lkIDAsdGhpcy5hdWRpb0NvZGVjPXQsdGhpcy52aWRlb0NvZGVjPWUsdGhpcy5pbml0U2VnbWVudERhdGE9cix0aGlzLmR1cmF0aW9uPWksdGhpcy5kZWZhdWx0SW5pdFB0cz1hfSxEdD1mdW5jdGlvbih0LGUscixpLGEsbil7dGhpcy5kaXNjb250aW51aXR5PXZvaWQgMCx0aGlzLmNvbnRpZ3VvdXM9dm9pZCAwLHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0PXZvaWQgMCx0aGlzLnRyYWNrU3dpdGNoPXZvaWQgMCx0aGlzLnRpbWVPZmZzZXQ9dm9pZCAwLHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2U9dm9pZCAwLHRoaXMuZGlzY29udGludWl0eT10LHRoaXMuY29udGlndW91cz1lLHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0PXIsdGhpcy50cmFja1N3aXRjaD1pLHRoaXMudGltZU9mZnNldD1hLHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2U9bn19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPXZvaWQgMH0sZnVuY3Rpb24odCxlLHIpe3ZhciBpLGEsbixzLG87aT0vXigoPzpbYS16QS1aMC05K1xcLS5dKzopPykoXFwvXFwvW15cXC8/I10qKT8oKD86W15cXC8/I10qXFwvKSpbXjs/I10qKT8oO1tePyNdKik/KFxcP1teI10qKT8oI1teXSopPyQvLGE9L14oW15cXC8/I10qKShbXl0qKSQvLG49Lyg/OlxcL3xeKVxcLig/PVxcLykvZyxzPS8oPzpcXC98XilcXC5cXC5cXC8oPyFcXC5cXC5cXC8pW15cXC9dKig/PVxcLykvZyxvPXtidWlsZEFic29sdXRlVVJMOmZ1bmN0aW9uKHQsZSxyKXtpZihyPXJ8fHt9LHQ9dC50cmltKCksIShlPWUudHJpbSgpKSl7aWYoIXIuYWx3YXlzTm9ybWFsaXplKXJldHVybiB0O3ZhciBpPW8ucGFyc2VVUkwodCk7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLlwiKTtyZXR1cm4gaS5wYXRoPW8ubm9ybWFsaXplUGF0aChpLnBhdGgpLG8uYnVpbGRVUkxGcm9tUGFydHMoaSl9dmFyIG49by5wYXJzZVVSTChlKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0cnlpbmcgdG8gcGFyc2UgcmVsYXRpdmUgVVJMLlwiKTtpZihuLnNjaGVtZSlyZXR1cm4gci5hbHdheXNOb3JtYWxpemU/KG4ucGF0aD1vLm5vcm1hbGl6ZVBhdGgobi5wYXRoKSxvLmJ1aWxkVVJMRnJvbVBhcnRzKG4pKTplO3ZhciBzPW8ucGFyc2VVUkwodCk7aWYoIXMpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLlwiKTtpZighcy5uZXRMb2MmJnMucGF0aCYmXCIvXCIhPT1zLnBhdGhbMF0pe3ZhciBsPWEuZXhlYyhzLnBhdGgpO3MubmV0TG9jPWxbMV0scy5wYXRoPWxbMl19cy5uZXRMb2MmJiFzLnBhdGgmJihzLnBhdGg9XCIvXCIpO3ZhciB1PXtzY2hlbWU6cy5zY2hlbWUsbmV0TG9jOm4ubmV0TG9jLHBhdGg6bnVsbCxwYXJhbXM6bi5wYXJhbXMscXVlcnk6bi5xdWVyeSxmcmFnbWVudDpuLmZyYWdtZW50fTtpZighbi5uZXRMb2MmJih1Lm5ldExvYz1zLm5ldExvYyxcIi9cIiE9PW4ucGF0aFswXSkpaWYobi5wYXRoKXt2YXIgZD1zLnBhdGgsaD1kLnN1YnN0cmluZygwLGQubGFzdEluZGV4T2YoXCIvXCIpKzEpK24ucGF0aDt1LnBhdGg9by5ub3JtYWxpemVQYXRoKGgpfWVsc2UgdS5wYXRoPXMucGF0aCxuLnBhcmFtc3x8KHUucGFyYW1zPXMucGFyYW1zLG4ucXVlcnl8fCh1LnF1ZXJ5PXMucXVlcnkpKTtyZXR1cm4gbnVsbD09PXUucGF0aCYmKHUucGF0aD1yLmFsd2F5c05vcm1hbGl6ZT9vLm5vcm1hbGl6ZVBhdGgobi5wYXRoKTpuLnBhdGgpLG8uYnVpbGRVUkxGcm9tUGFydHModSl9LHBhcnNlVVJMOmZ1bmN0aW9uKHQpe3ZhciBlPWkuZXhlYyh0KTtyZXR1cm4gZT97c2NoZW1lOmVbMV18fFwiXCIsbmV0TG9jOmVbMl18fFwiXCIscGF0aDplWzNdfHxcIlwiLHBhcmFtczplWzRdfHxcIlwiLHF1ZXJ5OmVbNV18fFwiXCIsZnJhZ21lbnQ6ZVs2XXx8XCJcIn06bnVsbH0sbm9ybWFsaXplUGF0aDpmdW5jdGlvbih0KXtmb3IodD10LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpLnJlcGxhY2UobixcIlwiKTt0Lmxlbmd0aCE9PSh0PXQucmVwbGFjZShzLFwiXCIpKS5sZW5ndGg7KTtyZXR1cm4gdC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKX0sYnVpbGRVUkxGcm9tUGFydHM6ZnVuY3Rpb24odCl7cmV0dXJuIHQuc2NoZW1lK3QubmV0TG9jK3QucGF0aCt0LnBhcmFtcyt0LnF1ZXJ5K3QuZnJhZ21lbnR9fSx0LmV4cG9ydHM9b30sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3IuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBpfSkpO3ZhciBpPWZ1bmN0aW9uKCl7dGhpcy5hYm9ydGVkPSExLHRoaXMubG9hZGVkPTAsdGhpcy5yZXRyeT0wLHRoaXMudG90YWw9MCx0aGlzLmNodW5rQ291bnQ9MCx0aGlzLmJ3RXN0aW1hdGU9MCx0aGlzLmxvYWRpbmc9e3N0YXJ0OjAsZmlyc3Q6MCxlbmQ6MH0sdGhpcy5wYXJzaW5nPXtzdGFydDowLGVuZDowfSx0aGlzLmJ1ZmZlcmluZz17c3RhcnQ6MCxmaXJzdDowLGVuZDowfX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LGE9XCJ+XCI7ZnVuY3Rpb24gbigpe31mdW5jdGlvbiBzKHQsZSxyKXt0aGlzLmZuPXQsdGhpcy5jb250ZXh0PWUsdGhpcy5vbmNlPXJ8fCExfWZ1bmN0aW9uIG8odCxlLHIsaSxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO3ZhciBvPW5ldyBzKHIsaXx8dCxuKSxsPWE/YStlOmU7cmV0dXJuIHQuX2V2ZW50c1tsXT90Ll9ldmVudHNbbF0uZm4/dC5fZXZlbnRzW2xdPVt0Ll9ldmVudHNbbF0sb106dC5fZXZlbnRzW2xdLnB1c2gobyk6KHQuX2V2ZW50c1tsXT1vLHQuX2V2ZW50c0NvdW50KyspLHR9ZnVuY3Rpb24gbCh0LGUpezA9PS0tdC5fZXZlbnRzQ291bnQ/dC5fZXZlbnRzPW5ldyBuOmRlbGV0ZSB0Ll9ldmVudHNbZV19ZnVuY3Rpb24gdSgpe3RoaXMuX2V2ZW50cz1uZXcgbix0aGlzLl9ldmVudHNDb3VudD0wfU9iamVjdC5jcmVhdGUmJihuLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKG51bGwpLChuZXcgbikuX19wcm90b19ffHwoYT0hMSkpLHUucHJvdG90eXBlLmV2ZW50TmFtZXM9ZnVuY3Rpb24oKXt2YXIgdCxlLHI9W107aWYoMD09PXRoaXMuX2V2ZW50c0NvdW50KXJldHVybiByO2ZvcihlIGluIHQ9dGhpcy5fZXZlbnRzKWkuY2FsbCh0LGUpJiZyLnB1c2goYT9lLnNsaWNlKDEpOmUpO3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP3IuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCkpOnJ9LHUucHJvdG90eXBlLmxpc3RlbmVycz1mdW5jdGlvbih0KXt2YXIgZT1hP2ErdDp0LHI9dGhpcy5fZXZlbnRzW2VdO2lmKCFyKXJldHVybltdO2lmKHIuZm4pcmV0dXJuW3IuZm5dO2Zvcih2YXIgaT0wLG49ci5sZW5ndGgscz1uZXcgQXJyYXkobik7aTxuO2krKylzW2ldPXJbaV0uZm47cmV0dXJuIHN9LHUucHJvdG90eXBlLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24odCl7dmFyIGU9YT9hK3Q6dCxyPXRoaXMuX2V2ZW50c1tlXTtyZXR1cm4gcj9yLmZuPzE6ci5sZW5ndGg6MH0sdS5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbih0LGUscixpLG4scyl7dmFyIG89YT9hK3Q6dDtpZighdGhpcy5fZXZlbnRzW29dKXJldHVybiExO3ZhciBsLHUsZD10aGlzLl9ldmVudHNbb10saD1hcmd1bWVudHMubGVuZ3RoO2lmKGQuZm4pe3N3aXRjaChkLm9uY2UmJnRoaXMucmVtb3ZlTGlzdGVuZXIodCxkLmZuLHZvaWQgMCwhMCksaCl7Y2FzZSAxOnJldHVybiBkLmZuLmNhbGwoZC5jb250ZXh0KSwhMDtjYXNlIDI6cmV0dXJuIGQuZm4uY2FsbChkLmNvbnRleHQsZSksITA7Y2FzZSAzOnJldHVybiBkLmZuLmNhbGwoZC5jb250ZXh0LGUsciksITA7Y2FzZSA0OnJldHVybiBkLmZuLmNhbGwoZC5jb250ZXh0LGUscixpKSwhMDtjYXNlIDU6cmV0dXJuIGQuZm4uY2FsbChkLmNvbnRleHQsZSxyLGksbiksITA7Y2FzZSA2OnJldHVybiBkLmZuLmNhbGwoZC5jb250ZXh0LGUscixpLG4scyksITB9Zm9yKHU9MSxsPW5ldyBBcnJheShoLTEpO3U8aDt1KyspbFt1LTFdPWFyZ3VtZW50c1t1XTtkLmZuLmFwcGx5KGQuY29udGV4dCxsKX1lbHNle3ZhciBmLGM9ZC5sZW5ndGg7Zm9yKHU9MDt1PGM7dSsrKXN3aXRjaChkW3VdLm9uY2UmJnRoaXMucmVtb3ZlTGlzdGVuZXIodCxkW3VdLmZuLHZvaWQgMCwhMCksaCl7Y2FzZSAxOmRbdV0uZm4uY2FsbChkW3VdLmNvbnRleHQpO2JyZWFrO2Nhc2UgMjpkW3VdLmZuLmNhbGwoZFt1XS5jb250ZXh0LGUpO2JyZWFrO2Nhc2UgMzpkW3VdLmZuLmNhbGwoZFt1XS5jb250ZXh0LGUscik7YnJlYWs7Y2FzZSA0OmRbdV0uZm4uY2FsbChkW3VdLmNvbnRleHQsZSxyLGkpO2JyZWFrO2RlZmF1bHQ6aWYoIWwpZm9yKGY9MSxsPW5ldyBBcnJheShoLTEpO2Y8aDtmKyspbFtmLTFdPWFyZ3VtZW50c1tmXTtkW3VdLmZuLmFwcGx5KGRbdV0uY29udGV4dCxsKX19cmV0dXJuITB9LHUucHJvdG90eXBlLm9uPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gbyh0aGlzLHQsZSxyLCExKX0sdS5wcm90b3R5cGUub25jZT1mdW5jdGlvbih0LGUscil7cmV0dXJuIG8odGhpcyx0LGUsciwhMCl9LHUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBuPWE/YSt0OnQ7aWYoIXRoaXMuX2V2ZW50c1tuXSlyZXR1cm4gdGhpcztpZighZSlyZXR1cm4gbCh0aGlzLG4pLHRoaXM7dmFyIHM9dGhpcy5fZXZlbnRzW25dO2lmKHMuZm4pcy5mbiE9PWV8fGkmJiFzLm9uY2V8fHImJnMuY29udGV4dCE9PXJ8fGwodGhpcyxuKTtlbHNle2Zvcih2YXIgbz0wLHU9W10sZD1zLmxlbmd0aDtvPGQ7bysrKShzW29dLmZuIT09ZXx8aSYmIXNbb10ub25jZXx8ciYmc1tvXS5jb250ZXh0IT09cikmJnUucHVzaChzW29dKTt1Lmxlbmd0aD90aGlzLl9ldmVudHNbbl09MT09PXUubGVuZ3RoP3VbMF06dTpsKHRoaXMsbil9cmV0dXJuIHRoaXN9LHUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gdD8oZT1hP2ErdDp0LHRoaXMuX2V2ZW50c1tlXSYmbCh0aGlzLGUpKToodGhpcy5fZXZlbnRzPW5ldyBuLHRoaXMuX2V2ZW50c0NvdW50PTApLHRoaXN9LHUucHJvdG90eXBlLm9mZj11LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcix1LnByb3RvdHlwZS5hZGRMaXN0ZW5lcj11LnByb3RvdHlwZS5vbix1LnByZWZpeGVkPWEsdS5FdmVudEVtaXR0ZXI9dSx0LmV4cG9ydHM9dX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3IuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiB1fSkpO3ZhciBpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMuc3VidGxlPXZvaWQgMCx0aGlzLmFlc0lWPXZvaWQgMCx0aGlzLnN1YnRsZT10LHRoaXMuYWVzSVY9ZX1yZXR1cm4gdC5wcm90b3R5cGUuZGVjcnlwdD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHtuYW1lOlwiQUVTLUNCQ1wiLGl2OnRoaXMuYWVzSVZ9LGUsdCl9LHR9KCksYT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLnN1YnRsZT12b2lkIDAsdGhpcy5rZXk9dm9pZCAwLHRoaXMuc3VidGxlPXQsdGhpcy5rZXk9ZX1yZXR1cm4gdC5wcm90b3R5cGUuZXhwYW5kS2V5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3VidGxlLmltcG9ydEtleShcInJhd1wiLHRoaXMua2V5LHtuYW1lOlwiQUVTLUNCQ1wifSwhMSxbXCJlbmNyeXB0XCIsXCJkZWNyeXB0XCJdKX0sdH0oKSxuPXIoOCk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5yY29uPVswLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI3LDU0XSx0aGlzLnN1Yk1peD1bbmV3IFVpbnQzMkFycmF5KDI1NiksbmV3IFVpbnQzMkFycmF5KDI1NiksbmV3IFVpbnQzMkFycmF5KDI1NiksbmV3IFVpbnQzMkFycmF5KDI1NildLHRoaXMuaW52U3ViTWl4PVtuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KV0sdGhpcy5zQm94PW5ldyBVaW50MzJBcnJheSgyNTYpLHRoaXMuaW52U0JveD1uZXcgVWludDMyQXJyYXkoMjU2KSx0aGlzLmtleT1uZXcgVWludDMyQXJyYXkoMCksdGhpcy5rc1Jvd3M9MCx0aGlzLmtleVNpemU9MCx0aGlzLmtleVNjaGVkdWxlPXZvaWQgMCx0aGlzLmludktleVNjaGVkdWxlPXZvaWQgMCx0aGlzLmluaXRUYWJsZSgpfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5Xz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IERhdGFWaWV3KHQpLHI9bmV3IFVpbnQzMkFycmF5KDQpLGk9MDtpPDQ7aSsrKXJbaV09ZS5nZXRVaW50MzIoNCppKTtyZXR1cm4gcn0sZS5pbml0VGFibGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnNCb3gsZT10aGlzLmludlNCb3gscj10aGlzLnN1Yk1peCxpPXJbMF0sYT1yWzFdLG49clsyXSxzPXJbM10sbz10aGlzLmludlN1Yk1peCxsPW9bMF0sdT1vWzFdLGQ9b1syXSxoPW9bM10sZj1uZXcgVWludDMyQXJyYXkoMjU2KSxjPTAsdj0wLGc9MDtmb3IoZz0wO2c8MjU2O2crKylmW2ddPWc8MTI4P2c8PDE6Zzw8MV4yODM7Zm9yKGc9MDtnPDI1NjtnKyspe3ZhciBwPXZedjw8MV52PDwyXnY8PDNedjw8NDtwPXA+Pj44XjI1NSZwXjk5LHRbY109cCxlW3BdPWM7dmFyIG09ZltjXSx5PWZbbV0sYj1mW3ldLFQ9MjU3KmZbcF1eMTY4NDMwMDgqcDtpW2NdPVQ8PDI0fFQ+Pj44LGFbY109VDw8MTZ8VD4+PjE2LG5bY109VDw8OHxUPj4+MjQsc1tjXT1ULFQ9MTY4NDMwMDkqYl42NTUzNyp5XjI1NyptXjE2ODQzMDA4KmMsbFtwXT1UPDwyNHxUPj4+OCx1W3BdPVQ8PDE2fFQ+Pj4xNixkW3BdPVQ8PDh8VD4+PjI0LGhbcF09VCxjPyhjPW1eZltmW2ZbYl5tXV1dLHZePWZbZlt2XV0pOmM9dj0xfX0sZS5leHBhbmRLZXk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKHQpLHI9ITAsaT0wO2k8ZS5sZW5ndGgmJnI7KXI9ZVtpXT09PXRoaXMua2V5W2ldLGkrKztpZighcil7dGhpcy5rZXk9ZTt2YXIgYT10aGlzLmtleVNpemU9ZS5sZW5ndGg7aWYoNCE9PWEmJjYhPT1hJiY4IT09YSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFlcyBrZXkgc2l6ZT1cIithKTt2YXIgbixzLG8sbCx1PXRoaXMua3NSb3dzPTQqKGErNisxKSxkPXRoaXMua2V5U2NoZWR1bGU9bmV3IFVpbnQzMkFycmF5KHUpLGg9dGhpcy5pbnZLZXlTY2hlZHVsZT1uZXcgVWludDMyQXJyYXkodSksZj10aGlzLnNCb3gsYz10aGlzLnJjb24sdj10aGlzLmludlN1Yk1peCxnPXZbMF0scD12WzFdLG09dlsyXSx5PXZbM107Zm9yKG49MDtuPHU7bisrKW48YT9vPWRbbl09ZVtuXToobD1vLG4lYT09MD8obD1mWyhsPWw8PDh8bD4+PjI0KT4+PjI0XTw8MjR8ZltsPj4+MTYmMjU1XTw8MTZ8ZltsPj4+OCYyNTVdPDw4fGZbMjU1JmxdLGxePWNbbi9hfDBdPDwyNCk6YT42JiZuJWE9PTQmJihsPWZbbD4+PjI0XTw8MjR8ZltsPj4+MTYmMjU1XTw8MTZ8ZltsPj4+OCYyNTVdPDw4fGZbMjU1JmxdKSxkW25dPW89KGRbbi1hXV5sKT4+PjApO2ZvcihzPTA7czx1O3MrKyluPXUtcyxsPTMmcz9kW25dOmRbbi00XSxoW3NdPXM8NHx8bjw9ND9sOmdbZltsPj4+MjRdXV5wW2ZbbD4+PjE2JjI1NV1dXm1bZltsPj4+OCYyNTVdXV55W2ZbMjU1JmxdXSxoW3NdPWhbc10+Pj4wfX0sZS5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwPWZ1bmN0aW9uKHQpe3JldHVybiB0PDwyNHwoNjUyODAmdCk8PDh8KDE2NzExNjgwJnQpPj44fHQ+Pj4yNH0sZS5kZWNyeXB0PWZ1bmN0aW9uKHQsZSxyKXtmb3IodmFyIGksYSxuLHMsbyxsLHUsZCxoLGYsYyx2LGcscCxtPXRoaXMua2V5U2l6ZSs2LHk9dGhpcy5pbnZLZXlTY2hlZHVsZSxiPXRoaXMuaW52U0JveCxUPXRoaXMuaW52U3ViTWl4LEU9VFswXSxTPVRbMV0sTD1UWzJdLEE9VFszXSxSPXRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKHIpLEQ9UlswXSxfPVJbMV0saz1SWzJdLHg9UlszXSxDPW5ldyBJbnQzMkFycmF5KHQpLHc9bmV3IEludDMyQXJyYXkoQy5sZW5ndGgpLE89dGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO2U8Qy5sZW5ndGg7KXtmb3IoaD1PKENbZV0pLGY9TyhDW2UrMV0pLGM9TyhDW2UrMl0pLHY9TyhDW2UrM10pLG89aF55WzBdLGw9dl55WzFdLHU9Y155WzJdLGQ9Zl55WzNdLGc9NCxwPTE7cDxtO3ArKylpPUVbbz4+PjI0XV5TW2w+PjE2JjI1NV1eTFt1Pj44JjI1NV1eQVsyNTUmZF1eeVtnXSxhPUVbbD4+PjI0XV5TW3U+PjE2JjI1NV1eTFtkPj44JjI1NV1eQVsyNTUmb11eeVtnKzFdLG49RVt1Pj4+MjRdXlNbZD4+MTYmMjU1XV5MW28+PjgmMjU1XV5BWzI1NSZsXV55W2crMl0scz1FW2Q+Pj4yNF1eU1tvPj4xNiYyNTVdXkxbbD4+OCYyNTVdXkFbMjU1JnVdXnlbZyszXSxvPWksbD1hLHU9bixkPXMsZys9NDtpPWJbbz4+PjI0XTw8MjReYltsPj4xNiYyNTVdPDwxNl5iW3U+PjgmMjU1XTw8OF5iWzI1NSZkXV55W2ddLGE9YltsPj4+MjRdPDwyNF5iW3U+PjE2JjI1NV08PDE2XmJbZD4+OCYyNTVdPDw4XmJbMjU1Jm9dXnlbZysxXSxuPWJbdT4+PjI0XTw8MjReYltkPj4xNiYyNTVdPDwxNl5iW28+PjgmMjU1XTw8OF5iWzI1NSZsXV55W2crMl0scz1iW2Q+Pj4yNF08PDI0XmJbbz4+MTYmMjU1XTw8MTZeYltsPj44JjI1NV08PDheYlsyNTUmdV1eeVtnKzNdLHdbZV09TyhpXkQpLHdbZSsxXT1PKHNeXyksd1tlKzJdPU8obl5rKSx3W2UrM109TyhhXngpLEQ9aCxfPWYsaz1jLHg9dixlKz00fXJldHVybiB3LmJ1ZmZlcn0sdH0oKSxvPXIoMSksbD1yKDYpLHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxyKXt2YXIgaT0odm9pZCAwPT09cj97fTpyKS5yZW1vdmVQS0NTN1BhZGRpbmcsYT12b2lkIDA9PT1pfHxpO2lmKHRoaXMubG9nRW5hYmxlZD0hMCx0aGlzLm9ic2VydmVyPXZvaWQgMCx0aGlzLmNvbmZpZz12b2lkIDAsdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmc9dm9pZCAwLHRoaXMuc3VidGxlPW51bGwsdGhpcy5zb2Z0d2FyZURlY3J5cHRlcj1udWxsLHRoaXMua2V5PW51bGwsdGhpcy5mYXN0QWVzS2V5PW51bGwsdGhpcy5yZW1haW5kZXJEYXRhPW51bGwsdGhpcy5jdXJyZW50SVY9bnVsbCx0aGlzLmN1cnJlbnRSZXN1bHQ9bnVsbCx0aGlzLm9ic2VydmVyPXQsdGhpcy5jb25maWc9ZSx0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZz1hLGEpdHJ5e3ZhciBuPXNlbGYuY3J5cHRvO24mJih0aGlzLnN1YnRsZT1uLnN1YnRsZXx8bi53ZWJraXRTdWJ0bGUpfWNhdGNoKHQpe31udWxsPT09dGhpcy5zdWJ0bGUmJih0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUz0hMCl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMub2JzZXJ2ZXI9bnVsbH0sZS5pc1N5bmM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVN9LGUuZmx1c2g9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmN1cnJlbnRSZXN1bHQ7aWYodCl7dmFyIGUscixpLGE9bmV3IFVpbnQ4QXJyYXkodCk7cmV0dXJuIHRoaXMucmVzZXQoKSx0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZz8ocj0oZT1hKS5ieXRlTGVuZ3RoLChpPXImJm5ldyBEYXRhVmlldyhlLmJ1ZmZlcikuZ2V0VWludDgoci0xKSk/T2JqZWN0KG4uYSkoZSwwLHItaSk6ZSk6YX10aGlzLnJlc2V0KCl9LGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmN1cnJlbnRSZXN1bHQ9bnVsbCx0aGlzLmN1cnJlbnRJVj1udWxsLHRoaXMucmVtYWluZGVyRGF0YT1udWxsLHRoaXMuc29mdHdhcmVEZWNyeXB0ZXImJih0aGlzLnNvZnR3YXJlRGVjcnlwdGVyPW51bGwpfSxlLmRlY3J5cHQ9ZnVuY3Rpb24odCxlLHIsaSl7aWYodGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpe3RoaXMuc29mdHdhcmVEZWNyeXB0KG5ldyBVaW50OEFycmF5KHQpLGUscik7dmFyIGE9dGhpcy5mbHVzaCgpO2EmJmkoYS5idWZmZXIpfWVsc2UgdGhpcy53ZWJDcnlwdG9EZWNyeXB0KG5ldyBVaW50OEFycmF5KHQpLGUscikudGhlbihpKX0sZS5zb2Z0d2FyZURlY3J5cHQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBpPXRoaXMuY3VycmVudElWLGE9dGhpcy5jdXJyZW50UmVzdWx0LG89dGhpcy5yZW1haW5kZXJEYXRhO3RoaXMubG9nT25jZShcIkpTIEFFUyBkZWNyeXB0XCIpLG8mJih0PU9iamVjdChsLmEpKG8sdCksdGhpcy5yZW1haW5kZXJEYXRhPW51bGwpO3ZhciB1PXRoaXMuZ2V0VmFsaWRDaHVuayh0KTtpZighdS5sZW5ndGgpcmV0dXJuIG51bGw7aSYmKHI9aSk7dmFyIGQ9dGhpcy5zb2Z0d2FyZURlY3J5cHRlcjtkfHwoZD10aGlzLnNvZnR3YXJlRGVjcnlwdGVyPW5ldyBzKSxkLmV4cGFuZEtleShlKTt2YXIgaD1hO3JldHVybiB0aGlzLmN1cnJlbnRSZXN1bHQ9ZC5kZWNyeXB0KHUuYnVmZmVyLDAsciksdGhpcy5jdXJyZW50SVY9T2JqZWN0KG4uYSkodSwtMTYpLmJ1ZmZlcixofHxudWxsfSxlLndlYkNyeXB0b0RlY3J5cHQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXRoaXMscz10aGlzLnN1YnRsZTtyZXR1cm4gdGhpcy5rZXk9PT1lJiZ0aGlzLmZhc3RBZXNLZXl8fCh0aGlzLmtleT1lLHRoaXMuZmFzdEFlc0tleT1uZXcgYShzLGUpKSx0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIHM/bmV3IGkocyxyKS5kZWNyeXB0KHQuYnVmZmVyLGUpOlByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIndlYiBjcnlwdG8gbm90IGluaXRpYWxpemVkXCIpKX0pKS5jYXRjaCgoZnVuY3Rpb24oaSl7cmV0dXJuIG4ub25XZWJDcnlwdG9FcnJvcihpLHQsZSxyKX0pKX0sZS5vbldlYkNyeXB0b0Vycm9yPWZ1bmN0aW9uKHQsZSxyLGkpe3JldHVybiBvLmIud2FybihcIltkZWNyeXB0ZXIudHNdOiBXZWJDcnlwdG8gRXJyb3IsIGRpc2FibGUgV2ViQ3J5cHRvIEFQSTpcIix0KSx0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUz0hMCx0aGlzLmxvZ0VuYWJsZWQ9ITAsdGhpcy5zb2Z0d2FyZURlY3J5cHQoZSxyLGkpfSxlLmdldFZhbGlkQ2h1bms9ZnVuY3Rpb24odCl7dmFyIGU9dCxyPXQubGVuZ3RoLXQubGVuZ3RoJTE2O3JldHVybiByIT09dC5sZW5ndGgmJihlPU9iamVjdChuLmEpKHQsMCxyKSx0aGlzLnJlbWFpbmRlckRhdGE9T2JqZWN0KG4uYSkodCxyKSksZX0sZS5sb2dPbmNlPWZ1bmN0aW9uKHQpe3RoaXMubG9nRW5hYmxlZCYmKG8uYi5sb2coXCJbZGVjcnlwdGVyLnRzXTogXCIrdCksdGhpcy5sb2dFbmFibGVkPSExKX0sdH0oKX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3IuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBufSkpO3ZhciBpPXIoMTEpO2Z1bmN0aW9uIGEodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaS5rZXksaSl9fXZhciBuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMuX3VyaT1udWxsLHRoaXMubWV0aG9kPW51bGwsdGhpcy5rZXlGb3JtYXQ9bnVsbCx0aGlzLmtleUZvcm1hdFZlcnNpb25zPW51bGwsdGhpcy5rZXlJRD1udWxsLHRoaXMua2V5PW51bGwsdGhpcy5pdj1udWxsLHRoaXMuX3VyaT1lP09iamVjdChpLmJ1aWxkQWJzb2x1dGVVUkwpKHQsZSx7YWx3YXlzTm9ybWFsaXplOiEwfSk6dH12YXIgZSxyLG47cmV0dXJuIHQuZnJvbVVSTD1mdW5jdGlvbihlLHIpe3JldHVybiBuZXcgdChlLHIpfSx0LmZyb21VUkk9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSxlPXQsKHI9W3trZXk6XCJ1cmlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdXJpfX1dKSYmYShlLnByb3RvdHlwZSxyKSxuJiZhKGUsbiksdH0oKX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3IuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBpfSkpO3ZhciBpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuY2h1bmtzPVtdLHRoaXMuZGF0YUxlbmd0aD0wfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnB1c2g9ZnVuY3Rpb24odCl7dGhpcy5jaHVua3MucHVzaCh0KSx0aGlzLmRhdGFMZW5ndGgrPXQubGVuZ3RofSxlLmZsdXNoPWZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzLmNodW5rcyxyPXRoaXMuZGF0YUxlbmd0aDtyZXR1cm4gZS5sZW5ndGg/KHQ9MT09PWUubGVuZ3RoP2VbMF06ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSksaT0wLGE9MDthPHQubGVuZ3RoO2ErKyl7dmFyIG49dFthXTtyLnNldChuLGkpLGkrPW4ubGVuZ3RofXJldHVybiByfShlLHIpLHRoaXMucmVzZXQoKSx0KTpuZXcgVWludDhBcnJheSgwKX0sZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuY2h1bmtzLmxlbmd0aD0wLHRoaXMuZGF0YUxlbmd0aD0wfSx0fSgpfSxmdW5jdGlvbih0LGUscil7ZnVuY3Rpb24gaSh0KXt2YXIgZT17fTtmdW5jdGlvbiByKGkpe2lmKGVbaV0pcmV0dXJuIGVbaV0uZXhwb3J0czt2YXIgYT1lW2ldPXtpOmksbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFtpXS5jYWxsKGEuZXhwb3J0cyxhLGEuZXhwb3J0cyxyKSxhLmw9ITAsYS5leHBvcnRzfXIubT10LHIuYz1lLHIuaT1mdW5jdGlvbih0KXtyZXR1cm4gdH0sci5kPWZ1bmN0aW9uKHQsZSxpKXtyLm8odCxlKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0Oml9KX0sci5yPWZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyLm49ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gdH07cmV0dXJuIHIuZChlLFwiYVwiLGUpLGV9LHIubz1mdW5jdGlvbih0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX0sci5wPVwiL1wiLHIub2U9ZnVuY3Rpb24odCl7dGhyb3cgY29uc29sZS5lcnJvcih0KSx0fTt2YXIgaT1yKHIucz1FTlRSWV9NT0RVTEUpO3JldHVybiBpLmRlZmF1bHR8fGl9ZnVuY3Rpb24gYSh0KXtyZXR1cm4odCtcIlwiKS5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csXCJcXFxcJCZcIil9ZnVuY3Rpb24gbih0LGUsaSl7dmFyIG49e307bltpXT1bXTt2YXIgcz1lLnRvU3RyaW5nKCksbz1zLm1hdGNoKC9eZnVuY3Rpb25cXHM/XFx3KlxcKFxcdyssXFxzKlxcdyssXFxzKihcXHcrKVxcKS8pO2lmKCFvKXJldHVybiBuO2Zvcih2YXIgbCx1PW9bMV0sZD1uZXcgUmVnRXhwKFwiKFxcXFxcXFxcbnxcXFxcVylcIithKHUpK1wiXFxcXChcXFxccyooL1xcXFwqLio/XFxcXCovKT9cXFxccyouKj8oW1xcXFwufFxcXFwtfFxcXFwrfFxcXFx3fC98QF0rKS4qP1xcXFwpXCIsXCJnXCIpO2w9ZC5leGVjKHMpOylcImRsbC1yZWZlcmVuY2VcIiE9PWxbM10mJm5baV0ucHVzaChsWzNdKTtmb3IoZD1uZXcgUmVnRXhwKFwiXFxcXChcIithKHUpKydcXFxcKFwiKGRsbC1yZWZlcmVuY2VcXFxccyhbXFxcXC58XFxcXC18XFxcXCt8XFxcXHd8L3xAXSspKVwiXFxcXClcXFxcKVxcXFwoXFxcXHMqKC9cXFxcKi4qP1xcXFwqLyk/XFxcXHMqLio/KFtcXFxcLnxcXFxcLXxcXFxcK3xcXFxcd3wvfEBdKykuKj9cXFxcKScsXCJnXCIpO2w9ZC5leGVjKHMpOyl0W2xbMl1dfHwobltpXS5wdXNoKGxbMV0pLHRbbFsyXV09cihsWzFdKS5tKSxuW2xbMl1dPW5bbFsyXV18fFtdLG5bbFsyXV0ucHVzaChsWzRdKTtmb3IodmFyIGgsZj1PYmplY3Qua2V5cyhuKSxjPTA7YzxmLmxlbmd0aDtjKyspZm9yKHZhciB2PTA7djxuW2ZbY11dLmxlbmd0aDt2KyspaD1uW2ZbY11dW3ZdLGlzTmFOKDEqaCl8fChuW2ZbY11dW3ZdPTEqbltmW2NdXVt2XSk7cmV0dXJuIG59ZnVuY3Rpb24gcyh0KXtyZXR1cm4gT2JqZWN0LmtleXModCkucmVkdWNlKChmdW5jdGlvbihlLHIpe3JldHVybiBlfHx0W3JdLmxlbmd0aD4wfSksITEpfXQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2U9ZXx8e307dmFyIGE9e21haW46ci5tfSxvPWUuYWxsP3ttYWluOk9iamVjdC5rZXlzKGEubWFpbil9OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPXttYWluOltlXX0saT17bWFpbjpbXX0sYT17bWFpbjp7fX07cyhyKTspZm9yKHZhciBvPU9iamVjdC5rZXlzKHIpLGw9MDtsPG8ubGVuZ3RoO2wrKyl7dmFyIHU9b1tsXSxkPXJbdV0ucG9wKCk7aWYoYVt1XT1hW3VdfHx7fSwhYVt1XVtkXSYmdFt1XVtkXSl7YVt1XVtkXT0hMCxpW3VdPWlbdV18fFtdLGlbdV0ucHVzaChkKTtmb3IodmFyIGg9bih0LHRbdV1bZF0sdSksZj1PYmplY3Qua2V5cyhoKSxjPTA7YzxmLmxlbmd0aDtjKyspcltmW2NdXT1yW2ZbY11dfHxbXSxyW2ZbY11dPXJbZltjXV0uY29uY2F0KGhbZltjXV0pfX1yZXR1cm4gaX0oYSx0KSxsPVwiXCI7T2JqZWN0LmtleXMobykuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm5cIm1haW5cIiE9PXR9KSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7b1t0XVtlXTspZSsrO29bdF0ucHVzaChlKSxhW3RdW2VdPVwiKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgeyBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX187IH0pXCIsbD1sK1widmFyIFwiK3QrXCIgPSAoXCIraS50b1N0cmluZygpLnJlcGxhY2UoXCJFTlRSWV9NT0RVTEVcIixKU09OLnN0cmluZ2lmeShlKSkrXCIpKHtcIitvW3RdLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KGUpK1wiOiBcIithW3RdW2VdLnRvU3RyaW5nKCl9KSkuam9pbihcIixcIikrXCJ9KTtcXG5cIn0pKSxsPWwrXCJuZXcgKChcIitpLnRvU3RyaW5nKCkucmVwbGFjZShcIkVOVFJZX01PRFVMRVwiLEpTT04uc3RyaW5naWZ5KHQpKStcIikoe1wiK28ubWFpbi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBKU09OLnN0cmluZ2lmeSh0KStcIjogXCIrYS5tYWluW3RdLnRvU3RyaW5nKCl9KSkuam9pbihcIixcIikrXCJ9KSkoc2VsZik7XCI7dmFyIHU9bmV3IHdpbmRvdy5CbG9iKFtsXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSk7aWYoZS5iYXJlKXJldHVybiB1O3ZhciBkPSh3aW5kb3cuVVJMfHx3aW5kb3cud2Via2l0VVJMfHx3aW5kb3cubW96VVJMfHx3aW5kb3cubXNVUkwpLmNyZWF0ZU9iamVjdFVSTCh1KSxoPW5ldyB3aW5kb3cuV29ya2VyKGQpO3JldHVybiBoLm9iamVjdFVSTD1kLGh9fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ci5yKGUpLHIuZChlLFwiZGVmYXVsdFwiLChmdW5jdGlvbigpe3JldHVybiBvfSkpO3ZhciBpPXIoOSksYT1yKDApLG49cigxKSxzPXIoMTMpO2Z1bmN0aW9uIG8odCl7dmFyIGU9bmV3IHMuRXZlbnRFbWl0dGVyLHI9ZnVuY3Rpb24oZSxyKXt0LnBvc3RNZXNzYWdlKHtldmVudDplLGRhdGE6cn0pfTtlLm9uKGEuYS5GUkFHX0RFQ1JZUFRFRCxyKSxlLm9uKGEuYS5FUlJPUixyKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsKGZ1bmN0aW9uKGEpe3ZhciBzPWEuZGF0YTtzd2l0Y2gocy5jbWQpe2Nhc2VcImluaXRcIjp2YXIgbz1KU09OLnBhcnNlKHMuY29uZmlnKTt0LnRyYW5zbXV4ZXI9bmV3IGkuYyhlLHMudHlwZVN1cHBvcnRlZCxvLHMudmVuZG9yLHMuaWQpLE9iamVjdChuLmEpKG8uZGVidWcpLHIoXCJpbml0XCIsbnVsbCk7YnJlYWs7Y2FzZVwiY29uZmlndXJlXCI6dC50cmFuc211eGVyLmNvbmZpZ3VyZShzLmNvbmZpZyk7YnJlYWs7Y2FzZVwiZGVtdXhcIjp2YXIgdT10LnRyYW5zbXV4ZXIucHVzaChzLmRhdGEscy5kZWNyeXB0ZGF0YSxzLmNodW5rTWV0YSxzLnN0YXRlKTtPYmplY3QoaS5kKSh1KT91LnRoZW4oKGZ1bmN0aW9uKGUpe2wodCxlKX0pKTpsKHQsdSk7YnJlYWs7Y2FzZVwiZmx1c2hcIjp2YXIgaD1zLmNodW5rTWV0YSxmPXQudHJhbnNtdXhlci5mbHVzaChoKTtPYmplY3QoaS5kKShmKT9mLnRoZW4oKGZ1bmN0aW9uKGUpe2QodCxlLGgpfSkpOmQodCxmLGgpfX0pKX1mdW5jdGlvbiBsKHQsZSl7aWYoKHI9ZS5yZW11eFJlc3VsdCkuYXVkaW98fHIudmlkZW98fHIudGV4dHx8ci5pZDN8fHIuaW5pdFNlZ21lbnQpe3ZhciByLGk9W10sYT1lLnJlbXV4UmVzdWx0LG49YS5hdWRpbyxzPWEudmlkZW87biYmdShpLG4pLHMmJnUoaSxzKSx0LnBvc3RNZXNzYWdlKHtldmVudDpcInRyYW5zbXV4Q29tcGxldGVcIixkYXRhOmV9LGkpfX1mdW5jdGlvbiB1KHQsZSl7ZS5kYXRhMSYmdC5wdXNoKGUuZGF0YTEuYnVmZmVyKSxlLmRhdGEyJiZ0LnB1c2goZS5kYXRhMi5idWZmZXIpfWZ1bmN0aW9uIGQodCxlLHIpe2UuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bCh0LGUpfSkpLHQucG9zdE1lc3NhZ2Uoe2V2ZW50OlwiZmx1c2hcIixkYXRhOnJ9KX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLnIoZSksci5kKGUsXCJkZWZhdWx0XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHdlfSkpO3ZhciBpPXIoMTEpLGE9cigzKSxuPXIoMCkscz1yKDIpLG89cigxKSxsPXIoNiksdT1yKDUpO2Z1bmN0aW9uIGQodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaS5rZXksaSl9fXZhciBoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLlBUU0tub3duPSExLHRoaXMuYWxpZ25lZFNsaWRpbmc9ITEsdGhpcy5hdmVyYWdldGFyZ2V0ZHVyYXRpb249dm9pZCAwLHRoaXMuZW5kQ0M9MCx0aGlzLmVuZFNOPTAsdGhpcy5mcmFnbWVudHM9dm9pZCAwLHRoaXMuZnJhZ21lbnRIaW50PXZvaWQgMCx0aGlzLnBhcnRMaXN0PW51bGwsdGhpcy5saXZlPSEwLHRoaXMuYWdlSGVhZGVyPTAsdGhpcy5hZHZhbmNlZERhdGVUaW1lPXZvaWQgMCx0aGlzLnVwZGF0ZWQ9ITAsdGhpcy5hZHZhbmNlZD0hMCx0aGlzLmF2YWlsYWJpbGl0eURlbGF5PXZvaWQgMCx0aGlzLm1pc3Nlcz0wLHRoaXMubmVlZFNpZHhSYW5nZXM9ITEsdGhpcy5zdGFydENDPTAsdGhpcy5zdGFydFNOPTAsdGhpcy5zdGFydFRpbWVPZmZzZXQ9bnVsbCx0aGlzLnRhcmdldGR1cmF0aW9uPTAsdGhpcy50b3RhbGR1cmF0aW9uPTAsdGhpcy50eXBlPW51bGwsdGhpcy51cmw9dm9pZCAwLHRoaXMubTN1OD1cIlwiLHRoaXMudmVyc2lvbj1udWxsLHRoaXMuY2FuQmxvY2tSZWxvYWQ9ITEsdGhpcy5jYW5Ta2lwVW50aWw9MCx0aGlzLmNhblNraXBEYXRlUmFuZ2VzPSExLHRoaXMuc2tpcHBlZFNlZ21lbnRzPTAsdGhpcy5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzPXZvaWQgMCx0aGlzLnBhcnRIb2xkQmFjaz0wLHRoaXMuaG9sZEJhY2s9MCx0aGlzLnBhcnRUYXJnZXQ9MCx0aGlzLnByZWxvYWRIaW50PXZvaWQgMCx0aGlzLnJlbmRpdGlvblJlcG9ydHM9dm9pZCAwLHRoaXMudHVuZUluR29hbD0wLHRoaXMuZGVsdGFVcGRhdGVGYWlsZWQ9dm9pZCAwLHRoaXMuZHJpZnRTdGFydFRpbWU9MCx0aGlzLmRyaWZ0RW5kVGltZT0wLHRoaXMuZHJpZnRTdGFydD0wLHRoaXMuZHJpZnRFbmQ9MCx0aGlzLmZyYWdtZW50cz1bXSx0aGlzLnVybD10fXZhciBlLHIsaTtyZXR1cm4gdC5wcm90b3R5cGUucmVsb2FkZWQ9ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuIHRoaXMuYWR2YW5jZWQ9ITAsdm9pZCh0aGlzLnVwZGF0ZWQ9ITApO3ZhciBlPXRoaXMubGFzdFBhcnRTbi10Lmxhc3RQYXJ0U24scj10aGlzLmxhc3RQYXJ0SW5kZXgtdC5sYXN0UGFydEluZGV4O3RoaXMudXBkYXRlZD10aGlzLmVuZFNOIT09dC5lbmRTTnx8ISFyfHwhIWUsdGhpcy5hZHZhbmNlZD10aGlzLmVuZFNOPnQuZW5kU058fGU+MHx8MD09PWUmJnI+MCx0aGlzLnVwZGF0ZWR8fHRoaXMuYWR2YW5jZWQ/dGhpcy5taXNzZXM9TWF0aC5mbG9vciguNip0Lm1pc3Nlcyk6dGhpcy5taXNzZXM9dC5taXNzZXMrMSx0aGlzLmF2YWlsYWJpbGl0eURlbGF5PXQuYXZhaWxhYmlsaXR5RGVsYXl9LGU9dCwocj1be2tleTpcImhhc1Byb2dyYW1EYXRlVGltZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiEhdGhpcy5mcmFnbWVudHMubGVuZ3RoJiZPYmplY3QoYS5hKSh0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGgtMV0ucHJvZ3JhbURhdGVUaW1lKX19LHtrZXk6XCJsZXZlbFRhcmdldER1cmF0aW9uXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9ufHx0aGlzLnRhcmdldGR1cmF0aW9ufHwxMH19LHtrZXk6XCJkcmlmdFwiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZHJpZnRFbmRUaW1lLXRoaXMuZHJpZnRTdGFydFRpbWU7cmV0dXJuIHQ+MD8xZTMqKHRoaXMuZHJpZnRFbmQtdGhpcy5kcmlmdFN0YXJ0KS90OjF9fSx7a2V5OlwiZWRnZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnRFbmR8fHRoaXMuZnJhZ21lbnRFbmR9fSx7a2V5OlwicGFydEVuZFwiLGdldDpmdW5jdGlvbigpe3ZhciB0O3JldHVybiBudWxsIT09KHQ9dGhpcy5wYXJ0TGlzdCkmJnZvaWQgMCE9PXQmJnQubGVuZ3RoP3RoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGgtMV0uZW5kOnRoaXMuZnJhZ21lbnRFbmR9fSx7a2V5OlwiZnJhZ21lbnRFbmRcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gbnVsbCE9PSh0PXRoaXMuZnJhZ21lbnRzKSYmdm9pZCAwIT09dCYmdC5sZW5ndGg/dGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoLTFdLmVuZDowfX0se2tleTpcImFnZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmFkdmFuY2VkRGF0ZVRpbWU/TWF0aC5tYXgoRGF0ZS5ub3coKS10aGlzLmFkdmFuY2VkRGF0ZVRpbWUsMCkvMWUzOjB9fSx7a2V5OlwibGFzdFBhcnRJbmRleFwiLGdldDpmdW5jdGlvbigpe3ZhciB0O3JldHVybiBudWxsIT09KHQ9dGhpcy5wYXJ0TGlzdCkmJnZvaWQgMCE9PXQmJnQubGVuZ3RoP3RoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGgtMV0uaW5kZXg6LTF9fSx7a2V5OlwibGFzdFBhcnRTblwiLGdldDpmdW5jdGlvbigpe3ZhciB0O3JldHVybiBudWxsIT09KHQ9dGhpcy5wYXJ0TGlzdCkmJnZvaWQgMCE9PXQmJnQubGVuZ3RoP3RoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGgtMV0uZnJhZ21lbnQuc246dGhpcy5lbmRTTn19XSkmJmQoZS5wcm90b3R5cGUsciksaSYmZChlLGkpLHR9KCksZj1yKDE1KSxjPS9eKFxcZCspeChcXGQrKSQvLHY9L1xccyooLis/KVxccyo9KCg/OlxcXCIuKj9cXFwiKXwuKj8pKD86LHwkKS9nLGc9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe2Zvcih2YXIgciBpblwic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT10LnBhcnNlQXR0ckxpc3QoZSkpLGUpZS5oYXNPd25Qcm9wZXJ0eShyKSYmKHRoaXNbcl09ZVtyXSl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuZGVjaW1hbEludGVnZXI9ZnVuY3Rpb24odCl7dmFyIGU9cGFyc2VJbnQodGhpc1t0XSwxMCk7cmV0dXJuIGU+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI/MS8wOmV9LGUuaGV4YWRlY2ltYWxJbnRlZ2VyPWZ1bmN0aW9uKHQpe2lmKHRoaXNbdF0pe3ZhciBlPSh0aGlzW3RdfHxcIjB4XCIpLnNsaWNlKDIpO2U9KDEmZS5sZW5ndGg/XCIwXCI6XCJcIikrZTtmb3IodmFyIHI9bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgvMiksaT0wO2k8ZS5sZW5ndGgvMjtpKyspcltpXT1wYXJzZUludChlLnNsaWNlKDIqaSwyKmkrMiksMTYpO3JldHVybiByfXJldHVybiBudWxsfSxlLmhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyPWZ1bmN0aW9uKHQpe3ZhciBlPXBhcnNlSW50KHRoaXNbdF0sMTYpO3JldHVybiBlPk51bWJlci5NQVhfU0FGRV9JTlRFR0VSPzEvMDplfSxlLmRlY2ltYWxGbG9hdGluZ1BvaW50PWZ1bmN0aW9uKHQpe3JldHVybiBwYXJzZUZsb2F0KHRoaXNbdF0pfSxlLm9wdGlvbmFsRmxvYXQ9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzW3RdO3JldHVybiByP3BhcnNlRmxvYXQocik6ZX0sZS5lbnVtZXJhdGVkU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzW3RdfSxlLmJvb2w9ZnVuY3Rpb24odCl7cmV0dXJuXCJZRVNcIj09PXRoaXNbdF19LGUuZGVjaW1hbFJlc29sdXRpb249ZnVuY3Rpb24odCl7dmFyIGU9Yy5leGVjKHRoaXNbdF0pO2lmKG51bGwhPT1lKXJldHVybnt3aWR0aDpwYXJzZUludChlWzFdLDEwKSxoZWlnaHQ6cGFyc2VJbnQoZVsyXSwxMCl9fSx0LnBhcnNlQXR0ckxpc3Q9ZnVuY3Rpb24odCl7dmFyIGUscj17fTtmb3Iodi5sYXN0SW5kZXg9MDtudWxsIT09KGU9di5leGVjKHQpKTspe3ZhciBpPWVbMl07MD09PWkuaW5kZXhPZignXCInKSYmaS5sYXN0SW5kZXhPZignXCInKT09PWkubGVuZ3RoLTEmJihpPWkuc2xpY2UoMSwtMSkpLHJbZVsxXV09aX1yZXR1cm4gcn0sdH0oKSxwPXthdWRpbzp7YTNkczohMCxcImFjLTNcIjohMCxcImFjLTRcIjohMCxhbGFjOiEwLGFsYXc6ITAsZHJhMTohMCxcImR0cytcIjohMCxcImR0cy1cIjohMCxkdHNjOiEwLGR0c2U6ITAsZHRzaDohMCxcImVjLTNcIjohMCxlbmNhOiEwLGc3MTk6ITAsZzcyNjohMCxtNGFlOiEwLG1oYTE6ITAsbWhhMjohMCxtaG0xOiEwLG1obTI6ITAsbWxwYTohMCxtcDRhOiEwLFwicmF3IFwiOiEwLE9wdXM6ITAsc2FtcjohMCxzYXdiOiEwLHNhd3A6ITAsc2V2YzohMCxzcWNwOiEwLHNzbXY6ITAsdHdvczohMCx1bGF3OiEwfSx2aWRlbzp7YXZjMTohMCxhdmMyOiEwLGF2YzM6ITAsYXZjNDohMCxhdmNwOiEwLGF2MDE6ITAsZHJhYzohMCxkdmF2OiEwLGR2aGU6ITAsZW5jdjohMCxoZXYxOiEwLGh2YzE6ITAsbWpwMjohMCxtcDR2OiEwLG12YzE6ITAsbXZjMjohMCxtdmMzOiEwLG12YzQ6ITAscmVzdjohMCxydjYwOiEwLHMyNjM6ITAsc3ZjMTohMCxzdmMyOiEwLFwidmMtMVwiOiEwLHZwMDg6ITAsdnAwOTohMH0sdGV4dDp7c3RwcDohMCx3dnR0OiEwfX07ZnVuY3Rpb24gbSh0LGUpe3JldHVybiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoKGV8fFwidmlkZW9cIikrJy9tcDQ7Y29kZWNzPVwiJyt0KydcIicpfXZhciB5PS8jRVhULVgtU1RSRUFNLUlORjooW15cXHJcXG5dKikoPzpbXFxyXFxuXSg/OiNbXlxcclxcbl0qKT8pKihbXlxcclxcbl0rKXwjRVhULVgtU0VTU0lPTi1EQVRBOihbXlxcclxcbl0qKVtcXHJcXG5dKy9nLGI9LyNFWFQtWC1NRURJQTooLiopL2csVD1uZXcgUmVnRXhwKFsvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSwvKD8hIykgKihcXFNbXFxTIF0qKS8uc291cmNlLC8jRVhULVgtQllURVJBTkdFOiooLispLy5zb3VyY2UsLyNFWFQtWC1QUk9HUkFNLURBVEUtVElNRTooLispLy5zb3VyY2UsLyMuKi8uc291cmNlXS5qb2luKFwifFwiKSxcImdcIiksRT1uZXcgUmVnRXhwKFsvIyhFWFRNM1UpLy5zb3VyY2UsLyNFWFQtWC0oUExBWUxJU1QtVFlQRSk6KC4rKS8uc291cmNlLC8jRVhULVgtKE1FRElBLVNFUVVFTkNFKTogKihcXGQrKS8uc291cmNlLC8jRVhULVgtKFNLSVApOiguKykvLnNvdXJjZSwvI0VYVC1YLShUQVJHRVREVVJBVElPTik6ICooXFxkKykvLnNvdXJjZSwvI0VYVC1YLShLRVkpOiguKykvLnNvdXJjZSwvI0VYVC1YLShTVEFSVCk6KC4rKS8uc291cmNlLC8jRVhULVgtKEVORExJU1QpLy5zb3VyY2UsLyNFWFQtWC0oRElTQ09OVElOVUlUWS1TRVEpVUVOQ0U6ICooXFxkKykvLnNvdXJjZSwvI0VYVC1YLShESVMpQ09OVElOVUlUWS8uc291cmNlLC8jRVhULVgtKFZFUlNJT04pOihcXGQrKS8uc291cmNlLC8jRVhULVgtKE1BUCk6KC4rKS8uc291cmNlLC8jRVhULVgtKFNFUlZFUi1DT05UUk9MKTooLispLy5zb3VyY2UsLyNFWFQtWC0oUEFSVC1JTkYpOiguKykvLnNvdXJjZSwvI0VYVC1YLShHQVApLy5zb3VyY2UsLyNFWFQtWC0oQklUUkFURSk6XFxzKihcXGQrKS8uc291cmNlLC8jRVhULVgtKFBBUlQpOiguKykvLnNvdXJjZSwvI0VYVC1YLShQUkVMT0FELUhJTlQpOiguKykvLnNvdXJjZSwvI0VYVC1YLShSRU5ESVRJT04tUkVQT1JUKTooLispLy5zb3VyY2UsLygjKShbXjpdKik6KC4qKS8uc291cmNlLC8oIykoLiopKD86LiopXFxyP1xcbj8vLnNvdXJjZV0uam9pbihcInxcIikpLFM9L1xcLihtcDR8bTRzfG00dnxtNGEpJC9pO3ZhciBMPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5maW5kR3JvdXA9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGk9dFtyXTtpZihpLmlkPT09ZSlyZXR1cm4gaX19LHQuY29udmVydEFWQzFUb0FWQ09UST1mdW5jdGlvbih0KXt2YXIgZT10LnNwbGl0KFwiLlwiKTtpZihlLmxlbmd0aD4yKXt2YXIgcj1lLnNoaWZ0KCkrXCIuXCI7cmV0dXJuIHIrPXBhcnNlSW50KGUuc2hpZnQoKSkudG9TdHJpbmcoMTYpLHIrPShcIjAwMFwiK3BhcnNlSW50KGUuc2hpZnQoKSkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTQpfXJldHVybiB0fSx0LnJlc29sdmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaS5idWlsZEFic29sdXRlVVJMKGUsdCx7YWx3YXlzTm9ybWFsaXplOiEwfSl9LHQucGFyc2VNYXN0ZXJQbGF5bGlzdD1mdW5jdGlvbihlLHIpe3ZhciBpLGE9W10sbj17fSxzPSExO2Zvcih5Lmxhc3RJbmRleD0wO251bGwhPShpPXkuZXhlYyhlKSk7KWlmKGlbMV0pe3ZhciBvPW5ldyBnKGlbMV0pLGw9e2F0dHJzOm8sYml0cmF0ZTpvLmRlY2ltYWxJbnRlZ2VyKFwiQVZFUkFHRS1CQU5EV0lEVEhcIil8fG8uZGVjaW1hbEludGVnZXIoXCJCQU5EV0lEVEhcIiksbmFtZTpvLk5BTUUsdXJsOnQucmVzb2x2ZShpWzJdLHIpfSx1PW8uZGVjaW1hbFJlc29sdXRpb24oXCJSRVNPTFVUSU9OXCIpO3UmJihsLndpZHRoPXUud2lkdGgsbC5oZWlnaHQ9dS5oZWlnaHQpLEEoKG8uQ09ERUNTfHxcIlwiKS5zcGxpdCgvWyAsXSsvKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpLGwpLGwudmlkZW9Db2RlYyYmLTEhPT1sLnZpZGVvQ29kZWMuaW5kZXhPZihcImF2YzFcIikmJihsLnZpZGVvQ29kZWM9dC5jb252ZXJ0QVZDMVRvQVZDT1RJKGwudmlkZW9Db2RlYykpLGEucHVzaChsKX1lbHNlIGlmKGlbM10pe3ZhciBkPW5ldyBnKGlbM10pO2RbXCJEQVRBLUlEXCJdJiYocz0hMCxuW2RbXCJEQVRBLUlEXCJdXT1kKX1yZXR1cm57bGV2ZWxzOmEsc2Vzc2lvbkRhdGE6cz9uOm51bGx9fSx0LnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYT1mdW5jdGlvbihlLHIsaSxhKXt2YXIgbjt2b2lkIDA9PT1hJiYoYT1bXSk7dmFyIHM9W10sbz0wO2ZvcihiLmxhc3RJbmRleD0wO251bGwhPT0obj1iLmV4ZWMoZSkpOyl7dmFyIGw9bmV3IGcoblsxXSk7aWYobC5UWVBFPT09aSl7dmFyIHU9e2F0dHJzOmwsYml0cmF0ZTowLGlkOm8rKyxncm91cElkOmxbXCJHUk9VUC1JRFwiXSxpbnN0cmVhbUlkOmxbXCJJTlNUUkVBTS1JRFwiXSxuYW1lOmwuTkFNRXx8bC5MQU5HVUFHRXx8XCJcIix0eXBlOmksZGVmYXVsdDpsLmJvb2woXCJERUZBVUxUXCIpLGF1dG9zZWxlY3Q6bC5ib29sKFwiQVVUT1NFTEVDVFwiKSxmb3JjZWQ6bC5ib29sKFwiRk9SQ0VEXCIpLGxhbmc6bC5MQU5HVUFHRSx1cmw6bC5VUkk/dC5yZXNvbHZlKGwuVVJJLHIpOlwiXCJ9O2lmKGEubGVuZ3RoKXt2YXIgZD10LmZpbmRHcm91cChhLHUuZ3JvdXBJZCl8fGFbMF07Uih1LGQsXCJhdWRpb0NvZGVjXCIpLFIodSxkLFwidGV4dENvZGVjXCIpfXMucHVzaCh1KX19cmV0dXJuIHN9LHQucGFyc2VMZXZlbFBsYXlsaXN0PWZ1bmN0aW9uKHQsZSxyLG4scyl7dmFyIGwsZCxjLHY9bmV3IGgoZSkscD12LmZyYWdtZW50cyxtPW51bGwseT0wLGI9MCxMPTAsQT0wLFI9bnVsbCxfPW5ldyB1LmIobixlKSxrPS0xLHg9ITE7Zm9yKFQubGFzdEluZGV4PTAsdi5tM3U4PXQ7bnVsbCE9PShsPVQuZXhlYyh0KSk7KXt4JiYoeD0hMSwoXz1uZXcgdS5iKG4sZSkpLnN0YXJ0PUwsXy5zbj15LF8uY2M9QSxfLmxldmVsPXIsbSYmKF8uaW5pdFNlZ21lbnQ9bSxfLnJhd1Byb2dyYW1EYXRlVGltZT1tLnJhd1Byb2dyYW1EYXRlVGltZSkpO3ZhciBDPWxbMV07aWYoQyl7Xy5kdXJhdGlvbj1wYXJzZUZsb2F0KEMpO3ZhciB3PShcIiBcIitsWzJdKS5zbGljZSgxKTtfLnRpdGxlPXd8fG51bGwsXy50YWdMaXN0LnB1c2godz9bXCJJTkZcIixDLHddOltcIklORlwiLENdKX1lbHNlIGlmKGxbM10pT2JqZWN0KGEuYSkoXy5kdXJhdGlvbikmJihfLnN0YXJ0PUwsYyYmKF8ubGV2ZWxrZXk9YyksXy5zbj15LF8ubGV2ZWw9cixfLmNjPUEsXy51cmxJZD1zLHAucHVzaChfKSxfLnJlbHVybD0oXCIgXCIrbFszXSkuc2xpY2UoMSksRChfLFIpLFI9XyxMKz1fLmR1cmF0aW9uLHkrKyxiPTAseD0hMCk7ZWxzZSBpZihsWzRdKXt2YXIgTz0oXCIgXCIrbFs0XSkuc2xpY2UoMSk7Uj9fLnNldEJ5dGVSYW5nZShPLFIpOl8uc2V0Qnl0ZVJhbmdlKE8pfWVsc2UgaWYobFs1XSlfLnJhd1Byb2dyYW1EYXRlVGltZT0oXCIgXCIrbFs1XSkuc2xpY2UoMSksXy50YWdMaXN0LnB1c2goW1wiUFJPR1JBTS1EQVRFLVRJTUVcIixfLnJhd1Byb2dyYW1EYXRlVGltZV0pLC0xPT09ayYmKGs9cC5sZW5ndGgpO2Vsc2V7aWYoIShsPWxbMF0ubWF0Y2goRSkpKXtvLmIud2FybihcIk5vIG1hdGNoZXMgb24gc2xvdyByZWdleCBtYXRjaCBmb3IgbGV2ZWwgcGxheWxpc3QhXCIpO2NvbnRpbnVlfWZvcihkPTE7ZDxsLmxlbmd0aCYmdm9pZCAwPT09bFtkXTtkKyspO3ZhciBJPShcIiBcIitsW2RdKS5zbGljZSgxKSxQPShcIiBcIitsW2QrMV0pLnNsaWNlKDEpLEY9bFtkKzJdPyhcIiBcIitsW2QrMl0pLnNsaWNlKDEpOlwiXCI7c3dpdGNoKEkpe2Nhc2VcIlBMQVlMSVNULVRZUEVcIjp2LnR5cGU9UC50b1VwcGVyQ2FzZSgpO2JyZWFrO2Nhc2VcIk1FRElBLVNFUVVFTkNFXCI6eT12LnN0YXJ0U049cGFyc2VJbnQoUCk7YnJlYWs7Y2FzZVwiU0tJUFwiOnZhciBNPW5ldyBnKFApLE49TS5kZWNpbWFsSW50ZWdlcihcIlNLSVBQRUQtU0VHTUVOVFNcIik7aWYoT2JqZWN0KGEuYSkoTikpe3Yuc2tpcHBlZFNlZ21lbnRzPU47Zm9yKHZhciBCPU47Qi0tOylwLnVuc2hpZnQobnVsbCk7eSs9Tn12YXIgVT1NLmVudW1lcmF0ZWRTdHJpbmcoXCJSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVNcIik7VSYmKHYucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcz1VLnNwbGl0KFwiXFx0XCIpKTticmVhaztjYXNlXCJUQVJHRVREVVJBVElPTlwiOnYudGFyZ2V0ZHVyYXRpb249cGFyc2VGbG9hdChQKTticmVhaztjYXNlXCJWRVJTSU9OXCI6di52ZXJzaW9uPXBhcnNlSW50KFApO2JyZWFrO2Nhc2VcIkVYVE0zVVwiOmJyZWFrO2Nhc2VcIkVORExJU1RcIjp2LmxpdmU9ITE7YnJlYWs7Y2FzZVwiI1wiOihQfHxGKSYmXy50YWdMaXN0LnB1c2goRj9bUCxGXTpbUF0pO2JyZWFrO2Nhc2VcIkRJU1wiOkErKztjYXNlXCJHQVBcIjpfLnRhZ0xpc3QucHVzaChbSV0pO2JyZWFrO2Nhc2VcIkJJVFJBVEVcIjpfLnRhZ0xpc3QucHVzaChbSSxQXSk7YnJlYWs7Y2FzZVwiRElTQ09OVElOVUlUWS1TRVFcIjpBPXBhcnNlSW50KFApO2JyZWFrO2Nhc2VcIktFWVwiOnZhciBHLGo9bmV3IGcoUCksSD1qLmVudW1lcmF0ZWRTdHJpbmcoXCJNRVRIT0RcIiksSz1qLlVSSSxWPWouaGV4YWRlY2ltYWxJbnRlZ2VyKFwiSVZcIiksVz1qLmVudW1lcmF0ZWRTdHJpbmcoXCJLRVlGT1JNQVRWRVJTSU9OU1wiKSxZPWouZW51bWVyYXRlZFN0cmluZyhcIktFWUlEXCIpLFg9bnVsbCE9KEc9ai5lbnVtZXJhdGVkU3RyaW5nKFwiS0VZRk9STUFUXCIpKT9HOlwiaWRlbnRpdHlcIjtpZihbXCJjb20uYXBwbGUuc3RyZWFtaW5na2V5ZGVsaXZlcnlcIixcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCIsXCJ1cm46dXVpZDplZGVmOGJhOS03OWQ2LTRhY2UtYTNjOC0yN2RjZDUxZDIxZWRcIixcImNvbS53aWRldmluZVwiXS5pbmRleE9mKFgpPi0xKXtvLmIud2FybihcIktleWZvcm1hdCBcIitYK1wiIGlzIG5vdCBzdXBwb3J0ZWQgZnJvbSB0aGUgbWFuaWZlc3RcIik7Y29udGludWV9aWYoXCJpZGVudGl0eVwiIT09WCljb250aW51ZTtIJiYoYz1mLmEuZnJvbVVSTChlLEspLEsmJltcIkFFUy0xMjhcIixcIlNBTVBMRS1BRVNcIixcIlNBTVBMRS1BRVMtQ0VOQ1wiXS5pbmRleE9mKEgpPj0wJiYoYy5tZXRob2Q9SCxjLmtleUZvcm1hdD1YLFkmJihjLmtleUlEPVkpLFcmJihjLmtleUZvcm1hdFZlcnNpb25zPVcpLGMuaXY9VikpO2JyZWFrO2Nhc2VcIlNUQVJUXCI6dmFyIHE9bmV3IGcoUCkuZGVjaW1hbEZsb2F0aW5nUG9pbnQoXCJUSU1FLU9GRlNFVFwiKTtPYmplY3QoYS5hKShxKSYmKHYuc3RhcnRUaW1lT2Zmc2V0PXEpO2JyZWFrO2Nhc2VcIk1BUFwiOnZhciB6PW5ldyBnKFApO18ucmVsdXJsPXouVVJJLHouQllURVJBTkdFJiZfLnNldEJ5dGVSYW5nZSh6LkJZVEVSQU5HRSksXy5sZXZlbD1yLF8uc249XCJpbml0U2VnbWVudFwiLGMmJihfLmxldmVsa2V5PWMpLF8uaW5pdFNlZ21lbnQ9bnVsbCxtPV8seD0hMDticmVhaztjYXNlXCJTRVJWRVItQ09OVFJPTFwiOnZhciBRPW5ldyBnKFApO3YuY2FuQmxvY2tSZWxvYWQ9US5ib29sKFwiQ0FOLUJMT0NLLVJFTE9BRFwiKSx2LmNhblNraXBVbnRpbD1RLm9wdGlvbmFsRmxvYXQoXCJDQU4tU0tJUC1VTlRJTFwiLDApLHYuY2FuU2tpcERhdGVSYW5nZXM9di5jYW5Ta2lwVW50aWw+MCYmUS5ib29sKFwiQ0FOLVNLSVAtREFURVJBTkdFU1wiKSx2LnBhcnRIb2xkQmFjaz1RLm9wdGlvbmFsRmxvYXQoXCJQQVJULUhPTEQtQkFDS1wiLDApLHYuaG9sZEJhY2s9US5vcHRpb25hbEZsb2F0KFwiSE9MRC1CQUNLXCIsMCk7YnJlYWs7Y2FzZVwiUEFSVC1JTkZcIjp2YXIgJD1uZXcgZyhQKTt2LnBhcnRUYXJnZXQ9JC5kZWNpbWFsRmxvYXRpbmdQb2ludChcIlBBUlQtVEFSR0VUXCIpO2JyZWFrO2Nhc2VcIlBBUlRcIjp2YXIgWj12LnBhcnRMaXN0O1p8fChaPXYucGFydExpc3Q9W10pO3ZhciBKPWI+MD9aW1oubGVuZ3RoLTFdOnZvaWQgMCx0dD1iKyssZXQ9bmV3IHUuYyhuZXcgZyhQKSxfLGUsdHQsSik7Wi5wdXNoKGV0KSxfLmR1cmF0aW9uKz1ldC5kdXJhdGlvbjticmVhaztjYXNlXCJQUkVMT0FELUhJTlRcIjp2YXIgcnQ9bmV3IGcoUCk7di5wcmVsb2FkSGludD1ydDticmVhaztjYXNlXCJSRU5ESVRJT04tUkVQT1JUXCI6dmFyIGl0PW5ldyBnKFApO3YucmVuZGl0aW9uUmVwb3J0cz12LnJlbmRpdGlvblJlcG9ydHN8fFtdLHYucmVuZGl0aW9uUmVwb3J0cy5wdXNoKGl0KTticmVhaztkZWZhdWx0Om8uYi53YXJuKFwibGluZSBwYXJzZWQgYnV0IG5vdCBoYW5kbGVkOiBcIitsKX19fVImJiFSLnJlbHVybD8ocC5wb3AoKSxMLT1SLmR1cmF0aW9uLHYucGFydExpc3QmJih2LmZyYWdtZW50SGludD1SKSk6di5wYXJ0TGlzdCYmKEQoXyxSKSxfLmNjPUEsdi5mcmFnbWVudEhpbnQ9Xyk7dmFyIGF0PXAubGVuZ3RoLG50PXBbMF0sc3Q9cFthdC0xXTtpZigoTCs9di5za2lwcGVkU2VnbWVudHMqdi50YXJnZXRkdXJhdGlvbik+MCYmYXQmJnN0KXt2LmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbj1ML2F0O3ZhciBvdD1zdC5zbjt2LmVuZFNOPVwiaW5pdFNlZ21lbnRcIiE9PW90P290OjAsbnQmJih2LnN0YXJ0Q0M9bnQuY2MsbnQuaW5pdFNlZ21lbnR8fHYuZnJhZ21lbnRzLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWx1cmwmJihlPXQucmVsdXJsLFMudGVzdChudWxsIT0ocj1udWxsPT09KGE9aS5wYXJzZVVSTChlKSl8fHZvaWQgMD09PWE/dm9pZCAwOmEucGF0aCk/cjpcIlwiKSk7dmFyIGUscixhfSkpJiYoby5iLndhcm4oXCJNUDQgZnJhZ21lbnRzIGZvdW5kIGJ1dCBubyBpbml0IHNlZ21lbnQgKHByb2JhYmx5IG5vIE1BUCwgaW5jb21wbGV0ZSBNM1U4KSwgdHJ5aW5nIHRvIGZldGNoIFNJRFhcIiksKF89bmV3IHUuYihuLGUpKS5yZWx1cmw9c3QucmVsdXJsLF8ubGV2ZWw9cixfLnNuPVwiaW5pdFNlZ21lbnRcIixudC5pbml0U2VnbWVudD1fLHYubmVlZFNpZHhSYW5nZXM9ITApKX1lbHNlIHYuZW5kU049MCx2LnN0YXJ0Q0M9MDtyZXR1cm4gdi5mcmFnbWVudEhpbnQmJihMKz12LmZyYWdtZW50SGludC5kdXJhdGlvbiksdi50b3RhbGR1cmF0aW9uPUwsdi5lbmRDQz1BLGs+MCYmZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9dFtlXSxpPWU7aS0tOyl7dmFyIGE9dFtpXTtpZighYSlyZXR1cm47YS5wcm9ncmFtRGF0ZVRpbWU9ci5wcm9ncmFtRGF0ZVRpbWUtMWUzKmEuZHVyYXRpb24scj1hfX0ocCxrKSx2fSx0fSgpO2Z1bmN0aW9uIEEodCxlKXtbXCJ2aWRlb1wiLFwiYXVkaW9cIixcInRleHRcIl0uZm9yRWFjaCgoZnVuY3Rpb24ocil7dmFyIGk9dC5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUpe3ZhciByPXBbZV07cmV0dXJuISFyJiYhMD09PXJbdC5zbGljZSgwLDQpXX0odCxyKX0pKTtpZihpLmxlbmd0aCl7dmFyIGE9aS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiAwPT09dC5sYXN0SW5kZXhPZihcImF2YzFcIiwwKXx8MD09PXQubGFzdEluZGV4T2YoXCJtcDRhXCIsMCl9KSk7ZVtyK1wiQ29kZWNcIl09YS5sZW5ndGg+MD9hWzBdOmlbMF0sdD10LmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuLTE9PT1pLmluZGV4T2YodCl9KSl9fSkpLGUudW5rbm93bkNvZGVjcz10fWZ1bmN0aW9uIFIodCxlLHIpe3ZhciBpPWVbcl07aSYmKHRbcl09aSl9ZnVuY3Rpb24gRCh0LGUpe3QucmF3UHJvZ3JhbURhdGVUaW1lP3QucHJvZ3JhbURhdGVUaW1lPURhdGUucGFyc2UodC5yYXdQcm9ncmFtRGF0ZVRpbWUpOm51bGwhPWUmJmUucHJvZ3JhbURhdGVUaW1lJiYodC5wcm9ncmFtRGF0ZVRpbWU9ZS5lbmRQcm9ncmFtRGF0ZVRpbWUpLE9iamVjdChhLmEpKHQucHJvZ3JhbURhdGVUaW1lKXx8KHQucHJvZ3JhbURhdGVUaW1lPW51bGwsdC5yYXdQcm9ncmFtRGF0ZVRpbWU9bnVsbCl9dmFyIF89cig0KTtmdW5jdGlvbiBrKHQsZSl7dmFyIHI9dC51cmw7cmV0dXJuIHZvaWQgMCE9PXImJjAhPT1yLmluZGV4T2YoXCJkYXRhOlwiKXx8KHI9ZS51cmwpLHJ9dmFyIHg9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuaGxzPXZvaWQgMCx0aGlzLmxvYWRlcnM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLmhscz10LHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzO3Qub24obi5hLk1BTklGRVNUX0xPQURJTkcsdGhpcy5vbk1hbmlmZXN0TG9hZGluZyx0aGlzKSx0Lm9uKG4uYS5MRVZFTF9MT0FESU5HLHRoaXMub25MZXZlbExvYWRpbmcsdGhpcyksdC5vbihuLmEuQVVESU9fVFJBQ0tfTE9BRElORyx0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsdGhpcyksdC5vbihuLmEuU1VCVElUTEVfVFJBQ0tfTE9BRElORyx0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsdGhpcyl9LGUudW5yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzO3Qub2ZmKG4uYS5NQU5JRkVTVF9MT0FESU5HLHRoaXMub25NYW5pZmVzdExvYWRpbmcsdGhpcyksdC5vZmYobi5hLkxFVkVMX0xPQURJTkcsdGhpcy5vbkxldmVsTG9hZGluZyx0aGlzKSx0Lm9mZihuLmEuQVVESU9fVFJBQ0tfTE9BRElORyx0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsdGhpcyksdC5vZmYobi5hLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkaW5nLHRoaXMpfSxlLmNyZWF0ZUludGVybmFsTG9hZGVyPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuaGxzLmNvbmZpZyxyPWUucExvYWRlcixpPWUubG9hZGVyLGE9bmV3KHJ8fGkpKGUpO3JldHVybiB0LmxvYWRlcj1hLHRoaXMubG9hZGVyc1t0LnR5cGVdPWEsYX0sZS5nZXRJbnRlcm5hbExvYWRlcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5sb2FkZXJzW3QudHlwZV19LGUucmVzZXRJbnRlcm5hbExvYWRlcj1mdW5jdGlvbih0KXt0aGlzLmxvYWRlcnNbdF0mJmRlbGV0ZSB0aGlzLmxvYWRlcnNbdF19LGUuZGVzdHJveUludGVybmFsTG9hZGVycz1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLmxvYWRlcnMpe3ZhciBlPXRoaXMubG9hZGVyc1t0XTtlJiZlLmRlc3Ryb3koKSx0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIodCl9fSxlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKSx0aGlzLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKX0sZS5vbk1hbmlmZXN0TG9hZGluZz1mdW5jdGlvbih0LGUpe3ZhciByPWUudXJsO3RoaXMubG9hZCh7aWQ6bnVsbCxncm91cElkOm51bGwsbGV2ZWw6MCxyZXNwb25zZVR5cGU6XCJ0ZXh0XCIsdHlwZTpfLmEuTUFOSUZFU1QsdXJsOnIsZGVsaXZlcnlEaXJlY3RpdmVzOm51bGx9KX0sZS5vbkxldmVsTG9hZGluZz1mdW5jdGlvbih0LGUpe3ZhciByPWUuaWQsaT1lLmxldmVsLGE9ZS51cmwsbj1lLmRlbGl2ZXJ5RGlyZWN0aXZlczt0aGlzLmxvYWQoe2lkOnIsZ3JvdXBJZDpudWxsLGxldmVsOmkscmVzcG9uc2VUeXBlOlwidGV4dFwiLHR5cGU6Xy5hLkxFVkVMLHVybDphLGRlbGl2ZXJ5RGlyZWN0aXZlczpufSl9LGUub25BdWRpb1RyYWNrTG9hZGluZz1mdW5jdGlvbih0LGUpe3ZhciByPWUuaWQsaT1lLmdyb3VwSWQsYT1lLnVybCxuPWUuZGVsaXZlcnlEaXJlY3RpdmVzO3RoaXMubG9hZCh7aWQ6cixncm91cElkOmksbGV2ZWw6bnVsbCxyZXNwb25zZVR5cGU6XCJ0ZXh0XCIsdHlwZTpfLmEuQVVESU9fVFJBQ0ssdXJsOmEsZGVsaXZlcnlEaXJlY3RpdmVzOm59KX0sZS5vblN1YnRpdGxlVHJhY2tMb2FkaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5pZCxpPWUuZ3JvdXBJZCxhPWUudXJsLG49ZS5kZWxpdmVyeURpcmVjdGl2ZXM7dGhpcy5sb2FkKHtpZDpyLGdyb3VwSWQ6aSxsZXZlbDpudWxsLHJlc3BvbnNlVHlwZTpcInRleHRcIix0eXBlOl8uYS5TVUJUSVRMRV9UUkFDSyx1cmw6YSxkZWxpdmVyeURpcmVjdGl2ZXM6bn0pfSxlLmxvYWQ9ZnVuY3Rpb24odCl7dmFyIGUscixpLGEsbixzLGw9dGhpcy5obHMuY29uZmlnLHU9dGhpcy5nZXRJbnRlcm5hbExvYWRlcih0KTtpZih1KXt2YXIgZD11LmNvbnRleHQ7aWYoZCYmZC51cmw9PT10LnVybClyZXR1cm4gdm9pZCBvLmIudHJhY2UoXCJbcGxheWxpc3QtbG9hZGVyXTogcGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nXCIpO28uYi5sb2coXCJbcGxheWxpc3QtbG9hZGVyXTogYWJvcnRpbmcgcHJldmlvdXMgbG9hZGVyIGZvciB0eXBlOiBcIit0LnR5cGUpLHUuYWJvcnQoKX1zd2l0Y2godC50eXBlKXtjYXNlIF8uYS5NQU5JRkVTVDpyPWwubWFuaWZlc3RMb2FkaW5nTWF4UmV0cnksaT1sLm1hbmlmZXN0TG9hZGluZ1RpbWVPdXQsYT1sLm1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXksbj1sLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDticmVhaztjYXNlIF8uYS5MRVZFTDpjYXNlIF8uYS5BVURJT19UUkFDSzpjYXNlIF8uYS5TVUJUSVRMRV9UUkFDSzpyPTAsaT1sLmxldmVsTG9hZGluZ1RpbWVPdXQ7YnJlYWs7ZGVmYXVsdDpyPWwubGV2ZWxMb2FkaW5nTWF4UmV0cnksaT1sLmxldmVsTG9hZGluZ1RpbWVPdXQsYT1sLmxldmVsTG9hZGluZ1JldHJ5RGVsYXksbj1sLmxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dH1pZigodT10aGlzLmNyZWF0ZUludGVybmFsTG9hZGVyKHQpLG51bGwhPT0oZT10LmRlbGl2ZXJ5RGlyZWN0aXZlcykmJnZvaWQgMCE9PWUmJmUucGFydCkmJih0LnR5cGU9PT1fLmEuTEVWRUwmJm51bGwhPT10LmxldmVsP3M9dGhpcy5obHMubGV2ZWxzW3QubGV2ZWxdLmRldGFpbHM6dC50eXBlPT09Xy5hLkFVRElPX1RSQUNLJiZudWxsIT09dC5pZD9zPXRoaXMuaGxzLmF1ZGlvVHJhY2tzW3QuaWRdLmRldGFpbHM6dC50eXBlPT09Xy5hLlNVQlRJVExFX1RSQUNLJiZudWxsIT09dC5pZCYmKHM9dGhpcy5obHMuc3VidGl0bGVUcmFja3NbdC5pZF0uZGV0YWlscykscykpe3ZhciBoPXMucGFydFRhcmdldCxmPXMudGFyZ2V0ZHVyYXRpb247aCYmZiYmKGk9TWF0aC5taW4oMWUzKk1hdGgubWF4KDMqaCwuOCpmKSxpKSl9dmFyIGM9e3RpbWVvdXQ6aSxtYXhSZXRyeTpyLHJldHJ5RGVsYXk6YSxtYXhSZXRyeURlbGF5Om4saGlnaFdhdGVyTWFyazowfSx2PXtvblN1Y2Nlc3M6dGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLG9uRXJyb3I6dGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSxvblRpbWVvdXQ6dGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpfTt1LmxvYWQodCxjLHYpfSxlLmxvYWRzdWNjZXNzPWZ1bmN0aW9uKHQsZSxyLGkpe2lmKHZvaWQgMD09PWkmJihpPW51bGwpLHIuaXNTaWR4UmVxdWVzdClyZXR1cm4gdGhpcy5oYW5kbGVTaWR4UmVxdWVzdCh0LHIpLHZvaWQgdGhpcy5oYW5kbGVQbGF5bGlzdExvYWRlZCh0LGUscixpKTt0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoci50eXBlKTt2YXIgYT10LmRhdGE7MD09PWEuaW5kZXhPZihcIiNFWFRNM1VcIik/KGUucGFyc2luZy5zdGFydD1wZXJmb3JtYW5jZS5ub3coKSxhLmluZGV4T2YoXCIjRVhUSU5GOlwiKT4wfHxhLmluZGV4T2YoXCIjRVhULVgtVEFSR0VURFVSQVRJT046XCIpPjA/dGhpcy5oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdCh0LGUscixpKTp0aGlzLmhhbmRsZU1hc3RlclBsYXlsaXN0KHQsZSxyLGkpKTp0aGlzLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHQscixcIm5vIEVYVE0zVSBkZWxpbWl0ZXJcIixpKX0sZS5sb2FkZXJyb3I9ZnVuY3Rpb24odCxlLHIpe3ZvaWQgMD09PXImJihyPW51bGwpLHRoaXMuaGFuZGxlTmV0d29ya0Vycm9yKGUsciwhMSx0KX0sZS5sb2FkdGltZW91dD1mdW5jdGlvbih0LGUscil7dm9pZCAwPT09ciYmKHI9bnVsbCksdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoZSxyLCEwKX0sZS5oYW5kbGVNYXN0ZXJQbGF5bGlzdD1mdW5jdGlvbih0LGUscixpKXt2YXIgYT10aGlzLmhscyxzPXQuZGF0YSxsPWsodCxyKSx1PUwucGFyc2VNYXN0ZXJQbGF5bGlzdChzLGwpLGQ9dS5sZXZlbHMsaD11LnNlc3Npb25EYXRhO2lmKGQubGVuZ3RoKXt2YXIgZj1kLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue2lkOnQuYXR0cnMuQVVESU8sYXVkaW9Db2RlYzp0LmF1ZGlvQ29kZWN9fSkpLGM9ZC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntpZDp0LmF0dHJzLlNVQlRJVExFUyx0ZXh0Q29kZWM6dC50ZXh0Q29kZWN9fSkpLHY9TC5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEocyxsLFwiQVVESU9cIixmKSxwPUwucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHMsbCxcIlNVQlRJVExFU1wiLGMpLG09TC5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEocyxsLFwiQ0xPU0VELUNBUFRJT05TXCIpO2lmKHYubGVuZ3RoKXYuc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIXQudXJsfSkpfHwhZFswXS5hdWRpb0NvZGVjfHxkWzBdLmF0dHJzLkFVRElPfHwoby5iLmxvZyhcIltwbGF5bGlzdC1sb2FkZXJdOiBhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCBidXQgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgc2lnbmFsZWQsIGNyZWF0ZSBvbmVcIiksdi51bnNoaWZ0KHt0eXBlOlwibWFpblwiLG5hbWU6XCJtYWluXCIsZGVmYXVsdDohMSxhdXRvc2VsZWN0OiExLGZvcmNlZDohMSxpZDotMSxhdHRyczpuZXcgZyh7fSksYml0cmF0ZTowLHVybDpcIlwifSkpO2EudHJpZ2dlcihuLmEuTUFOSUZFU1RfTE9BREVELHtsZXZlbHM6ZCxhdWRpb1RyYWNrczp2LHN1YnRpdGxlczpwLGNhcHRpb25zOm0sdXJsOmwsc3RhdHM6ZSxuZXR3b3JrRGV0YWlsczppLHNlc3Npb25EYXRhOmh9KX1lbHNlIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IodCxyLFwibm8gbGV2ZWwgZm91bmQgaW4gbWFuaWZlc3RcIixpKX0sZS5oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdD1mdW5jdGlvbih0LGUscixpKXt2YXIgbz10aGlzLmhscyxsPXIuaWQsdT1yLmxldmVsLGQ9ci50eXBlLGg9ayh0LHIpLGY9T2JqZWN0KGEuYSkobCk/bDowLGM9T2JqZWN0KGEuYSkodSk/dTpmLHY9ZnVuY3Rpb24odCl7c3dpdGNoKHQudHlwZSl7Y2FzZSBfLmEuQVVESU9fVFJBQ0s6cmV0dXJuIF8uYi5BVURJTztjYXNlIF8uYS5TVUJUSVRMRV9UUkFDSzpyZXR1cm4gXy5iLlNVQlRJVExFO2RlZmF1bHQ6cmV0dXJuIF8uYi5NQUlOfX0ocikscD1MLnBhcnNlTGV2ZWxQbGF5bGlzdCh0LmRhdGEsaCxjLHYsZik7aWYocC5mcmFnbWVudHMubGVuZ3RoKXtpZihkPT09Xy5hLk1BTklGRVNUKXt2YXIgbT17YXR0cnM6bmV3IGcoe30pLGJpdHJhdGU6MCxkZXRhaWxzOnAsbmFtZTpcIlwiLHVybDpofTtvLnRyaWdnZXIobi5hLk1BTklGRVNUX0xPQURFRCx7bGV2ZWxzOlttXSxhdWRpb1RyYWNrczpbXSx1cmw6aCxzdGF0czplLG5ldHdvcmtEZXRhaWxzOmksc2Vzc2lvbkRhdGE6bnVsbH0pfWlmKGUucGFyc2luZy5lbmQ9cGVyZm9ybWFuY2Uubm93KCkscC5uZWVkU2lkeFJhbmdlcyl7dmFyIHksYj1udWxsPT09KHk9cC5mcmFnbWVudHNbMF0uaW5pdFNlZ21lbnQpfHx2b2lkIDA9PT15P3ZvaWQgMDp5LnVybDt0aGlzLmxvYWQoe3VybDpiLGlzU2lkeFJlcXVlc3Q6ITAsdHlwZTpkLGxldmVsOnUsbGV2ZWxEZXRhaWxzOnAsaWQ6bCxncm91cElkOm51bGwscmFuZ2VTdGFydDowLHJhbmdlRW5kOjIwNDgscmVzcG9uc2VUeXBlOlwiYXJyYXlidWZmZXJcIixkZWxpdmVyeURpcmVjdGl2ZXM6bnVsbH0pfWVsc2Ugci5sZXZlbERldGFpbHM9cCx0aGlzLmhhbmRsZVBsYXlsaXN0TG9hZGVkKHQsZSxyLGkpfWVsc2Ugby50cmlnZ2VyKG4uYS5FUlJPUix7dHlwZTpzLmIuTkVUV09SS19FUlJPUixkZXRhaWxzOnMuYS5MRVZFTF9FTVBUWV9FUlJPUixmYXRhbDohMSx1cmw6aCxyZWFzb246XCJubyBmcmFnbWVudHMgZm91bmQgaW4gbGV2ZWxcIixsZXZlbDpcIm51bWJlclwiPT10eXBlb2Ygci5sZXZlbD9yLmxldmVsOnZvaWQgMH0pfSxlLmhhbmRsZVNpZHhSZXF1ZXN0PWZ1bmN0aW9uKHQsZSl7dmFyIHI9T2JqZWN0KGwuZykobmV3IFVpbnQ4QXJyYXkodC5kYXRhKSk7aWYocil7dmFyIGk9ci5yZWZlcmVuY2VzLGE9ZS5sZXZlbERldGFpbHM7aS5mb3JFYWNoKChmdW5jdGlvbih0LGUpe3ZhciBpPXQuaW5mbyxuPWEuZnJhZ21lbnRzW2VdOzA9PT1uLmJ5dGVSYW5nZS5sZW5ndGgmJm4uc2V0Qnl0ZVJhbmdlKFN0cmluZygxK2kuZW5kLWkuc3RhcnQpK1wiQFwiK1N0cmluZyhpLnN0YXJ0KSksbi5pbml0U2VnbWVudCYmbi5pbml0U2VnbWVudC5zZXRCeXRlUmFuZ2UoU3RyaW5nKHIubW9vdkVuZE9mZnNldCkrXCJAMFwiKX0pKX19LGUuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3I9ZnVuY3Rpb24odCxlLHIsaSl7dGhpcy5obHMudHJpZ2dlcihuLmEuRVJST1Ise3R5cGU6cy5iLk5FVFdPUktfRVJST1IsZGV0YWlsczpzLmEuTUFOSUZFU1RfUEFSU0lOR19FUlJPUixmYXRhbDplLnR5cGU9PT1fLmEuTUFOSUZFU1QsdXJsOnQudXJsLHJlYXNvbjpyLHJlc3BvbnNlOnQsY29udGV4dDplLG5ldHdvcmtEZXRhaWxzOml9KX0sZS5oYW5kbGVOZXR3b3JrRXJyb3I9ZnVuY3Rpb24odCxlLHIsaSl7dm9pZCAwPT09ciYmKHI9ITEpLG8uYi53YXJuKFwiW3BsYXlsaXN0LWxvYWRlcl06IEEgbmV0d29yayBcIisocj9cInRpbWVvdXRcIjpcImVycm9yXCIpK1wiIG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgXCIrdC50eXBlK1wiIGxldmVsOiBcIit0LmxldmVsK1wiIGlkOiBcIit0LmlkKycgZ3JvdXAtaWQ6IFwiJyt0Lmdyb3VwSWQrJ1wiJyk7dmFyIGE9cy5hLlVOS05PV04sbD0hMSx1PXRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIodCk7c3dpdGNoKHQudHlwZSl7Y2FzZSBfLmEuTUFOSUZFU1Q6YT1yP3MuYS5NQU5JRkVTVF9MT0FEX1RJTUVPVVQ6cy5hLk1BTklGRVNUX0xPQURfRVJST1IsbD0hMDticmVhaztjYXNlIF8uYS5MRVZFTDphPXI/cy5hLkxFVkVMX0xPQURfVElNRU9VVDpzLmEuTEVWRUxfTE9BRF9FUlJPUixsPSExO2JyZWFrO2Nhc2UgXy5hLkFVRElPX1RSQUNLOmE9cj9zLmEuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOnMuYS5BVURJT19UUkFDS19MT0FEX0VSUk9SLGw9ITE7YnJlYWs7Y2FzZSBfLmEuU1VCVElUTEVfVFJBQ0s6YT1yP3MuYS5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQ6cy5hLlNVQlRJVExFX0xPQURfRVJST1IsbD0hMX11JiZ0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIodC50eXBlKTt2YXIgZD17dHlwZTpzLmIuTkVUV09SS19FUlJPUixkZXRhaWxzOmEsZmF0YWw6bCx1cmw6dC51cmwsbG9hZGVyOnUsY29udGV4dDp0LG5ldHdvcmtEZXRhaWxzOmV9O2kmJihkLnJlc3BvbnNlPWkpLHRoaXMuaGxzLnRyaWdnZXIobi5hLkVSUk9SLGQpfSxlLmhhbmRsZVBsYXlsaXN0TG9hZGVkPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPXIudHlwZSxzPXIubGV2ZWwsbz1yLmlkLGw9ci5ncm91cElkLHU9ci5sb2FkZXIsZD1yLmxldmVsRGV0YWlscyxoPXIuZGVsaXZlcnlEaXJlY3RpdmVzO2lmKG51bGwhPWQmJmQudGFyZ2V0ZHVyYXRpb24pe2lmKHUpc3dpdGNoKGQubGl2ZSYmKHUuZ2V0Q2FjaGVBZ2UmJihkLmFnZUhlYWRlcj11LmdldENhY2hlQWdlKCl8fDApLHUuZ2V0Q2FjaGVBZ2UmJiFpc05hTihkLmFnZUhlYWRlcil8fChkLmFnZUhlYWRlcj0wKSksYSl7Y2FzZSBfLmEuTUFOSUZFU1Q6Y2FzZSBfLmEuTEVWRUw6dGhpcy5obHMudHJpZ2dlcihuLmEuTEVWRUxfTE9BREVELHtkZXRhaWxzOmQsbGV2ZWw6c3x8MCxpZDpvfHwwLHN0YXRzOmUsbmV0d29ya0RldGFpbHM6aSxkZWxpdmVyeURpcmVjdGl2ZXM6aH0pO2JyZWFrO2Nhc2UgXy5hLkFVRElPX1RSQUNLOnRoaXMuaGxzLnRyaWdnZXIobi5hLkFVRElPX1RSQUNLX0xPQURFRCx7ZGV0YWlsczpkLGlkOm98fDAsZ3JvdXBJZDpsfHxcIlwiLHN0YXRzOmUsbmV0d29ya0RldGFpbHM6aSxkZWxpdmVyeURpcmVjdGl2ZXM6aH0pO2JyZWFrO2Nhc2UgXy5hLlNVQlRJVExFX1RSQUNLOnRoaXMuaGxzLnRyaWdnZXIobi5hLlNVQlRJVExFX1RSQUNLX0xPQURFRCx7ZGV0YWlsczpkLGlkOm98fDAsZ3JvdXBJZDpsfHxcIlwiLHN0YXRzOmUsbmV0d29ya0RldGFpbHM6aSxkZWxpdmVyeURpcmVjdGl2ZXM6aH0pfX1lbHNlIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IodCxyLFwiaW52YWxpZCB0YXJnZXQgZHVyYXRpb25cIixpKX0sdH0oKSxDPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmhscz12b2lkIDAsdGhpcy5sb2FkZXJzPXt9LHRoaXMuZGVjcnlwdGtleT1udWxsLHRoaXMuZGVjcnlwdHVybD1udWxsLHRoaXMuaGxzPXQsdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5fcmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt0aGlzLmhscy5vbihuLmEuS0VZX0xPQURJTkcsdGhpcy5vbktleUxvYWRpbmcsdGhpcyl9LGUuX3VucmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt0aGlzLmhscy5vZmYobi5hLktFWV9MT0FESU5HLHRoaXMub25LZXlMb2FkaW5nKX0sZS5kZXN0cm95PWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSx0aGlzLmxvYWRlcnMpe3ZhciBlPXRoaXMubG9hZGVyc1t0XTtlJiZlLmRlc3Ryb3koKX10aGlzLmxvYWRlcnM9e319LGUub25LZXlMb2FkaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5mcmFnLGk9ci50eXBlLGE9dGhpcy5sb2FkZXJzW2ldO2lmKHIuZGVjcnlwdGRhdGEpe3ZhciBzPXIuZGVjcnlwdGRhdGEudXJpO2lmKHMhPT10aGlzLmRlY3J5cHR1cmx8fG51bGw9PT10aGlzLmRlY3J5cHRrZXkpe3ZhciBsPXRoaXMuaGxzLmNvbmZpZztpZihhJiYoby5iLndhcm4oXCJhYm9ydCBwcmV2aW91cyBrZXkgbG9hZGVyIGZvciB0eXBlOlwiK2kpLGEuYWJvcnQoKSksIXMpcmV0dXJuIHZvaWQgby5iLndhcm4oXCJrZXkgdXJpIGlzIGZhbHN5XCIpO3ZhciB1PWwubG9hZGVyLGQ9ci5sb2FkZXI9dGhpcy5sb2FkZXJzW2ldPW5ldyB1KGwpO3RoaXMuZGVjcnlwdHVybD1zLHRoaXMuZGVjcnlwdGtleT1udWxsO3ZhciBoPXt1cmw6cyxmcmFnOnIscmVzcG9uc2VUeXBlOlwiYXJyYXlidWZmZXJcIn0sZj17dGltZW91dDpsLmZyYWdMb2FkaW5nVGltZU91dCxtYXhSZXRyeTowLHJldHJ5RGVsYXk6bC5mcmFnTG9hZGluZ1JldHJ5RGVsYXksbWF4UmV0cnlEZWxheTpsLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0LGhpZ2hXYXRlck1hcms6MH0sYz17b25TdWNjZXNzOnRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSxvbkVycm9yOnRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksb25UaW1lb3V0OnRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKX07ZC5sb2FkKGgsZixjKX1lbHNlIHRoaXMuZGVjcnlwdGtleSYmKHIuZGVjcnlwdGRhdGEua2V5PXRoaXMuZGVjcnlwdGtleSx0aGlzLmhscy50cmlnZ2VyKG4uYS5LRVlfTE9BREVELHtmcmFnOnJ9KSl9ZWxzZSBvLmIud2FybihcIk1pc3NpbmcgZGVjcnlwdGlvbiBkYXRhIG9uIGZyYWdtZW50IGluIG9uS2V5TG9hZGluZ1wiKX0sZS5sb2Fkc3VjY2Vzcz1mdW5jdGlvbih0LGUscil7dmFyIGk9ci5mcmFnO2kuZGVjcnlwdGRhdGE/KHRoaXMuZGVjcnlwdGtleT1pLmRlY3J5cHRkYXRhLmtleT1uZXcgVWludDhBcnJheSh0LmRhdGEpLGkubG9hZGVyPW51bGwsZGVsZXRlIHRoaXMubG9hZGVyc1tpLnR5cGVdLHRoaXMuaGxzLnRyaWdnZXIobi5hLktFWV9MT0FERUQse2ZyYWc6aX0pKTpvLmIuZXJyb3IoXCJhZnRlciBrZXkgbG9hZCwgZGVjcnlwdGRhdGEgdW5zZXRcIil9LGUubG9hZGVycm9yPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5mcmFnLGk9ci5sb2FkZXI7aSYmaS5hYm9ydCgpLGRlbGV0ZSB0aGlzLmxvYWRlcnNbci50eXBlXSx0aGlzLmhscy50cmlnZ2VyKG4uYS5FUlJPUix7dHlwZTpzLmIuTkVUV09SS19FUlJPUixkZXRhaWxzOnMuYS5LRVlfTE9BRF9FUlJPUixmYXRhbDohMSxmcmFnOnIscmVzcG9uc2U6dH0pfSxlLmxvYWR0aW1lb3V0PWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5mcmFnLGk9ci5sb2FkZXI7aSYmaS5hYm9ydCgpLGRlbGV0ZSB0aGlzLmxvYWRlcnNbci50eXBlXSx0aGlzLmhscy50cmlnZ2VyKG4uYS5FUlJPUix7dHlwZTpzLmIuTkVUV09SS19FUlJPUixkZXRhaWxzOnMuYS5LRVlfTE9BRF9USU1FT1VULGZhdGFsOiExLGZyYWc6cn0pfSx0fSgpO2Z1bmN0aW9uIHcodCxlKXt2YXIgcjt0cnl7cj1uZXcgRXZlbnQoXCJhZGR0cmFja1wiKX1jYXRjaCh0KXsocj1kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKS5pbml0RXZlbnQoXCJhZGR0cmFja1wiLCExLCExKX1yLnRyYWNrPXQsZS5kaXNwYXRjaEV2ZW50KHIpfWZ1bmN0aW9uIE8odCxlLHIpe3ZhciBpPXQubW9kZTtpZihcImRpc2FibGVkXCI9PT1pJiYodC5tb2RlPVwiaGlkZGVuXCIpLHQuY3VlcyYmdC5jdWVzLmxlbmd0aD4wKWZvcih2YXIgYT1mdW5jdGlvbih0LGUscil7dmFyIGk9W10sYT1mdW5jdGlvbih0LGUpe2lmKGU8dFswXS5zdGFydFRpbWUpcmV0dXJuIDA7dmFyIHI9dC5sZW5ndGgtMTtpZihlPnRbcl0uZW5kVGltZSlyZXR1cm4tMTt2YXIgaT0wLGE9cjtmb3IoO2k8PWE7KXt2YXIgbj1NYXRoLmZsb29yKChhK2kpLzIpO2lmKGU8dFtuXS5zdGFydFRpbWUpYT1uLTE7ZWxzZXtpZighKGU+dFtuXS5zdGFydFRpbWUmJmk8cikpcmV0dXJuIG47aT1uKzF9fXJldHVybiB0W2ldLnN0YXJ0VGltZS1lPGUtdFthXS5zdGFydFRpbWU/aTphfSh0LGUpO2lmKGE+LTEpZm9yKHZhciBuPWEscz10Lmxlbmd0aDtuPHM7bisrKXt2YXIgbz10W25dO2lmKG8uc3RhcnRUaW1lPj1lJiZvLmVuZFRpbWU8PXIpaS5wdXNoKG8pO2Vsc2UgaWYoby5zdGFydFRpbWU+cilyZXR1cm4gaX1yZXR1cm4gaX0odC5jdWVzLGUsciksbj0wO248YS5sZW5ndGg7bisrKXQucmVtb3ZlQ3VlKGFbbl0pO1wiZGlzYWJsZWRcIj09PWkmJih0Lm1vZGU9aSl9dmFyIEk9cig3KSxQPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmhscz12b2lkIDAsdGhpcy5pZDNUcmFjaz1udWxsLHRoaXMubWVkaWE9bnVsbCx0aGlzLmhscz10LHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKX0sZS5fcmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhsczt0Lm9uKG4uYS5NRURJQV9BVFRBQ0hFRCx0aGlzLm9uTWVkaWFBdHRhY2hlZCx0aGlzKSx0Lm9uKG4uYS5NRURJQV9ERVRBQ0hJTkcsdGhpcy5vbk1lZGlhRGV0YWNoaW5nLHRoaXMpLHQub24obi5hLkZSQUdfUEFSU0lOR19NRVRBREFUQSx0aGlzLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSx0aGlzKSx0Lm9uKG4uYS5CVUZGRVJfRkxVU0hJTkcsdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLHRoaXMpfSxlLl91bnJlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vZmYobi5hLk1FRElBX0FUVEFDSEVELHRoaXMub25NZWRpYUF0dGFjaGVkLHRoaXMpLHQub2ZmKG4uYS5NRURJQV9ERVRBQ0hJTkcsdGhpcy5vbk1lZGlhRGV0YWNoaW5nLHRoaXMpLHQub2ZmKG4uYS5GUkFHX1BBUlNJTkdfTUVUQURBVEEsdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsdGhpcyksdC5vZmYobi5hLkJVRkZFUl9GTFVTSElORyx0aGlzLm9uQnVmZmVyRmx1c2hpbmcsdGhpcyl9LGUub25NZWRpYUF0dGFjaGVkPWZ1bmN0aW9uKHQsZSl7dGhpcy5tZWRpYT1lLm1lZGlhfSxlLm9uTWVkaWFEZXRhY2hpbmc9ZnVuY3Rpb24oKXt0aGlzLmlkM1RyYWNrJiYoIWZ1bmN0aW9uKHQpe3ZhciBlPXQubW9kZTtpZihcImRpc2FibGVkXCI9PT1lJiYodC5tb2RlPVwiaGlkZGVuXCIpLHQuY3Vlcylmb3IodmFyIHI9dC5jdWVzLmxlbmd0aDtyLS07KXQucmVtb3ZlQ3VlKHQuY3Vlc1tyXSk7XCJkaXNhYmxlZFwiPT09ZSYmKHQubW9kZT1lKX0odGhpcy5pZDNUcmFjayksdGhpcy5pZDNUcmFjaz1udWxsLHRoaXMubWVkaWE9bnVsbCl9LGUuZ2V0SUQzVHJhY2s9ZnVuY3Rpb24odCl7aWYodGhpcy5tZWRpYSl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciByPXRbZV07aWYoXCJtZXRhZGF0YVwiPT09ci5raW5kJiZcImlkM1wiPT09ci5sYWJlbClyZXR1cm4gdyhyLHRoaXMubWVkaWEpLHJ9cmV0dXJuIHRoaXMubWVkaWEuYWRkVGV4dFRyYWNrKFwibWV0YWRhdGFcIixcImlkM1wiKX19LGUub25GcmFnUGFyc2luZ01ldGFkYXRhPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5tZWRpYSl7dmFyIHI9ZS5mcmFnLGk9ZS5zYW1wbGVzO3RoaXMuaWQzVHJhY2t8fCh0aGlzLmlkM1RyYWNrPXRoaXMuZ2V0SUQzVHJhY2sodGhpcy5tZWRpYS50ZXh0VHJhY2tzKSx0aGlzLmlkM1RyYWNrLm1vZGU9XCJoaWRkZW5cIik7Zm9yKHZhciBhPXNlbGYuV2ViS2l0RGF0YUN1ZXx8c2VsZi5WVFRDdWV8fHNlbGYuVGV4dFRyYWNrQ3VlLG49MDtuPGkubGVuZ3RoO24rKyl7dmFyIHM9SS5jKGlbbl0uZGF0YSk7aWYocyl7dmFyIG89aVtuXS5wdHMsbD1uPGkubGVuZ3RoLTE/aVtuKzFdLnB0czpyLmVuZDtsLW88PTAmJihsPW8rLjI1KTtmb3IodmFyIHU9MDt1PHMubGVuZ3RoO3UrKyl7dmFyIGQ9c1t1XTtpZighSS5lKGQpKXt2YXIgaD1uZXcgYShvLGwsXCJcIik7aC52YWx1ZT1kLHRoaXMuaWQzVHJhY2suYWRkQ3VlKGgpfX19fX19LGUub25CdWZmZXJGbHVzaGluZz1mdW5jdGlvbih0LGUpe3ZhciByPWUuc3RhcnRPZmZzZXQsaT1lLmVuZE9mZnNldCxhPWUudHlwZTtpZighYXx8XCJhdWRpb1wiPT09YSl7dmFyIG49dGhpcy5pZDNUcmFjaztuJiZPKG4scixpKX19LHR9KCk7ZnVuY3Rpb24gRih0LGUpe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgaT1lW3JdO2kuZW51bWVyYWJsZT1pLmVudW1lcmFibGV8fCExLGkuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGkmJihpLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLmtleSxpKX19dmFyIE0sTj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIGU9dGhpczt0aGlzLmhscz12b2lkIDAsdGhpcy5jb25maWc9dm9pZCAwLHRoaXMubWVkaWE9bnVsbCx0aGlzLmxldmVsRGV0YWlscz1udWxsLHRoaXMuY3VycmVudFRpbWU9MCx0aGlzLnN0YWxsQ291bnQ9MCx0aGlzLl9sYXRlbmN5PW51bGwsdGhpcy50aW1ldXBkYXRlSGFuZGxlcj1mdW5jdGlvbigpe3JldHVybiBlLnRpbWV1cGRhdGUoKX0sdGhpcy5obHM9dCx0aGlzLmNvbmZpZz10LmNvbmZpZyx0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCl9dmFyIGUscixpLGE9dC5wcm90b3R5cGU7cmV0dXJuIGEuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpLHRoaXMub25NZWRpYURldGFjaGluZygpLHRoaXMubGV2ZWxEZXRhaWxzPW51bGwsdGhpcy5obHM9dGhpcy50aW1ldXBkYXRlSGFuZGxlcj1udWxsfSxhLnJlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dGhpcy5obHMub24obi5hLk1FRElBX0FUVEFDSEVELHRoaXMub25NZWRpYUF0dGFjaGVkLHRoaXMpLHRoaXMuaGxzLm9uKG4uYS5NRURJQV9ERVRBQ0hJTkcsdGhpcy5vbk1lZGlhRGV0YWNoaW5nLHRoaXMpLHRoaXMuaGxzLm9uKG4uYS5NQU5JRkVTVF9MT0FESU5HLHRoaXMub25NYW5pZmVzdExvYWRpbmcsdGhpcyksdGhpcy5obHMub24obi5hLkxFVkVMX1VQREFURUQsdGhpcy5vbkxldmVsVXBkYXRlZCx0aGlzKSx0aGlzLmhscy5vbihuLmEuRVJST1IsdGhpcy5vbkVycm9yLHRoaXMpfSxhLnVucmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt0aGlzLmhscy5vZmYobi5hLk1FRElBX0FUVEFDSEVELHRoaXMub25NZWRpYUF0dGFjaGVkKSx0aGlzLmhscy5vZmYobi5hLk1FRElBX0RFVEFDSElORyx0aGlzLm9uTWVkaWFEZXRhY2hpbmcpLHRoaXMuaGxzLm9mZihuLmEuTUFOSUZFU1RfTE9BRElORyx0aGlzLm9uTWFuaWZlc3RMb2FkaW5nKSx0aGlzLmhscy5vZmYobi5hLkxFVkVMX1VQREFURUQsdGhpcy5vbkxldmVsVXBkYXRlZCksdGhpcy5obHMub2ZmKG4uYS5FUlJPUix0aGlzLm9uRXJyb3IpfSxhLm9uTWVkaWFBdHRhY2hlZD1mdW5jdGlvbih0LGUpe3RoaXMubWVkaWE9ZS5tZWRpYSx0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aW1ldXBkYXRlXCIsdGhpcy50aW1ldXBkYXRlSGFuZGxlcil9LGEub25NZWRpYURldGFjaGluZz1mdW5jdGlvbigpe3RoaXMubWVkaWEmJih0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0aW1ldXBkYXRlXCIsdGhpcy50aW1ldXBkYXRlSGFuZGxlciksdGhpcy5tZWRpYT1udWxsKX0sYS5vbk1hbmlmZXN0TG9hZGluZz1mdW5jdGlvbigpe3RoaXMubGV2ZWxEZXRhaWxzPW51bGwsdGhpcy5fbGF0ZW5jeT1udWxsLHRoaXMuc3RhbGxDb3VudD0wfSxhLm9uTGV2ZWxVcGRhdGVkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5kZXRhaWxzO3RoaXMubGV2ZWxEZXRhaWxzPXIsci5hZHZhbmNlZCYmdGhpcy50aW1ldXBkYXRlKCksIXIubGl2ZSYmdGhpcy5tZWRpYSYmdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKFwidGltZXVwZGF0ZVwiLHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpfSxhLm9uRXJyb3I9ZnVuY3Rpb24odCxlKXtlLmRldGFpbHM9PT1zLmEuQlVGRkVSX1NUQUxMRURfRVJST1ImJih0aGlzLnN0YWxsQ291bnQrKyxvLmIud2FybihcIltwbGF5YmFjay1yYXRlLWNvbnRyb2xsZXJdOiBTdGFsbCBkZXRlY3RlZCwgYWRqdXN0aW5nIHRhcmdldCBsYXRlbmN5XCIpKX0sYS50aW1ldXBkYXRlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5tZWRpYSxlPXRoaXMubGV2ZWxEZXRhaWxzO2lmKHQmJmUpe3RoaXMuY3VycmVudFRpbWU9dC5jdXJyZW50VGltZTt2YXIgcj10aGlzLmNvbXB1dGVMYXRlbmN5KCk7aWYobnVsbCE9PXIpe3RoaXMuX2xhdGVuY3k9cjt2YXIgaT10aGlzLmNvbmZpZyxhPWkubG93TGF0ZW5jeU1vZGUsbj1pLm1heExpdmVTeW5jUGxheWJhY2tSYXRlO2lmKGEmJjEhPT1uKXt2YXIgcz10aGlzLnRhcmdldExhdGVuY3k7aWYobnVsbCE9PXMpe3ZhciBvPXItcyxsPW88TWF0aC5taW4odGhpcy5tYXhMYXRlbmN5LHMrZS50YXJnZXRkdXJhdGlvbik7aWYoZS5saXZlJiZsJiZvPi4wNSYmdGhpcy5mb3J3YXJkQnVmZmVyTGVuZ3RoPjEpe3ZhciB1PU1hdGgubWluKDIsTWF0aC5tYXgoMSxuKSksZD1NYXRoLnJvdW5kKDIvKDErTWF0aC5leHAoLS43NSpvLXRoaXMuZWRnZVN0YWxsZWQpKSoyMCkvMjA7dC5wbGF5YmFja1JhdGU9TWF0aC5taW4odSxNYXRoLm1heCgxLGQpKX1lbHNlIDEhPT10LnBsYXliYWNrUmF0ZSYmMCE9PXQucGxheWJhY2tSYXRlJiYodC5wbGF5YmFja1JhdGU9MSl9fX19fSxhLmVzdGltYXRlTGl2ZUVkZ2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxldmVsRGV0YWlscztyZXR1cm4gbnVsbD09PXQ/bnVsbDp0LmVkZ2UrdC5hZ2V9LGEuY29tcHV0ZUxhdGVuY3k9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVzdGltYXRlTGl2ZUVkZ2UoKTtyZXR1cm4gbnVsbD09PXQ/bnVsbDp0LXRoaXMuY3VycmVudFRpbWV9LGU9dCwocj1be2tleTpcImxhdGVuY3lcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGF0ZW5jeXx8MH19LHtrZXk6XCJtYXhMYXRlbmN5XCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jb25maWcsZT10aGlzLmxldmVsRGV0YWlscztyZXR1cm4gdm9pZCAwIT09dC5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uP3QubGl2ZU1heExhdGVuY3lEdXJhdGlvbjplP3QubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KmUudGFyZ2V0ZHVyYXRpb246MH19LHtrZXk6XCJ0YXJnZXRMYXRlbmN5XCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sZXZlbERldGFpbHM7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dmFyIGU9dC5ob2xkQmFjayxyPXQucGFydEhvbGRCYWNrLGk9dC50YXJnZXRkdXJhdGlvbixhPXRoaXMuY29uZmlnLG49YS5saXZlU3luY0R1cmF0aW9uLHM9YS5saXZlU3luY0R1cmF0aW9uQ291bnQsbz1hLmxvd0xhdGVuY3lNb2RlLGw9dGhpcy5obHMudXNlckNvbmZpZyx1PW8mJnJ8fGU7KGwubGl2ZVN5bmNEdXJhdGlvbnx8bC5saXZlU3luY0R1cmF0aW9uQ291bnR8fDA9PT11KSYmKHU9dm9pZCAwIT09bj9uOnMqaSk7dmFyIGQ9aTtyZXR1cm4gdStNYXRoLm1pbigxKnRoaXMuc3RhbGxDb3VudCxkKX19LHtrZXk6XCJsaXZlU3luY1Bvc2l0aW9uXCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lc3RpbWF0ZUxpdmVFZGdlKCksZT10aGlzLnRhcmdldExhdGVuY3kscj10aGlzLmxldmVsRGV0YWlscztpZihudWxsPT09dHx8bnVsbD09PWV8fG51bGw9PT1yKXJldHVybiBudWxsO3ZhciBpPXIuZWRnZSxhPXQtZS10aGlzLmVkZ2VTdGFsbGVkLG49aS1yLnRvdGFsZHVyYXRpb24scz1pLSh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSYmci5wYXJ0VGFyZ2V0fHxyLnRhcmdldGR1cmF0aW9uKTtyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobixhKSxzKX19LHtrZXk6XCJkcmlmdFwiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMubGV2ZWxEZXRhaWxzO3JldHVybiBudWxsPT09dD8xOnQuZHJpZnR9fSx7a2V5OlwiZWRnZVN0YWxsZWRcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxldmVsRGV0YWlscztpZihudWxsPT09dClyZXR1cm4gMDt2YXIgZT0zKih0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSYmdC5wYXJ0VGFyZ2V0fHx0LnRhcmdldGR1cmF0aW9uKTtyZXR1cm4gTWF0aC5tYXgodC5hZ2UtZSwwKX19LHtrZXk6XCJmb3J3YXJkQnVmZmVyTGVuZ3RoXCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5tZWRpYSxlPXRoaXMubGV2ZWxEZXRhaWxzO2lmKCF0fHwhZSlyZXR1cm4gMDt2YXIgcj10LmJ1ZmZlcmVkLmxlbmd0aDtyZXR1cm4gcj90LmJ1ZmZlcmVkLmVuZChyLTEpOmUuZWRnZS10aGlzLmN1cnJlbnRUaW1lfX1dKSYmRihlLnByb3RvdHlwZSxyKSxpJiZGKGUsaSksdH0oKTtmdW5jdGlvbiBCKHQsZSl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBpPWVbcl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGkua2V5LGkpfX0hZnVuY3Rpb24odCl7dC5Obz1cIlwiLHQuWWVzPVwiWUVTXCIsdC52Mj1cInYyXCJ9KE18fChNPXt9KSk7dmFyIFU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxyKXt0aGlzLm1zbj12b2lkIDAsdGhpcy5wYXJ0PXZvaWQgMCx0aGlzLnNraXA9dm9pZCAwLHRoaXMubXNuPXQsdGhpcy5wYXJ0PWUsdGhpcy5za2lwPXJ9cmV0dXJuIHQucHJvdG90eXBlLmFkZERpcmVjdGl2ZXM9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHNlbGYuVVJMKHQpO3JldHVybiB2b2lkIDAhPT10aGlzLm1zbiYmZS5zZWFyY2hQYXJhbXMuc2V0KFwiX0hMU19tc25cIix0aGlzLm1zbi50b1N0cmluZygpKSx2b2lkIDAhPT10aGlzLnBhcnQmJmUuc2VhcmNoUGFyYW1zLnNldChcIl9ITFNfcGFydFwiLHRoaXMucGFydC50b1N0cmluZygpKSx0aGlzLnNraXAmJmUuc2VhcmNoUGFyYW1zLnNldChcIl9ITFNfc2tpcFwiLHRoaXMuc2tpcCksZS50b1N0cmluZygpfSx0fSgpLEc9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuYXR0cnM9dm9pZCAwLHRoaXMuYXVkaW9Db2RlYz12b2lkIDAsdGhpcy5iaXRyYXRlPXZvaWQgMCx0aGlzLmNvZGVjU2V0PXZvaWQgMCx0aGlzLmhlaWdodD12b2lkIDAsdGhpcy5pZD12b2lkIDAsdGhpcy5uYW1lPXZvaWQgMCx0aGlzLnZpZGVvQ29kZWM9dm9pZCAwLHRoaXMud2lkdGg9dm9pZCAwLHRoaXMudW5rbm93bkNvZGVjcz12b2lkIDAsdGhpcy5hdWRpb0dyb3VwSWRzPXZvaWQgMCx0aGlzLmRldGFpbHM9dm9pZCAwLHRoaXMuZnJhZ21lbnRFcnJvcj0wLHRoaXMubG9hZEVycm9yPTAsdGhpcy5sb2FkZWQ9dm9pZCAwLHRoaXMucmVhbEJpdHJhdGU9MCx0aGlzLnRleHRHcm91cElkcz12b2lkIDAsdGhpcy51cmw9dm9pZCAwLHRoaXMuX3VybElkPTAsdGhpcy51cmw9W3QudXJsXSx0aGlzLmF0dHJzPXQuYXR0cnMsdGhpcy5iaXRyYXRlPXQuYml0cmF0ZSx0LmRldGFpbHMmJih0aGlzLmRldGFpbHM9dC5kZXRhaWxzKSx0aGlzLmlkPXQuaWR8fDAsdGhpcy5uYW1lPXQubmFtZSx0aGlzLndpZHRoPXQud2lkdGh8fDAsdGhpcy5oZWlnaHQ9dC5oZWlnaHR8fDAsdGhpcy5hdWRpb0NvZGVjPXQuYXVkaW9Db2RlYyx0aGlzLnZpZGVvQ29kZWM9dC52aWRlb0NvZGVjLHRoaXMudW5rbm93bkNvZGVjcz10LnVua25vd25Db2RlY3MsdGhpcy5jb2RlY1NldD1bdC52aWRlb0NvZGVjLHQuYXVkaW9Db2RlY10uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKS5qb2luKFwiLFwiKS5yZXBsYWNlKC9cXC5bXi4sXSsvZyxcIlwiKX12YXIgZSxyLGk7cmV0dXJuIGU9dCwocj1be2tleTpcIm1heEJpdHJhdGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5yZWFsQml0cmF0ZSx0aGlzLmJpdHJhdGUpfX0se2tleTpcInVyaVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVybFt0aGlzLl91cmxJZF18fFwiXCJ9fSx7a2V5OlwidXJsSWRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdXJsSWR9LHNldDpmdW5jdGlvbih0KXt2YXIgZT10JXRoaXMudXJsLmxlbmd0aDt0aGlzLl91cmxJZCE9PWUmJih0aGlzLmRldGFpbHM9dm9pZCAwLHRoaXMuX3VybElkPWUpfX1dKSYmQihlLnByb3RvdHlwZSxyKSxpJiZCKGUsaSksdH0oKTtmdW5jdGlvbiBqKHQsZSxyKXtzd2l0Y2goZSl7Y2FzZVwiYXVkaW9cIjp0LmF1ZGlvR3JvdXBJZHN8fCh0LmF1ZGlvR3JvdXBJZHM9W10pLHQuYXVkaW9Hcm91cElkcy5wdXNoKHIpO2JyZWFrO2Nhc2VcInRleHRcIjp0LnRleHRHcm91cElkc3x8KHQudGV4dEdyb3VwSWRzPVtdKSx0LnRleHRHcm91cElkcy5wdXNoKHIpfX1mdW5jdGlvbiBIKHQpe3ZhciBlPXt9O3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHI9dC5ncm91cElkfHxcIlwiO3QuaWQ9ZVtyXT1lW3JdfHwwLGVbcl0rK30pKX1mdW5jdGlvbiBLKHQsZSl7dmFyIHI9ZS5zdGFydFBUUztpZihPYmplY3QoYS5hKShyKSl7dmFyIGksbj0wO2Uuc24+dC5zbj8obj1yLXQuc3RhcnQsaT10KToobj10LnN0YXJ0LXIsaT1lKSxpLmR1cmF0aW9uIT09biYmKGkuZHVyYXRpb249bil9ZWxzZSBpZihlLnNuPnQuc24pe3QuY2M9PT1lLmNjJiZ0Lm1pbkVuZFBUUz9lLnN0YXJ0PXQuc3RhcnQrKHQubWluRW5kUFRTLXQuc3RhcnQpOmUuc3RhcnQ9dC5zdGFydCt0LmR1cmF0aW9ufWVsc2UgZS5zdGFydD1NYXRoLm1heCh0LnN0YXJ0LWUuZHVyYXRpb24sMCl9ZnVuY3Rpb24gVih0LGUscixpLG4scyl7aS1yPD0wJiYoby5iLndhcm4oXCJGcmFnbWVudCBzaG91bGQgaGF2ZSBhIHBvc2l0aXZlIGR1cmF0aW9uXCIsZSksaT1yK2UuZHVyYXRpb24scz1uK2UuZHVyYXRpb24pO3ZhciBsPXIsdT1pLGQ9ZS5zdGFydFBUUyxoPWUuZW5kUFRTO2lmKE9iamVjdChhLmEpKGQpKXt2YXIgZj1NYXRoLmFicyhkLXIpO09iamVjdChhLmEpKGUuZGVsdGFQVFMpP2UuZGVsdGFQVFM9TWF0aC5tYXgoZixlLmRlbHRhUFRTKTplLmRlbHRhUFRTPWYsbD1NYXRoLm1heChyLGQpLHI9TWF0aC5taW4ocixkKSxuPU1hdGgubWluKG4sZS5zdGFydERUUyksdT1NYXRoLm1pbihpLGgpLGk9TWF0aC5tYXgoaSxoKSxzPU1hdGgubWF4KHMsZS5lbmREVFMpfWUuZHVyYXRpb249aS1yO3ZhciBjPXItZS5zdGFydDtlLmFwcGVuZGVkUFRTPWksZS5zdGFydD1lLnN0YXJ0UFRTPXIsZS5tYXhTdGFydFBUUz1sLGUuc3RhcnREVFM9bixlLmVuZFBUUz1pLGUubWluRW5kUFRTPXUsZS5lbmREVFM9czt2YXIgdixnPWUuc247aWYoIXR8fGc8dC5zdGFydFNOfHxnPnQuZW5kU04pcmV0dXJuIDA7dmFyIHA9Zy10LnN0YXJ0U04sbT10LmZyYWdtZW50cztmb3IobVtwXT1lLHY9cDt2PjA7di0tKUsobVt2XSxtW3YtMV0pO2Zvcih2PXA7djxtLmxlbmd0aC0xO3YrKylLKG1bdl0sbVt2KzFdKTtyZXR1cm4gdC5mcmFnbWVudEhpbnQmJksobVttLmxlbmd0aC0xXSx0LmZyYWdtZW50SGludCksdC5QVFNLbm93bj10LmFsaWduZWRTbGlkaW5nPSEwLGN9ZnVuY3Rpb24gVyh0LGUpe2Zvcih2YXIgcj1udWxsLGk9dC5mcmFnbWVudHMsbj1pLmxlbmd0aC0xO24+PTA7bi0tKXt2YXIgcz1pW25dLmluaXRTZWdtZW50O2lmKHMpe3I9czticmVha319dC5mcmFnbWVudEhpbnQmJmRlbGV0ZSB0LmZyYWdtZW50SGludC5lbmRQVFM7dmFyIGwsdT0wOyhmdW5jdGlvbih0LGUscil7Zm9yKHZhciBpPWUuc2tpcHBlZFNlZ21lbnRzLGE9TWF0aC5tYXgodC5zdGFydFNOLGUuc3RhcnRTTiktZS5zdGFydFNOLG49KHQuZnJhZ21lbnRIaW50PzE6MCkrKGk/ZS5lbmRTTjpNYXRoLm1pbih0LmVuZFNOLGUuZW5kU04pKS1lLnN0YXJ0U04scz1lLnN0YXJ0U04tdC5zdGFydFNOLG89ZS5mcmFnbWVudEhpbnQ/ZS5mcmFnbWVudHMuY29uY2F0KGUuZnJhZ21lbnRIaW50KTplLmZyYWdtZW50cyxsPXQuZnJhZ21lbnRIaW50P3QuZnJhZ21lbnRzLmNvbmNhdCh0LmZyYWdtZW50SGludCk6dC5mcmFnbWVudHMsdT1hO3U8PW47dSsrKXt2YXIgZD1sW3MrdV0saD1vW3VdO2kmJiFoJiZ1PGkmJihoPWUuZnJhZ21lbnRzW3VdPWQpLGQmJmgmJnIoZCxoKX19KHQsZSwoZnVuY3Rpb24odCxpKXt0LnJlbHVybCYmKHU9dC5jYy1pLmNjKSxPYmplY3QoYS5hKSh0LnN0YXJ0UFRTKSYmT2JqZWN0KGEuYSkodC5lbmRQVFMpJiYoaS5zdGFydD1pLnN0YXJ0UFRTPXQuc3RhcnRQVFMsaS5zdGFydERUUz10LnN0YXJ0RFRTLGkuYXBwZW5kZWRQVFM9dC5hcHBlbmRlZFBUUyxpLm1heFN0YXJ0UFRTPXQubWF4U3RhcnRQVFMsaS5lbmRQVFM9dC5lbmRQVFMsaS5lbmREVFM9dC5lbmREVFMsaS5taW5FbmRQVFM9dC5taW5FbmRQVFMsaS5kdXJhdGlvbj10LmVuZFBUUy10LnN0YXJ0UFRTLGkuZHVyYXRpb24mJihsPWkpLGUuUFRTS25vd249ZS5hbGlnbmVkU2xpZGluZz0hMCksaS5lbGVtZW50YXJ5U3RyZWFtcz10LmVsZW1lbnRhcnlTdHJlYW1zLGkubG9hZGVyPXQubG9hZGVyLGkuc3RhdHM9dC5zdGF0cyxpLnVybElkPXQudXJsSWQsdC5pbml0U2VnbWVudCYmKGkuaW5pdFNlZ21lbnQ9dC5pbml0U2VnbWVudCxyPXQuaW5pdFNlZ21lbnQpfSkpLHIpJiYoZS5mcmFnbWVudEhpbnQ/ZS5mcmFnbWVudHMuY29uY2F0KGUuZnJhZ21lbnRIaW50KTplLmZyYWdtZW50cykuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU7dC5pbml0U2VnbWVudCYmdC5pbml0U2VnbWVudC5yZWx1cmwhPT0obnVsbD09PShlPXIpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLnJlbHVybCl8fCh0LmluaXRTZWdtZW50PXIpfSkpO2lmKGUuc2tpcHBlZFNlZ21lbnRzJiYoZS5kZWx0YVVwZGF0ZUZhaWxlZD1lLmZyYWdtZW50cy5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4hdH0pKSxlLmRlbHRhVXBkYXRlRmFpbGVkKSl7by5iLndhcm4oXCJbbGV2ZWwtaGVscGVyXSBQcmV2aW91cyBwbGF5bGlzdCBtaXNzaW5nIHNlZ21lbnRzIHNraXBwZWQgaW4gZGVsdGEgcGxheWxpc3RcIik7Zm9yKHZhciBkPWUuc2tpcHBlZFNlZ21lbnRzO2QtLTspZS5mcmFnbWVudHMuc2hpZnQoKTtlLnN0YXJ0U049ZS5mcmFnbWVudHNbMF0uc24sZS5zdGFydENDPWUuZnJhZ21lbnRzWzBdLmNjfXZhciBoPWUuZnJhZ21lbnRzO2lmKHUpe28uYi53YXJuKFwiZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50XCIpO2Zvcih2YXIgZj0wO2Y8aC5sZW5ndGg7ZisrKWhbZl0uY2MrPXV9ZS5za2lwcGVkU2VnbWVudHMmJihlLnN0YXJ0Q0M9ZS5mcmFnbWVudHNbMF0uY2MpLGZ1bmN0aW9uKHQsZSxyKXtpZih0JiZlKWZvcih2YXIgaT0wLGE9MCxuPXQubGVuZ3RoO2E8PW47YSsrKXt2YXIgcz10W2FdLG89ZVthK2ldO3MmJm8mJnMuaW5kZXg9PT1vLmluZGV4JiZzLmZyYWdtZW50LnNuPT09by5mcmFnbWVudC5zbj9yKHMsbyk6aS0tfX0odC5wYXJ0TGlzdCxlLnBhcnRMaXN0LChmdW5jdGlvbih0LGUpe2UuZWxlbWVudGFyeVN0cmVhbXM9dC5lbGVtZW50YXJ5U3RyZWFtcyxlLnN0YXRzPXQuc3RhdHN9KSksbD9WKGUsbCxsLnN0YXJ0UFRTLGwuZW5kUFRTLGwuc3RhcnREVFMsbC5lbmREVFMpOlkodCxlKSxoLmxlbmd0aCYmKGUudG90YWxkdXJhdGlvbj1lLmVkZ2UtaFswXS5zdGFydCksZS5kcmlmdFN0YXJ0VGltZT10LmRyaWZ0U3RhcnRUaW1lLGUuZHJpZnRTdGFydD10LmRyaWZ0U3RhcnQ7dmFyIGM9ZS5hZHZhbmNlZERhdGVUaW1lO2lmKGUuYWR2YW5jZWQmJmMpe3ZhciB2PWUuZWRnZTtlLmRyaWZ0U3RhcnR8fChlLmRyaWZ0U3RhcnRUaW1lPWMsZS5kcmlmdFN0YXJ0PXYpLGUuZHJpZnRFbmRUaW1lPWMsZS5kcmlmdEVuZD12fWVsc2UgZS5kcmlmdEVuZFRpbWU9dC5kcmlmdEVuZFRpbWUsZS5kcmlmdEVuZD10LmRyaWZ0RW5kLGUuYWR2YW5jZWREYXRlVGltZT10LmFkdmFuY2VkRGF0ZVRpbWV9ZnVuY3Rpb24gWSh0LGUpe3ZhciByPWUuc3RhcnRTTitlLnNraXBwZWRTZWdtZW50cy10LnN0YXJ0U04saT10LmZyYWdtZW50cztyPDB8fHI+PWkubGVuZ3RofHxmdW5jdGlvbih0LGUpe2lmKGUpe2Zvcih2YXIgcj10LmZyYWdtZW50cyxpPXQuc2tpcHBlZFNlZ21lbnRzO2k8ci5sZW5ndGg7aSsrKXJbaV0uc3RhcnQrPWU7dC5mcmFnbWVudEhpbnQmJih0LmZyYWdtZW50SGludC5zdGFydCs9ZSl9fShlLGlbcl0uc3RhcnQpfXZhciBYPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMuaGxzPXZvaWQgMCx0aGlzLnRpbWVyPS0xLHRoaXMuY2FuTG9hZD0hMSx0aGlzLnJldHJ5Q291bnQ9MCx0aGlzLmxvZz12b2lkIDAsdGhpcy53YXJuPXZvaWQgMCx0aGlzLmxvZz1vLmIubG9nLmJpbmQoby5iLGUrXCI6XCIpLHRoaXMud2Fybj1vLmIud2Fybi5iaW5kKG8uYixlK1wiOlwiKSx0aGlzLmhscz10fXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmNsZWFyVGltZXIoKSx0aGlzLmhscz10aGlzLmxvZz10aGlzLndhcm49bnVsbH0sZS5vbkVycm9yPWZ1bmN0aW9uKHQsZSl7ZS5mYXRhbCYmZS50eXBlPT09cy5iLk5FVFdPUktfRVJST1ImJnRoaXMuY2xlYXJUaW1lcigpfSxlLmNsZWFyVGltZXI9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGhpcy50aW1lciksdGhpcy50aW1lcj0tMX0sZS5zdGFydExvYWQ9ZnVuY3Rpb24oKXt0aGlzLmNhbkxvYWQ9ITAsdGhpcy5yZXRyeUNvdW50PTAsdGhpcy5sb2FkUGxheWxpc3QoKX0sZS5zdG9wTG9hZD1mdW5jdGlvbigpe3RoaXMuY2FuTG9hZD0hMSx0aGlzLmNsZWFyVGltZXIoKX0sZS5zd2l0Y2hQYXJhbXM9ZnVuY3Rpb24odCxlKXt2YXIgcj1udWxsPT1lP3ZvaWQgMDplLnJlbmRpdGlvblJlcG9ydHM7aWYocilmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKyl7dmFyIG49cltpXSxzPVwiXCIrbi5VUkk7aWYocz09PXQuc3Vic3RyKC1zLmxlbmd0aCkpe3ZhciBvPXBhcnNlSW50KG5bXCJMQVNULU1TTlwiXSksbD1wYXJzZUludChuW1wiTEFTVC1QQVJUXCJdKTtpZihlJiZ0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGUpe3ZhciB1PU1hdGgubWluKGUuYWdlLWUucGFydFRhcmdldCxlLnRhcmdldGR1cmF0aW9uKTt2b2lkIDAhPT1sJiZ1PmUucGFydFRhcmdldCYmKGwrPTEpfWlmKE9iamVjdChhLmEpKG8pKXJldHVybiBuZXcgVShvLE9iamVjdChhLmEpKGwpP2w6dm9pZCAwLE0uTm8pfX19LGUubG9hZFBsYXlsaXN0PWZ1bmN0aW9uKHQpe30sZS5zaG91bGRMb2FkVHJhY2s9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY2FuTG9hZCYmdCYmISF0LnVybCYmKCF0LmRldGFpbHN8fHQuZGV0YWlscy5saXZlKX0sZS5wbGF5bGlzdExvYWRlZD1mdW5jdGlvbih0LGUscil7dmFyIGk9dGhpcyxhPWUuZGV0YWlscyxuPWUuc3RhdHMscz1uLmxvYWRpbmcuZW5kP01hdGgubWF4KDAsc2VsZi5wZXJmb3JtYW5jZS5ub3coKS1uLmxvYWRpbmcuZW5kKTowO2lmKGEuYWR2YW5jZWREYXRlVGltZT1EYXRlLm5vdygpLXMsYS5saXZlfHxudWxsIT1yJiZyLmxpdmUpe2lmKGEucmVsb2FkZWQociksciYmdGhpcy5sb2coXCJsaXZlIHBsYXlsaXN0IFwiK3QrXCIgXCIrKGEuYWR2YW5jZWQ/XCJSRUZSRVNIRUQgXCIrYS5sYXN0UGFydFNuK1wiLVwiK2EubGFzdFBhcnRJbmRleDpcIk1JU1NFRFwiKSksciYmYS5mcmFnbWVudHMubGVuZ3RoPjAmJlcocixhKSwhdGhpcy5jYW5Mb2FkfHwhYS5saXZlKXJldHVybjt2YXIgbyxsPXZvaWQgMCx1PXZvaWQgMDtpZihhLmNhbkJsb2NrUmVsb2FkJiZhLmVuZFNOJiZhLmFkdmFuY2VkKXt2YXIgZD10aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGUsaD1hLmxhc3RQYXJ0U24sZj1hLmVuZFNOLGM9YS5sYXN0UGFydEluZGV4LHY9aD09PWY7LTEhPT1jPyhsPXY/ZisxOmgsdT12P2Q/MDpjOmMrMSk6bD1mKzE7dmFyIGc9YS5hZ2UscD1nK2EuYWdlSGVhZGVyLG09TWF0aC5taW4ocC1hLnBhcnRUYXJnZXQsMS41KmEudGFyZ2V0ZHVyYXRpb24pO2lmKG0+MCl7aWYociYmbT5yLnR1bmVJbkdvYWwpdGhpcy53YXJuKFwiQ0ROIFR1bmUtaW4gZ29hbCBpbmNyZWFzZWQgZnJvbTogXCIrci50dW5lSW5Hb2FsK1wiIHRvOiBcIittK1wiIHdpdGggcGxheWxpc3QgYWdlOiBcIithLmFnZSksbT0wO2Vsc2V7dmFyIHk9TWF0aC5mbG9vcihtL2EudGFyZ2V0ZHVyYXRpb24pO2lmKGwrPXksdm9pZCAwIT09dSl1Kz1NYXRoLnJvdW5kKG0lYS50YXJnZXRkdXJhdGlvbi9hLnBhcnRUYXJnZXQpO3RoaXMubG9nKFwiQ0ROIFR1bmUtaW4gYWdlOiBcIithLmFnZUhlYWRlcitcInMgbGFzdCBhZHZhbmNlZCBcIitnLnRvRml4ZWQoMikrXCJzIGdvYWw6IFwiK20rXCIgc2tpcCBzbiBcIit5K1wiIHRvIHBhcnQgXCIrdSl9YS50dW5lSW5Hb2FsPW19aWYobz10aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhhLGUuZGVsaXZlcnlEaXJlY3RpdmVzLGwsdSksZHx8IXYpcmV0dXJuIHZvaWQgdGhpcy5sb2FkUGxheWxpc3Qobyl9ZWxzZSBvPXRoaXMuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGEsZS5kZWxpdmVyeURpcmVjdGl2ZXMsbCx1KTt2YXIgYj1mdW5jdGlvbih0LGUpe3ZhciByLGk9MWUzKnQubGV2ZWxUYXJnZXREdXJhdGlvbixhPWkvMixuPXQuYWdlLHM9bj4wJiZuPDMqaSxvPWUubG9hZGluZy5lbmQtZS5sb2FkaW5nLnN0YXJ0LGw9dC5hdmFpbGFiaWxpdHlEZWxheTtpZighMT09PXQudXBkYXRlZClpZihzKXt2YXIgdT0zMzMqdC5taXNzZXM7cj1NYXRoLm1heChNYXRoLm1pbihhLDIqbyksdSksdC5hdmFpbGFiaWxpdHlEZWxheT0odC5hdmFpbGFiaWxpdHlEZWxheXx8MCkrcn1lbHNlIHI9YTtlbHNlIHM/KGw9TWF0aC5taW4obHx8aS8yLG4pLHQuYXZhaWxhYmlsaXR5RGVsYXk9bCxyPWwraS1uKTpyPWktbztyZXR1cm4gTWF0aC5yb3VuZChyKX0oYSxuKTt2b2lkIDAhPT1sJiZhLmNhbkJsb2NrUmVsb2FkJiYoYi09YS5wYXJ0VGFyZ2V0fHwxKSx0aGlzLmxvZyhcInJlbG9hZCBsaXZlIHBsYXlsaXN0IFwiK3QrXCIgaW4gXCIrTWF0aC5yb3VuZChiKStcIiBtc1wiKSx0aGlzLnRpbWVyPXNlbGYuc2V0VGltZW91dCgoZnVuY3Rpb24oKXtyZXR1cm4gaS5sb2FkUGxheWxpc3Qobyl9KSxiKX1lbHNlIHRoaXMuY2xlYXJUaW1lcigpfSxlLmdldERlbGl2ZXJ5RGlyZWN0aXZlcz1mdW5jdGlvbih0LGUscixpKXt2YXIgYT1mdW5jdGlvbih0LGUpe3ZhciByPXQuY2FuU2tpcFVudGlsLGk9dC5jYW5Ta2lwRGF0ZVJhbmdlcyxhPXQuZW5kU047cmV0dXJuIHImJih2b2lkIDAhPT1lP2UtYTowKTxyP2k/TS52MjpNLlllczpNLk5vfSh0LHIpO3JldHVybiBudWxsIT1lJiZlLnNraXAmJnQuZGVsdGFVcGRhdGVGYWlsZWQmJihyPWUubXNuLGk9ZS5wYXJ0LGE9TS5ObyksbmV3IFUocixpLGEpfSxlLnJldHJ5TG9hZGluZ09yRmFpbD1mdW5jdGlvbih0KXt2YXIgZSxyPXRoaXMsaT10aGlzLmhscy5jb25maWcsYT10aGlzLnJldHJ5Q291bnQ8aS5sZXZlbExvYWRpbmdNYXhSZXRyeTtpZihhKWlmKHRoaXMucmV0cnlDb3VudCsrLHQuZGV0YWlscy5pbmRleE9mKFwiTG9hZFRpbWVPdXRcIik+LTEmJm51bGwhPT0oZT10LmNvbnRleHQpJiZ2b2lkIDAhPT1lJiZlLmRlbGl2ZXJ5RGlyZWN0aXZlcyl0aGlzLndhcm4oXCJyZXRyeSBwbGF5bGlzdCBsb2FkaW5nICNcIit0aGlzLnJldHJ5Q291bnQrJyBhZnRlciBcIicrdC5kZXRhaWxzKydcIicpLHRoaXMubG9hZFBsYXlsaXN0KCk7ZWxzZXt2YXIgbj1NYXRoLm1pbihNYXRoLnBvdygyLHRoaXMucmV0cnlDb3VudCkqaS5sZXZlbExvYWRpbmdSZXRyeURlbGF5LGkubGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTt0aGlzLnRpbWVyPXNlbGYuc2V0VGltZW91dCgoZnVuY3Rpb24oKXtyZXR1cm4gci5sb2FkUGxheWxpc3QoKX0pLG4pLHRoaXMud2FybihcInJldHJ5IHBsYXlsaXN0IGxvYWRpbmcgI1wiK3RoaXMucmV0cnlDb3VudCtcIiBpbiBcIituKycgbXMgYWZ0ZXIgXCInK3QuZGV0YWlscysnXCInKX1lbHNlIHRoaXMud2FybignY2Fubm90IHJlY292ZXIgZnJvbSBlcnJvciBcIicrdC5kZXRhaWxzKydcIicpLHRoaXMuY2xlYXJUaW1lcigpLHQuZmF0YWw9ITA7cmV0dXJuIGF9LHR9KCk7ZnVuY3Rpb24gcSgpe3JldHVybihxPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciByPWFyZ3VtZW50c1tlXTtmb3IodmFyIGkgaW4gcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixpKSYmKHRbaV09cltpXSl9cmV0dXJuIHR9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24geih0LGUpe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgaT1lW3JdO2kuZW51bWVyYWJsZT1pLmVudW1lcmFibGV8fCExLGkuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGkmJihpLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLmtleSxpKX19ZnVuY3Rpb24gUSh0LGUpe3JldHVybihRPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fX3Byb3RvX189ZSx0fSkodCxlKX12YXIgJCxaPS9jaHJvbWV8ZmlyZWZveC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpLEo9ZnVuY3Rpb24odCl7dmFyIGUscjtmdW5jdGlvbiBpKGUpe3ZhciByO3JldHVybihyPXQuY2FsbCh0aGlzLGUsXCJbbGV2ZWwtY29udHJvbGxlcl1cIil8fHRoaXMpLl9sZXZlbHM9W10sci5fZmlyc3RMZXZlbD0tMSxyLl9zdGFydExldmVsPXZvaWQgMCxyLmN1cnJlbnRMZXZlbEluZGV4PS0xLHIubWFudWFsTGV2ZWxJbmRleD0tMSxyLm9uUGFyc2VkQ29tcGxldGU9dm9pZCAwLHIuX3JlZ2lzdGVyTGlzdGVuZXJzKCkscn1yPXQsKGU9aSkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWUsUShlLHIpO3ZhciBhLG8sbCx1PWkucHJvdG90eXBlO3JldHVybiB1Ll9yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzO3Qub24obi5hLk1BTklGRVNUX0xPQURFRCx0aGlzLm9uTWFuaWZlc3RMb2FkZWQsdGhpcyksdC5vbihuLmEuTEVWRUxfTE9BREVELHRoaXMub25MZXZlbExvYWRlZCx0aGlzKSx0Lm9uKG4uYS5BVURJT19UUkFDS19TV0lUQ0hFRCx0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLHRoaXMpLHQub24obi5hLkZSQUdfTE9BREVELHRoaXMub25GcmFnTG9hZGVkLHRoaXMpLHQub24obi5hLkVSUk9SLHRoaXMub25FcnJvcix0aGlzKX0sdS5fdW5yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzO3Qub2ZmKG4uYS5NQU5JRkVTVF9MT0FERUQsdGhpcy5vbk1hbmlmZXN0TG9hZGVkLHRoaXMpLHQub2ZmKG4uYS5MRVZFTF9MT0FERUQsdGhpcy5vbkxldmVsTG9hZGVkLHRoaXMpLHQub2ZmKG4uYS5BVURJT19UUkFDS19TV0lUQ0hFRCx0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLHRoaXMpLHQub2ZmKG4uYS5GUkFHX0xPQURFRCx0aGlzLm9uRnJhZ0xvYWRlZCx0aGlzKSx0Lm9mZihuLmEuRVJST1IsdGhpcy5vbkVycm9yLHRoaXMpfSx1LmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCksdGhpcy5tYW51YWxMZXZlbEluZGV4PS0xLHRoaXMuX2xldmVscy5sZW5ndGg9MCx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyl9LHUuc3RhcnRMb2FkPWZ1bmN0aW9uKCl7dGhpcy5fbGV2ZWxzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QubG9hZEVycm9yPTB9KSksdC5wcm90b3R5cGUuc3RhcnRMb2FkLmNhbGwodGhpcyl9LHUub25NYW5pZmVzdExvYWRlZD1mdW5jdGlvbih0LGUpe3ZhciByLGksYT1bXSxvPVtdLGw9W10sdT17fSxkPSExLGg9ITEsZj0hMTtpZihlLmxldmVscy5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT10LmF0dHJzO2Q9ZHx8ISghdC53aWR0aHx8IXQuaGVpZ2h0KSxoPWh8fCEhdC52aWRlb0NvZGVjLGY9Znx8ISF0LmF1ZGlvQ29kZWMsWiYmdC5hdWRpb0NvZGVjJiYtMSE9PXQuYXVkaW9Db2RlYy5pbmRleE9mKFwibXA0YS40MC4zNFwiKSYmKHQuYXVkaW9Db2RlYz12b2lkIDApO3ZhciByPXQuYml0cmF0ZStcIi1cIit0LmF0dHJzLlJFU09MVVRJT04rXCItXCIrdC5hdHRycy5DT0RFQ1M7KGk9dVtyXSk/aS51cmwucHVzaCh0LnVybCk6KGk9bmV3IEcodCksdVtyXT1pLGEucHVzaChpKSksZSYmKGUuQVVESU8mJmooaSxcImF1ZGlvXCIsZS5BVURJTyksZS5TVUJUSVRMRVMmJmooaSxcInRleHRcIixlLlNVQlRJVExFUykpfSkpLChkfHxoKSYmZiYmKGE9YS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3ZhciBlPXQudmlkZW9Db2RlYyxyPXQud2lkdGgsaT10LmhlaWdodDtyZXR1cm4hIWV8fCEoIXJ8fCFpKX0pKSksYT1hLmZpbHRlcigoZnVuY3Rpb24odCl7dmFyIGU9dC5hdWRpb0NvZGVjLHI9dC52aWRlb0NvZGVjO3JldHVybighZXx8bShlLFwiYXVkaW9cIikpJiYoIXJ8fG0ocixcInZpZGVvXCIpKX0pKSxlLmF1ZGlvVHJhY2tzJiZIKG89ZS5hdWRpb1RyYWNrcy5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiF0LmF1ZGlvQ29kZWN8fG0odC5hdWRpb0NvZGVjLFwiYXVkaW9cIil9KSkpLGUuc3VidGl0bGVzJiZIKGw9ZS5zdWJ0aXRsZXMpLGEubGVuZ3RoPjApe3I9YVswXS5iaXRyYXRlLGEuc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5iaXRyYXRlLWUuYml0cmF0ZX0pKSx0aGlzLl9sZXZlbHM9YTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKylpZihhW2NdLmJpdHJhdGU9PT1yKXt0aGlzLl9maXJzdExldmVsPWMsdGhpcy5sb2coXCJtYW5pZmVzdCBsb2FkZWQsIFwiK2EubGVuZ3RoK1wiIGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiBcIityKTticmVha312YXIgdj1mJiYhaCxnPXtsZXZlbHM6YSxhdWRpb1RyYWNrczpvLHN1YnRpdGxlVHJhY2tzOmwsZmlyc3RMZXZlbDp0aGlzLl9maXJzdExldmVsLHN0YXRzOmUuc3RhdHMsYXVkaW86Zix2aWRlbzpoLGFsdEF1ZGlvOiF2JiZvLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiEhdC51cmx9KSl9O3RoaXMuaGxzLnRyaWdnZXIobi5hLk1BTklGRVNUX1BBUlNFRCxnKSwodGhpcy5obHMuY29uZmlnLmF1dG9TdGFydExvYWR8fHRoaXMuaGxzLmZvcmNlU3RhcnRMb2FkKSYmdGhpcy5obHMuc3RhcnRMb2FkKHRoaXMuaGxzLmNvbmZpZy5zdGFydFBvc2l0aW9uKX1lbHNlIHRoaXMuaGxzLnRyaWdnZXIobi5hLkVSUk9SLHt0eXBlOnMuYi5NRURJQV9FUlJPUixkZXRhaWxzOnMuYS5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLGZhdGFsOiEwLHVybDplLnVybCxyZWFzb246XCJubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0XCJ9KX0sdS5vbkVycm9yPWZ1bmN0aW9uKGUscil7aWYodC5wcm90b3R5cGUub25FcnJvci5jYWxsKHRoaXMsZSxyKSwhci5mYXRhbCl7dmFyIGk9ci5jb250ZXh0LGE9dGhpcy5fbGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO2lmKGkmJihpLnR5cGU9PT1fLmEuQVVESU9fVFJBQ0smJmEuYXVkaW9Hcm91cElkcyYmaS5ncm91cElkPT09YS5hdWRpb0dyb3VwSWRzW2EudXJsSWRdfHxpLnR5cGU9PT1fLmEuU1VCVElUTEVfVFJBQ0smJmEudGV4dEdyb3VwSWRzJiZpLmdyb3VwSWQ9PT1hLnRleHRHcm91cElkc1thLnVybElkXSkpdGhpcy5yZWR1bmRhbnRGYWlsb3Zlcih0aGlzLmN1cnJlbnRMZXZlbEluZGV4KTtlbHNle3ZhciBuLG89ITEsbD0hMDtzd2l0Y2goci5kZXRhaWxzKXtjYXNlIHMuYS5GUkFHX0xPQURfRVJST1I6Y2FzZSBzLmEuRlJBR19MT0FEX1RJTUVPVVQ6Y2FzZSBzLmEuS0VZX0xPQURfRVJST1I6Y2FzZSBzLmEuS0VZX0xPQURfVElNRU9VVDppZihyLmZyYWcpe3ZhciB1PXRoaXMuX2xldmVsc1tyLmZyYWcubGV2ZWxdO3U/KHUuZnJhZ21lbnRFcnJvcisrLHUuZnJhZ21lbnRFcnJvcj50aGlzLmhscy5jb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSYmKG49ci5mcmFnLmxldmVsKSk6bj1yLmZyYWcubGV2ZWx9YnJlYWs7Y2FzZSBzLmEuTEVWRUxfTE9BRF9FUlJPUjpjYXNlIHMuYS5MRVZFTF9MT0FEX1RJTUVPVVQ6aSYmKGkuZGVsaXZlcnlEaXJlY3RpdmVzJiYobD0hMSksbj1pLmxldmVsKSxvPSEwO2JyZWFrO2Nhc2Ugcy5hLlJFTVVYX0FMTE9DX0VSUk9SOm49ci5sZXZlbCxvPSEwfXZvaWQgMCE9PW4mJnRoaXMucmVjb3ZlckxldmVsKHIsbixvLGwpfX19LHUucmVjb3ZlckxldmVsPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPXQuZGV0YWlscyxuPXRoaXMuX2xldmVsc1tlXTtpZihuLmxvYWRFcnJvcisrLHIpe2lmKCF0aGlzLnJldHJ5TG9hZGluZ09yRmFpbCh0KSlyZXR1cm4gdm9pZCh0aGlzLmN1cnJlbnRMZXZlbEluZGV4PS0xKTt0LmxldmVsUmV0cnk9ITB9aWYoaSl7dmFyIHM9bi51cmwubGVuZ3RoO2lmKHM+MSYmbi5sb2FkRXJyb3I8cyl0LmxldmVsUmV0cnk9ITAsdGhpcy5yZWR1bmRhbnRGYWlsb3ZlcihlKTtlbHNlIGlmKC0xPT09dGhpcy5tYW51YWxMZXZlbEluZGV4KXt2YXIgbz0wPT09ZT90aGlzLl9sZXZlbHMubGVuZ3RoLTE6ZS0xO3RoaXMuY3VycmVudExldmVsSW5kZXghPT1vJiYwPT09dGhpcy5fbGV2ZWxzW29dLmxvYWRFcnJvciYmKHRoaXMud2FybihhK1wiOiBzd2l0Y2ggdG8gXCIrbyksdC5sZXZlbFJldHJ5PSEwLHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw9byl9fX0sdS5yZWR1bmRhbnRGYWlsb3Zlcj1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9sZXZlbHNbdF0scj1lLnVybC5sZW5ndGg7aWYocj4xKXt2YXIgaT0oZS51cmxJZCsxKSVyO3RoaXMud2FybihcIlN3aXRjaGluZyB0byByZWR1bmRhbnQgVVJMLWlkIFwiK2kpLHRoaXMuX2xldmVscy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnVybElkPWl9KSksdGhpcy5sZXZlbD10fX0sdS5vbkZyYWdMb2FkZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1lLmZyYWc7aWYodm9pZCAwIT09ciYmci50eXBlPT09Xy5iLk1BSU4pe3ZhciBpPXRoaXMuX2xldmVsc1tyLmxldmVsXTt2b2lkIDAhPT1pJiYoaS5mcmFnbWVudEVycm9yPTAsaS5sb2FkRXJyb3I9MCl9fSx1Lm9uTGV2ZWxMb2FkZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcixpLGE9ZS5sZXZlbCxuPWUuZGV0YWlscyxzPXRoaXMuX2xldmVsc1thXTtpZighcylyZXR1cm4gdGhpcy53YXJuKFwiSW52YWxpZCBsZXZlbCBpbmRleCBcIithKSx2b2lkKG51bGwhPT0oaT1lLmRlbGl2ZXJ5RGlyZWN0aXZlcykmJnZvaWQgMCE9PWkmJmkuc2tpcCYmKG4uZGVsdGFVcGRhdGVGYWlsZWQ9ITApKTthPT09dGhpcy5jdXJyZW50TGV2ZWxJbmRleD8oMD09PXMuZnJhZ21lbnRFcnJvciYmKHMubG9hZEVycm9yPTAsdGhpcy5yZXRyeUNvdW50PTApLHRoaXMucGxheWxpc3RMb2FkZWQoYSxlLHMuZGV0YWlscykpOm51bGwhPT0ocj1lLmRlbGl2ZXJ5RGlyZWN0aXZlcykmJnZvaWQgMCE9PXImJnIuc2tpcCYmKG4uZGVsdGFVcGRhdGVGYWlsZWQ9ITApfSx1Lm9uQXVkaW9UcmFja1N3aXRjaGVkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5obHMubGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO2lmKHImJnIuYXVkaW9Hcm91cElkcyl7Zm9yKHZhciBpPS0xLGE9dGhpcy5obHMuYXVkaW9UcmFja3NbZS5pZF0uZ3JvdXBJZCxuPTA7bjxyLmF1ZGlvR3JvdXBJZHMubGVuZ3RoO24rKylpZihyLmF1ZGlvR3JvdXBJZHNbbl09PT1hKXtpPW47YnJlYWt9aSE9PXIudXJsSWQmJihyLnVybElkPWksdGhpcy5zdGFydExvYWQoKSl9fSx1LmxvYWRQbGF5bGlzdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmN1cnJlbnRMZXZlbEluZGV4LHI9dGhpcy5fbGV2ZWxzW2VdO2lmKHRoaXMuY2FuTG9hZCYmciYmci51cmwubGVuZ3RoPjApe3ZhciBpPXIudXJsSWQsYT1yLnVybFtpXTtpZih0KXRyeXthPXQuYWRkRGlyZWN0aXZlcyhhKX1jYXRjaCh0KXt0aGlzLndhcm4oXCJDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogXCIrdCl9dGhpcy5sb2coXCJBdHRlbXB0IGxvYWRpbmcgbGV2ZWwgaW5kZXggXCIrZSsodD9cIiBhdCBzbiBcIit0Lm1zbitcIiBwYXJ0IFwiK3QucGFydDpcIlwiKStcIiB3aXRoIFVSTC1pZCBcIitpK1wiIFwiK2EpLHRoaXMuY2xlYXJUaW1lcigpLHRoaXMuaGxzLnRyaWdnZXIobi5hLkxFVkVMX0xPQURJTkcse3VybDphLGxldmVsOmUsaWQ6aSxkZWxpdmVyeURpcmVjdGl2ZXM6dHx8bnVsbH0pfX0sdS5yZW1vdmVMZXZlbD1mdW5jdGlvbih0LGUpe3ZhciByPWZ1bmN0aW9uKHQscil7cmV0dXJuIHIhPT1lfSxpPXRoaXMuX2xldmVscy5maWx0ZXIoKGZ1bmN0aW9uKGksYSl7cmV0dXJuIGEhPT10fHxpLnVybC5sZW5ndGg+MSYmdm9pZCAwIT09ZSYmKGkudXJsPWkudXJsLmZpbHRlcihyKSxpLmF1ZGlvR3JvdXBJZHMmJihpLmF1ZGlvR3JvdXBJZHM9aS5hdWRpb0dyb3VwSWRzLmZpbHRlcihyKSksaS50ZXh0R3JvdXBJZHMmJihpLnRleHRHcm91cElkcz1pLnRleHRHcm91cElkcy5maWx0ZXIocikpLGkudXJsSWQ9MCwhMCl9KSkubWFwKChmdW5jdGlvbih0LGUpe3ZhciByPXQuZGV0YWlscztyZXR1cm4gbnVsbCE9ciYmci5mcmFnbWVudHMmJnIuZnJhZ21lbnRzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QubGV2ZWw9ZX0pKSx0fSkpO3RoaXMuX2xldmVscz1pLHRoaXMuaGxzLnRyaWdnZXIobi5hLkxFVkVMU19VUERBVEVELHtsZXZlbHM6aX0pfSxhPWksKG89W3trZXk6XCJsZXZlbHNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuX2xldmVscy5sZW5ndGg/bnVsbDp0aGlzLl9sZXZlbHN9fSx7a2V5OlwibGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJyZW50TGV2ZWxJbmRleH0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlLHI9dGhpcy5fbGV2ZWxzO2lmKDAhPT1yLmxlbmd0aCYmKHRoaXMuY3VycmVudExldmVsSW5kZXghPT10fHxudWxsPT09KGU9clt0XSl8fHZvaWQgMD09PWV8fCFlLmRldGFpbHMpKXtpZih0PDB8fHQ+PXIubGVuZ3RoKXt2YXIgaT10PDA7aWYodGhpcy5obHMudHJpZ2dlcihuLmEuRVJST1Ise3R5cGU6cy5iLk9USEVSX0VSUk9SLGRldGFpbHM6cy5hLkxFVkVMX1NXSVRDSF9FUlJPUixsZXZlbDp0LGZhdGFsOmkscmVhc29uOlwiaW52YWxpZCBsZXZlbCBpZHhcIn0pLGkpcmV0dXJuO3Q9TWF0aC5taW4odCxyLmxlbmd0aC0xKX10aGlzLmNsZWFyVGltZXIoKTt2YXIgYT10aGlzLmN1cnJlbnRMZXZlbEluZGV4LG89clthXSxsPXJbdF07dGhpcy5sb2coXCJzd2l0Y2hpbmcgdG8gbGV2ZWwgXCIrdCtcIiBmcm9tIFwiK2EpLHRoaXMuY3VycmVudExldmVsSW5kZXg9dDt2YXIgdT1xKHt9LGwse2xldmVsOnQsbWF4Qml0cmF0ZTpsLm1heEJpdHJhdGUsdXJpOmwudXJpLHVybElkOmwudXJsSWR9KTtkZWxldGUgdS5fdXJsSWQsdGhpcy5obHMudHJpZ2dlcihuLmEuTEVWRUxfU1dJVENISU5HLHUpO3ZhciBkPWwuZGV0YWlscztpZighZHx8ZC5saXZlKXt2YXIgaD10aGlzLnN3aXRjaFBhcmFtcyhsLnVyaSxudWxsPT1vP3ZvaWQgMDpvLmRldGFpbHMpO3RoaXMubG9hZFBsYXlsaXN0KGgpfX19fSx7a2V5OlwibWFudWFsTGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5tYW51YWxMZXZlbEluZGV4PXQsdm9pZCAwPT09dGhpcy5fc3RhcnRMZXZlbCYmKHRoaXMuX3N0YXJ0TGV2ZWw9dCksLTEhPT10JiYodGhpcy5sZXZlbD10KX19LHtrZXk6XCJmaXJzdExldmVsXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWx9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9maXJzdExldmVsPXR9fSx7a2V5Olwic3RhcnRMZXZlbFwiLGdldDpmdW5jdGlvbigpe2lmKHZvaWQgMD09PXRoaXMuX3N0YXJ0TGV2ZWwpe3ZhciB0PXRoaXMuaGxzLmNvbmZpZy5zdGFydExldmVsO3JldHVybiB2b2lkIDAhPT10P3Q6dGhpcy5fZmlyc3RMZXZlbH1yZXR1cm4gdGhpcy5fc3RhcnRMZXZlbH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX3N0YXJ0TGV2ZWw9dH19LHtrZXk6XCJuZXh0TG9hZExldmVsXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuLTEhPT10aGlzLm1hbnVhbExldmVsSW5kZXg/dGhpcy5tYW51YWxMZXZlbEluZGV4OnRoaXMuaGxzLm5leHRBdXRvTGV2ZWx9LHNldDpmdW5jdGlvbih0KXt0aGlzLmxldmVsPXQsLTE9PT10aGlzLm1hbnVhbExldmVsSW5kZXgmJih0aGlzLmhscy5uZXh0QXV0b0xldmVsPXQpfX1dKSYmeihhLnByb3RvdHlwZSxvKSxsJiZ6KGEsbCksaX0oWCk7IWZ1bmN0aW9uKHQpe3QuTk9UX0xPQURFRD1cIk5PVF9MT0FERURcIix0LkJBQ0tUUkFDS0VEPVwiQkFDS1RSQUNLRURcIix0LkFQUEVORElORz1cIkFQUEVORElOR1wiLHQuUEFSVElBTD1cIlBBUlRJQUxcIix0Lk9LPVwiT0tcIn0oJHx8KCQ9e30pKTt2YXIgdHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuYWN0aXZlRnJhZ21lbnQ9bnVsbCx0aGlzLmFjdGl2ZVBhcnRzPW51bGwsdGhpcy5mcmFnbWVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLnRpbWVSYW5nZXM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLmJ1ZmZlclBhZGRpbmc9LjIsdGhpcy5obHM9dm9pZCAwLHRoaXMuaGxzPXQsdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5fcmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhsczt0Lm9uKG4uYS5CVUZGRVJfQVBQRU5ERUQsdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLHRoaXMpLHQub24obi5hLkZSQUdfQlVGRkVSRUQsdGhpcy5vbkZyYWdCdWZmZXJlZCx0aGlzKSx0Lm9uKG4uYS5GUkFHX0xPQURFRCx0aGlzLm9uRnJhZ0xvYWRlZCx0aGlzKX0sZS5fdW5yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzO3Qub2ZmKG4uYS5CVUZGRVJfQVBQRU5ERUQsdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLHRoaXMpLHQub2ZmKG4uYS5GUkFHX0JVRkZFUkVELHRoaXMub25GcmFnQnVmZmVyZWQsdGhpcyksdC5vZmYobi5hLkZSQUdfTE9BREVELHRoaXMub25GcmFnTG9hZGVkLHRoaXMpfSxlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCksdGhpcy5mcmFnbWVudHM9dGhpcy50aW1lUmFuZ2VzPW51bGx9LGUuZ2V0QXBwZW5kZWRGcmFnPWZ1bmN0aW9uKHQsZSl7aWYoZT09PV8uYi5NQUlOKXt2YXIgcj10aGlzLmFjdGl2ZUZyYWdtZW50LGk9dGhpcy5hY3RpdmVQYXJ0cztpZighcilyZXR1cm4gbnVsbDtpZihpKWZvcih2YXIgYT1pLmxlbmd0aDthLS07KXt2YXIgbj1pW2FdLHM9bj9uLmVuZDpyLmFwcGVuZGVkUFRTO2lmKG4uc3RhcnQ8PXQmJnZvaWQgMCE9PXMmJnQ8PXMpcmV0dXJuIGE+OSYmKHRoaXMuYWN0aXZlUGFydHM9aS5zbGljZShhLTkpKSxufWVsc2UgaWYoci5zdGFydDw9dCYmdm9pZCAwIT09ci5hcHBlbmRlZFBUUyYmdDw9ci5hcHBlbmRlZFBUUylyZXR1cm4gcn1yZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcodCxlKX0sZS5nZXRCdWZmZXJlZEZyYWc9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9dGhpcy5mcmFnbWVudHMsaT1PYmplY3Qua2V5cyhyKSxhPWkubGVuZ3RoO2EtLTspe3ZhciBuPXJbaVthXV07aWYoKG51bGw9PW4/dm9pZCAwOm4uYm9keS50eXBlKT09PWUmJm4uYnVmZmVyZWQpe3ZhciBzPW4uYm9keTtpZihzLnN0YXJ0PD10JiZ0PD1zLmVuZClyZXR1cm4gc319cmV0dXJuIG51bGx9LGUuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cz1mdW5jdGlvbih0LGUscil7dmFyIGk9dGhpcztPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaCgoZnVuY3Rpb24oYSl7dmFyIG49aS5mcmFnbWVudHNbYV07aWYobilpZihuLmJ1ZmZlcmVkKXt2YXIgcz1uLnJhbmdlW3RdO3MmJnMudGltZS5zb21lKChmdW5jdGlvbih0KXt2YXIgcj0haS5pc1RpbWVCdWZmZXJlZCh0LnN0YXJ0UFRTLHQuZW5kUFRTLGUpO3JldHVybiByJiZpLnJlbW92ZUZyYWdtZW50KG4uYm9keSkscn0pKX1lbHNlIG4uYm9keS50eXBlPT09ciYmaS5yZW1vdmVGcmFnbWVudChuLmJvZHkpfSkpfSxlLmRldGVjdFBhcnRpYWxGcmFnbWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXMudGltZVJhbmdlcyxpPXQuZnJhZyxhPXQucGFydDtpZihyJiZcImluaXRTZWdtZW50XCIhPT1pLnNuKXt2YXIgbj1ydChpKSxzPXRoaXMuZnJhZ21lbnRzW25dO3MmJihPYmplY3Qua2V5cyhyKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbj1pLmVsZW1lbnRhcnlTdHJlYW1zW3RdO2lmKG4pe3ZhciBvPXJbdF0sbD1udWxsIT09YXx8ITA9PT1uLnBhcnRpYWw7cy5yYW5nZVt0XT1lLmdldEJ1ZmZlcmVkVGltZXMoaSxhLGwsbyl9fSkpLHMuYmFja3RyYWNrPXMubG9hZGVkPW51bGwsT2JqZWN0LmtleXMocy5yYW5nZSkubGVuZ3RoP3MuYnVmZmVyZWQ9ITA6dGhpcy5yZW1vdmVGcmFnbWVudChzLmJvZHkpKX19LGUuZnJhZ0J1ZmZlcmVkPWZ1bmN0aW9uKHQpe3ZhciBlPXJ0KHQpLHI9dGhpcy5mcmFnbWVudHNbZV07ciYmKHIuYmFja3RyYWNrPXIubG9hZGVkPW51bGwsci5idWZmZXJlZD0hMCl9LGUuZ2V0QnVmZmVyZWRUaW1lcz1mdW5jdGlvbih0LGUscixpKXtmb3IodmFyIGE9e3RpbWU6W10scGFydGlhbDpyfSxuPWU/ZS5zdGFydDp0LnN0YXJ0LHM9ZT9lLmVuZDp0LmVuZCxvPXQubWluRW5kUFRTfHxzLGw9dC5tYXhTdGFydFBUU3x8bix1PTA7dTxpLmxlbmd0aDt1Kyspe3ZhciBkPWkuc3RhcnQodSktdGhpcy5idWZmZXJQYWRkaW5nLGg9aS5lbmQodSkrdGhpcy5idWZmZXJQYWRkaW5nO2lmKGw+PWQmJm88PWgpe2EudGltZS5wdXNoKHtzdGFydFBUUzpNYXRoLm1heChuLGkuc3RhcnQodSkpLGVuZFBUUzpNYXRoLm1pbihzLGkuZW5kKHUpKX0pO2JyZWFrfWlmKG48aCYmcz5kKWEucGFydGlhbD0hMCxhLnRpbWUucHVzaCh7c3RhcnRQVFM6TWF0aC5tYXgobixpLnN0YXJ0KHUpKSxlbmRQVFM6TWF0aC5taW4ocyxpLmVuZCh1KSl9KTtlbHNlIGlmKHM8PWQpYnJlYWt9cmV0dXJuIGF9LGUuZ2V0UGFydGlhbEZyYWdtZW50PWZ1bmN0aW9uKHQpe3ZhciBlLHIsaSxhPW51bGwsbj0wLHM9dGhpcy5idWZmZXJQYWRkaW5nLG89dGhpcy5mcmFnbWVudHM7cmV0dXJuIE9iamVjdC5rZXlzKG8pLmZvckVhY2goKGZ1bmN0aW9uKGwpe3ZhciB1PW9bbF07dSYmZXQodSkmJihyPXUuYm9keS5zdGFydC1zLGk9dS5ib2R5LmVuZCtzLHQ+PXImJnQ8PWkmJihlPU1hdGgubWluKHQtcixpLXQpLG48PWUmJihhPXUuYm9keSxuPWUpKSl9KSksYX0sZS5nZXRTdGF0ZT1mdW5jdGlvbih0KXt2YXIgZT1ydCh0KSxyPXRoaXMuZnJhZ21lbnRzW2VdO3JldHVybiByP3IuYnVmZmVyZWQ/ZXQocik/JC5QQVJUSUFMOiQuT0s6ci5iYWNrdHJhY2s/JC5CQUNLVFJBQ0tFRDokLkFQUEVORElORzokLk5PVF9MT0FERUR9LGUuYmFja3RyYWNrPWZ1bmN0aW9uKHQsZSl7dmFyIHI9cnQodCksaT10aGlzLmZyYWdtZW50c1tyXTtpZighaXx8aS5iYWNrdHJhY2spcmV0dXJuIG51bGw7dmFyIGE9aS5iYWNrdHJhY2s9ZXx8aS5sb2FkZWQ7cmV0dXJuIGkubG9hZGVkPW51bGwsYX0sZS5nZXRCYWNrdHJhY2tEYXRhPWZ1bmN0aW9uKHQpe3ZhciBlPXJ0KHQpLHI9dGhpcy5mcmFnbWVudHNbZV07aWYocil7dmFyIGksYT1yLmJhY2t0cmFjaztpZihudWxsIT1hJiZudWxsIT09KGk9YS5wYXlsb2FkKSYmdm9pZCAwIT09aSYmaS5ieXRlTGVuZ3RoKXJldHVybiBhO3RoaXMucmVtb3ZlRnJhZ21lbnQodCl9cmV0dXJuIG51bGx9LGUuaXNUaW1lQnVmZmVyZWQ9ZnVuY3Rpb24odCxlLHIpe2Zvcih2YXIgaSxhLG49MDtuPHIubGVuZ3RoO24rKyl7aWYoaT1yLnN0YXJ0KG4pLXRoaXMuYnVmZmVyUGFkZGluZyxhPXIuZW5kKG4pK3RoaXMuYnVmZmVyUGFkZGluZyx0Pj1pJiZlPD1hKXJldHVybiEwO2lmKGU8PWkpcmV0dXJuITF9cmV0dXJuITF9LGUub25GcmFnTG9hZGVkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5mcmFnLGk9ZS5wYXJ0O2lmKFwiaW5pdFNlZ21lbnRcIiE9PXIuc24mJiFyLmJpdHJhdGVUZXN0JiYhaSl7dmFyIGE9cnQocik7dGhpcy5mcmFnbWVudHNbYV09e2JvZHk6cixsb2FkZWQ6ZSxiYWNrdHJhY2s6bnVsbCxidWZmZXJlZDohMSxyYW5nZTpPYmplY3QuY3JlYXRlKG51bGwpfX19LGUub25CdWZmZXJBcHBlbmRlZD1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMsaT1lLmZyYWcsYT1lLnBhcnQsbj1lLnRpbWVSYW5nZXM7aWYoaS50eXBlPT09Xy5iLk1BSU4paWYodGhpcy5hY3RpdmVGcmFnbWVudD1pLGEpe3ZhciBzPXRoaXMuYWN0aXZlUGFydHM7c3x8KHRoaXMuYWN0aXZlUGFydHM9cz1bXSkscy5wdXNoKGEpfWVsc2UgdGhpcy5hY3RpdmVQYXJ0cz1udWxsO3RoaXMudGltZVJhbmdlcz1uLE9iamVjdC5rZXlzKG4pLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPW5bdF07aWYoci5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKHQsZSksIWEpZm9yKHZhciBzPTA7czxlLmxlbmd0aDtzKyspaS5hcHBlbmRlZFBUUz1NYXRoLm1heChlLmVuZChzKSxpLmFwcGVuZGVkUFRTfHwwKX0pKX0sZS5vbkZyYWdCdWZmZXJlZD1mdW5jdGlvbih0LGUpe3RoaXMuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyhlKX0sZS5oYXNGcmFnbWVudD1mdW5jdGlvbih0KXt2YXIgZT1ydCh0KTtyZXR1cm4hIXRoaXMuZnJhZ21lbnRzW2VdfSxlLnJlbW92ZUZyYWdtZW50c0luUmFuZ2U9ZnVuY3Rpb24odCxlLHIpe3ZhciBpPXRoaXM7T2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goKGZ1bmN0aW9uKGEpe3ZhciBuPWkuZnJhZ21lbnRzW2FdO2lmKG4mJm4uYnVmZmVyZWQpe3ZhciBzPW4uYm9keTtzLnR5cGU9PT1yJiZzLnN0YXJ0PGUmJnMuZW5kPnQmJmkucmVtb3ZlRnJhZ21lbnQocyl9fSkpfSxlLnJlbW92ZUZyYWdtZW50PWZ1bmN0aW9uKHQpe3ZhciBlPXJ0KHQpO3Quc3RhdHMubG9hZGVkPTAsdC5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCksZGVsZXRlIHRoaXMuZnJhZ21lbnRzW2VdfSxlLnJlbW92ZUFsbEZyYWdtZW50cz1mdW5jdGlvbigpe3RoaXMuZnJhZ21lbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5hY3RpdmVGcmFnbWVudD1udWxsLHRoaXMuYWN0aXZlUGFydHM9bnVsbH0sdH0oKTtmdW5jdGlvbiBldCh0KXt2YXIgZSxyO3JldHVybiB0LmJ1ZmZlcmVkJiYoKG51bGw9PT0oZT10LnJhbmdlLnZpZGVvKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5wYXJ0aWFsKXx8KG51bGw9PT0ocj10LnJhbmdlLmF1ZGlvKXx8dm9pZCAwPT09cj92b2lkIDA6ci5wYXJ0aWFsKSl9ZnVuY3Rpb24gcnQodCl7cmV0dXJuIHQudHlwZStcIl9cIit0LmxldmVsK1wiX1wiK3QudXJsSWQrXCJfXCIrdC5zbn12YXIgaXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5fYm91bmRUaWNrPXZvaWQgMCx0aGlzLl90aWNrVGltZXI9bnVsbCx0aGlzLl90aWNrSW50ZXJ2YWw9bnVsbCx0aGlzLl90aWNrQ2FsbENvdW50PTAsdGhpcy5fYm91bmRUaWNrPXRoaXMudGljay5iaW5kKHRoaXMpfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLm9uSGFuZGxlckRlc3Ryb3lpbmcoKSx0aGlzLm9uSGFuZGxlckRlc3Ryb3llZCgpfSxlLm9uSGFuZGxlckRlc3Ryb3lpbmc9ZnVuY3Rpb24oKXt0aGlzLmNsZWFyTmV4dFRpY2soKSx0aGlzLmNsZWFySW50ZXJ2YWwoKX0sZS5vbkhhbmRsZXJEZXN0cm95ZWQ9ZnVuY3Rpb24oKXt9LGUuaGFzSW50ZXJ2YWw9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuX3RpY2tJbnRlcnZhbH0sZS5oYXNOZXh0VGljaz1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5fdGlja1RpbWVyfSxlLnNldEludGVydmFsPWZ1bmN0aW9uKHQpe3JldHVybiF0aGlzLl90aWNrSW50ZXJ2YWwmJih0aGlzLl90aWNrSW50ZXJ2YWw9c2VsZi5zZXRJbnRlcnZhbCh0aGlzLl9ib3VuZFRpY2ssdCksITApfSxlLmNsZWFySW50ZXJ2YWw9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuX3RpY2tJbnRlcnZhbCYmKHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLl90aWNrSW50ZXJ2YWwpLHRoaXMuX3RpY2tJbnRlcnZhbD1udWxsLCEwKX0sZS5jbGVhck5leHRUaWNrPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLl90aWNrVGltZXImJihzZWxmLmNsZWFyVGltZW91dCh0aGlzLl90aWNrVGltZXIpLHRoaXMuX3RpY2tUaW1lcj1udWxsLCEwKX0sZS50aWNrPWZ1bmN0aW9uKCl7dGhpcy5fdGlja0NhbGxDb3VudCsrLDE9PT10aGlzLl90aWNrQ2FsbENvdW50JiYodGhpcy5kb1RpY2soKSx0aGlzLl90aWNrQ2FsbENvdW50PjEmJnRoaXMudGlja0ltbWVkaWF0ZSgpLHRoaXMuX3RpY2tDYWxsQ291bnQ9MCl9LGUudGlja0ltbWVkaWF0ZT1mdW5jdGlvbigpe3RoaXMuY2xlYXJOZXh0VGljaygpLHRoaXMuX3RpY2tUaW1lcj1zZWxmLnNldFRpbWVvdXQodGhpcy5fYm91bmRUaWNrLDApfSxlLmRvVGljaz1mdW5jdGlvbigpe30sdH0oKSxhdD17bGVuZ3RoOjAsc3RhcnQ6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIDB9fSxudD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQuaXNCdWZmZXJlZD1mdW5jdGlvbihlLHIpe3RyeXtpZihlKWZvcih2YXIgaT10LmdldEJ1ZmZlcmVkKGUpLGE9MDthPGkubGVuZ3RoO2ErKylpZihyPj1pLnN0YXJ0KGEpJiZyPD1pLmVuZChhKSlyZXR1cm4hMH1jYXRjaCh0KXt9cmV0dXJuITF9LHQuYnVmZmVySW5mbz1mdW5jdGlvbihlLHIsaSl7dHJ5e2lmKGUpe3ZhciBhLG49dC5nZXRCdWZmZXJlZChlKSxzPVtdO2ZvcihhPTA7YTxuLmxlbmd0aDthKyspcy5wdXNoKHtzdGFydDpuLnN0YXJ0KGEpLGVuZDpuLmVuZChhKX0pO3JldHVybiB0aGlzLmJ1ZmZlcmVkSW5mbyhzLHIsaSl9fWNhdGNoKHQpe31yZXR1cm57bGVuOjAsc3RhcnQ6cixlbmQ6cixuZXh0U3RhcnQ6dm9pZCAwfX0sdC5idWZmZXJlZEluZm89ZnVuY3Rpb24odCxlLHIpe2U9TWF0aC5tYXgoMCxlKSx0LnNvcnQoKGZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5zdGFydC1lLnN0YXJ0O3JldHVybiByfHxlLmVuZC10LmVuZH0pKTt2YXIgaT1bXTtpZihyKWZvcih2YXIgYT0wO2E8dC5sZW5ndGg7YSsrKXt2YXIgbj1pLmxlbmd0aDtpZihuKXt2YXIgcz1pW24tMV0uZW5kO3RbYV0uc3RhcnQtczxyP3RbYV0uZW5kPnMmJihpW24tMV0uZW5kPXRbYV0uZW5kKTppLnB1c2godFthXSl9ZWxzZSBpLnB1c2godFthXSl9ZWxzZSBpPXQ7Zm9yKHZhciBvLGw9MCx1PWUsZD1lLGg9MDtoPGkubGVuZ3RoO2grKyl7dmFyIGY9aVtoXS5zdGFydCxjPWlbaF0uZW5kO2lmKGUrcj49ZiYmZTxjKXU9ZixsPShkPWMpLWU7ZWxzZSBpZihlK3I8Zil7bz1mO2JyZWFrfX1yZXR1cm57bGVuOmwsc3RhcnQ6dXx8MCxlbmQ6ZHx8MCxuZXh0U3RhcnQ6b319LHQuZ2V0QnVmZmVyZWQ9ZnVuY3Rpb24odCl7dHJ5e3JldHVybiB0LmJ1ZmZlcmVkfWNhdGNoKHQpe3JldHVybiBvLmIubG9nKFwiZmFpbGVkIHRvIGdldCBtZWRpYS5idWZmZXJlZFwiLHQpLGF0fX0sdH0oKSxzdD1mdW5jdGlvbih0LGUscixpLGEsbil7dm9pZCAwPT09aSYmKGk9MCksdm9pZCAwPT09YSYmKGE9LTEpLHZvaWQgMD09PW4mJihuPSExKSx0aGlzLmxldmVsPXZvaWQgMCx0aGlzLnNuPXZvaWQgMCx0aGlzLnBhcnQ9dm9pZCAwLHRoaXMuaWQ9dm9pZCAwLHRoaXMuc2l6ZT12b2lkIDAsdGhpcy5wYXJ0aWFsPXZvaWQgMCx0aGlzLnRyYW5zbXV4aW5nPXtzdGFydDowLGV4ZWN1dGVTdGFydDowLGV4ZWN1dGVFbmQ6MCxlbmQ6MH0sdGhpcy5idWZmZXJpbmc9e2F1ZGlvOntzdGFydDowLGV4ZWN1dGVTdGFydDowLGV4ZWN1dGVFbmQ6MCxlbmQ6MH0sdmlkZW86e3N0YXJ0OjAsZXhlY3V0ZVN0YXJ0OjAsZXhlY3V0ZUVuZDowLGVuZDowfSxhdWRpb3ZpZGVvOntzdGFydDowLGV4ZWN1dGVTdGFydDowLGV4ZWN1dGVFbmQ6MCxlbmQ6MH19LHRoaXMubGV2ZWw9dCx0aGlzLnNuPWUsdGhpcy5pZD1yLHRoaXMuc2l6ZT1pLHRoaXMucGFydD1hLHRoaXMucGFydGlhbD1ufTtmdW5jdGlvbiBvdCh0LGUpe2lmKHQpe3ZhciByPXQuc3RhcnQrZTt0LnN0YXJ0PXQuc3RhcnRQVFM9cix0LmVuZFBUUz1yK3QuZHVyYXRpb259fWZ1bmN0aW9uIGx0KHQsZSl7Zm9yKHZhciByPWUuZnJhZ21lbnRzLGk9MCxhPXIubGVuZ3RoO2k8YTtpKyspb3QocltpXSx0KTtlLmZyYWdtZW50SGludCYmb3QoZS5mcmFnbWVudEhpbnQsdCksZS5hbGlnbmVkU2xpZGluZz0hMH1mdW5jdGlvbiB1dCh0LGUscil7ZSYmKCFmdW5jdGlvbih0LGUscil7aWYoZnVuY3Rpb24odCxlLHIpe3JldHVybiEoIWUuZGV0YWlsc3x8IShyLmVuZENDPnIuc3RhcnRDQ3x8dCYmdC5jYzxyLnN0YXJ0Q0MpKX0odCxyLGUpKXt2YXIgaT1mdW5jdGlvbih0LGUpe3ZhciByPXQuZnJhZ21lbnRzLGk9ZS5mcmFnbWVudHM7aWYoaS5sZW5ndGgmJnIubGVuZ3RoKXt2YXIgYT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgcj1udWxsLGk9MCxhPXQubGVuZ3RoO2k8YTtpKyspe3ZhciBuPXRbaV07aWYobiYmbi5jYz09PWUpe3I9bjticmVha319cmV0dXJuIHJ9KHIsaVswXS5jYyk7aWYoYSYmKCFhfHxhLnN0YXJ0UFRTKSlyZXR1cm4gYTtvLmIubG9nKFwiTm8gZnJhZyBpbiBwcmV2aW91cyBsZXZlbCB0byBhbGlnbiBvblwiKX1lbHNlIG8uYi5sb2coXCJObyBmcmFnbWVudHMgdG8gYWxpZ25cIil9KHIuZGV0YWlscyxlKTtpJiZPYmplY3QoYS5hKShpLnN0YXJ0KSYmKG8uYi5sb2coXCJBZGp1c3RpbmcgUFRTIHVzaW5nIGxhc3QgbGV2ZWwgZHVlIHRvIENDIGluY3JlYXNlIHdpdGhpbiBjdXJyZW50IGxldmVsIFwiK2UudXJsKSxsdChpLnN0YXJ0LGUpKX19KHQscixlKSwhci5hbGlnbmVkU2xpZGluZyYmZS5kZXRhaWxzJiZmdW5jdGlvbih0LGUpe2lmKCFlLmZyYWdtZW50cy5sZW5ndGh8fCF0Lmhhc1Byb2dyYW1EYXRlVGltZXx8IWUuaGFzUHJvZ3JhbURhdGVUaW1lKXJldHVybjt2YXIgcj1lLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWUsaT10LmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWUsbj0oaS1yKS8xZTMrZS5mcmFnbWVudHNbMF0uc3RhcnQ7biYmT2JqZWN0KGEuYSkobikmJihvLmIubG9nKFwiQWRqdXN0aW5nIFBUUyB1c2luZyBwcm9ncmFtRGF0ZVRpbWUgZGVsdGEgXCIrKGktcikrXCJtcywgc2xpZGluZzpcIituLnRvRml4ZWQoMykrXCIgXCIrdC51cmwrXCIgXCIpLGx0KG4sdCkpfShyLGUuZGV0YWlscyksci5hbGlnbmVkU2xpZGluZ3x8IWUuZGV0YWlsc3x8ci5za2lwcGVkU2VnbWVudHN8fFkoZS5kZXRhaWxzLHIpKX12YXIgZHQ9e3NlYXJjaDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgcj0wLGk9dC5sZW5ndGgtMSxhPW51bGwsbj1udWxsO3I8PWk7KXt2YXIgcz1lKG49dFthPShyK2kpLzJ8MF0pO2lmKHM+MClyPWErMTtlbHNle2lmKCEoczwwKSlyZXR1cm4gbjtpPWEtMX19cmV0dXJuIG51bGx9fTtmdW5jdGlvbiBodCh0LGUscil7dm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09ZSYmKGU9MCk7dmFyIGk9TWF0aC5taW4oZSxyLmR1cmF0aW9uKyhyLmRlbHRhUFRTP3IuZGVsdGFQVFM6MCkpO3JldHVybiByLnN0YXJ0K3IuZHVyYXRpb24taTw9dD8xOnIuc3RhcnQtaT50JiZyLnN0YXJ0Py0xOjB9ZnVuY3Rpb24gZnQodCxlLHIpe3ZhciBpPTFlMypNYXRoLm1pbihlLHIuZHVyYXRpb24rKHIuZGVsdGFQVFM/ci5kZWx0YVBUUzowKSk7cmV0dXJuKHIuZW5kUHJvZ3JhbURhdGVUaW1lfHwwKS1pPnR9ZnVuY3Rpb24gY3QodCl7dmFyIGU9XCJmdW5jdGlvblwiPT10eXBlb2YgTWFwP25ldyBNYXA6dm9pZCAwO3JldHVybihjdD1mdW5jdGlvbih0KXtpZihudWxsPT09dHx8KHI9dCwtMT09PUZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwocikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikpKXJldHVybiB0O3ZhciByO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2lmKHZvaWQgMCE9PWUpe2lmKGUuaGFzKHQpKXJldHVybiBlLmdldCh0KTtlLnNldCh0LGkpfWZ1bmN0aW9uIGkoKXtyZXR1cm4gdnQodCxhcmd1bWVudHMsbXQodGhpcykuY29uc3RydWN0b3IpfXJldHVybiBpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6aSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxwdChpLHQpfSkodCl9ZnVuY3Rpb24gdnQodCxlLHIpe3JldHVybih2dD1ndCgpP1JlZmxlY3QuY29uc3RydWN0OmZ1bmN0aW9uKHQsZSxyKXt2YXIgaT1bbnVsbF07aS5wdXNoLmFwcGx5KGksZSk7dmFyIGE9bmV3KEZ1bmN0aW9uLmJpbmQuYXBwbHkodCxpKSk7cmV0dXJuIHImJnB0KGEsci5wcm90b3R5cGUpLGF9KS5hcHBseShudWxsLGFyZ3VtZW50cyl9ZnVuY3Rpb24gZ3QoKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX1mdW5jdGlvbiBwdCh0LGUpe3JldHVybihwdD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWUsdH0pKHQsZSl9ZnVuY3Rpb24gbXQodCl7cmV0dXJuKG10PU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9KSh0KX12YXIgeXQ9TWF0aC5wb3coMiwxNyksYnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuY29uZmlnPXZvaWQgMCx0aGlzLmxvYWRlcj1udWxsLHRoaXMucGFydExvYWRUaW1lb3V0PS0xLHRoaXMuY29uZmlnPXR9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMubG9hZGVyJiYodGhpcy5sb2FkZXIuZGVzdHJveSgpLHRoaXMubG9hZGVyPW51bGwpfSxlLmFib3J0PWZ1bmN0aW9uKCl7dGhpcy5sb2FkZXImJnRoaXMubG9hZGVyLmFib3J0KCl9LGUubG9hZD1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMsaT10LnVybDtpZighaSlyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEV0KHt0eXBlOnMuYi5ORVRXT1JLX0VSUk9SLGRldGFpbHM6cy5hLkZSQUdfTE9BRF9FUlJPUixmYXRhbDohMSxmcmFnOnQsbmV0d29ya0RldGFpbHM6bnVsbH0sXCJGcmFnbWVudCBkb2VzIG5vdCBoYXZlIGEgXCIrKGk/XCJwYXJ0IGxpc3RcIjpcInVybFwiKSkpO3RoaXMuYWJvcnQoKTt2YXIgYT10aGlzLmNvbmZpZyxuPWEuZkxvYWRlcixvPWEubG9hZGVyO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oaSxsKXtyLmxvYWRlciYmci5sb2FkZXIuZGVzdHJveSgpO3ZhciB1PXIubG9hZGVyPXQubG9hZGVyPW4/bmV3IG4oYSk6bmV3IG8oYSksZD1UdCh0KSxoPXt0aW1lb3V0OmEuZnJhZ0xvYWRpbmdUaW1lT3V0LG1heFJldHJ5OjAscmV0cnlEZWxheTowLG1heFJldHJ5RGVsYXk6YS5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCxoaWdoV2F0ZXJNYXJrOnl0fTt0LnN0YXRzPXUuc3RhdHMsdS5sb2FkKGQsaCx7b25TdWNjZXNzOmZ1bmN0aW9uKGUsYSxuLHMpe3IucmVzZXRMb2FkZXIodCx1KSxpKHtmcmFnOnQscGFydDpudWxsLHBheWxvYWQ6ZS5kYXRhLG5ldHdvcmtEZXRhaWxzOnN9KX0sb25FcnJvcjpmdW5jdGlvbihlLGksYSl7ci5yZXNldExvYWRlcih0LHUpLGwobmV3IEV0KHt0eXBlOnMuYi5ORVRXT1JLX0VSUk9SLGRldGFpbHM6cy5hLkZSQUdfTE9BRF9FUlJPUixmYXRhbDohMSxmcmFnOnQscmVzcG9uc2U6ZSxuZXR3b3JrRGV0YWlsczphfSkpfSxvbkFib3J0OmZ1bmN0aW9uKGUsaSxhKXtyLnJlc2V0TG9hZGVyKHQsdSksbChuZXcgRXQoe3R5cGU6cy5iLk5FVFdPUktfRVJST1IsZGV0YWlsczpzLmEuSU5URVJOQUxfQUJPUlRFRCxmYXRhbDohMSxmcmFnOnQsbmV0d29ya0RldGFpbHM6YX0pKX0sb25UaW1lb3V0OmZ1bmN0aW9uKGUsaSxhKXtyLnJlc2V0TG9hZGVyKHQsdSksbChuZXcgRXQoe3R5cGU6cy5iLk5FVFdPUktfRVJST1IsZGV0YWlsczpzLmEuRlJBR19MT0FEX1RJTUVPVVQsZmF0YWw6ITEsZnJhZzp0LG5ldHdvcmtEZXRhaWxzOmF9KSl9LG9uUHJvZ3Jlc3M6ZnVuY3Rpb24ocixpLGEsbil7ZSYmZSh7ZnJhZzp0LHBhcnQ6bnVsbCxwYXlsb2FkOmEsbmV0d29ya0RldGFpbHM6bn0pfX0pfSkpfSxlLmxvYWRQYXJ0PWZ1bmN0aW9uKHQsZSxyKXt2YXIgaT10aGlzO3RoaXMuYWJvcnQoKTt2YXIgYT10aGlzLmNvbmZpZyxuPWEuZkxvYWRlcixvPWEubG9hZGVyO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24obCx1KXtpLmxvYWRlciYmaS5sb2FkZXIuZGVzdHJveSgpO3ZhciBkPWkubG9hZGVyPXQubG9hZGVyPW4/bmV3IG4oYSk6bmV3IG8oYSksaD1UdCh0LGUpLGY9e3RpbWVvdXQ6YS5mcmFnTG9hZGluZ1RpbWVPdXQsbWF4UmV0cnk6MCxyZXRyeURlbGF5OjAsbWF4UmV0cnlEZWxheTphLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0LGhpZ2hXYXRlck1hcms6eXR9O2Uuc3RhdHM9ZC5zdGF0cyxkLmxvYWQoaCxmLHtvblN1Y2Nlc3M6ZnVuY3Rpb24oYSxuLHMsbyl7aS5yZXNldExvYWRlcih0LGQpLGkudXBkYXRlU3RhdHNGcm9tUGFydCh0LGUpO3ZhciB1PXtmcmFnOnQscGFydDplLHBheWxvYWQ6YS5kYXRhLG5ldHdvcmtEZXRhaWxzOm99O3IodSksbCh1KX0sb25FcnJvcjpmdW5jdGlvbihyLGEsbil7aS5yZXNldExvYWRlcih0LGQpLHUobmV3IEV0KHt0eXBlOnMuYi5ORVRXT1JLX0VSUk9SLGRldGFpbHM6cy5hLkZSQUdfTE9BRF9FUlJPUixmYXRhbDohMSxmcmFnOnQscGFydDplLHJlc3BvbnNlOnIsbmV0d29ya0RldGFpbHM6bn0pKX0sb25BYm9ydDpmdW5jdGlvbihyLGEsbil7dC5zdGF0cy5hYm9ydGVkPWUuc3RhdHMuYWJvcnRlZCxpLnJlc2V0TG9hZGVyKHQsZCksdShuZXcgRXQoe3R5cGU6cy5iLk5FVFdPUktfRVJST1IsZGV0YWlsczpzLmEuSU5URVJOQUxfQUJPUlRFRCxmYXRhbDohMSxmcmFnOnQscGFydDplLG5ldHdvcmtEZXRhaWxzOm59KSl9LG9uVGltZW91dDpmdW5jdGlvbihyLGEsbil7aS5yZXNldExvYWRlcih0LGQpLHUobmV3IEV0KHt0eXBlOnMuYi5ORVRXT1JLX0VSUk9SLGRldGFpbHM6cy5hLkZSQUdfTE9BRF9USU1FT1VULGZhdGFsOiExLGZyYWc6dCxwYXJ0OmUsbmV0d29ya0RldGFpbHM6bn0pKX19KX0pKX0sZS51cGRhdGVTdGF0c0Zyb21QYXJ0PWZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5zdGF0cyxpPWUuc3RhdHMsYT1pLnRvdGFsO2lmKHIubG9hZGVkKz1pLmxvYWRlZCxhKXt2YXIgbj1NYXRoLnJvdW5kKHQuZHVyYXRpb24vZS5kdXJhdGlvbikscz1NYXRoLm1pbihNYXRoLnJvdW5kKHIubG9hZGVkL2EpLG4pLG89KG4tcykqTWF0aC5yb3VuZChyLmxvYWRlZC9zKTtyLnRvdGFsPXIubG9hZGVkK299ZWxzZSByLnRvdGFsPU1hdGgubWF4KHIubG9hZGVkLHIudG90YWwpO3ZhciBsPXIubG9hZGluZyx1PWkubG9hZGluZztsLnN0YXJ0P2wuZmlyc3QrPXUuZmlyc3QtdS5zdGFydDoobC5zdGFydD11LnN0YXJ0LGwuZmlyc3Q9dS5maXJzdCksbC5lbmQ9dS5lbmR9LGUucmVzZXRMb2FkZXI9ZnVuY3Rpb24odCxlKXt0LmxvYWRlcj1udWxsLHRoaXMubG9hZGVyPT09ZSYmKHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucGFydExvYWRUaW1lb3V0KSx0aGlzLmxvYWRlcj1udWxsKSxlLmRlc3Ryb3koKX0sdH0oKTtmdW5jdGlvbiBUdCh0LGUpe3ZvaWQgMD09PWUmJihlPW51bGwpO3ZhciByPWV8fHQsaT17ZnJhZzp0LHBhcnQ6ZSxyZXNwb25zZVR5cGU6XCJhcnJheWJ1ZmZlclwiLHVybDpyLnVybCxoZWFkZXJzOnt9LHJhbmdlU3RhcnQ6MCxyYW5nZUVuZDowfSxuPXIuYnl0ZVJhbmdlU3RhcnRPZmZzZXQscz1yLmJ5dGVSYW5nZUVuZE9mZnNldDtyZXR1cm4gT2JqZWN0KGEuYSkobikmJk9iamVjdChhLmEpKHMpJiYoaS5yYW5nZVN0YXJ0PW4saS5yYW5nZUVuZD1zKSxpfXZhciBFdD1mdW5jdGlvbih0KXt2YXIgZSxyO2Z1bmN0aW9uIGkoZSl7Zm9yKHZhciByLGk9YXJndW1lbnRzLmxlbmd0aCxhPW5ldyBBcnJheShpPjE/aS0xOjApLG49MTtuPGk7bisrKWFbbi0xXT1hcmd1bWVudHNbbl07cmV0dXJuKHI9dC5jYWxsLmFwcGx5KHQsW3RoaXNdLmNvbmNhdChhKSl8fHRoaXMpLmRhdGE9dm9pZCAwLHIuZGF0YT1lLHJ9cmV0dXJuIHI9dCwoZT1pKS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSxwdChlLHIpLGl9KGN0KEVycm9yKSksU3Q9cigxNCksTHQ9e3RvU3RyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1cIlwiLHI9dC5sZW5ndGgsaT0wO2k8cjtpKyspZSs9XCJbXCIrdC5zdGFydChpKS50b0ZpeGVkKDMpK1wiLFwiK3QuZW5kKGkpLnRvRml4ZWQoMykrXCJdXCI7cmV0dXJuIGV9fTtmdW5jdGlvbiBBdCh0LGUpe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgaT1lW3JdO2kuZW51bWVyYWJsZT1pLmVudW1lcmFibGV8fCExLGkuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGkmJihpLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLmtleSxpKX19ZnVuY3Rpb24gUnQodCxlKXtyZXR1cm4oUnQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfXZhciBEdD1cIlNUT1BQRURcIixfdD1cIklETEVcIixrdD1cIktFWV9MT0FESU5HXCIseHQ9XCJGUkFHX0xPQURJTkdcIixDdD1cIkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZXCIsd3Q9XCJQQVJTSU5HXCIsT3Q9XCJQQVJTRURcIixJdD1cIkJBQ0tUUkFDS0lOR1wiLFB0PVwiRU5ERURcIixGdD1cIkVSUk9SXCIsTXQ9XCJXQUlUSU5HX0xFVkVMXCIsTnQ9ZnVuY3Rpb24odCl7dmFyIGUscjtmdW5jdGlvbiBpKGUscixpKXt2YXIgYTtyZXR1cm4oYT10LmNhbGwodGhpcyl8fHRoaXMpLmhscz12b2lkIDAsYS5mcmFnUHJldmlvdXM9bnVsbCxhLmZyYWdDdXJyZW50PW51bGwsYS5mcmFnbWVudFRyYWNrZXI9dm9pZCAwLGEudHJhbnNtdXhlcj1udWxsLGEuX3N0YXRlPUR0LGEubWVkaWE9dm9pZCAwLGEubWVkaWFCdWZmZXI9dm9pZCAwLGEuY29uZmlnPXZvaWQgMCxhLmJpdHJhdGVUZXN0PSExLGEubGFzdEN1cnJlbnRUaW1lPTAsYS5uZXh0TG9hZFBvc2l0aW9uPTAsYS5zdGFydFBvc2l0aW9uPTAsYS5sb2FkZWRtZXRhZGF0YT0hMSxhLmZyYWdMb2FkRXJyb3I9MCxhLnJldHJ5RGF0ZT0wLGEubGV2ZWxzPW51bGwsYS5mcmFnbWVudExvYWRlcj12b2lkIDAsYS5sZXZlbExhc3RMb2FkZWQ9bnVsbCxhLnN0YXJ0RnJhZ1JlcXVlc3RlZD0hMSxhLmRlY3J5cHRlcj12b2lkIDAsYS5pbml0UFRTPVtdLGEub252c2Vla2luZz1udWxsLGEub252ZW5kZWQ9bnVsbCxhLmxvZ1ByZWZpeD1cIlwiLGEubG9nPXZvaWQgMCxhLndhcm49dm9pZCAwLGEubG9nUHJlZml4PWksYS5sb2c9by5iLmxvZy5iaW5kKG8uYixpK1wiOlwiKSxhLndhcm49by5iLndhcm4uYmluZChvLmIsaStcIjpcIiksYS5obHM9ZSxhLmZyYWdtZW50TG9hZGVyPW5ldyBidChlLmNvbmZpZyksYS5mcmFnbWVudFRyYWNrZXI9cixhLmNvbmZpZz1lLmNvbmZpZyxhLmRlY3J5cHRlcj1uZXcgU3QuYShlLGUuY29uZmlnKSxlLm9uKG4uYS5LRVlfTE9BREVELGEub25LZXlMb2FkZWQsZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9KGEpKSxhfXI9dCwoZT1pKS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSxSdChlLHIpO3ZhciB1LGQsaCxmPWkucHJvdG90eXBlO3JldHVybiBmLmRvVGljaz1mdW5jdGlvbigpe3RoaXMub25UaWNrRW5kKCl9LGYub25UaWNrRW5kPWZ1bmN0aW9uKCl7fSxmLnN0YXJ0TG9hZD1mdW5jdGlvbih0KXt9LGYuc3RvcExvYWQ9ZnVuY3Rpb24oKXt0aGlzLmZyYWdtZW50TG9hZGVyLmFib3J0KCk7dmFyIHQ9dGhpcy5mcmFnQ3VycmVudDt0JiZ0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudCh0KSx0aGlzLnJlc2V0VHJhbnNtdXhlcigpLHRoaXMuZnJhZ0N1cnJlbnQ9bnVsbCx0aGlzLmZyYWdQcmV2aW91cz1udWxsLHRoaXMuY2xlYXJJbnRlcnZhbCgpLHRoaXMuY2xlYXJOZXh0VGljaygpLHRoaXMuc3RhdGU9RHR9LGYuX3N0cmVhbUVuZGVkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5mcmFnQ3VycmVudCxpPXRoaXMuZnJhZ21lbnRUcmFja2VyO2lmKCFlLmxpdmUmJnImJnIuc24+PWUuZW5kU04mJiF0Lm5leHRTdGFydCl7dmFyIGE9ZS5wYXJ0TGlzdDtpZihudWxsIT1hJiZhLmxlbmd0aCl7dmFyIG49YVthLmxlbmd0aC0xXTtyZXR1cm4gbnQuaXNCdWZmZXJlZCh0aGlzLm1lZGlhLG4uc3RhcnQrbi5kdXJhdGlvbi8yKX12YXIgcz1pLmdldFN0YXRlKHIpO3JldHVybiBzPT09JC5QQVJUSUFMfHxzPT09JC5PS31yZXR1cm4hMX0sZi5vbk1lZGlhQXR0YWNoZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLm1lZGlhPXRoaXMubWVkaWFCdWZmZXI9ZS5tZWRpYTt0aGlzLm9udnNlZWtpbmc9dGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpLHRoaXMub252ZW5kZWQ9dGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKSxyLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWVraW5nXCIsdGhpcy5vbnZzZWVraW5nKSxyLmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLHRoaXMub252ZW5kZWQpO3ZhciBpPXRoaXMuY29uZmlnO3RoaXMubGV2ZWxzJiZpLmF1dG9TdGFydExvYWQmJnRoaXMuc3RhdGU9PT1EdCYmdGhpcy5zdGFydExvYWQoaS5zdGFydFBvc2l0aW9uKX0sZi5vbk1lZGlhRGV0YWNoaW5nPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5tZWRpYTtudWxsIT10JiZ0LmVuZGVkJiYodGhpcy5sb2coXCJNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvblwiKSx0aGlzLnN0YXJ0UG9zaXRpb249dGhpcy5sYXN0Q3VycmVudFRpbWU9MCksdCYmKHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlZWtpbmdcIix0aGlzLm9udnNlZWtpbmcpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsdGhpcy5vbnZlbmRlZCksdGhpcy5vbnZzZWVraW5nPXRoaXMub252ZW5kZWQ9bnVsbCksdGhpcy5tZWRpYT10aGlzLm1lZGlhQnVmZmVyPW51bGwsdGhpcy5sb2FkZWRtZXRhZGF0YT0hMSx0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKSx0aGlzLnN0b3BMb2FkKCl9LGYub25NZWRpYVNlZWtpbmc9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNvbmZpZyxlPXRoaXMuZnJhZ0N1cnJlbnQscj10aGlzLm1lZGlhLGk9dGhpcy5tZWRpYUJ1ZmZlcixuPXRoaXMuc3RhdGUscz1yP3IuY3VycmVudFRpbWU6MCxvPW50LmJ1ZmZlckluZm8oaXx8cixzLHQubWF4QnVmZmVySG9sZSk7aWYodGhpcy5sb2coXCJtZWRpYSBzZWVraW5nIHRvIFwiKyhPYmplY3QoYS5hKShzKT9zLnRvRml4ZWQoMyk6cykrXCIsIHN0YXRlOiBcIituKSxuPT09UHQpdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO2Vsc2UgaWYoZSYmIW8ubGVuKXt2YXIgbD10Lm1heEZyYWdMb29rVXBUb2xlcmFuY2UsdT1lLnN0YXJ0LWwsZD1zPmUuc3RhcnQrZS5kdXJhdGlvbitsOyhzPHV8fGQpJiYoZCYmZS5sb2FkZXImJih0aGlzLmxvZyhcInNlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgd2hpbGUgZnJhZ21lbnQgbG9hZCBpbiBwcm9ncmVzcywgY2FuY2VsIGZyYWdtZW50IGxvYWRcIiksZS5sb2FkZXIuYWJvcnQoKSksdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpKX1yJiYodGhpcy5sYXN0Q3VycmVudFRpbWU9cyksdGhpcy5sb2FkZWRtZXRhZGF0YXx8by5sZW58fCh0aGlzLm5leHRMb2FkUG9zaXRpb249dGhpcy5zdGFydFBvc2l0aW9uPXMpLHRoaXMudGlja0ltbWVkaWF0ZSgpfSxmLm9uTWVkaWFFbmRlZD1mdW5jdGlvbigpe3RoaXMuc3RhcnRQb3NpdGlvbj10aGlzLmxhc3RDdXJyZW50VGltZT0wfSxmLm9uS2V5TG9hZGVkPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zdGF0ZT09PWt0JiZlLmZyYWc9PT10aGlzLmZyYWdDdXJyZW50JiZ0aGlzLmxldmVscyl7dGhpcy5zdGF0ZT1fdDt2YXIgcj10aGlzLmxldmVsc1tlLmZyYWcubGV2ZWxdLmRldGFpbHM7ciYmdGhpcy5sb2FkRnJhZ21lbnQoZS5mcmFnLHIsZS5mcmFnLnN0YXJ0KX19LGYub25IYW5kbGVyRGVzdHJveWluZz1mdW5jdGlvbigpe3RoaXMuc3RvcExvYWQoKSx0LnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95aW5nLmNhbGwodGhpcyl9LGYub25IYW5kbGVyRGVzdHJveWVkPWZ1bmN0aW9uKCl7dGhpcy5zdGF0ZT1EdCx0aGlzLmhscy5vZmYobi5hLktFWV9MT0FERUQsdGhpcy5vbktleUxvYWRlZCx0aGlzKSx0aGlzLmZyYWdtZW50TG9hZGVyJiZ0aGlzLmZyYWdtZW50TG9hZGVyLmRlc3Ryb3koKSx0aGlzLmRlY3J5cHRlciYmdGhpcy5kZWNyeXB0ZXIuZGVzdHJveSgpLHRoaXMuaGxzPXRoaXMubG9nPXRoaXMud2Fybj10aGlzLmRlY3J5cHRlcj10aGlzLmZyYWdtZW50TG9hZGVyPXRoaXMuZnJhZ21lbnRUcmFja2VyPW51bGwsdC5wcm90b3R5cGUub25IYW5kbGVyRGVzdHJveWVkLmNhbGwodGhpcyl9LGYubG9hZEtleT1mdW5jdGlvbih0LGUpe3RoaXMubG9nKFwiTG9hZGluZyBrZXkgZm9yIFwiK3Quc24rXCIgb2YgW1wiK2Uuc3RhcnRTTitcIi1cIitlLmVuZFNOK1wiXSwgXCIrKFwiW3N0cmVhbS1jb250cm9sbGVyXVwiPT09dGhpcy5sb2dQcmVmaXg/XCJsZXZlbFwiOlwidHJhY2tcIikrXCIgXCIrdC5sZXZlbCksdGhpcy5zdGF0ZT1rdCx0aGlzLmZyYWdDdXJyZW50PXQsdGhpcy5obHMudHJpZ2dlcihuLmEuS0VZX0xPQURJTkcse2ZyYWc6dH0pfSxmLmxvYWRGcmFnbWVudD1mdW5jdGlvbih0LGUscil7dGhpcy5fbG9hZEZyYWdGb3JQbGF5YmFjayh0LGUscil9LGYuX2xvYWRGcmFnRm9yUGxheWJhY2s9ZnVuY3Rpb24odCxlLHIpe3ZhciBpPXRoaXM7dGhpcy5fZG9GcmFnTG9hZCh0LGUsciwoZnVuY3Rpb24oZSl7aWYoaS5mcmFnQ29udGV4dENoYW5nZWQodCkpcmV0dXJuIGkud2FybihcIkZyYWdtZW50IFwiK3Quc24rKGUucGFydD9cIiBwOiBcIitlLnBhcnQuaW5kZXg6XCJcIikrXCIgb2YgbGV2ZWwgXCIrdC5sZXZlbCtcIiB3YXMgZHJvcHBlZCBkdXJpbmcgZG93bmxvYWQuXCIpLHZvaWQgaS5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQodCk7dC5zdGF0cy5jaHVua0NvdW50KyssaS5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZSl9KSkudGhlbigoZnVuY3Rpb24oZSl7aWYoZSl7aS5mcmFnTG9hZEVycm9yPTA7dmFyIHI9aS5zdGF0ZTtpZighaS5mcmFnQ29udGV4dENoYW5nZWQodCkpcmV0dXJuXCJwYXlsb2FkXCJpbiBlJiYoaS5sb2coXCJMb2FkZWQgZnJhZ21lbnQgXCIrdC5zbitcIiBvZiBsZXZlbCBcIit0LmxldmVsKSxpLmhscy50cmlnZ2VyKG4uYS5GUkFHX0xPQURFRCxlKSxpLnN0YXRlPT09SXQpPyhpLmZyYWdtZW50VHJhY2tlci5iYWNrdHJhY2sodCxlKSx2b2lkIGkucmVzZXRGcmFnbWVudExvYWRpbmcodCkpOnZvaWQgaS5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZSk7KHI9PT14dHx8cj09PUl0fHwhaS5mcmFnQ3VycmVudCYmcj09PXd0KSYmKGkuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KHQpLGkuc3RhdGU9X3QpfX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7aS53YXJuKGUpLGkucmVzZXRGcmFnbWVudExvYWRpbmcodCl9KSl9LGYuZmx1c2hNYWluQnVmZmVyPWZ1bmN0aW9uKHQsZSxyKXtpZih2b2lkIDA9PT1yJiYocj1udWxsKSx0LWUpe3ZhciBpPXtzdGFydE9mZnNldDp0LGVuZE9mZnNldDplLHR5cGU6cn07dGhpcy5mcmFnTG9hZEVycm9yPTAsdGhpcy5obHMudHJpZ2dlcihuLmEuQlVGRkVSX0ZMVVNISU5HLGkpfX0sZi5fbG9hZEluaXRTZWdtZW50PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy5fZG9GcmFnTG9hZCh0KS50aGVuKChmdW5jdGlvbihyKXtpZighcnx8ZS5mcmFnQ29udGV4dENoYW5nZWQodCl8fCFlLmxldmVscyl0aHJvdyBuZXcgRXJyb3IoXCJpbml0IGxvYWQgYWJvcnRlZFwiKTtyZXR1cm4gcn0pKS50aGVuKChmdW5jdGlvbihyKXt2YXIgaT1lLmhscyxhPXIucGF5bG9hZCxzPXQuZGVjcnlwdGRhdGE7aWYoYSYmYS5ieXRlTGVuZ3RoPjAmJnMmJnMua2V5JiZzLml2JiZcIkFFUy0xMjhcIj09PXMubWV0aG9kKXt2YXIgbz1zZWxmLnBlcmZvcm1hbmNlLm5vdygpO3JldHVybiBlLmRlY3J5cHRlci53ZWJDcnlwdG9EZWNyeXB0KG5ldyBVaW50OEFycmF5KGEpLHMua2V5LmJ1ZmZlcixzLml2LmJ1ZmZlcikudGhlbigoZnVuY3Rpb24oZSl7dmFyIGE9c2VsZi5wZXJmb3JtYW5jZS5ub3coKTtyZXR1cm4gaS50cmlnZ2VyKG4uYS5GUkFHX0RFQ1JZUFRFRCx7ZnJhZzp0LHBheWxvYWQ6ZSxzdGF0czp7dHN0YXJ0Om8sdGRlY3J5cHQ6YX19KSxyLnBheWxvYWQ9ZSxyfSkpfXJldHVybiByfSkpLnRoZW4oKGZ1bmN0aW9uKHIpe3ZhciBpPWUuZnJhZ0N1cnJlbnQsYT1lLmhscyxzPWUubGV2ZWxzO2lmKCFzKXRocm93IG5ldyBFcnJvcihcImluaXQgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVsc1wiKTtzW3QubGV2ZWxdLmRldGFpbHM7dmFyIG89dC5zdGF0cztlLnN0YXRlPV90LGUuZnJhZ0xvYWRFcnJvcj0wLHQuZGF0YT1uZXcgVWludDhBcnJheShyLnBheWxvYWQpLG8ucGFyc2luZy5zdGFydD1vLmJ1ZmZlcmluZy5zdGFydD1zZWxmLnBlcmZvcm1hbmNlLm5vdygpLG8ucGFyc2luZy5lbmQ9by5idWZmZXJpbmcuZW5kPXNlbGYucGVyZm9ybWFuY2Uubm93KCksci5mcmFnPT09aSYmYS50cmlnZ2VyKG4uYS5GUkFHX0JVRkZFUkVELHtzdGF0czpvLGZyYWc6aSxwYXJ0Om51bGwsaWQ6dC50eXBlfSksZS50aWNrKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKHIpe2Uud2FybihyKSxlLnJlc2V0RnJhZ21lbnRMb2FkaW5nKHQpfSkpfSxmLmZyYWdDb250ZXh0Q2hhbmdlZD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmZyYWdDdXJyZW50O3JldHVybiF0fHwhZXx8dC5sZXZlbCE9PWUubGV2ZWx8fHQuc24hPT1lLnNufHx0LnVybElkIT09ZS51cmxJZH0sZi5mcmFnQnVmZmVyZWRDb21wbGV0ZT1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMubWVkaWFCdWZmZXI/dGhpcy5tZWRpYUJ1ZmZlcjp0aGlzLm1lZGlhO3RoaXMubG9nKFwiQnVmZmVyZWQgXCIrdC50eXBlK1wiIHNuOiBcIit0LnNuKyhlP1wiIHBhcnQ6IFwiK2UuaW5kZXg6XCJcIikrXCIgb2YgXCIrKFwiW3N0cmVhbS1jb250cm9sbGVyXVwiPT09dGhpcy5sb2dQcmVmaXg/XCJsZXZlbFwiOlwidHJhY2tcIikrXCIgXCIrdC5sZXZlbCtcIiBcIitMdC50b1N0cmluZyhudC5nZXRCdWZmZXJlZChyKSkpLHRoaXMuc3RhdGU9X3QsdGhpcy50aWNrKCl9LGYuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudHJhbnNtdXhlcjtpZihlKXt2YXIgcj10LmZyYWcsaT10LnBhcnQsYT10LnBhcnRzTG9hZGVkLG49IWF8fDA9PT1hLmxlbmd0aHx8YS5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4hdH0pKSxzPW5ldyBzdChyLmxldmVsLHIuc24sci5zdGF0cy5jaHVua0NvdW50KzEsMCxpP2kuaW5kZXg6LTEsIW4pO2UuZmx1c2gocyl9fSxmLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcz1mdW5jdGlvbih0KXt9LGYuX2RvRnJhZ0xvYWQ9ZnVuY3Rpb24odCxlLHIsaSl7dmFyIHM9dGhpcztpZih2b2lkIDA9PT1yJiYocj1udWxsKSwhdGhpcy5sZXZlbHMpdGhyb3cgbmV3IEVycm9yKFwiZnJhZyBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWxzXCIpO2lmKHI9TWF0aC5tYXgodC5zdGFydCxyfHwwKSx0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSYmZSl7dmFyIG89ZS5wYXJ0TGlzdDtpZihvJiZpKXtyPnQuZW5kJiZlLmZyYWdtZW50SGludCYmKHQ9ZS5mcmFnbWVudEhpbnQpO3ZhciBsPXRoaXMuZ2V0TmV4dFBhcnQobyx0LHIpO2lmKGw+LTEpe3ZhciB1PW9bbF07cmV0dXJuIHRoaXMubG9nKFwiTG9hZGluZyBwYXJ0IHNuOiBcIit0LnNuK1wiIHA6IFwiK3UuaW5kZXgrXCIgY2M6IFwiK3QuY2MrXCIgb2YgcGxheWxpc3QgW1wiK2Uuc3RhcnRTTitcIi1cIitlLmVuZFNOK1wiXSBwYXJ0cyBbMC1cIitsK1wiLVwiKyhvLmxlbmd0aC0xKStcIl0gXCIrKFwiW3N0cmVhbS1jb250cm9sbGVyXVwiPT09dGhpcy5sb2dQcmVmaXg/XCJsZXZlbFwiOlwidHJhY2tcIikrXCI6IFwiK3QubGV2ZWwrXCIsIHRhcmdldDogXCIrcGFyc2VGbG9hdChyLnRvRml4ZWQoMykpKSx0aGlzLm5leHRMb2FkUG9zaXRpb249dS5zdGFydCt1LmR1cmF0aW9uLHRoaXMuc3RhdGU9eHQsdGhpcy5obHMudHJpZ2dlcihuLmEuRlJBR19MT0FESU5HLHtmcmFnOnQscGFydDpvW2xdLHRhcmdldEJ1ZmZlclRpbWU6cn0pLHRoaXMuZG9GcmFnUGFydHNMb2FkKHQsbyxsLGkpLmNhdGNoKChmdW5jdGlvbih0KXtyZXR1cm4gcy5oYW5kbGVGcmFnTG9hZEVycm9yKHQpfSkpfWlmKCF0LnVybHx8dGhpcy5sb2FkZWRFbmRPZlBhcnRzKG8scikpcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKX19cmV0dXJuIHRoaXMubG9nKFwiTG9hZGluZyBmcmFnbWVudCBcIit0LnNuK1wiIGNjOiBcIit0LmNjK1wiIFwiKyhlP1wib2YgW1wiK2Uuc3RhcnRTTitcIi1cIitlLmVuZFNOK1wiXSBcIjpcIlwiKSsoXCJbc3RyZWFtLWNvbnRyb2xsZXJdXCI9PT10aGlzLmxvZ1ByZWZpeD9cImxldmVsXCI6XCJ0cmFja1wiKStcIjogXCIrdC5sZXZlbCtcIiwgdGFyZ2V0OiBcIitwYXJzZUZsb2F0KHIudG9GaXhlZCgzKSkpLE9iamVjdChhLmEpKHQuc24pJiYhdGhpcy5iaXRyYXRlVGVzdCYmKHRoaXMubmV4dExvYWRQb3NpdGlvbj10LnN0YXJ0K3QuZHVyYXRpb24pLHRoaXMuc3RhdGU9eHQsdGhpcy5obHMudHJpZ2dlcihuLmEuRlJBR19MT0FESU5HLHtmcmFnOnQsdGFyZ2V0QnVmZmVyVGltZTpyfSksdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKHQsaSkuY2F0Y2goKGZ1bmN0aW9uKHQpe3JldHVybiBzLmhhbmRsZUZyYWdMb2FkRXJyb3IodCl9KSl9LGYuZG9GcmFnUGFydHNMb2FkPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihzLG8pe3ZhciBsPVtdOyFmdW5jdGlvbiByKHUpe3ZhciBkPWVbdV07YS5mcmFnbWVudExvYWRlci5sb2FkUGFydCh0LGQsaSkudGhlbigoZnVuY3Rpb24oaSl7bFtkLmluZGV4XT1pO3ZhciBvPWkucGFydDthLmhscy50cmlnZ2VyKG4uYS5GUkFHX0xPQURFRCxpKTt2YXIgaD1lW3UrMV07aWYoIWh8fGguZnJhZ21lbnQhPT10KXJldHVybiBzKHtmcmFnOnQscGFydDpvLHBhcnRzTG9hZGVkOmx9KTtyKHUrMSl9KSkuY2F0Y2gobyl9KHIpfSkpfSxmLmhhbmRsZUZyYWdMb2FkRXJyb3I9ZnVuY3Rpb24odCl7dmFyIGU9dC5kYXRhO3JldHVybiBlJiZlLmRldGFpbHM9PT1zLmEuSU5URVJOQUxfQUJPUlRFRD90aGlzLmhhbmRsZUZyYWdMb2FkQWJvcnRlZChlLmZyYWcsZS5wYXJ0KTp0aGlzLmhscy50cmlnZ2VyKG4uYS5FUlJPUixlKSxudWxsfSxmLl9oYW5kbGVUcmFuc211eGVyRmx1c2g9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRDdXJyZW50Q29udGV4dCh0KTtpZihlJiZ0aGlzLnN0YXRlPT09d3Qpe3ZhciByPWUuZnJhZyxpPWUucGFydCxhPWUubGV2ZWwsbj1zZWxmLnBlcmZvcm1hbmNlLm5vdygpO3Iuc3RhdHMucGFyc2luZy5lbmQ9bixpJiYoaS5zdGF0cy5wYXJzaW5nLmVuZD1uKSx0aGlzLnVwZGF0ZUxldmVsVGltaW5nKHIsaSxhLHQucGFydGlhbCl9ZWxzZSB0aGlzLmZyYWdDdXJyZW50fHwodGhpcy5zdGF0ZT1fdCl9LGYuZ2V0Q3VycmVudENvbnRleHQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5sZXZlbHMscj10LmxldmVsLGk9dC5zbixhPXQucGFydDtpZighZXx8IWVbcl0pcmV0dXJuIHRoaXMud2FybihcIkxldmVscyBvYmplY3Qgd2FzIHVuc2V0IHdoaWxlIGJ1ZmZlcmluZyBmcmFnbWVudCBcIitpK1wiIG9mIGxldmVsIFwiK3IrXCIuIFRoZSBjdXJyZW50IGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLlwiKSxudWxsO3ZhciBuPWVbcl0scz1hPi0xP2Z1bmN0aW9uKHQsZSxyKXtpZighdHx8IXQuZGV0YWlscylyZXR1cm4gbnVsbDt2YXIgaT10LmRldGFpbHMucGFydExpc3Q7aWYoaSlmb3IodmFyIGE9aS5sZW5ndGg7YS0tOyl7dmFyIG49aVthXTtpZihuLmluZGV4PT09ciYmbi5mcmFnbWVudC5zbj09PWUpcmV0dXJuIG59cmV0dXJuIG51bGx9KG4saSxhKTpudWxsLG89cz9zLmZyYWdtZW50OmZ1bmN0aW9uKHQsZSxyKXtpZighdHx8IXQuZGV0YWlscylyZXR1cm4gbnVsbDt2YXIgaT10LmRldGFpbHMsYT1pLmZyYWdtZW50c1tlLWkuc3RhcnRTTl07cmV0dXJuIGF8fCgoYT1pLmZyYWdtZW50SGludCkmJmEuc249PT1lP2E6ZTxpLnN0YXJ0U04mJnImJnIuc249PT1lP3I6bnVsbCl9KG4saSx0aGlzLmZyYWdDdXJyZW50KTtyZXR1cm4gbz97ZnJhZzpvLHBhcnQ6cyxsZXZlbDpufTpudWxsfSxmLmJ1ZmZlckZyYWdtZW50RGF0YT1mdW5jdGlvbih0LGUscixpKXtpZih0JiZ0aGlzLnN0YXRlPT09d3Qpe3ZhciBhPXQuZGF0YTEscz10LmRhdGEyLG89YTtpZihhJiZzJiYobz1PYmplY3QobC5hKShhLHMpKSxvJiZvLmxlbmd0aCl7dmFyIHU9e3R5cGU6dC50eXBlLGZyYWc6ZSxwYXJ0OnIsY2h1bmtNZXRhOmkscGFyZW50OmUudHlwZSxkYXRhOm99O3RoaXMuaGxzLnRyaWdnZXIobi5hLkJVRkZFUl9BUFBFTkRJTkcsdSksdC5kcm9wcGVkJiZ0LmluZGVwZW5kZW50JiYhciYmdGhpcy5mbHVzaEJ1ZmZlckdhcChlKX19fSxmLmZsdXNoQnVmZmVyR2FwPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubWVkaWE7aWYoZSlpZihudC5pc0J1ZmZlcmVkKGUsZS5jdXJyZW50VGltZSkpe3ZhciByPWUuY3VycmVudFRpbWUsaT1udC5idWZmZXJJbmZvKGUsciwwKSxhPXQuZHVyYXRpb24sbj1NYXRoLm1pbigyKnRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsLjI1KmEpLHM9TWF0aC5tYXgoTWF0aC5taW4odC5zdGFydC1uLGkuZW5kLW4pLHIrbik7dC5zdGFydC1zPm4mJnRoaXMuZmx1c2hNYWluQnVmZmVyKHMsdC5zdGFydCl9ZWxzZSB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLHQuc3RhcnQpfSxmLmdldEZ3ZEJ1ZmZlckluZm89ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLmNvbmZpZyxpPXRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7aWYoIU9iamVjdChhLmEpKGkpKXJldHVybiBudWxsO3ZhciBuPW50LmJ1ZmZlckluZm8odCxpLHIubWF4QnVmZmVySG9sZSk7aWYoMD09PW4ubGVuJiZ2b2lkIDAhPT1uLm5leHRTdGFydCl7dmFyIHM9dGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKGksZSk7aWYocyYmbi5uZXh0U3RhcnQ8cy5lbmQpcmV0dXJuIG50LmJ1ZmZlckluZm8odCxpLE1hdGgubWF4KG4ubmV4dFN0YXJ0LHIubWF4QnVmZmVySG9sZSkpfXJldHVybiBufSxmLmdldE1heEJ1ZmZlckxlbmd0aD1mdW5jdGlvbih0KXt2YXIgZSxyPXRoaXMuY29uZmlnO3JldHVybiBlPXQ/TWF0aC5tYXgoOCpyLm1heEJ1ZmZlclNpemUvdCxyLm1heEJ1ZmZlckxlbmd0aCk6ci5tYXhCdWZmZXJMZW5ndGgsTWF0aC5taW4oZSxyLm1heE1heEJ1ZmZlckxlbmd0aCl9LGYucmVkdWNlTWF4QnVmZmVyTGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY29uZmlnLHI9dHx8ZS5tYXhCdWZmZXJMZW5ndGg7cmV0dXJuIGUubWF4TWF4QnVmZmVyTGVuZ3RoPj1yJiYoZS5tYXhNYXhCdWZmZXJMZW5ndGgvPTIsdGhpcy53YXJuKFwiUmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvIFwiK2UubWF4TWF4QnVmZmVyTGVuZ3RoK1wic1wiKSwhMCl9LGYuZ2V0TmV4dEZyYWdtZW50PWZ1bmN0aW9uKHQsZSl7dmFyIHIsaSxhPWUuZnJhZ21lbnRzLG49YS5sZW5ndGg7aWYoIW4pcmV0dXJuIG51bGw7dmFyIHMsbz10aGlzLmNvbmZpZyxsPWFbMF0uc3RhcnQ7aWYoZS5saXZlKXt2YXIgdT1vLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO2lmKG48dSlyZXR1cm4gdGhpcy53YXJuKFwiTm90IGVub3VnaCBmcmFnbWVudHMgdG8gc3RhcnQgcGxheWJhY2sgKGhhdmU6IFwiK24rXCIsIG5lZWQ6IFwiK3UrXCIpXCIpLG51bGw7ZS5QVFNLbm93bnx8dGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWR8fC0xIT09dGhpcy5zdGFydFBvc2l0aW9ufHwocz10aGlzLmdldEluaXRpYWxMaXZlRnJhZ21lbnQoZSxhKSx0aGlzLnN0YXJ0UG9zaXRpb249cz90aGlzLmhscy5saXZlU3luY1Bvc2l0aW9ufHxzLnN0YXJ0OnQpfWVsc2UgdDw9bCYmKHM9YVswXSk7aWYoIXMpe3ZhciBkPW8ubG93TGF0ZW5jeU1vZGU/ZS5wYXJ0RW5kOmUuZnJhZ21lbnRFbmQ7cz10aGlzLmdldEZyYWdtZW50QXRQb3NpdGlvbih0LGQsZSl9cmV0dXJuIG51bGw9PT0ocj1zKXx8dm9pZCAwPT09cnx8IXIuaW5pdFNlZ21lbnR8fG51bGwhPT0oaT1zKSYmdm9pZCAwIT09aSYmaS5pbml0U2VnbWVudC5kYXRhfHx0aGlzLmJpdHJhdGVUZXN0fHwocz1zLmluaXRTZWdtZW50KSxzfSxmLmdldE5leHRQYXJ0PWZ1bmN0aW9uKHQsZSxyKXtmb3IodmFyIGk9LTEsYT0hMSxuPSEwLHM9MCxvPXQubGVuZ3RoO3M8bztzKyspe3ZhciBsPXRbc107aWYobj1uJiYhbC5pbmRlcGVuZGVudCxpPi0xJiZyPGwuc3RhcnQpYnJlYWs7dmFyIHU9bC5sb2FkZWQ7IXUmJihhfHxsLmluZGVwZW5kZW50fHxuKSYmbC5mcmFnbWVudD09PWUmJihpPXMpLGE9dX1yZXR1cm4gaX0sZi5sb2FkZWRFbmRPZlBhcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dFt0Lmxlbmd0aC0xXTtyZXR1cm4gciYmZT5yLnN0YXJ0JiZyLmxvYWRlZH0sZi5nZXRJbml0aWFsTGl2ZUZyYWdtZW50PWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5mcmFnUHJldmlvdXMsaT1udWxsO2lmKHIpe2lmKHQuaGFzUHJvZ3JhbURhdGVUaW1lJiYodGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgUERUOiBcIityLnByb2dyYW1EYXRlVGltZSksaT1mdW5jdGlvbih0LGUscil7aWYobnVsbD09PWV8fCFBcnJheS5pc0FycmF5KHQpfHwhdC5sZW5ndGh8fCFPYmplY3QoYS5hKShlKSlyZXR1cm4gbnVsbDtpZihlPCh0WzBdLnByb2dyYW1EYXRlVGltZXx8MCkpcmV0dXJuIG51bGw7aWYoZT49KHRbdC5sZW5ndGgtMV0uZW5kUHJvZ3JhbURhdGVUaW1lfHwwKSlyZXR1cm4gbnVsbDtyPXJ8fDA7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDsrK2kpe3ZhciBuPXRbaV07aWYoZnQoZSxyLG4pKXJldHVybiBufXJldHVybiBudWxsfShlLHIuZW5kUHJvZ3JhbURhdGVUaW1lLHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpKSwhaSl7dmFyIG49ci5zbisxO2lmKG4+PXQuc3RhcnRTTiYmbjw9dC5lbmRTTil7dmFyIHM9ZVtuLXQuc3RhcnRTTl07ci5jYz09PXMuY2MmJihpPXMsdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046IFwiK2kuc24pKX1pfHwoaT1mdW5jdGlvbih0LGUpe3JldHVybiBkdC5zZWFyY2godCwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2M8ZT8xOnQuY2M+ZT8tMTowfSkpfShlLHIuY2MpKSYmdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgQ0M6IFwiK2kuc24pfX1lbHNle3ZhciBvPXRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb247bnVsbCE9PW8mJihpPXRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKG8sdGhpcy5iaXRyYXRlVGVzdD90LmZyYWdtZW50RW5kOnQuZWRnZSx0KSl9cmV0dXJuIGl9LGYuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uPWZ1bmN0aW9uKHQsZSxyKXt2YXIgaSxhPXRoaXMuY29uZmlnLG49dGhpcy5mcmFnUHJldmlvdXMscz1yLmZyYWdtZW50cyxvPXIuZW5kU04sbD1yLmZyYWdtZW50SGludCx1PWEubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSxkPSEhKGEubG93TGF0ZW5jeU1vZGUmJnIucGFydExpc3QmJmwpOyhkJiZsJiYhdGhpcy5iaXRyYXRlVGVzdCYmKHM9cy5jb25jYXQobCksbz1sLnNuKSx0PGUpP2k9ZnVuY3Rpb24odCxlLHIsaSl7dm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09aSYmKGk9MCk7dmFyIGE9bnVsbDtpZih0P2E9ZVt0LnNuLWVbMF0uc24rMV18fG51bGw6MD09PXImJjA9PT1lWzBdLnN0YXJ0JiYoYT1lWzBdKSxhJiYwPT09aHQocixpLGEpKXJldHVybiBhO3ZhciBuPWR0LnNlYXJjaChlLGh0LmJpbmQobnVsbCxyLGkpKTtyZXR1cm4gbnx8YX0obixzLHQsdD5lLXU/MDp1KTppPXNbcy5sZW5ndGgtMV07aWYoaSl7dmFyIGg9aS5zbi1yLnN0YXJ0U04sZj1uJiZpLmxldmVsPT09bi5sZXZlbCxjPXNbaCsxXTtpZih0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShpKT09PSQuQkFDS1RSQUNLRUQpe2k9bnVsbDtmb3IodmFyIHY9aDtzW3ZdJiZ0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShzW3ZdKT09PSQuQkFDS1RSQUNLRUQ7KWk9bj9zW3YtLV06c1stLXZdO2l8fChpPWMpfWVsc2UgbiYmaS5zbj09PW4uc24mJiFkJiZmJiYoaS5zbjxvJiZ0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShjKSE9PSQuT0s/KHRoaXMubG9nKFwiU04gXCIraS5zbitcIiBqdXN0IGxvYWRlZCwgbG9hZCBuZXh0IG9uZTogXCIrYy5zbiksaT1jKTppPW51bGwpfXJldHVybiBpfSxmLnN5bmNocm9uaXplVG9MaXZlRWRnZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbmZpZyxyPXRoaXMubWVkaWE7aWYocil7dmFyIGk9dGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbixhPXIuY3VycmVudFRpbWUsbj10LmZyYWdtZW50c1swXS5zdGFydCxzPXQuZWRnZSxvPWE+PW4tZS5tYXhGcmFnTG9va1VwVG9sZXJhbmNlJiZhPD1zO2lmKG51bGwhPT1pJiZyLmR1cmF0aW9uPmkmJihhPGl8fCFvKSl7dmFyIGw9dm9pZCAwIT09ZS5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uP2UubGl2ZU1heExhdGVuY3lEdXJhdGlvbjplLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCp0LnRhcmdldGR1cmF0aW9uOyghbyYmci5yZWFkeVN0YXRlPDR8fGE8cy1sKSYmKHRoaXMubG9hZGVkbWV0YWRhdGF8fCh0aGlzLm5leHRMb2FkUG9zaXRpb249aSksci5yZWFkeVN0YXRlJiYodGhpcy53YXJuKFwiUGxheWJhY2s6IFwiK2EudG9GaXhlZCgzKStcIiBpcyBsb2NhdGVkIHRvbyBmYXIgZnJvbSB0aGUgZW5kIG9mIGxpdmUgc2xpZGluZyBwbGF5bGlzdDogXCIrcytcIiwgcmVzZXQgY3VycmVudFRpbWUgdG8gOiBcIitpLnRvRml4ZWQoMykpLHIuY3VycmVudFRpbWU9aSkpfX19LGYuYWxpZ25QbGF5bGlzdHM9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLmxldmVscyxpPXRoaXMubGV2ZWxMYXN0TG9hZGVkLG49dGhpcy5mcmFnUHJldmlvdXMscz1udWxsIT09aT9yW2ldOm51bGwsbz10LmZyYWdtZW50cy5sZW5ndGg7aWYoIW8pcmV0dXJuIHRoaXMud2FybihcIk5vIGZyYWdtZW50cyBpbiBsaXZlIHBsYXlsaXN0XCIpLDA7dmFyIGw9dC5mcmFnbWVudHNbMF0uc3RhcnQsdT0hZSxkPXQuYWxpZ25lZFNsaWRpbmcmJk9iamVjdChhLmEpKGwpO2lmKHV8fCFkJiYhbCl7dXQobixzLHQpO3ZhciBoPXQuZnJhZ21lbnRzWzBdLnN0YXJ0O3JldHVybiB0aGlzLmxvZyhcIkxpdmUgcGxheWxpc3Qgc2xpZGluZzogXCIraC50b0ZpeGVkKDIpK1wiIHN0YXJ0LXNuOiBcIisoZT9lLnN0YXJ0U046XCJuYVwiKStcIi0+XCIrdC5zdGFydFNOK1wiIHByZXYtc246IFwiKyhuP24uc246XCJuYVwiKStcIiBmcmFnbWVudHM6IFwiK28pLGh9cmV0dXJuIGx9LGYud2FpdEZvckNkblR1bmVJbj1mdW5jdGlvbih0KXtyZXR1cm4gdC5saXZlJiZ0LmNhbkJsb2NrUmVsb2FkJiZ0LnR1bmVJbkdvYWw+TWF0aC5tYXgodC5wYXJ0SG9sZEJhY2ssMyp0LnBhcnRUYXJnZXQpfSxmLnNldFN0YXJ0UG9zaXRpb249ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLnN0YXJ0UG9zaXRpb247aWYocjxlJiYocj0tMSksLTE9PT1yfHwtMT09PXRoaXMubGFzdEN1cnJlbnRUaW1lKXt2YXIgaT10LnN0YXJ0VGltZU9mZnNldDtPYmplY3QoYS5hKShpKT8ocj1lK2ksaTwwJiYocis9dC50b3RhbGR1cmF0aW9uKSxyPU1hdGgubWluKE1hdGgubWF4KGUsciksZSt0LnRvdGFsZHVyYXRpb24pLHRoaXMubG9nKFwiU3RhcnQgdGltZSBvZmZzZXQgXCIraStcIiBmb3VuZCBpbiBwbGF5bGlzdCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gdG8gXCIrciksdGhpcy5zdGFydFBvc2l0aW9uPXIpOnQubGl2ZT9yPXRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb258fGU6dGhpcy5zdGFydFBvc2l0aW9uPXI9MCx0aGlzLmxhc3RDdXJyZW50VGltZT1yfXRoaXMubmV4dExvYWRQb3NpdGlvbj1yfSxmLmdldExvYWRQb3NpdGlvbj1mdW5jdGlvbigpe3ZhciB0PXRoaXMubWVkaWEsZT0wO3JldHVybiB0aGlzLmxvYWRlZG1ldGFkYXRhJiZ0P2U9dC5jdXJyZW50VGltZTp0aGlzLm5leHRMb2FkUG9zaXRpb24mJihlPXRoaXMubmV4dExvYWRQb3NpdGlvbiksZX0sZi5oYW5kbGVGcmFnTG9hZEFib3J0ZWQ9ZnVuY3Rpb24odCxlKXt0aGlzLnRyYW5zbXV4ZXImJlwiaW5pdFNlZ21lbnRcIiE9PXQuc24mJnQuc3RhdHMuYWJvcnRlZCYmKHRoaXMud2FybihcIkZyYWdtZW50IFwiK3Quc24rKGU/XCIgcGFydFwiK2UuaW5kZXg6XCJcIikrXCIgb2YgbGV2ZWwgXCIrdC5sZXZlbCtcIiB3YXMgYWJvcnRlZFwiKSx0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKHQpKX0sZi5yZXNldEZyYWdtZW50TG9hZGluZz1mdW5jdGlvbih0KXt0aGlzLmZyYWdDdXJyZW50JiZ0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZCh0KXx8KHRoaXMuc3RhdGU9X3QpfSxmLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvcj1mdW5jdGlvbih0LGUpe2lmKCFlLmZhdGFsKXt2YXIgcj1lLmZyYWc7aWYociYmci50eXBlPT09dCl7dGhpcy5mcmFnQ3VycmVudDt2YXIgaT10aGlzLmNvbmZpZztpZih0aGlzLmZyYWdMb2FkRXJyb3IrMTw9aS5mcmFnTG9hZGluZ01heFJldHJ5KXtpZih0aGlzLnJlc2V0TGl2ZVN0YXJ0V2hlbk5vdExvYWRlZChyLmxldmVsKSlyZXR1cm47dmFyIGE9TWF0aC5taW4oTWF0aC5wb3coMix0aGlzLmZyYWdMb2FkRXJyb3IpKmkuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LGkuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO3RoaXMud2FybihcIkZyYWdtZW50IFwiK3Iuc24rXCIgb2YgXCIrdCtcIiBcIityLmxldmVsK1wiIGZhaWxlZCB0byBsb2FkLCByZXRyeWluZyBpbiBcIithK1wibXNcIiksdGhpcy5yZXRyeURhdGU9c2VsZi5wZXJmb3JtYW5jZS5ub3coKSthLHRoaXMuZnJhZ0xvYWRFcnJvcisrLHRoaXMuc3RhdGU9Q3R9ZWxzZSBlLmxldmVsUmV0cnk/KHQ9PT1fLmIuQVVESU8mJih0aGlzLmZyYWdDdXJyZW50PW51bGwpLHRoaXMuZnJhZ0xvYWRFcnJvcj0wLHRoaXMuc3RhdGU9X3QpOihvLmIuZXJyb3IoZS5kZXRhaWxzK1wiIHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLlwiKSxlLmZhdGFsPSEwLHRoaXMuaGxzLnN0b3BMb2FkKCksdGhpcy5zdGF0ZT1GdCl9fX0sZi5hZnRlckJ1ZmZlckZsdXNoZWQ9ZnVuY3Rpb24odCxlLHIpe2lmKHQpe3ZhciBpPW50LmdldEJ1ZmZlcmVkKHQpO3RoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZSxpLHIpLHRoaXMuc3RhdGU9PT1QdCYmdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpfX0sZi5yZXNldExvYWRpbmdTdGF0ZT1mdW5jdGlvbigpe3RoaXMuZnJhZ0N1cnJlbnQ9bnVsbCx0aGlzLmZyYWdQcmV2aW91cz1udWxsLHRoaXMuc3RhdGU9X3R9LGYucmVzZXRMaXZlU3RhcnRXaGVuTm90TG9hZGVkPWZ1bmN0aW9uKHQpe2lmKCF0aGlzLmxvYWRlZG1ldGFkYXRhKXt0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZD0hMTt2YXIgZT10aGlzLmxldmVscz90aGlzLmxldmVsc1t0XS5kZXRhaWxzOm51bGw7aWYobnVsbCE9ZSYmZS5saXZlKXJldHVybiB0aGlzLnN0YXJ0UG9zaXRpb249LTEsdGhpcy5zZXRTdGFydFBvc2l0aW9uKGUsMCksdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpLCEwO3RoaXMubmV4dExvYWRQb3NpdGlvbj10aGlzLnN0YXJ0UG9zaXRpb259cmV0dXJuITF9LGYudXBkYXRlTGV2ZWxUaW1pbmc9ZnVuY3Rpb24odCxlLHIsaSl7dmFyIGE9dGhpcyxzPXIuZGV0YWlscztPYmplY3Qua2V5cyh0LmVsZW1lbnRhcnlTdHJlYW1zKS5yZWR1Y2UoKGZ1bmN0aW9uKGUsbyl7dmFyIGw9dC5lbGVtZW50YXJ5U3RyZWFtc1tvXTtpZihsKXt2YXIgdT1sLmVuZFBUUy1sLnN0YXJ0UFRTO2lmKHU8PTApcmV0dXJuIGEud2FybihcIkNvdWxkIG5vdCBwYXJzZSBmcmFnbWVudCBcIit0LnNuK1wiIFwiK28rXCIgZHVyYXRpb24gcmVsaWFibHkgKFwiK3UrXCIpIHJlc2V0dGluZyB0cmFuc211eGVyIHRvIGZhbGxiYWNrIHRvIHBsYXlsaXN0IHRpbWluZ1wiKSxhLnJlc2V0VHJhbnNtdXhlcigpLGV8fCExO3ZhciBkPWk/MDpWKHMsdCxsLnN0YXJ0UFRTLGwuZW5kUFRTLGwuc3RhcnREVFMsbC5lbmREVFMpO3JldHVybiBhLmhscy50cmlnZ2VyKG4uYS5MRVZFTF9QVFNfVVBEQVRFRCx7ZGV0YWlsczpzLGxldmVsOnIsZHJpZnQ6ZCx0eXBlOm8sZnJhZzp0LHN0YXJ0Omwuc3RhcnRQVFMsZW5kOmwuZW5kUFRTfSksITB9cmV0dXJuIGV9KSwhMSk/KHRoaXMuc3RhdGU9T3QsdGhpcy5obHMudHJpZ2dlcihuLmEuRlJBR19QQVJTRUQse2ZyYWc6dCxwYXJ0OmV9KSk6dGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpfSxmLnJlc2V0VHJhbnNtdXhlcj1mdW5jdGlvbigpe3RoaXMudHJhbnNtdXhlciYmKHRoaXMudHJhbnNtdXhlci5kZXN0cm95KCksdGhpcy50cmFuc211eGVyPW51bGwpfSx1PWksKGQ9W3trZXk6XCJzdGF0ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdGF0ZX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX3N0YXRlO2UhPT10JiYodGhpcy5fc3RhdGU9dCx0aGlzLmxvZyhlK1wiLT5cIit0KSl9fV0pJiZBdCh1LnByb3RvdHlwZSxkKSxoJiZBdCh1LGgpLGl9KGl0KTtmdW5jdGlvbiBCdCgpe3JldHVybiBzZWxmLk1lZGlhU291cmNlfHxzZWxmLldlYktpdE1lZGlhU291cmNlfWZ1bmN0aW9uIFV0KCl7cmV0dXJuIHNlbGYuU291cmNlQnVmZmVyfHxzZWxmLldlYktpdFNvdXJjZUJ1ZmZlcn12YXIgR3Q9cigxNyksanQ9cig5KSxIdD1yKDEzKSxLdD1CdCgpfHx7aXNUeXBlU3VwcG9ydGVkOmZ1bmN0aW9uKCl7cmV0dXJuITF9fSxWdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLHIsaSl7dmFyIGE9dGhpczt0aGlzLmhscz12b2lkIDAsdGhpcy5pZD12b2lkIDAsdGhpcy5vYnNlcnZlcj12b2lkIDAsdGhpcy5mcmFnPW51bGwsdGhpcy5wYXJ0PW51bGwsdGhpcy53b3JrZXI9dm9pZCAwLHRoaXMub253bXNnPXZvaWQgMCx0aGlzLnRyYW5zbXV4ZXI9bnVsbCx0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZT12b2lkIDAsdGhpcy5vbkZsdXNoPXZvaWQgMCx0aGlzLmhscz10LHRoaXMuaWQ9ZSx0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZT1yLHRoaXMub25GbHVzaD1pO3ZhciBsPXQuY29uZmlnLHU9ZnVuY3Rpb24oZSxyKXsocj1yfHx7fSkuZnJhZz1hLmZyYWcsci5pZD1hLmlkLHQudHJpZ2dlcihlLHIpfTt0aGlzLm9ic2VydmVyPW5ldyBIdC5FdmVudEVtaXR0ZXIsdGhpcy5vYnNlcnZlci5vbihuLmEuRlJBR19ERUNSWVBURUQsdSksdGhpcy5vYnNlcnZlci5vbihuLmEuRVJST1IsdSk7dmFyIGQ9e21wNDpLdC5pc1R5cGVTdXBwb3J0ZWQoXCJ2aWRlby9tcDRcIiksbXBlZzpLdC5pc1R5cGVTdXBwb3J0ZWQoXCJhdWRpby9tcGVnXCIpLG1wMzpLdC5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wNDsgY29kZWNzPVwibXAzXCInKX0saD1uYXZpZ2F0b3IudmVuZG9yO2lmKGwuZW5hYmxlV29ya2VyJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgV29ya2VyKXt2YXIgZjtvLmIubG9nKFwiZGVtdXhpbmcgaW4gd2Vid29ya2VyXCIpO3RyeXtmPXRoaXMud29ya2VyPUd0KDE4KSx0aGlzLm9ud21zZz10aGlzLm9uV29ya2VyTWVzc2FnZS5iaW5kKHRoaXMpLGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix0aGlzLm9ud21zZyksZi5vbmVycm9yPWZ1bmN0aW9uKGUpe3QudHJpZ2dlcihuLmEuRVJST1Ise3R5cGU6cy5iLk9USEVSX0VSUk9SLGRldGFpbHM6cy5hLklOVEVSTkFMX0VYQ0VQVElPTixmYXRhbDohMCxldmVudDpcImRlbXV4ZXJXb3JrZXJcIixlcnJvcjpuZXcgRXJyb3IoZS5tZXNzYWdlK1wiICAoXCIrZS5maWxlbmFtZStcIjpcIitlLmxpbmVubytcIilcIil9KX0sZi5wb3N0TWVzc2FnZSh7Y21kOlwiaW5pdFwiLHR5cGVTdXBwb3J0ZWQ6ZCx2ZW5kb3I6aCxpZDplLGNvbmZpZzpKU09OLnN0cmluZ2lmeShsKX0pfWNhdGNoKHQpe28uYi53YXJuKFwiRXJyb3IgaW4gd29ya2VyOlwiLHQpLG8uYi5lcnJvcihcIkVycm9yIHdoaWxlIGluaXRpYWxpemluZyBEZW11eGVyV29ya2VyLCBmYWxsYmFjayB0byBpbmxpbmVcIiksZiYmc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKGYub2JqZWN0VVJMKSx0aGlzLnRyYW5zbXV4ZXI9bmV3IGp0LmModGhpcy5vYnNlcnZlcixkLGwsaCxlKSx0aGlzLndvcmtlcj1udWxsfX1lbHNlIHRoaXMudHJhbnNtdXhlcj1uZXcganQuYyh0aGlzLm9ic2VydmVyLGQsbCxoLGUpfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLndvcmtlcjtpZih0KXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix0aGlzLm9ud21zZyksdC50ZXJtaW5hdGUoKSx0aGlzLndvcmtlcj1udWxsO2Vsc2V7dmFyIGU9dGhpcy50cmFuc211eGVyO2UmJihlLmRlc3Ryb3koKSx0aGlzLnRyYW5zbXV4ZXI9bnVsbCl9dmFyIHI9dGhpcy5vYnNlcnZlcjtyJiZyLnJlbW92ZUFsbExpc3RlbmVycygpLHRoaXMub2JzZXJ2ZXI9bnVsbH0sZS5wdXNoPWZ1bmN0aW9uKHQsZSxyLGksYSxuLHMsbCx1LGQpe3ZhciBoLGYsYz10aGlzO3UudHJhbnNtdXhpbmcuc3RhcnQ9c2VsZi5wZXJmb3JtYW5jZS5ub3coKTt2YXIgdj10aGlzLnRyYW5zbXV4ZXIsZz10aGlzLndvcmtlcixwPW4/bi5zdGFydDphLnN0YXJ0LG09YS5kZWNyeXB0ZGF0YSx5PXRoaXMuZnJhZyxiPSEoeSYmYS5jYz09PXkuY2MpLFQ9ISh5JiZ1LmxldmVsPT09eS5sZXZlbCksRT15P3Uuc24teS5zbjotMSxTPXRoaXMucGFydD91LnBhcnQtdGhpcy5wYXJ0LmluZGV4OjEsTD0hVCYmKDE9PT1FfHwwPT09RSYmMT09PVMpLEE9c2VsZi5wZXJmb3JtYW5jZS5ub3coKTsoVHx8RXx8MD09PWEuc3RhdHMucGFyc2luZy5zdGFydCkmJihhLnN0YXRzLnBhcnNpbmcuc3RhcnQ9QSksIW58fCFTJiZMfHwobi5zdGF0cy5wYXJzaW5nLnN0YXJ0PUEpO3ZhciBSPSEoeSYmKG51bGw9PT0oaD1hLmluaXRTZWdtZW50KXx8dm9pZCAwPT09aD92b2lkIDA6aC51cmwpPT09KG51bGw9PT0oZj15LmluaXRTZWdtZW50KXx8dm9pZCAwPT09Zj92b2lkIDA6Zi51cmwpKSxEPW5ldyBqdC5iKGIsTCxsLFQscCxSKTtpZighTHx8Ynx8Uil7by5iLmxvZyhcIlt0cmFuc211eGVyLWludGVyZmFjZSwgXCIrYS50eXBlK1wiXTogU3RhcnRpbmcgbmV3IHRyYW5zbXV4IHNlc3Npb24gZm9yIHNuOiBcIit1LnNuK1wiIHA6IFwiK3UucGFydCtcIiBsZXZlbDogXCIrdS5sZXZlbCtcIiBpZDogXCIrdS5pZCtcIlxcbiAgICAgICAgZGlzY29udGludWl0eTogXCIrYitcIlxcbiAgICAgICAgdHJhY2tTd2l0Y2g6IFwiK1QrXCJcXG4gICAgICAgIGNvbnRpZ3VvdXM6IFwiK0wrXCJcXG4gICAgICAgIGFjY3VyYXRlVGltZU9mZnNldDogXCIrbCtcIlxcbiAgICAgICAgdGltZU9mZnNldDogXCIrcCtcIlxcbiAgICAgICAgaW5pdFNlZ21lbnRDaGFuZ2U6IFwiK1IpO3ZhciBfPW5ldyBqdC5hKHIsaSxlLHMsZCk7dGhpcy5jb25maWd1cmVUcmFuc211eGVyKF8pfWlmKHRoaXMuZnJhZz1hLHRoaXMucGFydD1uLGcpZy5wb3N0TWVzc2FnZSh7Y21kOlwiZGVtdXhcIixkYXRhOnQsZGVjcnlwdGRhdGE6bSxjaHVua01ldGE6dSxzdGF0ZTpEfSx0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/W3RdOltdKTtlbHNlIGlmKHYpe3ZhciBrPXYucHVzaCh0LG0sdSxEKTtPYmplY3QoanQuZCkoayk/ay50aGVuKChmdW5jdGlvbih0KXtjLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUodCl9KSk6dGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKGspfX0sZS5mbHVzaD1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3QudHJhbnNtdXhpbmcuc3RhcnQ9c2VsZi5wZXJmb3JtYW5jZS5ub3coKTt2YXIgcj10aGlzLnRyYW5zbXV4ZXIsaT10aGlzLndvcmtlcjtpZihpKWkucG9zdE1lc3NhZ2Uoe2NtZDpcImZsdXNoXCIsY2h1bmtNZXRhOnR9KTtlbHNlIGlmKHIpe3ZhciBhPXIuZmx1c2godCk7T2JqZWN0KGp0LmQpKGEpP2EudGhlbigoZnVuY3Rpb24ocil7ZS5oYW5kbGVGbHVzaFJlc3VsdChyLHQpfSkpOnRoaXMuaGFuZGxlRmx1c2hSZXN1bHQoYSx0KX19LGUuaGFuZGxlRmx1c2hSZXN1bHQ9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7ci5oYW5kbGVUcmFuc211eENvbXBsZXRlKHQpfSkpLHRoaXMub25GbHVzaChlKX0sZS5vbldvcmtlck1lc3NhZ2U9ZnVuY3Rpb24odCl7dmFyIGU9dC5kYXRhLHI9dGhpcy5obHM7c3dpdGNoKGUuZXZlbnQpe2Nhc2VcImluaXRcIjpzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwodGhpcy53b3JrZXIub2JqZWN0VVJMKTticmVhaztjYXNlXCJ0cmFuc211eENvbXBsZXRlXCI6dGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKGUuZGF0YSk7YnJlYWs7Y2FzZVwiZmx1c2hcIjp0aGlzLm9uRmx1c2goZS5kYXRhKTticmVhaztkZWZhdWx0OmUuZGF0YT1lLmRhdGF8fHt9LGUuZGF0YS5mcmFnPXRoaXMuZnJhZyxlLmRhdGEuaWQ9dGhpcy5pZCxyLnRyaWdnZXIoZS5ldmVudCxlLmRhdGEpfX0sZS5jb25maWd1cmVUcmFuc211eGVyPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMud29ya2VyLHI9dGhpcy50cmFuc211eGVyO2U/ZS5wb3N0TWVzc2FnZSh7Y21kOlwiY29uZmlndXJlXCIsY29uZmlnOnR9KTpyJiZyLmNvbmZpZ3VyZSh0KX0sZS5oYW5kbGVUcmFuc211eENvbXBsZXRlPWZ1bmN0aW9uKHQpe3QuY2h1bmtNZXRhLnRyYW5zbXV4aW5nLmVuZD1zZWxmLnBlcmZvcm1hbmNlLm5vdygpLHRoaXMub25UcmFuc211eENvbXBsZXRlKHQpfSx0fSgpLFd0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscixpKXt0aGlzLmNvbmZpZz12b2lkIDAsdGhpcy5tZWRpYT12b2lkIDAsdGhpcy5mcmFnbWVudFRyYWNrZXI9dm9pZCAwLHRoaXMuaGxzPXZvaWQgMCx0aGlzLm51ZGdlUmV0cnk9MCx0aGlzLnN0YWxsUmVwb3J0ZWQ9ITEsdGhpcy5zdGFsbGVkPW51bGwsdGhpcy5tb3ZlZD0hMSx0aGlzLnNlZWtpbmc9ITEsdGhpcy5jb25maWc9dCx0aGlzLm1lZGlhPWUsdGhpcy5mcmFnbWVudFRyYWNrZXI9cix0aGlzLmhscz1pfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmhscz10aGlzLmZyYWdtZW50VHJhY2tlcj10aGlzLm1lZGlhPW51bGx9LGUucG9sbD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbmZpZyxyPXRoaXMubWVkaWEsaT10aGlzLnN0YWxsZWQsYT1yLmN1cnJlbnRUaW1lLG49ci5zZWVraW5nLHM9dGhpcy5zZWVraW5nJiYhbixsPSF0aGlzLnNlZWtpbmcmJm47aWYodGhpcy5zZWVraW5nPW4sYT09PXQpe2lmKChsfHxzKSYmKHRoaXMuc3RhbGxlZD1udWxsKSwhci5wYXVzZWQmJiFyLmVuZGVkJiYwIT09ci5wbGF5YmFja1JhdGUmJm50LmdldEJ1ZmZlcmVkKHIpLmxlbmd0aCl7dmFyIHU9bnQuYnVmZmVySW5mbyhyLGEsMCksZD11Lmxlbj4wLGg9dS5uZXh0U3RhcnR8fDA7aWYoZHx8aCl7aWYobil7dmFyIGY9dS5sZW4+MixjPSFofHxoLWE+MiYmIXRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChhKTtpZihmfHxjKXJldHVybjt0aGlzLm1vdmVkPSExfWlmKCF0aGlzLm1vdmVkJiZudWxsIT09dGhpcy5zdGFsbGVkKXt2YXIgdixnPU1hdGgubWF4KGgsdS5zdGFydHx8MCktYSxwPXRoaXMuaGxzLmxldmVscz90aGlzLmhscy5sZXZlbHNbdGhpcy5obHMuY3VycmVudExldmVsXTpudWxsLG09KG51bGw9PXB8fG51bGw9PT0odj1wLmRldGFpbHMpfHx2b2lkIDA9PT12P3ZvaWQgMDp2LmxpdmUpPzIqcC5kZXRhaWxzLnRhcmdldGR1cmF0aW9uOjI7aWYoZz4wJiZnPD1tKXJldHVybiB2b2lkIHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKG51bGwpfXZhciB5PXNlbGYucGVyZm9ybWFuY2Uubm93KCk7aWYobnVsbCE9PWkpe3ZhciBiPXktaTshbiYmYj49MjUwJiZ0aGlzLl9yZXBvcnRTdGFsbCh1Lmxlbik7dmFyIFQ9bnQuYnVmZmVySW5mbyhyLGEsZS5tYXhCdWZmZXJIb2xlKTt0aGlzLl90cnlGaXhCdWZmZXJTdGFsbChULGIpfWVsc2UgdGhpcy5zdGFsbGVkPXl9fX1lbHNlIGlmKHRoaXMubW92ZWQ9ITAsbnVsbCE9PWkpe2lmKHRoaXMuc3RhbGxSZXBvcnRlZCl7dmFyIEU9c2VsZi5wZXJmb3JtYW5jZS5ub3coKS1pO28uYi53YXJuKFwicGxheWJhY2sgbm90IHN0dWNrIGFueW1vcmUgQFwiK2ErXCIsIGFmdGVyIFwiK01hdGgucm91bmQoRSkrXCJtc1wiKSx0aGlzLnN0YWxsUmVwb3J0ZWQ9ITF9dGhpcy5zdGFsbGVkPW51bGwsdGhpcy5udWRnZVJldHJ5PTB9fSxlLl90cnlGaXhCdWZmZXJTdGFsbD1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMuY29uZmlnLGk9dGhpcy5mcmFnbWVudFRyYWNrZXIsYT10aGlzLm1lZGlhLmN1cnJlbnRUaW1lLG49aS5nZXRQYXJ0aWFsRnJhZ21lbnQoYSk7aWYobiYmdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUobikpcmV0dXJuO3QubGVuPnIubWF4QnVmZmVySG9sZSYmZT4xZTMqci5oaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2QmJihvLmIud2FybihcIlRyeWluZyB0byBudWRnZSBwbGF5aGVhZCBvdmVyIGJ1ZmZlci1ob2xlXCIpLHRoaXMuc3RhbGxlZD1udWxsLHRoaXMuX3RyeU51ZGdlQnVmZmVyKCkpfSxlLl9yZXBvcnRTdGFsbD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmhscyxyPXRoaXMubWVkaWE7dGhpcy5zdGFsbFJlcG9ydGVkfHwodGhpcy5zdGFsbFJlcG9ydGVkPSEwLG8uYi53YXJuKFwiUGxheWJhY2sgc3RhbGxpbmcgYXQgQFwiK3IuY3VycmVudFRpbWUrXCIgZHVlIHRvIGxvdyBidWZmZXIgKGJ1ZmZlcj1cIit0K1wiKVwiKSxlLnRyaWdnZXIobi5hLkVSUk9SLHt0eXBlOnMuYi5NRURJQV9FUlJPUixkZXRhaWxzOnMuYS5CVUZGRVJfU1RBTExFRF9FUlJPUixmYXRhbDohMSxidWZmZXI6dH0pKX0sZS5fdHJ5U2tpcEJ1ZmZlckhvbGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuY29uZmlnLHI9dGhpcy5obHMsaT10aGlzLm1lZGlhLGE9aS5jdXJyZW50VGltZSxsPTAsdT1udC5nZXRCdWZmZXJlZChpKSxkPTA7ZDx1Lmxlbmd0aDtkKyspe3ZhciBoPXUuc3RhcnQoZCk7aWYoYStlLm1heEJ1ZmZlckhvbGU+PWwmJmE8aCl7dmFyIGY9TWF0aC5tYXgoaCsuMDUsaS5jdXJyZW50VGltZSsuMSk7cmV0dXJuIG8uYi53YXJuKFwic2tpcHBpbmcgaG9sZSwgYWRqdXN0aW5nIGN1cnJlbnRUaW1lIGZyb20gXCIrYStcIiB0byBcIitmKSx0aGlzLm1vdmVkPSEwLHRoaXMuc3RhbGxlZD1udWxsLGkuY3VycmVudFRpbWU9Zix0JiZyLnRyaWdnZXIobi5hLkVSUk9SLHt0eXBlOnMuYi5NRURJQV9FUlJPUixkZXRhaWxzOnMuYS5CVUZGRVJfU0VFS19PVkVSX0hPTEUsZmF0YWw6ITEscmVhc29uOlwiZnJhZ21lbnQgbG9hZGVkIHdpdGggYnVmZmVyIGhvbGVzLCBzZWVraW5nIGZyb20gXCIrYStcIiB0byBcIitmLGZyYWc6dH0pLGZ9bD11LmVuZChkKX1yZXR1cm4gMH0sZS5fdHJ5TnVkZ2VCdWZmZXI9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNvbmZpZyxlPXRoaXMuaGxzLHI9dGhpcy5tZWRpYSxpPXIuY3VycmVudFRpbWUsYT0odGhpcy5udWRnZVJldHJ5fHwwKSsxO2lmKHRoaXMubnVkZ2VSZXRyeT1hLGE8dC5udWRnZU1heFJldHJ5KXt2YXIgbD1pK2EqdC5udWRnZU9mZnNldDtvLmIud2FybihcIk51ZGdpbmcgJ2N1cnJlbnRUaW1lJyBmcm9tIFwiK2krXCIgdG8gXCIrbCksci5jdXJyZW50VGltZT1sLGUudHJpZ2dlcihuLmEuRVJST1Ise3R5cGU6cy5iLk1FRElBX0VSUk9SLGRldGFpbHM6cy5hLkJVRkZFUl9OVURHRV9PTl9TVEFMTCxmYXRhbDohMX0pfWVsc2Ugby5iLmVycm9yKFwiUGxheWhlYWQgc3RpbGwgbm90IG1vdmluZyB3aGlsZSBlbm91Z2ggZGF0YSBidWZmZXJlZCBAXCIraStcIiBhZnRlciBcIit0Lm51ZGdlTWF4UmV0cnkrXCIgbnVkZ2VzXCIpLGUudHJpZ2dlcihuLmEuRVJST1Ise3R5cGU6cy5iLk1FRElBX0VSUk9SLGRldGFpbHM6cy5hLkJVRkZFUl9TVEFMTEVEX0VSUk9SLGZhdGFsOiEwfSl9LHR9KCk7ZnVuY3Rpb24gWXQodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaS5rZXksaSl9fWZ1bmN0aW9uIFh0KHQsZSl7cmV0dXJuKFh0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fX3Byb3RvX189ZSx0fSkodCxlKX12YXIgcXQ9ZnVuY3Rpb24odCl7dmFyIGUscjtmdW5jdGlvbiBpKGUscil7dmFyIGk7cmV0dXJuKGk9dC5jYWxsKHRoaXMsZSxyLFwiW3N0cmVhbS1jb250cm9sbGVyXVwiKXx8dGhpcykuYXVkaW9Db2RlY1N3YXA9ITEsaS5nYXBDb250cm9sbGVyPW51bGwsaS5sZXZlbD0tMSxpLl9mb3JjZVN0YXJ0TG9hZD0hMSxpLmFsdEF1ZGlvPSExLGkuYXVkaW9Pbmx5PSExLGkuZnJhZ1BsYXlpbmc9bnVsbCxpLm9udnBsYXlpbmc9bnVsbCxpLm9udnNlZWtlZD1udWxsLGkuZnJhZ0xhc3RLYnBzPTAsaS5zdGFsbGVkPSExLGkuY291bGRCYWNrdHJhY2s9ITEsaS5hdWRpb0NvZGVjU3dpdGNoPSExLGkudmlkZW9CdWZmZXI9bnVsbCxpLl9yZWdpc3Rlckxpc3RlbmVycygpLGl9cj10LChlPWkpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHIucHJvdG90eXBlKSxlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lLFh0KGUscik7dmFyIGwsZCxoLGY9aS5wcm90b3R5cGU7cmV0dXJuIGYuX3JlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vbihuLmEuTUVESUFfQVRUQUNIRUQsdGhpcy5vbk1lZGlhQXR0YWNoZWQsdGhpcyksdC5vbihuLmEuTUVESUFfREVUQUNISU5HLHRoaXMub25NZWRpYURldGFjaGluZyx0aGlzKSx0Lm9uKG4uYS5NQU5JRkVTVF9MT0FESU5HLHRoaXMub25NYW5pZmVzdExvYWRpbmcsdGhpcyksdC5vbihuLmEuTUFOSUZFU1RfUEFSU0VELHRoaXMub25NYW5pZmVzdFBhcnNlZCx0aGlzKSx0Lm9uKG4uYS5MRVZFTF9MT0FESU5HLHRoaXMub25MZXZlbExvYWRpbmcsdGhpcyksdC5vbihuLmEuTEVWRUxfTE9BREVELHRoaXMub25MZXZlbExvYWRlZCx0aGlzKSx0Lm9uKG4uYS5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCx0aGlzKSx0Lm9uKG4uYS5FUlJPUix0aGlzLm9uRXJyb3IsdGhpcyksdC5vbihuLmEuQVVESU9fVFJBQ0tfU1dJVENISU5HLHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLHRoaXMpLHQub24obi5hLkFVRElPX1RSQUNLX1NXSVRDSEVELHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsdGhpcyksdC5vbihuLmEuQlVGRkVSX0NSRUFURUQsdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsdGhpcyksdC5vbihuLmEuQlVGRkVSX0ZMVVNIRUQsdGhpcy5vbkJ1ZmZlckZsdXNoZWQsdGhpcyksdC5vbihuLmEuTEVWRUxTX1VQREFURUQsdGhpcy5vbkxldmVsc1VwZGF0ZWQsdGhpcyksdC5vbihuLmEuRlJBR19CVUZGRVJFRCx0aGlzLm9uRnJhZ0J1ZmZlcmVkLHRoaXMpfSxmLl91bnJlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vZmYobi5hLk1FRElBX0FUVEFDSEVELHRoaXMub25NZWRpYUF0dGFjaGVkLHRoaXMpLHQub2ZmKG4uYS5NRURJQV9ERVRBQ0hJTkcsdGhpcy5vbk1lZGlhRGV0YWNoaW5nLHRoaXMpLHQub2ZmKG4uYS5NQU5JRkVTVF9MT0FESU5HLHRoaXMub25NYW5pZmVzdExvYWRpbmcsdGhpcyksdC5vZmYobi5hLk1BTklGRVNUX1BBUlNFRCx0aGlzLm9uTWFuaWZlc3RQYXJzZWQsdGhpcyksdC5vZmYobi5hLkxFVkVMX0xPQURFRCx0aGlzLm9uTGV2ZWxMb2FkZWQsdGhpcyksdC5vZmYobi5hLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCx0aGlzLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkLHRoaXMpLHQub2ZmKG4uYS5FUlJPUix0aGlzLm9uRXJyb3IsdGhpcyksdC5vZmYobi5hLkFVRElPX1RSQUNLX1NXSVRDSElORyx0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZyx0aGlzKSx0Lm9mZihuLmEuQVVESU9fVFJBQ0tfU1dJVENIRUQsdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCx0aGlzKSx0Lm9mZihuLmEuQlVGRkVSX0NSRUFURUQsdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsdGhpcyksdC5vZmYobi5hLkJVRkZFUl9GTFVTSEVELHRoaXMub25CdWZmZXJGbHVzaGVkLHRoaXMpLHQub2ZmKG4uYS5MRVZFTFNfVVBEQVRFRCx0aGlzLm9uTGV2ZWxzVXBkYXRlZCx0aGlzKSx0Lm9mZihuLmEuRlJBR19CVUZGRVJFRCx0aGlzLm9uRnJhZ0J1ZmZlcmVkLHRoaXMpfSxmLm9uSGFuZGxlckRlc3Ryb3lpbmc9ZnVuY3Rpb24oKXt0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCksdGhpcy5vbk1lZGlhRGV0YWNoaW5nKCl9LGYuc3RhcnRMb2FkPWZ1bmN0aW9uKHQpe2lmKHRoaXMubGV2ZWxzKXt2YXIgZT10aGlzLmxhc3RDdXJyZW50VGltZSxyPXRoaXMuaGxzO2lmKHRoaXMuc3RvcExvYWQoKSx0aGlzLnNldEludGVydmFsKDEwMCksdGhpcy5sZXZlbD0tMSx0aGlzLmZyYWdMb2FkRXJyb3I9MCwhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpe3ZhciBpPXIuc3RhcnRMZXZlbDstMT09PWkmJihyLmNvbmZpZy50ZXN0QmFuZHdpZHRoPyhpPTAsdGhpcy5iaXRyYXRlVGVzdD0hMCk6aT1yLm5leHRBdXRvTGV2ZWwpLHRoaXMubGV2ZWw9ci5uZXh0TG9hZExldmVsPWksdGhpcy5sb2FkZWRtZXRhZGF0YT0hMX1lPjAmJi0xPT09dCYmKHRoaXMubG9nKFwiT3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAXCIrZS50b0ZpeGVkKDMpKSx0PWUpLHRoaXMuc3RhdGU9X3QsdGhpcy5uZXh0TG9hZFBvc2l0aW9uPXRoaXMuc3RhcnRQb3NpdGlvbj10aGlzLmxhc3RDdXJyZW50VGltZT10LHRoaXMudGljaygpfWVsc2UgdGhpcy5fZm9yY2VTdGFydExvYWQ9ITAsdGhpcy5zdGF0ZT1EdH0sZi5zdG9wTG9hZD1mdW5jdGlvbigpe3RoaXMuX2ZvcmNlU3RhcnRMb2FkPSExLHQucHJvdG90eXBlLnN0b3BMb2FkLmNhbGwodGhpcyl9LGYuZG9UaWNrPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuc3RhdGUpe2Nhc2UgX3Q6dGhpcy5kb1RpY2tJZGxlKCk7YnJlYWs7Y2FzZSBNdDp2YXIgdCxlPXRoaXMubGV2ZWxzLHI9dGhpcy5sZXZlbCxpPW51bGw9PWV8fG51bGw9PT0odD1lW3JdKXx8dm9pZCAwPT09dD92b2lkIDA6dC5kZXRhaWxzO2lmKGkmJighaS5saXZlfHx0aGlzLmxldmVsTGFzdExvYWRlZD09PXRoaXMubGV2ZWwpKXtpZih0aGlzLndhaXRGb3JDZG5UdW5lSW4oaSkpYnJlYWs7dGhpcy5zdGF0ZT1fdDticmVha31icmVhaztjYXNlIEN0OnZhciBhLG49c2VsZi5wZXJmb3JtYW5jZS5ub3coKSxzPXRoaXMucmV0cnlEYXRlOyghc3x8bj49c3x8bnVsbCE9PShhPXRoaXMubWVkaWEpJiZ2b2lkIDAhPT1hJiZhLnNlZWtpbmcpJiYodGhpcy5sb2coXCJyZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZVwiKSx0aGlzLnN0YXRlPV90KX10aGlzLm9uVGlja0VuZCgpfSxmLm9uVGlja0VuZD1mdW5jdGlvbigpe3QucHJvdG90eXBlLm9uVGlja0VuZC5jYWxsKHRoaXMpLHRoaXMuY2hlY2tCdWZmZXIoKSx0aGlzLmNoZWNrRnJhZ21lbnRDaGFuZ2VkKCl9LGYuZG9UaWNrSWRsZT1mdW5jdGlvbigpe3ZhciB0LGUscj10aGlzLmhscyxpPXRoaXMubGV2ZWxMYXN0TG9hZGVkLGE9dGhpcy5sZXZlbHMscz10aGlzLm1lZGlhLG89ci5jb25maWcsbD1yLm5leHRMb2FkTGV2ZWw7aWYobnVsbCE9PWkmJihzfHwhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQmJm8uc3RhcnRGcmFnUHJlZmV0Y2gpJiYoIXRoaXMuYWx0QXVkaW98fCF0aGlzLmF1ZGlvT25seSkmJmEmJmFbbF0pe3ZhciBkPWFbbF07dGhpcy5sZXZlbD1yLm5leHRMb2FkTGV2ZWw9bDt2YXIgaD1kLmRldGFpbHM7aWYoIWh8fHRoaXMuc3RhdGU9PT1NdHx8aC5saXZlJiZ0aGlzLmxldmVsTGFzdExvYWRlZCE9PWwpdGhpcy5zdGF0ZT1NdDtlbHNle3ZhciBmPXRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyP3RoaXMubWVkaWFCdWZmZXI6cyxfLmIuTUFJTik7aWYobnVsbCE9PWYpaWYoIShmLmxlbj49dGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgoZC5tYXhCaXRyYXRlKSkpe2lmKHRoaXMuX3N0cmVhbUVuZGVkKGYsaCkpe3ZhciBjPXt9O3JldHVybiB0aGlzLmFsdEF1ZGlvJiYoYy50eXBlPVwidmlkZW9cIiksdGhpcy5obHMudHJpZ2dlcihuLmEuQlVGRkVSX0VPUyxjKSx2b2lkKHRoaXMuc3RhdGU9UHQpfXZhciB2PWYuZW5kLGc9dGhpcy5nZXROZXh0RnJhZ21lbnQodixoKTtpZih0aGlzLmNvdWxkQmFja3RyYWNrJiYhdGhpcy5mcmFnUHJldmlvdXMmJmcmJlwiaW5pdFNlZ21lbnRcIiE9PWcuc24pe3ZhciBwPWcuc24taC5zdGFydFNOO3A+MSYmKGc9aC5mcmFnbWVudHNbcC0xXSx0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChnKSl9aWYoZyYmdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZyk9PT0kLk9LJiZ0aGlzLm5leHRMb2FkUG9zaXRpb24+dil7dmFyIG09dGhpcy5hdWRpb09ubHkmJiF0aGlzLmFsdEF1ZGlvP3UuYS5BVURJTzp1LmEuVklERU87dGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQocyxtLF8uYi5NQUlOKSxnPXRoaXMuZ2V0TmV4dEZyYWdtZW50KHRoaXMubmV4dExvYWRQb3NpdGlvbixoKX1nJiYoIWcuaW5pdFNlZ21lbnR8fGcuaW5pdFNlZ21lbnQuZGF0YXx8dGhpcy5iaXRyYXRlVGVzdHx8KGc9Zy5pbml0U2VnbWVudCksXCJpZGVudGl0eVwiIT09KG51bGw9PT0odD1nLmRlY3J5cHRkYXRhKXx8dm9pZCAwPT09dD92b2lkIDA6dC5rZXlGb3JtYXQpfHxudWxsIT09KGU9Zy5kZWNyeXB0ZGF0YSkmJnZvaWQgMCE9PWUmJmUua2V5P3RoaXMubG9hZEZyYWdtZW50KGcsaCx2KTp0aGlzLmxvYWRLZXkoZyxoKSl9fX19LGYubG9hZEZyYWdtZW50PWZ1bmN0aW9uKGUscixpKXt2YXIgYSxuPXRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGUpO2lmKHRoaXMuZnJhZ0N1cnJlbnQ9ZSxuPT09JC5CQUNLVFJBQ0tFRCl7dmFyIHM9dGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QmFja3RyYWNrRGF0YShlKTtpZihzKXJldHVybiB0aGlzLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhzKSx2b2lkIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKHMpO249JC5OT1RfTE9BREVEfW49PT0kLk5PVF9MT0FERUR8fG49PT0kLlBBUlRJQUw/XCJpbml0U2VnbWVudFwiPT09ZS5zbj90aGlzLl9sb2FkSW5pdFNlZ21lbnQoZSk6dGhpcy5iaXRyYXRlVGVzdD8oZS5iaXRyYXRlVGVzdD0hMCx0aGlzLmxvZyhcIkZyYWdtZW50IFwiK2Uuc24rXCIgb2YgbGV2ZWwgXCIrZS5sZXZlbCtcIiBpcyBiZWluZyBkb3dubG9hZGVkIHRvIHRlc3QgYml0cmF0ZSBhbmQgd2lsbCBub3QgYmUgYnVmZmVyZWRcIiksdGhpcy5fbG9hZEJpdHJhdGVUZXN0RnJhZyhlKSk6KHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkPSEwLHQucHJvdG90eXBlLmxvYWRGcmFnbWVudC5jYWxsKHRoaXMsZSxyLGkpKTpuPT09JC5BUFBFTkRJTkc/dGhpcy5yZWR1Y2VNYXhCdWZmZXJMZW5ndGgoZS5kdXJhdGlvbikmJnRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGUpOjA9PT0obnVsbD09PShhPXRoaXMubWVkaWEpfHx2b2lkIDA9PT1hP3ZvaWQgMDphLmJ1ZmZlcmVkLmxlbmd0aCkmJnRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpfSxmLmdldEFwcGVuZGVkRnJhZz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcodCxfLmIuTUFJTik7cmV0dXJuIGUmJlwiZnJhZ21lbnRcImluIGU/ZS5mcmFnbWVudDplfSxmLmdldEJ1ZmZlcmVkRnJhZz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHQsXy5iLk1BSU4pfSxmLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZz1mdW5jdGlvbih0KXtyZXR1cm4gdD90aGlzLmdldEJ1ZmZlcmVkRnJhZyh0LmVuZCsuNSk6bnVsbH0sZi5pbW1lZGlhdGVMZXZlbFN3aXRjaD1mdW5jdGlvbigpe3RoaXMuYWJvcnRDdXJyZW50RnJhZygpLHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKX0sZi5uZXh0TGV2ZWxTd2l0Y2g9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxldmVscyxlPXRoaXMubWVkaWE7aWYobnVsbCE9ZSYmZS5yZWFkeVN0YXRlKXt2YXIgcixpPXRoaXMuZ2V0QXBwZW5kZWRGcmFnKGUuY3VycmVudFRpbWUpO2lmKGkmJmkuc3RhcnQ+MSYmdGhpcy5mbHVzaE1haW5CdWZmZXIoMCxpLnN0YXJ0LTEpLCFlLnBhdXNlZCYmdCl7dmFyIGE9dFt0aGlzLmhscy5uZXh0TG9hZExldmVsXSxuPXRoaXMuZnJhZ0xhc3RLYnBzO3I9biYmdGhpcy5mcmFnQ3VycmVudD90aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uKmEubWF4Qml0cmF0ZS8oMWUzKm4pKzE6MH1lbHNlIHI9MDt2YXIgcz10aGlzLmdldEJ1ZmZlcmVkRnJhZyhlLmN1cnJlbnRUaW1lK3IpO2lmKHMpe3ZhciBvPXRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKHMpO2lmKG8pe3RoaXMuYWJvcnRDdXJyZW50RnJhZygpO3ZhciBsPW8ubWF4U3RhcnRQVFM/by5tYXhTdGFydFBUUzpvLnN0YXJ0LHU9by5kdXJhdGlvbixkPU1hdGgubWF4KHMuZW5kLGwrTWF0aC5taW4oTWF0aC5tYXgodS10aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLC41KnUpLC43NSp1KSk7dGhpcy5mbHVzaE1haW5CdWZmZXIoZCxOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpfX19fSxmLmFib3J0Q3VycmVudEZyYWc9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmZyYWdDdXJyZW50O3RoaXMuZnJhZ0N1cnJlbnQ9bnVsbCxudWxsIT10JiZ0LmxvYWRlciYmdC5sb2FkZXIuYWJvcnQoKSx0aGlzLnN0YXRlPT09a3QmJih0aGlzLnN0YXRlPV90KSx0aGlzLm5leHRMb2FkUG9zaXRpb249dGhpcy5nZXRMb2FkUG9zaXRpb24oKX0sZi5mbHVzaE1haW5CdWZmZXI9ZnVuY3Rpb24oZSxyKXt0LnByb3RvdHlwZS5mbHVzaE1haW5CdWZmZXIuY2FsbCh0aGlzLGUscix0aGlzLmFsdEF1ZGlvP1widmlkZW9cIjpudWxsKX0sZi5vbk1lZGlhQXR0YWNoZWQ9ZnVuY3Rpb24oZSxyKXt0LnByb3RvdHlwZS5vbk1lZGlhQXR0YWNoZWQuY2FsbCh0aGlzLGUscik7dmFyIGk9ci5tZWRpYTt0aGlzLm9udnBsYXlpbmc9dGhpcy5vbk1lZGlhUGxheWluZy5iaW5kKHRoaXMpLHRoaXMub252c2Vla2VkPXRoaXMub25NZWRpYVNlZWtlZC5iaW5kKHRoaXMpLGkuYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlpbmdcIix0aGlzLm9udnBsYXlpbmcpLGkuYWRkRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLHRoaXMub252c2Vla2VkKSx0aGlzLmdhcENvbnRyb2xsZXI9bmV3IFd0KHRoaXMuY29uZmlnLGksdGhpcy5mcmFnbWVudFRyYWNrZXIsdGhpcy5obHMpfSxmLm9uTWVkaWFEZXRhY2hpbmc9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm1lZGlhO2UmJihlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwbGF5aW5nXCIsdGhpcy5vbnZwbGF5aW5nKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWVrZWRcIix0aGlzLm9udnNlZWtlZCksdGhpcy5vbnZwbGF5aW5nPXRoaXMub252c2Vla2VkPW51bGwsdGhpcy52aWRlb0J1ZmZlcj1udWxsKSx0aGlzLmZyYWdQbGF5aW5nPW51bGwsdGhpcy5nYXBDb250cm9sbGVyJiYodGhpcy5nYXBDb250cm9sbGVyLmRlc3Ryb3koKSx0aGlzLmdhcENvbnRyb2xsZXI9bnVsbCksdC5wcm90b3R5cGUub25NZWRpYURldGFjaGluZy5jYWxsKHRoaXMpfSxmLm9uTWVkaWFQbGF5aW5nPWZ1bmN0aW9uKCl7dGhpcy50aWNrKCl9LGYub25NZWRpYVNlZWtlZD1mdW5jdGlvbigpe3ZhciB0PXRoaXMubWVkaWEsZT10P3QuY3VycmVudFRpbWU6bnVsbDtPYmplY3QoYS5hKShlKSYmdGhpcy5sb2coXCJNZWRpYSBzZWVrZWQgdG8gXCIrZS50b0ZpeGVkKDMpKSx0aGlzLnRpY2soKX0sZi5vbk1hbmlmZXN0TG9hZGluZz1mdW5jdGlvbigpe3RoaXMubG9nKFwiVHJpZ2dlciBCVUZGRVJfUkVTRVRcIiksdGhpcy5obHMudHJpZ2dlcihuLmEuQlVGRkVSX1JFU0VULHZvaWQgMCksdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCksdGhpcy5jb3VsZEJhY2t0cmFjaz10aGlzLnN0YWxsZWQ9ITEsdGhpcy5zdGFydFBvc2l0aW9uPXRoaXMubGFzdEN1cnJlbnRUaW1lPTAsdGhpcy5mcmFnUGxheWluZz1udWxsfSxmLm9uTWFuaWZlc3RQYXJzZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcixpLGEsbj0hMSxzPSExO2UubGV2ZWxzLmZvckVhY2goKGZ1bmN0aW9uKHQpeyhyPXQuYXVkaW9Db2RlYykmJigtMSE9PXIuaW5kZXhPZihcIm1wNGEuNDAuMlwiKSYmKG49ITApLC0xIT09ci5pbmRleE9mKFwibXA0YS40MC41XCIpJiYocz0hMCkpfSkpLHRoaXMuYXVkaW9Db2RlY1N3aXRjaD1uJiZzJiYhKFwiZnVuY3Rpb25cIj09dHlwZW9mKG51bGw9PShhPVV0KCkpfHxudWxsPT09KGk9YS5wcm90b3R5cGUpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLmNoYW5nZVR5cGUpKSx0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gmJnRoaXMubG9nKFwiQm90aCBBQUMvSEUtQUFDIGF1ZGlvIGZvdW5kIGluIGxldmVsczsgZGVjbGFyaW5nIGxldmVsIGNvZGVjIGFzIEhFLUFBQ1wiKSx0aGlzLmxldmVscz1lLmxldmVscyx0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZD0hMX0sZi5vbkxldmVsTG9hZGluZz1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMubGV2ZWxzO2lmKHImJnRoaXMuc3RhdGU9PT1fdCl7dmFyIGk9cltlLmxldmVsXTsoIWkuZGV0YWlsc3x8aS5kZXRhaWxzLmxpdmUmJnRoaXMubGV2ZWxMYXN0TG9hZGVkIT09ZS5sZXZlbHx8dGhpcy53YWl0Rm9yQ2RuVHVuZUluKGkuZGV0YWlscykpJiYodGhpcy5zdGF0ZT1NdCl9fSxmLm9uTGV2ZWxMb2FkZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcixpPXRoaXMubGV2ZWxzLGE9ZS5sZXZlbCxzPWUuZGV0YWlscyxvPXMudG90YWxkdXJhdGlvbjtpZihpKXt0aGlzLmxvZyhcIkxldmVsIFwiK2ErXCIgbG9hZGVkIFtcIitzLnN0YXJ0U04rXCIsXCIrcy5lbmRTTitcIl0sIGNjIFtcIitzLnN0YXJ0Q0MrXCIsIFwiK3MuZW5kQ0MrXCJdIGR1cmF0aW9uOlwiK28pO3ZhciBsPXRoaXMuZnJhZ0N1cnJlbnQ7IWx8fHRoaXMuc3RhdGUhPT14dCYmdGhpcy5zdGF0ZSE9PUN0fHxsLmxldmVsIT09ZS5sZXZlbCYmbC5sb2FkZXImJih0aGlzLnN0YXRlPV90LGwubG9hZGVyLmFib3J0KCkpO3ZhciB1PWlbYV0sZD0wO2lmKHMubGl2ZXx8bnVsbCE9PShyPXUuZGV0YWlscykmJnZvaWQgMCE9PXImJnIubGl2ZSl7aWYocy5mcmFnbWVudHNbMF18fChzLmRlbHRhVXBkYXRlRmFpbGVkPSEwKSxzLmRlbHRhVXBkYXRlRmFpbGVkKXJldHVybjtkPXRoaXMuYWxpZ25QbGF5bGlzdHMocyx1LmRldGFpbHMpfWlmKHUuZGV0YWlscz1zLHRoaXMubGV2ZWxMYXN0TG9hZGVkPWEsdGhpcy5obHMudHJpZ2dlcihuLmEuTEVWRUxfVVBEQVRFRCx7ZGV0YWlsczpzLGxldmVsOmF9KSx0aGlzLnN0YXRlPT09TXQpe2lmKHRoaXMud2FpdEZvckNkblR1bmVJbihzKSlyZXR1cm47dGhpcy5zdGF0ZT1fdH10aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZD9zLmxpdmUmJnRoaXMuc3luY2hyb25pemVUb0xpdmVFZGdlKHMpOnRoaXMuc2V0U3RhcnRQb3NpdGlvbihzLGQpLHRoaXMudGljaygpfWVsc2UgdGhpcy53YXJuKFwiTGV2ZWxzIHdlcmUgcmVzZXQgd2hpbGUgbG9hZGluZyBsZXZlbCBcIithKX0sZi5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3M9ZnVuY3Rpb24odCl7dmFyIGUscj10LmZyYWcsaT10LnBhcnQsYT10LnBheWxvYWQsbj10aGlzLmxldmVscztpZihuKXt2YXIgcz1uW3IubGV2ZWxdLG89cy5kZXRhaWxzO2lmKG8pe3ZhciBsPXMudmlkZW9Db2RlYyx1PW8uUFRTS25vd258fCFvLmxpdmUsZD1udWxsPT09KGU9ci5pbml0U2VnbWVudCl8fHZvaWQgMD09PWU/dm9pZCAwOmUuZGF0YSxoPXRoaXMuX2dldEF1ZGlvQ29kZWMocyksZj10aGlzLnRyYW5zbXV4ZXI9dGhpcy50cmFuc211eGVyfHxuZXcgVnQodGhpcy5obHMsXy5iLk1BSU4sdGhpcy5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZS5iaW5kKHRoaXMpLHRoaXMuX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaC5iaW5kKHRoaXMpKSxjPWk/aS5pbmRleDotMSx2PS0xIT09YyxnPW5ldyBzdChyLmxldmVsLHIuc24sci5zdGF0cy5jaHVua0NvdW50LGEuYnl0ZUxlbmd0aCxjLHYpLHA9dGhpcy5pbml0UFRTW3IuY2NdO2YucHVzaChhLGQsaCxsLHIsaSxvLnRvdGFsZHVyYXRpb24sdSxnLHApfWVsc2UgdGhpcy53YXJuKFwiRHJvcHBpbmcgZnJhZ21lbnQgXCIrci5zbitcIiBvZiBsZXZlbCBcIityLmxldmVsK1wiIGFmdGVyIGxldmVsIGRldGFpbHMgd2VyZSByZXNldFwiKX1lbHNlIHRoaXMud2FybihcIkxldmVscyB3ZXJlIHJlc2V0IHdoaWxlIGZyYWdtZW50IGxvYWQgd2FzIGluIHByb2dyZXNzLiBGcmFnbWVudCBcIityLnNuK1wiIG9mIGxldmVsIFwiK3IubGV2ZWwrXCIgd2lsbCBub3QgYmUgYnVmZmVyZWRcIil9LGYub25BdWRpb1RyYWNrU3dpdGNoaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5hbHRBdWRpbyxpPSEhZS51cmwsYT1lLmlkO2lmKCFpKXtpZih0aGlzLm1lZGlhQnVmZmVyIT09dGhpcy5tZWRpYSl7dGhpcy5sb2coXCJTd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ1wiKSx0aGlzLm1lZGlhQnVmZmVyPXRoaXMubWVkaWE7dmFyIHM9dGhpcy5mcmFnQ3VycmVudDtudWxsIT1zJiZzLmxvYWRlciYmKHRoaXMubG9nKFwiU3dpdGNoaW5nIHRvIG1haW4gYXVkaW8gdHJhY2ssIGNhbmNlbCBtYWluIGZyYWdtZW50IGxvYWRcIikscy5sb2FkZXIuYWJvcnQoKSksdGhpcy5yZXNldFRyYW5zbXV4ZXIoKSx0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCl9ZWxzZSB0aGlzLmF1ZGlvT25seSYmdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTt2YXIgbz10aGlzLmhscztyJiZvLnRyaWdnZXIobi5hLkJVRkZFUl9GTFVTSElORyx7c3RhcnRPZmZzZXQ6MCxlbmRPZmZzZXQ6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHR5cGU6XCJhdWRpb1wifSksby50cmlnZ2VyKG4uYS5BVURJT19UUkFDS19TV0lUQ0hFRCx7aWQ6YX0pfX0sZi5vbkF1ZGlvVHJhY2tTd2l0Y2hlZD1mdW5jdGlvbih0LGUpe3ZhciByPWUuaWQsaT0hIXRoaXMuaGxzLmF1ZGlvVHJhY2tzW3JdLnVybDtpZihpKXt2YXIgYT10aGlzLnZpZGVvQnVmZmVyO2EmJnRoaXMubWVkaWFCdWZmZXIhPT1hJiYodGhpcy5sb2coXCJTd2l0Y2hpbmcgb24gYWx0ZXJuYXRlIGF1ZGlvLCB1c2UgdmlkZW8uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nXCIpLHRoaXMubWVkaWFCdWZmZXI9YSl9dGhpcy5hbHRBdWRpbz1pLHRoaXMudGljaygpfSxmLm9uQnVmZmVyQ3JlYXRlZD1mdW5jdGlvbih0LGUpe3ZhciByLGksYT1lLnRyYWNrcyxuPSExO2Zvcih2YXIgcyBpbiBhKXt2YXIgbz1hW3NdO2lmKFwibWFpblwiPT09by5pZCl7aWYoaT1zLHI9byxcInZpZGVvXCI9PT1zKXt2YXIgbD1hW3NdO2wmJih0aGlzLnZpZGVvQnVmZmVyPWwuYnVmZmVyKX19ZWxzZSBuPSEwfW4mJnI/KHRoaXMubG9nKFwiQWx0ZXJuYXRlIHRyYWNrIGZvdW5kLCB1c2UgXCIraStcIi5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdcIiksdGhpcy5tZWRpYUJ1ZmZlcj1yLmJ1ZmZlcik6dGhpcy5tZWRpYUJ1ZmZlcj10aGlzLm1lZGlhfSxmLm9uRnJhZ0J1ZmZlcmVkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5mcmFnLGk9ZS5wYXJ0O2lmKCFyfHxyLnR5cGU9PT1fLmIuTUFJTil7aWYodGhpcy5mcmFnQ29udGV4dENoYW5nZWQocikpcmV0dXJuIHRoaXMud2FybihcIkZyYWdtZW50IFwiK3Iuc24rKGk/XCIgcDogXCIraS5pbmRleDpcIlwiKStcIiBvZiBsZXZlbCBcIityLmxldmVsK1wiIGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogXCIrdGhpcy5zdGF0ZSksdm9pZCh0aGlzLnN0YXRlPT09T3QmJih0aGlzLnN0YXRlPV90KSk7dmFyIGE9aT9pLnN0YXRzOnIuc3RhdHM7dGhpcy5mcmFnTGFzdEticHM9TWF0aC5yb3VuZCg4KmEudG90YWwvKGEuYnVmZmVyaW5nLmVuZC1hLmxvYWRpbmcuZmlyc3QpKSxcImluaXRTZWdtZW50XCIhPT1yLnNuJiYodGhpcy5mcmFnUHJldmlvdXM9ciksdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShyLGkpfX0sZi5vbkVycm9yPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKGUuZGV0YWlscyl7Y2FzZSBzLmEuRlJBR19MT0FEX0VSUk9SOmNhc2Ugcy5hLkZSQUdfTE9BRF9USU1FT1VUOmNhc2Ugcy5hLktFWV9MT0FEX0VSUk9SOmNhc2Ugcy5hLktFWV9MT0FEX1RJTUVPVVQ6dGhpcy5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoXy5iLk1BSU4sZSk7YnJlYWs7Y2FzZSBzLmEuTEVWRUxfTE9BRF9FUlJPUjpjYXNlIHMuYS5MRVZFTF9MT0FEX1RJTUVPVVQ6dGhpcy5zdGF0ZSE9PUZ0JiYoZS5mYXRhbD8odGhpcy53YXJuKFwiXCIrZS5kZXRhaWxzKSx0aGlzLnN0YXRlPUZ0KTplLmxldmVsUmV0cnl8fHRoaXMuc3RhdGUhPT1NdHx8KHRoaXMuc3RhdGU9X3QpKTticmVhaztjYXNlIHMuYS5CVUZGRVJfRlVMTF9FUlJPUjppZihcIm1haW5cIj09PWUucGFyZW50JiYodGhpcy5zdGF0ZT09PXd0fHx0aGlzLnN0YXRlPT09T3QpKXt2YXIgcj0hMCxpPXRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhLF8uYi5NQUlOKTtpJiZpLmxlbj4uNSYmKHI9IXRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGkubGVuKSksciYmKHRoaXMud2FybihcImJ1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBtYWluXCIpLHRoaXMuaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKSksdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpfX19LGYuY2hlY2tCdWZmZXI9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1lZGlhLGU9dGhpcy5nYXBDb250cm9sbGVyO2lmKHQmJmUmJnQucmVhZHlTdGF0ZSl7dmFyIHI9bnQuZ2V0QnVmZmVyZWQodCk7IXRoaXMubG9hZGVkbWV0YWRhdGEmJnIubGVuZ3RoPyh0aGlzLmxvYWRlZG1ldGFkYXRhPSEwLHRoaXMuc2Vla1RvU3RhcnRQb3MoKSk6ZS5wb2xsKHRoaXMubGFzdEN1cnJlbnRUaW1lKSx0aGlzLmxhc3RDdXJyZW50VGltZT10LmN1cnJlbnRUaW1lfX0sZi5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZD1mdW5jdGlvbigpe3RoaXMuc3RhdGU9X3QsdGhpcy5sb2FkZWRtZXRhZGF0YXx8KHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkPSExLHRoaXMubmV4dExvYWRQb3NpdGlvbj10aGlzLnN0YXJ0UG9zaXRpb24pLHRoaXMudGlja0ltbWVkaWF0ZSgpfSxmLm9uQnVmZmVyRmx1c2hlZD1mdW5jdGlvbih0LGUpe3ZhciByPWUudHlwZTtpZihyIT09dS5hLkFVRElPfHx0aGlzLmF1ZGlvT25seSYmIXRoaXMuYWx0QXVkaW8pe3ZhciBpPShyPT09dS5hLlZJREVPP3RoaXMudmlkZW9CdWZmZXI6dGhpcy5tZWRpYUJ1ZmZlcil8fHRoaXMubWVkaWE7dGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQoaSxyLF8uYi5NQUlOKX19LGYub25MZXZlbHNVcGRhdGVkPWZ1bmN0aW9uKHQsZSl7dGhpcy5sZXZlbHM9ZS5sZXZlbHN9LGYuc3dhcEF1ZGlvQ29kZWM9ZnVuY3Rpb24oKXt0aGlzLmF1ZGlvQ29kZWNTd2FwPSF0aGlzLmF1ZGlvQ29kZWNTd2FwfSxmLnNlZWtUb1N0YXJ0UG9zPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5tZWRpYSxlPXQuY3VycmVudFRpbWUscj10aGlzLnN0YXJ0UG9zaXRpb247aWYocj49MCYmZTxyKXtpZih0LnNlZWtpbmcpcmV0dXJuIHZvaWQgby5iLmxvZyhcImNvdWxkIG5vdCBzZWVrIHRvIFwiK3IrXCIsIGFscmVhZHkgc2Vla2luZyBhdCBcIitlKTt2YXIgaT1udC5nZXRCdWZmZXJlZCh0KSxhPShpLmxlbmd0aD9pLnN0YXJ0KDApOjApLXI7YT4wJiYoYTx0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlfHxhPHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpJiYoby5iLmxvZyhcImFkanVzdGluZyBzdGFydCBwb3NpdGlvbiBieSBcIithK1wiIHRvIG1hdGNoIGJ1ZmZlciBzdGFydFwiKSxyKz1hLHRoaXMuc3RhcnRQb3NpdGlvbj1yKSx0aGlzLmxvZyhcInNlZWsgdG8gdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uIFwiK3IrXCIgZnJvbSBjdXJyZW50IHRpbWUgXCIrZSksdC5jdXJyZW50VGltZT1yfX0sZi5fZ2V0QXVkaW9Db2RlYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlY3x8dC5hdWRpb0NvZGVjO3JldHVybiB0aGlzLmF1ZGlvQ29kZWNTd2FwJiZlJiYodGhpcy5sb2coXCJTd2FwcGluZyBhdWRpbyBjb2RlY1wiKSxlPS0xIT09ZS5pbmRleE9mKFwibXA0YS40MC41XCIpP1wibXA0YS40MC4yXCI6XCJtcDRhLjQwLjVcIiksZX0sZi5fbG9hZEJpdHJhdGVUZXN0RnJhZz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMuX2RvRnJhZ0xvYWQodCkudGhlbigoZnVuY3Rpb24ocil7dmFyIGk9ZS5obHM7aWYociYmIWkubmV4dExvYWRMZXZlbCYmIWUuZnJhZ0NvbnRleHRDaGFuZ2VkKHQpKXtlLmZyYWdMb2FkRXJyb3I9MCxlLnN0YXRlPV90LGUuc3RhcnRGcmFnUmVxdWVzdGVkPSExLGUuYml0cmF0ZVRlc3Q9ITE7dmFyIGE9dC5zdGF0czthLnBhcnNpbmcuc3RhcnQ9YS5wYXJzaW5nLmVuZD1hLmJ1ZmZlcmluZy5zdGFydD1hLmJ1ZmZlcmluZy5lbmQ9c2VsZi5wZXJmb3JtYW5jZS5ub3coKSxpLnRyaWdnZXIobi5hLkZSQUdfTE9BREVELHIpfX0pKX0sZi5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZT1mdW5jdGlvbih0KXt2YXIgZSxyPVwibWFpblwiLGk9dGhpcy5obHMscz10LnJlbXV4UmVzdWx0LG89dC5jaHVua01ldGEsbD10aGlzLmdldEN1cnJlbnRDb250ZXh0KG8pO2lmKCFsKXJldHVybiB0aGlzLndhcm4oXCJUaGUgbG9hZGluZyBjb250ZXh0IGNoYW5nZWQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50IFwiK28uc24rXCIgb2YgbGV2ZWwgXCIrby5sZXZlbCtcIi4gVGhpcyBjaHVuayB3aWxsIG5vdCBiZSBidWZmZXJlZC5cIiksdm9pZCB0aGlzLnJlc2V0TGl2ZVN0YXJ0V2hlbk5vdExvYWRlZChvLmxldmVsKTt2YXIgZD1sLmZyYWcsaD1sLnBhcnQsZj1sLmxldmVsLGM9cy52aWRlbyx2PXMudGV4dCxnPXMuaWQzLHA9cy5pbml0U2VnbWVudCxtPXRoaXMuYWx0QXVkaW8/dm9pZCAwOnMuYXVkaW87aWYoIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGQpKXtpZih0aGlzLnN0YXRlPXd0LHApe3AudHJhY2tzJiYodGhpcy5fYnVmZmVySW5pdFNlZ21lbnQoZixwLnRyYWNrcyxkLG8pLGkudHJpZ2dlcihuLmEuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCx7ZnJhZzpkLGlkOnIsdHJhY2tzOnAudHJhY2tzfSkpO3ZhciB5PXAuaW5pdFBUUyxiPXAudGltZXNjYWxlO09iamVjdChhLmEpKHkpJiYodGhpcy5pbml0UFRTW2QuY2NdPXksaS50cmlnZ2VyKG4uYS5JTklUX1BUU19GT1VORCx7ZnJhZzpkLGlkOnIsaW5pdFBUUzp5LHRpbWVzY2FsZTpifSkpfWlmKGMmJiExIT09cy5pbmRlcGVuZGVudCl7aWYoZi5kZXRhaWxzKXt2YXIgVD1jLnN0YXJ0UFRTLEU9Yy5lbmRQVFMsUz1jLnN0YXJ0RFRTLEw9Yy5lbmREVFM7aWYoaCloLmVsZW1lbnRhcnlTdHJlYW1zW2MudHlwZV09e3N0YXJ0UFRTOlQsZW5kUFRTOkUsc3RhcnREVFM6UyxlbmREVFM6TH07ZWxzZSBpZihjLmZpcnN0S2V5RnJhbWUmJmMuaW5kZXBlbmRlbnQmJih0aGlzLmNvdWxkQmFja3RyYWNrPSEwKSxjLmRyb3BwZWQmJmMuaW5kZXBlbmRlbnQpe2lmKHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCkrdGhpcy5jb25maWcubWF4QnVmZmVySG9sZTxUKXJldHVybiB2b2lkIHRoaXMuYmFja3RyYWNrKGQpO2Quc2V0RWxlbWVudGFyeVN0cmVhbUluZm8oYy50eXBlLGQuc3RhcnQsRSxkLnN0YXJ0LEwsITApfWQuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8oYy50eXBlLFQsRSxTLEwpLHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKGMsZCxoLG8pfX1lbHNlIGlmKCExPT09cy5pbmRlcGVuZGVudClyZXR1cm4gdm9pZCB0aGlzLmJhY2t0cmFjayhkKTtpZihtKXt2YXIgQT1tLnN0YXJ0UFRTLFI9bS5lbmRQVFMsRD1tLnN0YXJ0RFRTLF89bS5lbmREVFM7aCYmKGguZWxlbWVudGFyeVN0cmVhbXNbdS5hLkFVRElPXT17c3RhcnRQVFM6QSxlbmRQVFM6UixzdGFydERUUzpELGVuZERUUzpffSksZC5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyh1LmEuQVVESU8sQSxSLEQsXyksdGhpcy5idWZmZXJGcmFnbWVudERhdGEobSxkLGgsbyl9aWYobnVsbCE9ZyYmbnVsbCE9PShlPWcuc2FtcGxlcykmJnZvaWQgMCE9PWUmJmUubGVuZ3RoKXt2YXIgaz17ZnJhZzpkLGlkOnIsc2FtcGxlczpnLnNhbXBsZXN9O2kudHJpZ2dlcihuLmEuRlJBR19QQVJTSU5HX01FVEFEQVRBLGspfWlmKHYpe3ZhciB4PXtmcmFnOmQsaWQ6cixzYW1wbGVzOnYuc2FtcGxlc307aS50cmlnZ2VyKG4uYS5GUkFHX1BBUlNJTkdfVVNFUkRBVEEseCl9fX0sZi5fYnVmZmVySW5pdFNlZ21lbnQ9ZnVuY3Rpb24odCxlLHIsaSl7dmFyIGE9dGhpcztpZih0aGlzLnN0YXRlPT09d3Qpe3RoaXMuYXVkaW9Pbmx5PSEhZS5hdWRpbyYmIWUudmlkZW8sdGhpcy5hbHRBdWRpbyYmIXRoaXMuYXVkaW9Pbmx5JiZkZWxldGUgZS5hdWRpbzt2YXIgcz1lLmF1ZGlvLG89ZS52aWRlbyxsPWUuYXVkaW92aWRlbztpZihzKXt2YXIgdT10LmF1ZGlvQ29kZWMsZD1uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7dGhpcy5hdWRpb0NvZGVjU3dpdGNoJiYodSYmKHU9LTEhPT11LmluZGV4T2YoXCJtcDRhLjQwLjVcIik/XCJtcDRhLjQwLjJcIjpcIm1wNGEuNDAuNVwiKSwxIT09cy5tZXRhZGF0YS5jaGFubmVsQ291bnQmJi0xPT09ZC5pbmRleE9mKFwiZmlyZWZveFwiKSYmKHU9XCJtcDRhLjQwLjVcIikpLC0xIT09ZC5pbmRleE9mKFwiYW5kcm9pZFwiKSYmXCJhdWRpby9tcGVnXCIhPT1zLmNvbnRhaW5lciYmKHU9XCJtcDRhLjQwLjJcIix0aGlzLmxvZyhcIkFuZHJvaWQ6IGZvcmNlIGF1ZGlvIGNvZGVjIHRvIFwiK3UpKSx0LmF1ZGlvQ29kZWMmJnQuYXVkaW9Db2RlYyE9PXUmJnRoaXMubG9nKCdTd2FwcGluZyBtYW5pZmVzdCBhdWRpbyBjb2RlYyBcIicrdC5hdWRpb0NvZGVjKydcIiBmb3IgXCInK3UrJ1wiJykscy5sZXZlbENvZGVjPXUscy5pZD1cIm1haW5cIix0aGlzLmxvZyhcIkluaXQgYXVkaW8gYnVmZmVyLCBjb250YWluZXI6XCIrcy5jb250YWluZXIrXCIsIGNvZGVjc1tzZWxlY3RlZC9sZXZlbC9wYXJzZWRdPVtcIisodXx8XCJcIikrXCIvXCIrKHQuYXVkaW9Db2RlY3x8XCJcIikrXCIvXCIrcy5jb2RlYytcIl1cIil9byYmKG8ubGV2ZWxDb2RlYz10LnZpZGVvQ29kZWMsby5pZD1cIm1haW5cIix0aGlzLmxvZyhcIkluaXQgdmlkZW8gYnVmZmVyLCBjb250YWluZXI6XCIrby5jb250YWluZXIrXCIsIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVtcIisodC52aWRlb0NvZGVjfHxcIlwiKStcIi9cIitvLmNvZGVjK1wiXVwiKSksbCYmdGhpcy5sb2coXCJJbml0IGF1ZGlvdmlkZW8gYnVmZmVyLCBjb250YWluZXI6XCIrbC5jb250YWluZXIrXCIsIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVtcIisodC5hdHRycy5DT0RFQ1N8fFwiXCIpK1wiL1wiK2wuY29kZWMrXCJdXCIpLHRoaXMuaGxzLnRyaWdnZXIobi5hLkJVRkZFUl9DT0RFQ1MsZSksT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHM9ZVt0XS5pbml0U2VnbWVudDtudWxsIT1zJiZzLmJ5dGVMZW5ndGgmJmEuaGxzLnRyaWdnZXIobi5hLkJVRkZFUl9BUFBFTkRJTkcse3R5cGU6dCxkYXRhOnMsZnJhZzpyLHBhcnQ6bnVsbCxjaHVua01ldGE6aSxwYXJlbnQ6ci50eXBlfSl9KSksdGhpcy50aWNrKCl9fSxmLmJhY2t0cmFjaz1mdW5jdGlvbih0KXt0aGlzLmNvdWxkQmFja3RyYWNrPSEwLHRoaXMucmVzZXRUcmFuc211eGVyKCksdGhpcy5mbHVzaEJ1ZmZlckdhcCh0KTt2YXIgZT10aGlzLmZyYWdtZW50VHJhY2tlci5iYWNrdHJhY2sodCk7dGhpcy5mcmFnUHJldmlvdXM9bnVsbCx0aGlzLm5leHRMb2FkUG9zaXRpb249dC5zdGFydCxlP3RoaXMucmVzZXRGcmFnbWVudExvYWRpbmcodCk6dGhpcy5zdGF0ZT1JdH0sZi5jaGVja0ZyYWdtZW50Q2hhbmdlZD1mdW5jdGlvbigpe3ZhciB0PXRoaXMubWVkaWEsZT1udWxsO2lmKHQmJnQucmVhZHlTdGF0ZT4xJiYhMT09PXQuc2Vla2luZyl7dmFyIHI9dC5jdXJyZW50VGltZTtpZihudC5pc0J1ZmZlcmVkKHQscik/ZT10aGlzLmdldEFwcGVuZGVkRnJhZyhyKTpudC5pc0J1ZmZlcmVkKHQscisuMSkmJihlPXRoaXMuZ2V0QXBwZW5kZWRGcmFnKHIrLjEpKSxlKXt2YXIgaT10aGlzLmZyYWdQbGF5aW5nLGE9ZS5sZXZlbDtpJiZlLnNuPT09aS5zbiYmaS5sZXZlbD09PWEmJmUudXJsSWQ9PT1pLnVybElkfHwodGhpcy5obHMudHJpZ2dlcihuLmEuRlJBR19DSEFOR0VELHtmcmFnOmV9KSxpJiZpLmxldmVsPT09YXx8dGhpcy5obHMudHJpZ2dlcihuLmEuTEVWRUxfU1dJVENIRUQse2xldmVsOmF9KSx0aGlzLmZyYWdQbGF5aW5nPWUpfX19LGw9aSwoZD1be2tleTpcIm5leHRMZXZlbFwiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMubmV4dEJ1ZmZlcmVkRnJhZztyZXR1cm4gdD90LmxldmVsOi0xfX0se2tleTpcImN1cnJlbnRMZXZlbFwiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMubWVkaWE7aWYodCl7dmFyIGU9dGhpcy5nZXRBcHBlbmRlZEZyYWcodC5jdXJyZW50VGltZSk7aWYoZSlyZXR1cm4gZS5sZXZlbH1yZXR1cm4tMX19LHtrZXk6XCJuZXh0QnVmZmVyZWRGcmFnXCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5tZWRpYTtpZih0KXt2YXIgZT10aGlzLmdldEFwcGVuZGVkRnJhZyh0LmN1cnJlbnRUaW1lKTtyZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcoZSl9cmV0dXJuIG51bGx9fSx7a2V5OlwiZm9yY2VTdGFydExvYWRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZm9yY2VTdGFydExvYWR9fV0pJiZZdChsLnByb3RvdHlwZSxkKSxoJiZZdChsLGgpLGl9KE50KSx6dD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLHIpe3ZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PXImJihyPTApLHRoaXMuaGFsZkxpZmU9dm9pZCAwLHRoaXMuYWxwaGFfPXZvaWQgMCx0aGlzLmVzdGltYXRlXz12b2lkIDAsdGhpcy50b3RhbFdlaWdodF89dm9pZCAwLHRoaXMuaGFsZkxpZmU9dCx0aGlzLmFscGhhXz10P01hdGguZXhwKE1hdGgubG9nKC41KS90KTowLHRoaXMuZXN0aW1hdGVfPWUsdGhpcy50b3RhbFdlaWdodF89cn12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5zYW1wbGU9ZnVuY3Rpb24odCxlKXt2YXIgcj1NYXRoLnBvdyh0aGlzLmFscGhhXyx0KTt0aGlzLmVzdGltYXRlXz1lKigxLXIpK3IqdGhpcy5lc3RpbWF0ZV8sdGhpcy50b3RhbFdlaWdodF8rPXR9LGUuZ2V0VG90YWxXZWlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b3RhbFdlaWdodF99LGUuZ2V0RXN0aW1hdGU9ZnVuY3Rpb24oKXtpZih0aGlzLmFscGhhXyl7dmFyIHQ9MS1NYXRoLnBvdyh0aGlzLmFscGhhXyx0aGlzLnRvdGFsV2VpZ2h0Xyk7aWYodClyZXR1cm4gdGhpcy5lc3RpbWF0ZV8vdH1yZXR1cm4gdGhpcy5lc3RpbWF0ZV99LHR9KCksUXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxyKXt0aGlzLmRlZmF1bHRFc3RpbWF0ZV89dm9pZCAwLHRoaXMubWluV2VpZ2h0Xz12b2lkIDAsdGhpcy5taW5EZWxheU1zXz12b2lkIDAsdGhpcy5zbG93Xz12b2lkIDAsdGhpcy5mYXN0Xz12b2lkIDAsdGhpcy5kZWZhdWx0RXN0aW1hdGVfPXIsdGhpcy5taW5XZWlnaHRfPS4wMDEsdGhpcy5taW5EZWxheU1zXz01MCx0aGlzLnNsb3dfPW5ldyB6dCh0KSx0aGlzLmZhc3RfPW5ldyB6dChlKX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS51cGRhdGU9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLnNsb3dfLGk9dGhpcy5mYXN0Xzt0aGlzLnNsb3dfLmhhbGZMaWZlIT09dCYmKHRoaXMuc2xvd189bmV3IHp0KHQsci5nZXRFc3RpbWF0ZSgpLHIuZ2V0VG90YWxXZWlnaHQoKSkpLHRoaXMuZmFzdF8uaGFsZkxpZmUhPT1lJiYodGhpcy5mYXN0Xz1uZXcgenQoZSxpLmdldEVzdGltYXRlKCksaS5nZXRUb3RhbFdlaWdodCgpKSl9LGUuc2FtcGxlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9KHQ9TWF0aC5tYXgodCx0aGlzLm1pbkRlbGF5TXNfKSkvMWUzLGk9OCplL3I7dGhpcy5mYXN0Xy5zYW1wbGUocixpKSx0aGlzLnNsb3dfLnNhbXBsZShyLGkpfSxlLmNhbkVzdGltYXRlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5mYXN0XztyZXR1cm4gdCYmdC5nZXRUb3RhbFdlaWdodCgpPj10aGlzLm1pbldlaWdodF99LGUuZ2V0RXN0aW1hdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYW5Fc3RpbWF0ZSgpP01hdGgubWluKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSx0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpOnRoaXMuZGVmYXVsdEVzdGltYXRlX30sZS5kZXN0cm95PWZ1bmN0aW9uKCl7fSx0fSgpO2Z1bmN0aW9uICR0KHQsZSl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBpPWVbcl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGkua2V5LGkpfX12YXIgWnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuaGxzPXZvaWQgMCx0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWw9MCx0aGlzLl9uZXh0QXV0b0xldmVsPS0xLHRoaXMudGltZXI9dm9pZCAwLHRoaXMub25DaGVjaz10aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKHRoaXMpLHRoaXMuZnJhZ0N1cnJlbnQ9bnVsbCx0aGlzLnBhcnRDdXJyZW50PW51bGwsdGhpcy5iaXRyYXRlVGVzdERlbGF5PTAsdGhpcy5id0VzdGltYXRvcj12b2lkIDAsdGhpcy5obHM9dDt2YXIgZT10LmNvbmZpZzt0aGlzLmJ3RXN0aW1hdG9yPW5ldyBRdChlLmFickV3bWFTbG93Vm9ELGUuYWJyRXdtYUZhc3RWb0QsZS5hYnJFd21hRGVmYXVsdEVzdGltYXRlKSx0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCl9dmFyIGUscixpLGw9dC5wcm90b3R5cGU7cmV0dXJuIGwucmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhsczt0Lm9uKG4uYS5GUkFHX0xPQURJTkcsdGhpcy5vbkZyYWdMb2FkaW5nLHRoaXMpLHQub24obi5hLkZSQUdfTE9BREVELHRoaXMub25GcmFnTG9hZGVkLHRoaXMpLHQub24obi5hLkZSQUdfQlVGRkVSRUQsdGhpcy5vbkZyYWdCdWZmZXJlZCx0aGlzKSx0Lm9uKG4uYS5MRVZFTF9MT0FERUQsdGhpcy5vbkxldmVsTG9hZGVkLHRoaXMpLHQub24obi5hLkVSUk9SLHRoaXMub25FcnJvcix0aGlzKX0sbC51bnJlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vZmYobi5hLkZSQUdfTE9BRElORyx0aGlzLm9uRnJhZ0xvYWRpbmcsdGhpcyksdC5vZmYobi5hLkZSQUdfTE9BREVELHRoaXMub25GcmFnTG9hZGVkLHRoaXMpLHQub2ZmKG4uYS5GUkFHX0JVRkZFUkVELHRoaXMub25GcmFnQnVmZmVyZWQsdGhpcyksdC5vZmYobi5hLkxFVkVMX0xPQURFRCx0aGlzLm9uTGV2ZWxMb2FkZWQsdGhpcyksdC5vZmYobi5hLkVSUk9SLHRoaXMub25FcnJvcix0aGlzKX0sbC5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCksdGhpcy5jbGVhclRpbWVyKCksdGhpcy5obHM9dGhpcy5vbkNoZWNrPW51bGwsdGhpcy5mcmFnQ3VycmVudD10aGlzLnBhcnRDdXJyZW50PW51bGx9LGwub25GcmFnTG9hZGluZz1mdW5jdGlvbih0LGUpe3ZhciByLGk9ZS5mcmFnO2kudHlwZT09PV8uYi5NQUlOJiYodGhpcy50aW1lcnx8KHRoaXMuZnJhZ0N1cnJlbnQ9aSx0aGlzLnBhcnRDdXJyZW50PW51bGwhPShyPWUucGFydCk/cjpudWxsLHRoaXMudGltZXI9c2VsZi5zZXRJbnRlcnZhbCh0aGlzLm9uQ2hlY2ssMTAwKSkpfSxsLm9uTGV2ZWxMb2FkZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLmhscy5jb25maWc7ZS5kZXRhaWxzLmxpdmU/dGhpcy5id0VzdGltYXRvci51cGRhdGUoci5hYnJFd21hU2xvd0xpdmUsci5hYnJFd21hRmFzdExpdmUpOnRoaXMuYndFc3RpbWF0b3IudXBkYXRlKHIuYWJyRXdtYVNsb3dWb0Qsci5hYnJFd21hRmFzdFZvRCl9LGwuX2FiYW5kb25SdWxlc0NoZWNrPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5mcmFnQ3VycmVudCxlPXRoaXMucGFydEN1cnJlbnQscj10aGlzLmhscyxpPXIuYXV0b0xldmVsRW5hYmxlZCxzPXIuY29uZmlnLGw9ci5tZWRpYTtpZih0JiZsKXt2YXIgdT1lP2Uuc3RhdHM6dC5zdGF0cyxkPWU/ZS5kdXJhdGlvbjp0LmR1cmF0aW9uO2lmKHUuYWJvcnRlZClyZXR1cm4gby5iLndhcm4oXCJmcmFnIGxvYWRlciBkZXN0cm95IG9yIGFib3J0ZWQsIGRpc2FybSBhYmFuZG9uUnVsZXNcIiksdGhpcy5jbGVhclRpbWVyKCksdm9pZCh0aGlzLl9uZXh0QXV0b0xldmVsPS0xKTtpZihpJiYhbC5wYXVzZWQmJmwucGxheWJhY2tSYXRlJiZsLnJlYWR5U3RhdGUpe3ZhciBoPXBlcmZvcm1hbmNlLm5vdygpLXUubG9hZGluZy5zdGFydCxmPU1hdGguYWJzKGwucGxheWJhY2tSYXRlKTtpZighKGg8PTUwMCpkL2YpKXt2YXIgYz1yLmxldmVscyx2PXIubWluQXV0b0xldmVsLGc9Y1t0LmxldmVsXSxwPXUudG90YWx8fE1hdGgubWF4KHUubG9hZGVkLE1hdGgucm91bmQoZCpnLm1heEJpdHJhdGUvOCkpLG09TWF0aC5tYXgoMSx1LmJ3RXN0aW1hdGU/dS5id0VzdGltYXRlLzg6MWUzKnUubG9hZGVkL2gpLHk9KHAtdS5sb2FkZWQpL20sYj1sLmN1cnJlbnRUaW1lLFQ9KG50LmJ1ZmZlckluZm8obCxiLHMubWF4QnVmZmVySG9sZSkuZW5kLWIpL2Y7aWYoIShUPj0yKmQvZnx8eTw9VCkpe3ZhciBFLFM9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO2ZvcihFPXQubGV2ZWwtMTtFPnY7RS0tKXtpZigoUz1kKmNbRV0ubWF4Qml0cmF0ZS8oNi40Km0pKTxUKWJyZWFrfWlmKCEoUz49eSkpe3ZhciBMPXRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtvLmIud2FybihcIkZyYWdtZW50IFwiK3Quc24rKGU/XCIgcGFydCBcIitlLmluZGV4OlwiXCIpK1wiIG9mIGxldmVsIFwiK3QubGV2ZWwrXCIgaXMgbG9hZGluZyB0b28gc2xvd2x5IGFuZCB3aWxsIGNhdXNlIGFuIHVuZGVyYnVmZmVyOyBhYm9ydGluZyBhbmQgc3dpdGNoaW5nIHRvIGxldmVsIFwiK0UrXCJcXG4gICAgICBDdXJyZW50IEJXIGVzdGltYXRlOiBcIisoT2JqZWN0KGEuYSkoTCk/KEwvMTAyNCkudG9GaXhlZCgzKTpcIlVua25vd25cIikrXCIgS2Ivc1xcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGN1cnJlbnQgZnJhZ21lbnQ6IFwiK3kudG9GaXhlZCgzKStcIiBzXFxuICAgICAgRXN0aW1hdGVkIGxvYWQgdGltZSBmb3IgdGhlIG5leHQgZnJhZ21lbnQ6IFwiK1MudG9GaXhlZCgzKStcIiBzXFxuICAgICAgVGltZSB0byB1bmRlcmJ1ZmZlcjogXCIrVC50b0ZpeGVkKDMpK1wiIHNcIiksci5uZXh0TG9hZExldmVsPUUsdGhpcy5id0VzdGltYXRvci5zYW1wbGUoaCx1LmxvYWRlZCksdGhpcy5jbGVhclRpbWVyKCksdC5sb2FkZXImJih0aGlzLmZyYWdDdXJyZW50PXRoaXMucGFydEN1cnJlbnQ9bnVsbCx0LmxvYWRlci5hYm9ydCgpKSxyLnRyaWdnZXIobi5hLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCx7ZnJhZzp0LHBhcnQ6ZSxzdGF0czp1fSl9fX19fX0sbC5vbkZyYWdMb2FkZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1lLmZyYWcsaT1lLnBhcnQ7aWYoci50eXBlPT09Xy5iLk1BSU4mJk9iamVjdChhLmEpKHIuc24pKXt2YXIgcz1pP2kuc3RhdHM6ci5zdGF0cyxvPWk/aS5kdXJhdGlvbjpyLmR1cmF0aW9uO2lmKHRoaXMuY2xlYXJUaW1lcigpLHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbD1yLmxldmVsLHRoaXMuX25leHRBdXRvTGV2ZWw9LTEsdGhpcy5obHMuY29uZmlnLmFick1heFdpdGhSZWFsQml0cmF0ZSl7dmFyIGw9dGhpcy5obHMubGV2ZWxzW3IubGV2ZWxdLHU9KGwubG9hZGVkP2wubG9hZGVkLmJ5dGVzOjApK3MubG9hZGVkLGQ9KGwubG9hZGVkP2wubG9hZGVkLmR1cmF0aW9uOjApK287bC5sb2FkZWQ9e2J5dGVzOnUsZHVyYXRpb246ZH0sbC5yZWFsQml0cmF0ZT1NYXRoLnJvdW5kKDgqdS9kKX1pZihyLmJpdHJhdGVUZXN0KXt2YXIgaD17c3RhdHM6cyxmcmFnOnIscGFydDppLGlkOnIudHlwZX07dGhpcy5vbkZyYWdCdWZmZXJlZChuLmEuRlJBR19CVUZGRVJFRCxoKSxyLmJpdHJhdGVUZXN0PSExfX19LGwub25GcmFnQnVmZmVyZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1lLmZyYWcsaT1lLnBhcnQsYT1pP2kuc3RhdHM6ci5zdGF0cztpZighYS5hYm9ydGVkJiZyLnR5cGU9PT1fLmIuTUFJTiYmXCJpbml0U2VnbWVudFwiIT09ci5zbil7dmFyIG49YS5wYXJzaW5nLmVuZC1hLmxvYWRpbmcuc3RhcnQ7dGhpcy5id0VzdGltYXRvci5zYW1wbGUobixhLmxvYWRlZCksYS5id0VzdGltYXRlPXRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKSxyLmJpdHJhdGVUZXN0P3RoaXMuYml0cmF0ZVRlc3REZWxheT1uLzFlMzp0aGlzLmJpdHJhdGVUZXN0RGVsYXk9MH19LGwub25FcnJvcj1mdW5jdGlvbih0LGUpe3N3aXRjaChlLmRldGFpbHMpe2Nhc2Ugcy5hLkZSQUdfTE9BRF9FUlJPUjpjYXNlIHMuYS5GUkFHX0xPQURfVElNRU9VVDp0aGlzLmNsZWFyVGltZXIoKX19LGwuY2xlYXJUaW1lcj1mdW5jdGlvbigpe3NlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKSx0aGlzLnRpbWVyPXZvaWQgMH0sbC5nZXROZXh0QUJSQXV0b0xldmVsPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5mcmFnQ3VycmVudCxlPXRoaXMucGFydEN1cnJlbnQscj10aGlzLmhscyxpPXIubWF4QXV0b0xldmVsLGE9ci5jb25maWcsbj1yLm1pbkF1dG9MZXZlbCxzPXIubWVkaWEsbD1lP2UuZHVyYXRpb246dD90LmR1cmF0aW9uOjAsdT1zP3MuY3VycmVudFRpbWU6MCxkPXMmJjAhPT1zLnBsYXliYWNrUmF0ZT9NYXRoLmFicyhzLnBsYXliYWNrUmF0ZSk6MSxoPXRoaXMuYndFc3RpbWF0b3I/dGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpOmEuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSxmPShudC5idWZmZXJJbmZvKHMsdSxhLm1heEJ1ZmZlckhvbGUpLmVuZC11KS9kLGM9dGhpcy5maW5kQmVzdExldmVsKGgsbixpLGYsYS5hYnJCYW5kV2lkdGhGYWN0b3IsYS5hYnJCYW5kV2lkdGhVcEZhY3Rvcik7aWYoYz49MClyZXR1cm4gYztvLmIudHJhY2UoKGY/XCJyZWJ1ZmZlcmluZyBleHBlY3RlZFwiOlwiYnVmZmVyIGlzIGVtcHR5XCIpK1wiLCBmaW5kaW5nIG9wdGltYWwgcXVhbGl0eSBsZXZlbFwiKTt2YXIgdj1sP01hdGgubWluKGwsYS5tYXhTdGFydmF0aW9uRGVsYXkpOmEubWF4U3RhcnZhdGlvbkRlbGF5LGc9YS5hYnJCYW5kV2lkdGhGYWN0b3IscD1hLmFickJhbmRXaWR0aFVwRmFjdG9yO2lmKCFmKXt2YXIgbT10aGlzLmJpdHJhdGVUZXN0RGVsYXk7aWYobSl2PShsP01hdGgubWluKGwsYS5tYXhMb2FkaW5nRGVsYXkpOmEubWF4TG9hZGluZ0RlbGF5KS1tLG8uYi50cmFjZShcImJpdHJhdGUgdGVzdCB0b29rIFwiK01hdGgucm91bmQoMWUzKm0pK1wibXMsIHNldCBmaXJzdCBmcmFnbWVudCBtYXggZmV0Y2hEdXJhdGlvbiB0byBcIitNYXRoLnJvdW5kKDFlMyp2KStcIiBtc1wiKSxnPXA9MX1yZXR1cm4gYz10aGlzLmZpbmRCZXN0TGV2ZWwoaCxuLGksZit2LGcscCksTWF0aC5tYXgoYywwKX0sbC5maW5kQmVzdExldmVsPWZ1bmN0aW9uKHQsZSxyLGksYSxuKXtmb3IodmFyIHMsbD10aGlzLmZyYWdDdXJyZW50LHU9dGhpcy5wYXJ0Q3VycmVudCxkPXRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCxoPXRoaXMuaGxzLmxldmVscyxmPWhbZF0sYz0hKG51bGw9PWZ8fG51bGw9PT0ocz1mLmRldGFpbHMpfHx2b2lkIDA9PT1zfHwhcy5saXZlKSx2PW51bGw9PWY/dm9pZCAwOmYuY29kZWNTZXQsZz11P3UuZHVyYXRpb246bD9sLmR1cmF0aW9uOjAscD1yO3A+PWU7cC0tKXt2YXIgbT1oW3BdO2lmKG0mJighdnx8bS5jb2RlY1NldD09PXYpKXt2YXIgeT1tLmRldGFpbHMsYj0odT9udWxsPT15P3ZvaWQgMDp5LnBhcnRUYXJnZXQ6bnVsbD09eT92b2lkIDA6eS5hdmVyYWdldGFyZ2V0ZHVyYXRpb24pfHxnLFQ9dm9pZCAwO1Q9cDw9ZD9hKnQ6bip0O3ZhciBFPWhbcF0ubWF4Qml0cmF0ZSxTPUUqYi9UO2lmKG8uYi50cmFjZShcImxldmVsL2FkanVzdGVkYncvYml0cmF0ZS9hdmdEdXJhdGlvbi9tYXhGZXRjaER1cmF0aW9uL2ZldGNoRHVyYXRpb246IFwiK3ArXCIvXCIrTWF0aC5yb3VuZChUKStcIi9cIitFK1wiL1wiK2IrXCIvXCIraStcIi9cIitTKSxUPkUmJighU3x8YyYmIXRoaXMuYml0cmF0ZVRlc3REZWxheXx8UzxpKSlyZXR1cm4gcH19cmV0dXJuLTF9LGU9dCwocj1be2tleTpcIm5leHRBdXRvTGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9uZXh0QXV0b0xldmVsLGU9dGhpcy5id0VzdGltYXRvcjtpZighKC0xPT09dHx8ZSYmZS5jYW5Fc3RpbWF0ZSgpKSlyZXR1cm4gdDt2YXIgcj10aGlzLmdldE5leHRBQlJBdXRvTGV2ZWwoKTtyZXR1cm4tMSE9PXQmJihyPU1hdGgubWluKHQscikpLHJ9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9uZXh0QXV0b0xldmVsPXR9fV0pJiYkdChlLnByb3RvdHlwZSxyKSxpJiYkdChlLGkpLHR9KCksSnQ9cigxMCksdGU9ci5uKEp0KSxlZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5idWZmZXJzPXZvaWQgMCx0aGlzLnF1ZXVlcz17dmlkZW86W10sYXVkaW86W10sYXVkaW92aWRlbzpbXX0sdGhpcy5idWZmZXJzPXR9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuYXBwZW5kPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5xdWV1ZXNbZV07ci5wdXNoKHQpLDE9PT1yLmxlbmd0aCYmdGhpcy5idWZmZXJzW2VdJiZ0aGlzLmV4ZWN1dGVOZXh0KGUpfSxlLmluc2VydEFib3J0PWZ1bmN0aW9uKHQsZSl7dGhpcy5xdWV1ZXNbZV0udW5zaGlmdCh0KSx0aGlzLmV4ZWN1dGVOZXh0KGUpfSxlLmFwcGVuZEJsb2NrZXI9ZnVuY3Rpb24odCl7dmFyIGUscj1uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7ZT10fSkpLGk9e2V4ZWN1dGU6ZSxvblN0YXJ0OmZ1bmN0aW9uKCl7fSxvbkNvbXBsZXRlOmZ1bmN0aW9uKCl7fSxvbkVycm9yOmZ1bmN0aW9uKCl7fX07cmV0dXJuIHRoaXMuYXBwZW5kKGksdCkscn0sZS5leGVjdXRlTmV4dD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmJ1ZmZlcnMscj10aGlzLnF1ZXVlcyxpPWVbdF0sYT1yW3RdO2lmKGEubGVuZ3RoKXt2YXIgbj1hWzBdO3RyeXtuLmV4ZWN1dGUoKX1jYXRjaChlKXtvLmIud2FybihcIltidWZmZXItb3BlcmF0aW9uLXF1ZXVlXTogVW5oYW5kbGVkIGV4Y2VwdGlvbiBleGVjdXRpbmcgdGhlIGN1cnJlbnQgb3BlcmF0aW9uXCIpLG4ub25FcnJvcihlKSxpJiZpLnVwZGF0aW5nfHwoYS5zaGlmdCgpLHRoaXMuZXhlY3V0ZU5leHQodCkpfX19LGUuc2hpZnRBbmRFeGVjdXRlTmV4dD1mdW5jdGlvbih0KXt0aGlzLnF1ZXVlc1t0XS5zaGlmdCgpLHRoaXMuZXhlY3V0ZU5leHQodCl9LGUuY3VycmVudD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5xdWV1ZXNbdF1bMF19LHR9KCkscmU9QnQoKSxpZT0vKFtoYV12Yy4pKD86XFwuW14uLF0rKSsvLGFlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt2YXIgZT10aGlzO3RoaXMuZGV0YWlscz1udWxsLHRoaXMuX29iamVjdFVybD1udWxsLHRoaXMub3BlcmF0aW9uUXVldWU9dm9pZCAwLHRoaXMubGlzdGVuZXJzPXZvaWQgMCx0aGlzLmhscz12b2lkIDAsdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkPTAsdGhpcy5fYnVmZmVyQ29kZWNFdmVudHNUb3RhbD0wLHRoaXMubWVkaWE9bnVsbCx0aGlzLm1lZGlhU291cmNlPW51bGwsdGhpcy5hcHBlbmRFcnJvcj0wLHRoaXMudHJhY2tzPXt9LHRoaXMucGVuZGluZ1RyYWNrcz17fSx0aGlzLnNvdXJjZUJ1ZmZlcj12b2lkIDAsdGhpcy5fb25NZWRpYVNvdXJjZU9wZW49ZnVuY3Rpb24oKXt2YXIgdD1lLmhscyxyPWUubWVkaWEsaT1lLm1lZGlhU291cmNlO28uYi5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBzb3VyY2Ugb3BlbmVkXCIpLHImJihlLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCksdC50cmlnZ2VyKG4uYS5NRURJQV9BVFRBQ0hFRCx7bWVkaWE6cn0pKSxpJiZpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzb3VyY2VvcGVuXCIsZS5fb25NZWRpYVNvdXJjZU9wZW4pLGUuY2hlY2tQZW5kaW5nVHJhY2tzKCl9LHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZT1mdW5jdGlvbigpe28uYi5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBzb3VyY2UgY2xvc2VkXCIpfSx0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQ9ZnVuY3Rpb24oKXtvLmIubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgc291cmNlIGVuZGVkXCIpfSx0aGlzLmhscz10LHRoaXMuX2luaXRTb3VyY2VCdWZmZXIoKSx0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuaGFzU291cmNlVHlwZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aD4wfHxPYmplY3Qua2V5cyh0aGlzLnBlbmRpbmdUcmFja3MpLmxlbmd0aD4wfSxlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKSx0aGlzLmRldGFpbHM9bnVsbH0sZS5yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzO3Qub24obi5hLk1FRElBX0FUVEFDSElORyx0aGlzLm9uTWVkaWFBdHRhY2hpbmcsdGhpcyksdC5vbihuLmEuTUVESUFfREVUQUNISU5HLHRoaXMub25NZWRpYURldGFjaGluZyx0aGlzKSx0Lm9uKG4uYS5NQU5JRkVTVF9QQVJTRUQsdGhpcy5vbk1hbmlmZXN0UGFyc2VkLHRoaXMpLHQub24obi5hLkJVRkZFUl9SRVNFVCx0aGlzLm9uQnVmZmVyUmVzZXQsdGhpcyksdC5vbihuLmEuQlVGRkVSX0FQUEVORElORyx0aGlzLm9uQnVmZmVyQXBwZW5kaW5nLHRoaXMpLHQub24obi5hLkJVRkZFUl9DT0RFQ1MsdGhpcy5vbkJ1ZmZlckNvZGVjcyx0aGlzKSx0Lm9uKG4uYS5CVUZGRVJfRU9TLHRoaXMub25CdWZmZXJFb3MsdGhpcyksdC5vbihuLmEuQlVGRkVSX0ZMVVNISU5HLHRoaXMub25CdWZmZXJGbHVzaGluZyx0aGlzKSx0Lm9uKG4uYS5MRVZFTF9VUERBVEVELHRoaXMub25MZXZlbFVwZGF0ZWQsdGhpcyksdC5vbihuLmEuRlJBR19QQVJTRUQsdGhpcy5vbkZyYWdQYXJzZWQsdGhpcyksdC5vbihuLmEuRlJBR19DSEFOR0VELHRoaXMub25GcmFnQ2hhbmdlZCx0aGlzKX0sZS51bnJlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vZmYobi5hLk1FRElBX0FUVEFDSElORyx0aGlzLm9uTWVkaWFBdHRhY2hpbmcsdGhpcyksdC5vZmYobi5hLk1FRElBX0RFVEFDSElORyx0aGlzLm9uTWVkaWFEZXRhY2hpbmcsdGhpcyksdC5vZmYobi5hLk1BTklGRVNUX1BBUlNFRCx0aGlzLm9uTWFuaWZlc3RQYXJzZWQsdGhpcyksdC5vZmYobi5hLkJVRkZFUl9SRVNFVCx0aGlzLm9uQnVmZmVyUmVzZXQsdGhpcyksdC5vZmYobi5hLkJVRkZFUl9BUFBFTkRJTkcsdGhpcy5vbkJ1ZmZlckFwcGVuZGluZyx0aGlzKSx0Lm9mZihuLmEuQlVGRkVSX0NPREVDUyx0aGlzLm9uQnVmZmVyQ29kZWNzLHRoaXMpLHQub2ZmKG4uYS5CVUZGRVJfRU9TLHRoaXMub25CdWZmZXJFb3MsdGhpcyksdC5vZmYobi5hLkJVRkZFUl9GTFVTSElORyx0aGlzLm9uQnVmZmVyRmx1c2hpbmcsdGhpcyksdC5vZmYobi5hLkxFVkVMX1VQREFURUQsdGhpcy5vbkxldmVsVXBkYXRlZCx0aGlzKSx0Lm9mZihuLmEuRlJBR19QQVJTRUQsdGhpcy5vbkZyYWdQYXJzZWQsdGhpcyksdC5vZmYobi5hLkZSQUdfQ0hBTkdFRCx0aGlzLm9uRnJhZ0NoYW5nZWQsdGhpcyl9LGUuX2luaXRTb3VyY2VCdWZmZXI9ZnVuY3Rpb24oKXt0aGlzLnNvdXJjZUJ1ZmZlcj17fSx0aGlzLm9wZXJhdGlvblF1ZXVlPW5ldyBlZSh0aGlzLnNvdXJjZUJ1ZmZlciksdGhpcy5saXN0ZW5lcnM9e2F1ZGlvOltdLHZpZGVvOltdLGF1ZGlvdmlkZW86W119fSxlLm9uTWFuaWZlc3RQYXJzZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj0yOyhlLmF1ZGlvJiYhZS52aWRlb3x8IWUuYWx0QXVkaW8pJiYocj0xKSx0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQ9dGhpcy5fYnVmZmVyQ29kZWNFdmVudHNUb3RhbD1yLHRoaXMuZGV0YWlscz1udWxsLG8uYi5sb2codGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkK1wiIGJ1ZmZlckNvZGVjIGV2ZW50KHMpIGV4cGVjdGVkXCIpfSxlLm9uTWVkaWFBdHRhY2hpbmc9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLm1lZGlhPWUubWVkaWE7aWYociYmcmUpe3ZhciBpPXRoaXMubWVkaWFTb3VyY2U9bmV3IHJlO2kuYWRkRXZlbnRMaXN0ZW5lcihcInNvdXJjZW9wZW5cIix0aGlzLl9vbk1lZGlhU291cmNlT3BlbiksaS5hZGRFdmVudExpc3RlbmVyKFwic291cmNlZW5kZWRcIix0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQpLGkuYWRkRXZlbnRMaXN0ZW5lcihcInNvdXJjZWNsb3NlXCIsdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKSxyLnNyYz1zZWxmLlVSTC5jcmVhdGVPYmplY3RVUkwoaSksdGhpcy5fb2JqZWN0VXJsPXIuc3JjfX0sZS5vbk1lZGlhRGV0YWNoaW5nPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5tZWRpYSxlPXRoaXMubWVkaWFTb3VyY2Uscj10aGlzLl9vYmplY3RVcmw7aWYoZSl7aWYoby5iLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IG1lZGlhIHNvdXJjZSBkZXRhY2hpbmdcIiksXCJvcGVuXCI9PT1lLnJlYWR5U3RhdGUpdHJ5e2UuZW5kT2ZTdHJlYW0oKX1jYXRjaCh0KXtvLmIud2FybihcIltidWZmZXItY29udHJvbGxlcl06IG9uTWVkaWFEZXRhY2hpbmc6IFwiK3QubWVzc2FnZStcIiB3aGlsZSBjYWxsaW5nIGVuZE9mU3RyZWFtXCIpfXRoaXMub25CdWZmZXJSZXNldCgpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNvdXJjZW9wZW5cIix0aGlzLl9vbk1lZGlhU291cmNlT3BlbiksZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic291cmNlZW5kZWRcIix0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNvdXJjZWNsb3NlXCIsdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKSx0JiYociYmc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKHIpLHQuc3JjPT09cj8odC5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIiksdC5sb2FkKCkpOm8uYi53YXJuKFwiW2J1ZmZlci1jb250cm9sbGVyXTogbWVkaWEuc3JjIHdhcyBjaGFuZ2VkIGJ5IGEgdGhpcmQgcGFydHkgLSBza2lwIGNsZWFudXBcIikpLHRoaXMubWVkaWFTb3VyY2U9bnVsbCx0aGlzLm1lZGlhPW51bGwsdGhpcy5fb2JqZWN0VXJsPW51bGwsdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkPXRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWwsdGhpcy5wZW5kaW5nVHJhY2tzPXt9LHRoaXMudHJhY2tzPXt9fXRoaXMuaGxzLnRyaWdnZXIobi5hLk1FRElBX0RFVEFDSEVELHZvaWQgMCl9LGUub25CdWZmZXJSZXNldD1mdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciByPXQuc291cmNlQnVmZmVyW2VdO3RyeXtyJiYodC5yZW1vdmVCdWZmZXJMaXN0ZW5lcnMoZSksdC5tZWRpYVNvdXJjZSYmdC5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIociksdC5zb3VyY2VCdWZmZXJbZV09dm9pZCAwKX1jYXRjaCh0KXtvLmIud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCB0byByZXNldCB0aGUgXCIrZStcIiBidWZmZXJcIix0KX19KSksdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpfSxlLm9uQnVmZmVyQ29kZWNzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcyxpPXRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5sZW5ndGg7T2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYoaSl7dmFyIGE9ci50cmFja3NbdF07aWYoYSYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS5idWZmZXIuY2hhbmdlVHlwZSl7dmFyIG49ZVt0XSxzPW4uY29kZWMsbz1uLmxldmVsQ29kZWMsbD1uLmNvbnRhaW5lcjtpZigoYS5sZXZlbENvZGVjfHxhLmNvZGVjKS5yZXBsYWNlKGllLFwiJDFcIikhPT0ob3x8cykucmVwbGFjZShpZSxcIiQxXCIpKXt2YXIgdT1sK1wiO2NvZGVjcz1cIisob3x8cyk7ci5hcHBlbmRDaGFuZ2VUeXBlKHQsdSl9fX1lbHNlIHIucGVuZGluZ1RyYWNrc1t0XT1lW3RdfSkpLGl8fCh0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQ9TWF0aC5tYXgodGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkLTEsMCksdGhpcy5tZWRpYVNvdXJjZSYmXCJvcGVuXCI9PT10aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUmJnRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCkpfSxlLmFwcGVuZENoYW5nZVR5cGU9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLGk9dGhpcy5vcGVyYXRpb25RdWV1ZSxhPXtleGVjdXRlOmZ1bmN0aW9uKCl7dmFyIGE9ci5zb3VyY2VCdWZmZXJbdF07YSYmKG8uYi5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBjaGFuZ2luZyBcIit0K1wiIHNvdXJjZUJ1ZmZlciB0eXBlIHRvIFwiK2UpLGEuY2hhbmdlVHlwZShlKSksaS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHQpfSxvblN0YXJ0OmZ1bmN0aW9uKCl7fSxvbkNvbXBsZXRlOmZ1bmN0aW9uKCl7fSxvbkVycm9yOmZ1bmN0aW9uKGUpe28uYi53YXJuKFwiW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIHRvIGNoYW5nZSBcIit0K1wiIFNvdXJjZUJ1ZmZlciB0eXBlXCIsZSl9fTtpLmFwcGVuZChhLHQpfSxlLm9uQnVmZmVyQXBwZW5kaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcyxpPXRoaXMuaGxzLGE9dGhpcy5vcGVyYXRpb25RdWV1ZSxsPXRoaXMudHJhY2tzLHU9ZS5kYXRhLGQ9ZS50eXBlLGg9ZS5mcmFnLGY9ZS5wYXJ0LGM9ZS5jaHVua01ldGEsdj1jLmJ1ZmZlcmluZ1tkXSxnPXNlbGYucGVyZm9ybWFuY2Uubm93KCk7di5zdGFydD1nO3ZhciBwPWguc3RhdHMuYnVmZmVyaW5nLG09Zj9mLnN0YXRzLmJ1ZmZlcmluZzpudWxsOzA9PT1wLnN0YXJ0JiYocC5zdGFydD1nKSxtJiYwPT09bS5zdGFydCYmKG0uc3RhcnQ9Zyk7dmFyIHk9bC5hdWRpbyxiPVwiYXVkaW9cIj09PWQmJjE9PT1jLmlkJiZcImF1ZGlvL21wZWdcIj09PShudWxsPT15P3ZvaWQgMDp5LmNvbnRhaW5lciksVD17ZXhlY3V0ZTpmdW5jdGlvbigpe2lmKHYuZXhlY3V0ZVN0YXJ0PXNlbGYucGVyZm9ybWFuY2Uubm93KCksYil7dmFyIHQ9ci5zb3VyY2VCdWZmZXJbZF07aWYodCl7dmFyIGU9aC5zdGFydC10LnRpbWVzdGFtcE9mZnNldDtNYXRoLmFicyhlKT49LjEmJihvLmIubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogVXBkYXRpbmcgYXVkaW8gU291cmNlQnVmZmVyIHRpbWVzdGFtcE9mZnNldCB0byBcIitoLnN0YXJ0K1wiIChkZWx0YTogXCIrZStcIikgc246IFwiK2guc24rXCIpXCIpLHQudGltZXN0YW1wT2Zmc2V0PWguc3RhcnQpfX1yLmFwcGVuZEV4ZWN1dG9yKHUsZCl9LG9uU3RhcnQ6ZnVuY3Rpb24oKXt9LG9uQ29tcGxldGU6ZnVuY3Rpb24oKXt2YXIgdD1zZWxmLnBlcmZvcm1hbmNlLm5vdygpO3YuZXhlY3V0ZUVuZD12LmVuZD10LDA9PT1wLmZpcnN0JiYocC5maXJzdD10KSxtJiYwPT09bS5maXJzdCYmKG0uZmlyc3Q9dCk7dmFyIGU9ci5zb3VyY2VCdWZmZXIsaT17fTtmb3IodmFyIGEgaW4gZSlpW2FdPW50LmdldEJ1ZmZlcmVkKGVbYV0pO3IuYXBwZW5kRXJyb3I9MCxyLmhscy50cmlnZ2VyKG4uYS5CVUZGRVJfQVBQRU5ERUQse3R5cGU6ZCxmcmFnOmgscGFydDpmLGNodW5rTWV0YTpjLHBhcmVudDpoLnR5cGUsdGltZVJhbmdlczppfSl9LG9uRXJyb3I6ZnVuY3Rpb24odCl7by5iLmVycm9yKFwiW2J1ZmZlci1jb250cm9sbGVyXTogRXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgdHJ5aW5nIHRvIGFwcGVuZCB0byB0aGUgXCIrZCtcIiBTb3VyY2VCdWZmZXJcIix0KTt2YXIgZT17dHlwZTpzLmIuTUVESUFfRVJST1IscGFyZW50OmgudHlwZSxkZXRhaWxzOnMuYS5CVUZGRVJfQVBQRU5EX0VSUk9SLGVycjp0LGZhdGFsOiExfTt0LmNvZGU9PT1ET01FeGNlcHRpb24uUVVPVEFfRVhDRUVERURfRVJSP2UuZGV0YWlscz1zLmEuQlVGRkVSX0ZVTExfRVJST1I6KHIuYXBwZW5kRXJyb3IrKyxlLmRldGFpbHM9cy5hLkJVRkZFUl9BUFBFTkRfRVJST1Isci5hcHBlbmRFcnJvcj5pLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5JiYoby5iLmVycm9yKFwiW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIFwiK2kuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkrXCIgdGltZXMgdG8gYXBwZW5kIHNlZ21lbnQgaW4gc291cmNlQnVmZmVyXCIpLGUuZmF0YWw9ITApKSxpLnRyaWdnZXIobi5hLkVSUk9SLGUpfX07YS5hcHBlbmQoVCxkKX0sZS5vbkJ1ZmZlckZsdXNoaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcyxpPXRoaXMub3BlcmF0aW9uUXVldWUsYT1mdW5jdGlvbih0KXtyZXR1cm57ZXhlY3V0ZTpyLnJlbW92ZUV4ZWN1dG9yLmJpbmQocix0LGUuc3RhcnRPZmZzZXQsZS5lbmRPZmZzZXQpLG9uU3RhcnQ6ZnVuY3Rpb24oKXt9LG9uQ29tcGxldGU6ZnVuY3Rpb24oKXtyLmhscy50cmlnZ2VyKG4uYS5CVUZGRVJfRkxVU0hFRCx7dHlwZTp0fSl9LG9uRXJyb3I6ZnVuY3Rpb24oZSl7by5iLndhcm4oXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBGYWlsZWQgdG8gcmVtb3ZlIGZyb20gXCIrdCtcIiBTb3VyY2VCdWZmZXJcIixlKX19fTtlLnR5cGU/aS5hcHBlbmQoYShlLnR5cGUpLGUudHlwZSk6dGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2goKGZ1bmN0aW9uKHQpe2kuYXBwZW5kKGEodCksdCl9KSl9LGUub25GcmFnUGFyc2VkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcyxpPWUuZnJhZyxhPWUucGFydCxzPVtdLGw9YT9hLmVsZW1lbnRhcnlTdHJlYW1zOmkuZWxlbWVudGFyeVN0cmVhbXM7bFt1LmEuQVVESU9WSURFT10/cy5wdXNoKFwiYXVkaW92aWRlb1wiKToobFt1LmEuQVVESU9dJiZzLnB1c2goXCJhdWRpb1wiKSxsW3UuYS5WSURFT10mJnMucHVzaChcInZpZGVvXCIpKTswPT09cy5sZW5ndGgmJm8uYi53YXJuKFwiRnJhZ21lbnRzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgRWxlbWVudGFyeVN0cmVhbVR5cGUgc2V0LiB0eXBlOiBcIitpLnR5cGUrXCIgbGV2ZWw6IFwiK2kubGV2ZWwrXCIgc246IFwiK2kuc24pLHRoaXMuYmxvY2tCdWZmZXJzKChmdW5jdGlvbigpe3ZhciB0PXNlbGYucGVyZm9ybWFuY2Uubm93KCk7aS5zdGF0cy5idWZmZXJpbmcuZW5kPXQsYSYmKGEuc3RhdHMuYnVmZmVyaW5nLmVuZD10KTt2YXIgZT1hP2Euc3RhdHM6aS5zdGF0cztyLmhscy50cmlnZ2VyKG4uYS5GUkFHX0JVRkZFUkVELHtmcmFnOmkscGFydDphLHN0YXRzOmUsaWQ6aS50eXBlfSl9KSxzKX0sZS5vbkZyYWdDaGFuZ2VkPWZ1bmN0aW9uKHQsZSl7dGhpcy5mbHVzaEJhY2tCdWZmZXIoKX0sZS5vbkJ1ZmZlckVvcz1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXM7dGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLnJlZHVjZSgoZnVuY3Rpb24odCxpKXt2YXIgYT1yLnNvdXJjZUJ1ZmZlcltpXTtyZXR1cm4gZS50eXBlJiZlLnR5cGUhPT1pfHxhJiYhYS5lbmRlZCYmKGEuZW5kZWQ9ITAsby5iLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFwiK2krXCIgc291cmNlQnVmZmVyIG5vdyBFT1NcIikpLHQmJiEoYSYmIWEuZW5kZWQpfSksITApJiZ0aGlzLmJsb2NrQnVmZmVycygoZnVuY3Rpb24oKXt2YXIgdD1yLm1lZGlhU291cmNlO3QmJlwib3BlblwiPT09dC5yZWFkeVN0YXRlJiZ0LmVuZE9mU3RyZWFtKCl9KSl9LGUub25MZXZlbFVwZGF0ZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1lLmRldGFpbHM7ci5mcmFnbWVudHMubGVuZ3RoJiYodGhpcy5kZXRhaWxzPXIsdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aD90aGlzLmJsb2NrQnVmZmVycyh0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uLmJpbmQodGhpcykpOnRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKSl9LGUuZmx1c2hCYWNrQnVmZmVyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHMsZT10aGlzLmRldGFpbHMscj10aGlzLm1lZGlhLGk9dGhpcy5zb3VyY2VCdWZmZXI7aWYociYmbnVsbCE9PWUpe3ZhciBzPXRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtpZihzLmxlbmd0aCl7dmFyIG89ZS5saXZlJiZudWxsIT09dC5jb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGg/dC5jb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGg6dC5jb25maWcuYmFja0J1ZmZlckxlbmd0aDtpZihPYmplY3QoYS5hKShvKSYmIShvPDApKXt2YXIgbD1yLmN1cnJlbnRUaW1lLHU9ZS5sZXZlbFRhcmdldER1cmF0aW9uLGQ9TWF0aC5tYXgobyx1KSxoPU1hdGguZmxvb3IobC91KSp1LWQ7cy5mb3JFYWNoKChmdW5jdGlvbihyKXt2YXIgYT1pW3JdO2lmKGEpe3ZhciBzPW50LmdldEJ1ZmZlcmVkKGEpO3MubGVuZ3RoPjAmJmg+cy5zdGFydCgwKSYmKHQudHJpZ2dlcihuLmEuQkFDS19CVUZGRVJfUkVBQ0hFRCx7YnVmZmVyRW5kOmh9KSxlLmxpdmUmJnQudHJpZ2dlcihuLmEuTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVELHtidWZmZXJFbmQ6aH0pLHQudHJpZ2dlcihuLmEuQlVGRkVSX0ZMVVNISU5HLHtzdGFydE9mZnNldDowLGVuZE9mZnNldDpoLHR5cGU6cn0pKX19KSl9fX19LGUudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb249ZnVuY3Rpb24oKXtpZih0aGlzLmRldGFpbHMmJnRoaXMubWVkaWEmJnRoaXMubWVkaWFTb3VyY2UmJlwib3BlblwiPT09dGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlKXt2YXIgdD10aGlzLmRldGFpbHMsZT10aGlzLmhscyxyPXRoaXMubWVkaWEsaT10aGlzLm1lZGlhU291cmNlLG49dC5mcmFnbWVudHNbMF0uc3RhcnQrdC50b3RhbGR1cmF0aW9uLHM9ci5kdXJhdGlvbixsPU9iamVjdChhLmEpKGkuZHVyYXRpb24pP2kuZHVyYXRpb246MDt0LmxpdmUmJmUuY29uZmlnLmxpdmVEdXJhdGlvbkluZmluaXR5PyhvLmIubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgU291cmNlIGR1cmF0aW9uIGlzIHNldCB0byBJbmZpbml0eVwiKSxpLmR1cmF0aW9uPTEvMCx0aGlzLnVwZGF0ZVNlZWthYmxlUmFuZ2UodCkpOihuPmwmJm4+c3x8IU9iamVjdChhLmEpKHMpKSYmKG8uYi5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBVcGRhdGluZyBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gXCIrbi50b0ZpeGVkKDMpKSxpLmR1cmF0aW9uPW4pfX0sZS51cGRhdGVTZWVrYWJsZVJhbmdlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubWVkaWFTb3VyY2Uscj10LmZyYWdtZW50cztpZihyLmxlbmd0aCYmdC5saXZlJiZudWxsIT1lJiZlLnNldExpdmVTZWVrYWJsZVJhbmdlKXt2YXIgaT1NYXRoLm1heCgwLHJbMF0uc3RhcnQpLGE9TWF0aC5tYXgoaSxpK3QudG90YWxkdXJhdGlvbik7ZS5zZXRMaXZlU2Vla2FibGVSYW5nZShpLGEpfX0sZS5jaGVja1BlbmRpbmdUcmFja3M9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQsZT10aGlzLm9wZXJhdGlvblF1ZXVlLHI9dGhpcy5wZW5kaW5nVHJhY2tzLGk9T2JqZWN0LmtleXMocikubGVuZ3RoO2lmKGkmJiF0fHwyPT09aSl7dGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJzKHIpLHRoaXMucGVuZGluZ1RyYWNrcz17fTt2YXIgYT10aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCk7aWYoMD09PWEubGVuZ3RoKXJldHVybiB2b2lkIHRoaXMuaGxzLnRyaWdnZXIobi5hLkVSUk9SLHt0eXBlOnMuYi5NRURJQV9FUlJPUixkZXRhaWxzOnMuYS5CVUZGRVJfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUixmYXRhbDohMCxyZWFzb246XCJjb3VsZCBub3QgY3JlYXRlIHNvdXJjZSBidWZmZXIgZm9yIG1lZGlhIGNvZGVjKHMpXCJ9KTthLmZvckVhY2goKGZ1bmN0aW9uKHQpe2UuZXhlY3V0ZU5leHQodCl9KSl9fSxlLmNyZWF0ZVNvdXJjZUJ1ZmZlcnM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zb3VyY2VCdWZmZXIscj10aGlzLm1lZGlhU291cmNlO2lmKCFyKXRocm93IEVycm9yKFwiY3JlYXRlU291cmNlQnVmZmVycyBjYWxsZWQgd2hlbiBtZWRpYVNvdXJjZSB3YXMgbnVsbFwiKTt2YXIgaT0wO2Zvcih2YXIgYSBpbiB0KWlmKCFlW2FdKXt2YXIgbD10W2FdO2lmKCFsKXRocm93IEVycm9yKFwic291cmNlIGJ1ZmZlciBleGlzdHMgZm9yIHRyYWNrIFwiK2ErXCIsIGhvd2V2ZXIgdHJhY2sgZG9lcyBub3RcIik7dmFyIHU9bC5sZXZlbENvZGVjfHxsLmNvZGVjLGQ9bC5jb250YWluZXIrXCI7Y29kZWNzPVwiK3U7by5iLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IGNyZWF0aW5nIHNvdXJjZUJ1ZmZlcihcIitkK1wiKVwiKTt0cnl7dmFyIGg9ZVthXT1yLmFkZFNvdXJjZUJ1ZmZlcihkKSxmPWE7dGhpcy5hZGRCdWZmZXJMaXN0ZW5lcihmLFwidXBkYXRlc3RhcnRcIix0aGlzLl9vblNCVXBkYXRlU3RhcnQpLHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoZixcInVwZGF0ZWVuZFwiLHRoaXMuX29uU0JVcGRhdGVFbmQpLHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoZixcImVycm9yXCIsdGhpcy5fb25TQlVwZGF0ZUVycm9yKSx0aGlzLnRyYWNrc1thXT17YnVmZmVyOmgsY29kZWM6dSxjb250YWluZXI6bC5jb250YWluZXIsbGV2ZWxDb2RlYzpsLmxldmVsQ29kZWMsaWQ6bC5pZH0saSsrfWNhdGNoKHQpe28uYi5lcnJvcihcIltidWZmZXItY29udHJvbGxlcl06IGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiBcIit0Lm1lc3NhZ2UpLHRoaXMuaGxzLnRyaWdnZXIobi5hLkVSUk9SLHt0eXBlOnMuYi5NRURJQV9FUlJPUixkZXRhaWxzOnMuYS5CVUZGRVJfQUREX0NPREVDX0VSUk9SLGZhdGFsOiExLGVycm9yOnQsbWltZVR5cGU6ZH0pfX1pJiZ0aGlzLmhscy50cmlnZ2VyKG4uYS5CVUZGRVJfQ1JFQVRFRCx7dHJhY2tzOnRoaXMudHJhY2tzfSl9LGUuX29uU0JVcGRhdGVTdGFydD1mdW5jdGlvbih0KXt0aGlzLm9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodCkub25TdGFydCgpfSxlLl9vblNCVXBkYXRlRW5kPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMub3BlcmF0aW9uUXVldWU7ZS5jdXJyZW50KHQpLm9uQ29tcGxldGUoKSxlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodCl9LGUuX29uU0JVcGRhdGVFcnJvcj1mdW5jdGlvbih0LGUpe28uYi5lcnJvcihcIltidWZmZXItY29udHJvbGxlcl06IFwiK3QrXCIgU291cmNlQnVmZmVyIGVycm9yXCIsZSksdGhpcy5obHMudHJpZ2dlcihuLmEuRVJST1Ise3R5cGU6cy5iLk1FRElBX0VSUk9SLGRldGFpbHM6cy5hLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsZmF0YWw6ITF9KTt2YXIgcj10aGlzLm9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodCk7ciYmci5vbkVycm9yKGUpfSxlLnJlbW92ZUV4ZWN1dG9yPWZ1bmN0aW9uKHQsZSxyKXt2YXIgaT10aGlzLm1lZGlhLG49dGhpcy5tZWRpYVNvdXJjZSxzPXRoaXMub3BlcmF0aW9uUXVldWUsbD10aGlzLnNvdXJjZUJ1ZmZlclt0XTtpZighaXx8IW58fCFsKXJldHVybiBvLmIud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEF0dGVtcHRpbmcgdG8gcmVtb3ZlIGZyb20gdGhlIFwiK3QrXCIgU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RcIiksdm9pZCBzLnNoaWZ0QW5kRXhlY3V0ZU5leHQodCk7dmFyIHU9T2JqZWN0KGEuYSkoaS5kdXJhdGlvbik/aS5kdXJhdGlvbjoxLzAsZD1PYmplY3QoYS5hKShuLmR1cmF0aW9uKT9uLmR1cmF0aW9uOjEvMCxoPU1hdGgubWF4KDAsZSksZj1NYXRoLm1pbihyLHUsZCk7Zj5oPyhvLmIubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogUmVtb3ZpbmcgW1wiK2grXCIsXCIrZitcIl0gZnJvbSB0aGUgXCIrdCtcIiBTb3VyY2VCdWZmZXJcIiksbC5yZW1vdmUoaCxmKSk6cy5zaGlmdEFuZEV4ZWN1dGVOZXh0KHQpfSxlLmFwcGVuZEV4ZWN1dG9yPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5vcGVyYXRpb25RdWV1ZSxpPXRoaXMuc291cmNlQnVmZmVyW2VdO2lmKCFpKXJldHVybiBvLmIud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEF0dGVtcHRpbmcgdG8gYXBwZW5kIHRvIHRoZSBcIitlK1wiIFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0XCIpLHZvaWQgci5zaGlmdEFuZEV4ZWN1dGVOZXh0KGUpO2kuZW5kZWQ9ITEsaS5hcHBlbmRCdWZmZXIodCl9LGUuYmxvY2tCdWZmZXJzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcztpZih2b2lkIDA9PT1lJiYoZT10aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkpLCFlLmxlbmd0aClyZXR1cm4gby5iLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nIG9wZXJhdGlvbiByZXF1ZXN0ZWQsIGJ1dCBubyBTb3VyY2VCdWZmZXJzIGV4aXN0XCIpLHZvaWQgUHJvbWlzZS5yZXNvbHZlKHQpO3ZhciBpPXRoaXMub3BlcmF0aW9uUXVldWUsYT1lLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGkuYXBwZW5kQmxvY2tlcih0KX0pKTtQcm9taXNlLmFsbChhKS50aGVuKChmdW5jdGlvbigpe3QoKSxlLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPXIuc291cmNlQnVmZmVyW3RdO2UmJmUudXBkYXRpbmd8fGkuc2hpZnRBbmRFeGVjdXRlTmV4dCh0KX0pKX0pKX0sZS5nZXRTb3VyY2VCdWZmZXJUeXBlcz1mdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcil9LGUuYWRkQnVmZmVyTGlzdGVuZXI9ZnVuY3Rpb24odCxlLHIpe3ZhciBpPXRoaXMuc291cmNlQnVmZmVyW3RdO2lmKGkpe3ZhciBhPXIuYmluZCh0aGlzLHQpO3RoaXMubGlzdGVuZXJzW3RdLnB1c2goe2V2ZW50OmUsbGlzdGVuZXI6YX0pLGkuYWRkRXZlbnRMaXN0ZW5lcihlLGEpfX0sZS5yZW1vdmVCdWZmZXJMaXN0ZW5lcnM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zb3VyY2VCdWZmZXJbdF07ZSYmdGhpcy5saXN0ZW5lcnNbdF0uZm9yRWFjaCgoZnVuY3Rpb24odCl7ZS5yZW1vdmVFdmVudExpc3RlbmVyKHQuZXZlbnQsdC5saXN0ZW5lcil9KSl9LHR9KCk7ZnVuY3Rpb24gbmUodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaS5rZXksaSl9fXZhciBzZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5hdXRvTGV2ZWxDYXBwaW5nPXZvaWQgMCx0aGlzLmZpcnN0TGV2ZWw9dm9pZCAwLHRoaXMubWVkaWE9dm9pZCAwLHRoaXMucmVzdHJpY3RlZExldmVscz12b2lkIDAsdGhpcy50aW1lcj12b2lkIDAsdGhpcy5obHM9dm9pZCAwLHRoaXMuc3RyZWFtQ29udHJvbGxlcj12b2lkIDAsdGhpcy5jbGllbnRSZWN0PXZvaWQgMCx0aGlzLmhscz10LHRoaXMuYXV0b0xldmVsQ2FwcGluZz1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5maXJzdExldmVsPS0xLHRoaXMubWVkaWE9bnVsbCx0aGlzLnJlc3RyaWN0ZWRMZXZlbHM9W10sdGhpcy50aW1lcj12b2lkIDAsdGhpcy5jbGllbnRSZWN0PW51bGwsdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpfXZhciBlLHIsaSxhPXQucHJvdG90eXBlO3JldHVybiBhLnNldFN0cmVhbUNvbnRyb2xsZXI9ZnVuY3Rpb24odCl7dGhpcy5zdHJlYW1Db250cm9sbGVyPXR9LGEuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMudW5yZWdpc3Rlckxpc3RlbmVyKCksdGhpcy5obHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplJiZ0aGlzLnN0b3BDYXBwaW5nKCksdGhpcy5tZWRpYT1udWxsLHRoaXMuY2xpZW50UmVjdD1udWxsLHRoaXMuaGxzPXRoaXMuc3RyZWFtQ29udHJvbGxlcj1udWxsfSxhLnJlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vbihuLmEuRlBTX0RST1BfTEVWRUxfQ0FQUElORyx0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZyx0aGlzKSx0Lm9uKG4uYS5NRURJQV9BVFRBQ0hJTkcsdGhpcy5vbk1lZGlhQXR0YWNoaW5nLHRoaXMpLHQub24obi5hLk1BTklGRVNUX1BBUlNFRCx0aGlzLm9uTWFuaWZlc3RQYXJzZWQsdGhpcyksdC5vbihuLmEuQlVGRkVSX0NPREVDUyx0aGlzLm9uQnVmZmVyQ29kZWNzLHRoaXMpLHQub24obi5hLk1FRElBX0RFVEFDSElORyx0aGlzLm9uTWVkaWFEZXRhY2hpbmcsdGhpcyl9LGEudW5yZWdpc3Rlckxpc3RlbmVyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vZmYobi5hLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsdGhpcy5vbkZwc0Ryb3BMZXZlbENhcHBpbmcsdGhpcyksdC5vZmYobi5hLk1FRElBX0FUVEFDSElORyx0aGlzLm9uTWVkaWFBdHRhY2hpbmcsdGhpcyksdC5vZmYobi5hLk1BTklGRVNUX1BBUlNFRCx0aGlzLm9uTWFuaWZlc3RQYXJzZWQsdGhpcyksdC5vZmYobi5hLkJVRkZFUl9DT0RFQ1MsdGhpcy5vbkJ1ZmZlckNvZGVjcyx0aGlzKSx0Lm9mZihuLmEuTUVESUFfREVUQUNISU5HLHRoaXMub25NZWRpYURldGFjaGluZyx0aGlzKX0sYS5vbkZwc0Ryb3BMZXZlbENhcHBpbmc9ZnVuY3Rpb24oZSxyKXt0LmlzTGV2ZWxBbGxvd2VkKHIuZHJvcHBlZExldmVsLHRoaXMucmVzdHJpY3RlZExldmVscykmJnRoaXMucmVzdHJpY3RlZExldmVscy5wdXNoKHIuZHJvcHBlZExldmVsKX0sYS5vbk1lZGlhQXR0YWNoaW5nPWZ1bmN0aW9uKHQsZSl7dGhpcy5tZWRpYT1lLm1lZGlhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudD9lLm1lZGlhOm51bGx9LGEub25NYW5pZmVzdFBhcnNlZD1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMuaGxzO3RoaXMucmVzdHJpY3RlZExldmVscz1bXSx0aGlzLmZpcnN0TGV2ZWw9ZS5maXJzdExldmVsLHIuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplJiZlLnZpZGVvJiZ0aGlzLnN0YXJ0Q2FwcGluZygpfSxhLm9uQnVmZmVyQ29kZWNzPWZ1bmN0aW9uKHQsZSl7dGhpcy5obHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplJiZlLnZpZGVvJiZ0aGlzLnN0YXJ0Q2FwcGluZygpfSxhLm9uTWVkaWFEZXRhY2hpbmc9ZnVuY3Rpb24oKXt0aGlzLnN0b3BDYXBwaW5nKCl9LGEuZGV0ZWN0UGxheWVyU2l6ZT1mdW5jdGlvbigpe2lmKHRoaXMubWVkaWEmJnRoaXMubWVkaWFIZWlnaHQ+MCYmdGhpcy5tZWRpYVdpZHRoPjApe3ZhciB0PXRoaXMuaGxzLmxldmVscztpZih0Lmxlbmd0aCl7dmFyIGU9dGhpcy5obHM7ZS5hdXRvTGV2ZWxDYXBwaW5nPXRoaXMuZ2V0TWF4TGV2ZWwodC5sZW5ndGgtMSksZS5hdXRvTGV2ZWxDYXBwaW5nPnRoaXMuYXV0b0xldmVsQ2FwcGluZyYmdGhpcy5zdHJlYW1Db250cm9sbGVyJiZ0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCksdGhpcy5hdXRvTGV2ZWxDYXBwaW5nPWUuYXV0b0xldmVsQ2FwcGluZ319fSxhLmdldE1heExldmVsPWZ1bmN0aW9uKGUpe3ZhciByPXRoaXMsaT10aGlzLmhscy5sZXZlbHM7aWYoIWkubGVuZ3RoKXJldHVybi0xO3ZhciBhPWkuZmlsdGVyKChmdW5jdGlvbihpLGEpe3JldHVybiB0LmlzTGV2ZWxBbGxvd2VkKGEsci5yZXN0cmljdGVkTGV2ZWxzKSYmYTw9ZX0pKTtyZXR1cm4gdGhpcy5jbGllbnRSZWN0PW51bGwsdC5nZXRNYXhMZXZlbEJ5TWVkaWFTaXplKGEsdGhpcy5tZWRpYVdpZHRoLHRoaXMubWVkaWFIZWlnaHQpfSxhLnN0YXJ0Q2FwcGluZz1mdW5jdGlvbigpe3RoaXMudGltZXJ8fCh0aGlzLmF1dG9MZXZlbENhcHBpbmc9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHRoaXMuaGxzLmZpcnN0TGV2ZWw9dGhpcy5nZXRNYXhMZXZlbCh0aGlzLmZpcnN0TGV2ZWwpLHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKSx0aGlzLnRpbWVyPXNlbGYuc2V0SW50ZXJ2YWwodGhpcy5kZXRlY3RQbGF5ZXJTaXplLmJpbmQodGhpcyksMWUzKSx0aGlzLmRldGVjdFBsYXllclNpemUoKSl9LGEuc3RvcENhcHBpbmc9ZnVuY3Rpb24oKXt0aGlzLnJlc3RyaWN0ZWRMZXZlbHM9W10sdGhpcy5maXJzdExldmVsPS0xLHRoaXMuYXV0b0xldmVsQ2FwcGluZz1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy50aW1lciYmKHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKSx0aGlzLnRpbWVyPXZvaWQgMCl9LGEuZ2V0RGltZW5zaW9ucz1mdW5jdGlvbigpe2lmKHRoaXMuY2xpZW50UmVjdClyZXR1cm4gdGhpcy5jbGllbnRSZWN0O3ZhciB0PXRoaXMubWVkaWEsZT17d2lkdGg6MCxoZWlnaHQ6MH07aWYodCl7dmFyIHI9dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtlLndpZHRoPXIud2lkdGgsZS5oZWlnaHQ9ci5oZWlnaHQsZS53aWR0aHx8ZS5oZWlnaHR8fChlLndpZHRoPXIucmlnaHQtci5sZWZ0fHx0LndpZHRofHwwLGUuaGVpZ2h0PXIuYm90dG9tLXIudG9wfHx0LmhlaWdodHx8MCl9cmV0dXJuIHRoaXMuY2xpZW50UmVjdD1lLGV9LHQuaXNMZXZlbEFsbG93ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9W10pLC0xPT09ZS5pbmRleE9mKHQpfSx0LmdldE1heExldmVsQnlNZWRpYVNpemU9ZnVuY3Rpb24odCxlLHIpe2lmKCF0fHwhdC5sZW5ndGgpcmV0dXJuLTE7Zm9yKHZhciBpLGEsbj10Lmxlbmd0aC0xLHM9MDtzPHQubGVuZ3RoO3MrPTEpe3ZhciBvPXRbc107aWYoKG8ud2lkdGg+PWV8fG8uaGVpZ2h0Pj1yKSYmKGk9bywhKGE9dFtzKzFdKXx8aS53aWR0aCE9PWEud2lkdGh8fGkuaGVpZ2h0IT09YS5oZWlnaHQpKXtuPXM7YnJlYWt9fXJldHVybiBufSxlPXQsaT1be2tleTpcImNvbnRlbnRTY2FsZUZhY3RvclwiLGdldDpmdW5jdGlvbigpe3ZhciB0PTE7dHJ5e3Q9c2VsZi5kZXZpY2VQaXhlbFJhdGlvfWNhdGNoKHQpe31yZXR1cm4gdH19XSwocj1be2tleTpcIm1lZGlhV2lkdGhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXREaW1lbnNpb25zKCkud2lkdGgqdC5jb250ZW50U2NhbGVGYWN0b3J9fSx7a2V5OlwibWVkaWFIZWlnaHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXREaW1lbnNpb25zKCkuaGVpZ2h0KnQuY29udGVudFNjYWxlRmFjdG9yfX1dKSYmbmUoZS5wcm90b3R5cGUsciksaSYmbmUoZSxpKSx0fSgpLG9lPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmhscz12b2lkIDAsdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlPSExLHRoaXMudGltZXI9dm9pZCAwLHRoaXMubWVkaWE9bnVsbCx0aGlzLmxhc3RUaW1lPXZvaWQgMCx0aGlzLmxhc3REcm9wcGVkRnJhbWVzPTAsdGhpcy5sYXN0RGVjb2RlZEZyYW1lcz0wLHRoaXMuc3RyZWFtQ29udHJvbGxlcj12b2lkIDAsdGhpcy5obHM9dCx0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuc2V0U3RyZWFtQ29udHJvbGxlcj1mdW5jdGlvbih0KXt0aGlzLnN0cmVhbUNvbnRyb2xsZXI9dH0sZS5yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3RoaXMuaGxzLm9uKG4uYS5NRURJQV9BVFRBQ0hJTkcsdGhpcy5vbk1lZGlhQXR0YWNoaW5nLHRoaXMpfSxlLnVucmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt0aGlzLmhscy5vZmYobi5hLk1FRElBX0FUVEFDSElORyx0aGlzLm9uTWVkaWFBdHRhY2hpbmcpfSxlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnRpbWVyJiZjbGVhckludGVydmFsKHRoaXMudGltZXIpLHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpLHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZT0hMSx0aGlzLm1lZGlhPW51bGx9LGUub25NZWRpYUF0dGFjaGluZz1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMuaGxzLmNvbmZpZztpZihyLmNhcExldmVsT25GUFNEcm9wKXt2YXIgaT1lLm1lZGlhIGluc3RhbmNlb2Ygc2VsZi5IVE1MVmlkZW9FbGVtZW50P2UubWVkaWE6bnVsbDt0aGlzLm1lZGlhPWksaSYmXCJmdW5jdGlvblwiPT10eXBlb2YgaS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSYmKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZT0hMCksc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpLHRoaXMudGltZXI9c2VsZi5zZXRJbnRlcnZhbCh0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSxyLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kKX19LGUuY2hlY2tGUFM9ZnVuY3Rpb24odCxlLHIpe3ZhciBpPXBlcmZvcm1hbmNlLm5vdygpO2lmKGUpe2lmKHRoaXMubGFzdFRpbWUpe3ZhciBhPWktdGhpcy5sYXN0VGltZSxzPXItdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyxsPWUtdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyx1PTFlMypzL2EsZD10aGlzLmhscztpZihkLnRyaWdnZXIobi5hLkZQU19EUk9QLHtjdXJyZW50RHJvcHBlZDpzLGN1cnJlbnREZWNvZGVkOmwsdG90YWxEcm9wcGVkRnJhbWVzOnJ9KSx1PjAmJnM+ZC5jb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQqbCl7dmFyIGg9ZC5jdXJyZW50TGV2ZWw7by5iLndhcm4oXCJkcm9wIEZQUyByYXRpbyBncmVhdGVyIHRoYW4gbWF4IGFsbG93ZWQgdmFsdWUgZm9yIGN1cnJlbnRMZXZlbDogXCIraCksaD4wJiYoLTE9PT1kLmF1dG9MZXZlbENhcHBpbmd8fGQuYXV0b0xldmVsQ2FwcGluZz49aCkmJihoLT0xLGQudHJpZ2dlcihuLmEuRlBTX0RST1BfTEVWRUxfQ0FQUElORyx7bGV2ZWw6aCxkcm9wcGVkTGV2ZWw6ZC5jdXJyZW50TGV2ZWx9KSxkLmF1dG9MZXZlbENhcHBpbmc9aCx0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCkpfX10aGlzLmxhc3RUaW1lPWksdGhpcy5sYXN0RHJvcHBlZEZyYW1lcz1yLHRoaXMubGFzdERlY29kZWRGcmFtZXM9ZX19LGUuY2hlY2tGUFNJbnRlcnZhbD1mdW5jdGlvbigpe3ZhciB0PXRoaXMubWVkaWE7aWYodClpZih0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpe3ZhciBlPXQuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKTt0aGlzLmNoZWNrRlBTKHQsZS50b3RhbFZpZGVvRnJhbWVzLGUuZHJvcHBlZFZpZGVvRnJhbWVzKX1lbHNlIHRoaXMuY2hlY2tGUFModCx0LndlYmtpdERlY29kZWRGcmFtZUNvdW50LHQud2Via2l0RHJvcHBlZEZyYW1lQ291bnQpfSx0fSgpLGxlPXIoMTIpLHVlPS9eYWdlOlxccypbXFxkLl0rXFxzKiQvbSxkZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy54aHJTZXR1cD12b2lkIDAsdGhpcy5yZXF1ZXN0VGltZW91dD12b2lkIDAsdGhpcy5yZXRyeVRpbWVvdXQ9dm9pZCAwLHRoaXMucmV0cnlEZWxheT12b2lkIDAsdGhpcy5jb25maWc9bnVsbCx0aGlzLmNhbGxiYWNrcz1udWxsLHRoaXMuY29udGV4dD12b2lkIDAsdGhpcy5sb2FkZXI9bnVsbCx0aGlzLnN0YXRzPXZvaWQgMCx0aGlzLnhoclNldHVwPXQ/dC54aHJTZXR1cDpudWxsLHRoaXMuc3RhdHM9bmV3IGxlLmEsdGhpcy5yZXRyeURlbGF5PTB9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuY2FsbGJhY2tzPW51bGwsdGhpcy5hYm9ydEludGVybmFsKCksdGhpcy5sb2FkZXI9bnVsbCx0aGlzLmNvbmZpZz1udWxsfSxlLmFib3J0SW50ZXJuYWw9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxvYWRlcjtzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KSxzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCksdCYmKHQub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsdC5vbnByb2dyZXNzPW51bGwsNCE9PXQucmVhZHlTdGF0ZSYmKHRoaXMuc3RhdHMuYWJvcnRlZD0hMCx0LmFib3J0KCkpKX0sZS5hYm9ydD1mdW5jdGlvbigpe3ZhciB0O3RoaXMuYWJvcnRJbnRlcm5hbCgpLG51bGwhPT0odD10aGlzLmNhbGxiYWNrcykmJnZvaWQgMCE9PXQmJnQub25BYm9ydCYmdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLHRoaXMuY29udGV4dCx0aGlzLmxvYWRlcil9LGUubG9hZD1mdW5jdGlvbih0LGUscil7aWYodGhpcy5zdGF0cy5sb2FkaW5nLnN0YXJ0KXRocm93IG5ldyBFcnJvcihcIkxvYWRlciBjYW4gb25seSBiZSB1c2VkIG9uY2UuXCIpO3RoaXMuc3RhdHMubG9hZGluZy5zdGFydD1zZWxmLnBlcmZvcm1hbmNlLm5vdygpLHRoaXMuY29udGV4dD10LHRoaXMuY29uZmlnPWUsdGhpcy5jYWxsYmFja3M9cix0aGlzLnJldHJ5RGVsYXk9ZS5yZXRyeURlbGF5LHRoaXMubG9hZEludGVybmFsKCl9LGUubG9hZEludGVybmFsPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jb25maWcsZT10aGlzLmNvbnRleHQ7aWYodCl7dmFyIHI9dGhpcy5sb2FkZXI9bmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QsaT10aGlzLnN0YXRzO2kubG9hZGluZy5maXJzdD0wLGkubG9hZGVkPTA7dmFyIGE9dGhpcy54aHJTZXR1cDt0cnl7aWYoYSl0cnl7YShyLGUudXJsKX1jYXRjaCh0KXtyLm9wZW4oXCJHRVRcIixlLnVybCwhMCksYShyLGUudXJsKX1yLnJlYWR5U3RhdGV8fHIub3BlbihcIkdFVFwiLGUudXJsLCEwKTt2YXIgbj10aGlzLmNvbnRleHQuaGVhZGVycztpZihuKWZvcih2YXIgcyBpbiBuKXIuc2V0UmVxdWVzdEhlYWRlcihzLG5bc10pfWNhdGNoKHQpe3JldHVybiB2b2lkIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3Ioe2NvZGU6ci5zdGF0dXMsdGV4dDp0Lm1lc3NhZ2V9LGUscil9ZS5yYW5nZUVuZCYmci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIixcImJ5dGVzPVwiK2UucmFuZ2VTdGFydCtcIi1cIisoZS5yYW5nZUVuZC0xKSksci5vbnJlYWR5c3RhdGVjaGFuZ2U9dGhpcy5yZWFkeXN0YXRlY2hhbmdlLmJpbmQodGhpcyksci5vbnByb2dyZXNzPXRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyksci5yZXNwb25zZVR5cGU9ZS5yZXNwb25zZVR5cGUsc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCksdGhpcy5yZXF1ZXN0VGltZW91dD1zZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLHQudGltZW91dCksci5zZW5kKCl9fSxlLnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNvbnRleHQsZT10aGlzLmxvYWRlcixyPXRoaXMuc3RhdHM7aWYodCYmZSl7dmFyIGk9ZS5yZWFkeVN0YXRlLGE9dGhpcy5jb25maWc7aWYoIXIuYWJvcnRlZCYmaT49MilpZihzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KSwwPT09ci5sb2FkaW5nLmZpcnN0JiYoci5sb2FkaW5nLmZpcnN0PU1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksci5sb2FkaW5nLnN0YXJ0KSksND09PWkpe2Uub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsZS5vbnByb2dyZXNzPW51bGw7dmFyIG49ZS5zdGF0dXM7aWYobj49MjAwJiZuPDMwMCl7dmFyIHMsbDtpZihyLmxvYWRpbmcuZW5kPU1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksci5sb2FkaW5nLmZpcnN0KSxsPVwiYXJyYXlidWZmZXJcIj09PXQucmVzcG9uc2VUeXBlPyhzPWUucmVzcG9uc2UpLmJ5dGVMZW5ndGg6KHM9ZS5yZXNwb25zZVRleHQpLmxlbmd0aCxyLmxvYWRlZD1yLnRvdGFsPWwsIXRoaXMuY2FsbGJhY2tzKXJldHVybjt2YXIgdT10aGlzLmNhbGxiYWNrcy5vblByb2dyZXNzO2lmKHUmJnUocix0LHMsZSksIXRoaXMuY2FsbGJhY2tzKXJldHVybjt2YXIgZD17dXJsOmUucmVzcG9uc2VVUkwsZGF0YTpzfTt0aGlzLmNhbGxiYWNrcy5vblN1Y2Nlc3MoZCxyLHQsZSl9ZWxzZSByLnJldHJ5Pj1hLm1heFJldHJ5fHxuPj00MDAmJm48NDk5PyhvLmIuZXJyb3IobitcIiB3aGlsZSBsb2FkaW5nIFwiK3QudXJsKSx0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHtjb2RlOm4sdGV4dDplLnN0YXR1c1RleHR9LHQsZSkpOihvLmIud2FybihuK1wiIHdoaWxlIGxvYWRpbmcgXCIrdC51cmwrXCIsIHJldHJ5aW5nIGluIFwiK3RoaXMucmV0cnlEZWxheStcIi4uLlwiKSx0aGlzLmFib3J0SW50ZXJuYWwoKSx0aGlzLmxvYWRlcj1udWxsLHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KSx0aGlzLnJldHJ5VGltZW91dD1zZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkSW50ZXJuYWwuYmluZCh0aGlzKSx0aGlzLnJldHJ5RGVsYXkpLHRoaXMucmV0cnlEZWxheT1NYXRoLm1pbigyKnRoaXMucmV0cnlEZWxheSxhLm1heFJldHJ5RGVsYXkpLHIucmV0cnkrKyl9ZWxzZSBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KSx0aGlzLnJlcXVlc3RUaW1lb3V0PXNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksYS50aW1lb3V0KX19LGUubG9hZHRpbWVvdXQ9ZnVuY3Rpb24oKXtvLmIud2FybihcInRpbWVvdXQgd2hpbGUgbG9hZGluZyBcIit0aGlzLmNvbnRleHQudXJsKTt2YXIgdD10aGlzLmNhbGxiYWNrczt0JiYodGhpcy5hYm9ydEludGVybmFsKCksdC5vblRpbWVvdXQodGhpcy5zdGF0cyx0aGlzLmNvbnRleHQsdGhpcy5sb2FkZXIpKX0sZS5sb2FkcHJvZ3Jlc3M9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zdGF0cztlLmxvYWRlZD10LmxvYWRlZCx0Lmxlbmd0aENvbXB1dGFibGUmJihlLnRvdGFsPXQudG90YWwpfSxlLmdldENhY2hlQWdlPWZ1bmN0aW9uKCl7dmFyIHQ9bnVsbDtpZih0aGlzLmxvYWRlciYmdWUudGVzdCh0aGlzLmxvYWRlci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpe3ZhciBlPXRoaXMubG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKFwiYWdlXCIpO3Q9ZT9wYXJzZUZsb2F0KGUpOm51bGx9cmV0dXJuIHR9LHR9KCksaGU9cigxNik7ZnVuY3Rpb24gZmUodCl7dmFyIGU9XCJmdW5jdGlvblwiPT10eXBlb2YgTWFwP25ldyBNYXA6dm9pZCAwO3JldHVybihmZT1mdW5jdGlvbih0KXtpZihudWxsPT09dHx8KHI9dCwtMT09PUZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwocikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikpKXJldHVybiB0O3ZhciByO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2lmKHZvaWQgMCE9PWUpe2lmKGUuaGFzKHQpKXJldHVybiBlLmdldCh0KTtlLnNldCh0LGkpfWZ1bmN0aW9uIGkoKXtyZXR1cm4gY2UodCxhcmd1bWVudHMscGUodGhpcykuY29uc3RydWN0b3IpfXJldHVybiBpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6aSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxnZShpLHQpfSkodCl9ZnVuY3Rpb24gY2UodCxlLHIpe3JldHVybihjZT12ZSgpP1JlZmxlY3QuY29uc3RydWN0OmZ1bmN0aW9uKHQsZSxyKXt2YXIgaT1bbnVsbF07aS5wdXNoLmFwcGx5KGksZSk7dmFyIGE9bmV3KEZ1bmN0aW9uLmJpbmQuYXBwbHkodCxpKSk7cmV0dXJuIHImJmdlKGEsci5wcm90b3R5cGUpLGF9KS5hcHBseShudWxsLGFyZ3VtZW50cyl9ZnVuY3Rpb24gdmUoKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKHQpe3JldHVybiExfX1mdW5jdGlvbiBnZSh0LGUpe3JldHVybihnZT1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWUsdH0pKHQsZSl9ZnVuY3Rpb24gcGUodCl7cmV0dXJuKHBlPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9KSh0KX1mdW5jdGlvbiBtZSgpe3JldHVybihtZT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgcj1hcmd1bWVudHNbZV07Zm9yKHZhciBpIGluIHIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsaSkmJih0W2ldPXJbaV0pfXJldHVybiB0fSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciB5ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5mZXRjaFNldHVwPXZvaWQgMCx0aGlzLnJlcXVlc3RUaW1lb3V0PXZvaWQgMCx0aGlzLnJlcXVlc3Q9dm9pZCAwLHRoaXMucmVzcG9uc2U9dm9pZCAwLHRoaXMuY29udHJvbGxlcj12b2lkIDAsdGhpcy5jb250ZXh0PXZvaWQgMCx0aGlzLmNvbmZpZz1udWxsLHRoaXMuY2FsbGJhY2tzPW51bGwsdGhpcy5zdGF0cz12b2lkIDAsdGhpcy5sb2FkZXI9bnVsbCx0aGlzLmZldGNoU2V0dXA9dC5mZXRjaFNldHVwfHxiZSx0aGlzLmNvbnRyb2xsZXI9bmV3IHNlbGYuQWJvcnRDb250cm9sbGVyLHRoaXMuc3RhdHM9bmV3IGxlLmF9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMubG9hZGVyPXRoaXMuY2FsbGJhY2tzPW51bGwsdGhpcy5hYm9ydEludGVybmFsKCl9LGUuYWJvcnRJbnRlcm5hbD1mdW5jdGlvbigpe3ZhciB0PXRoaXMucmVzcG9uc2U7dCYmdC5va3x8KHRoaXMuc3RhdHMuYWJvcnRlZD0hMCx0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSl9LGUuYWJvcnQ9ZnVuY3Rpb24oKXt2YXIgdDt0aGlzLmFib3J0SW50ZXJuYWwoKSxudWxsIT09KHQ9dGhpcy5jYWxsYmFja3MpJiZ2b2lkIDAhPT10JiZ0Lm9uQWJvcnQmJnRoaXMuY2FsbGJhY2tzLm9uQWJvcnQodGhpcy5zdGF0cyx0aGlzLmNvbnRleHQsdGhpcy5yZXNwb25zZSl9LGUubG9hZD1mdW5jdGlvbih0LGUscil7dmFyIGk9dGhpcyxuPXRoaXMuc3RhdHM7aWYobi5sb2FkaW5nLnN0YXJ0KXRocm93IG5ldyBFcnJvcihcIkxvYWRlciBjYW4gb25seSBiZSB1c2VkIG9uY2UuXCIpO24ubG9hZGluZy5zdGFydD1zZWxmLnBlcmZvcm1hbmNlLm5vdygpO3ZhciBzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9e21ldGhvZDpcIkdFVFwiLG1vZGU6XCJjb3JzXCIsY3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwiLHNpZ25hbDplLGhlYWRlcnM6bmV3IHNlbGYuSGVhZGVycyhtZSh7fSx0LmhlYWRlcnMpKX07dC5yYW5nZUVuZCYmci5oZWFkZXJzLnNldChcIlJhbmdlXCIsXCJieXRlcz1cIit0LnJhbmdlU3RhcnQrXCItXCIrU3RyaW5nKHQucmFuZ2VFbmQtMSkpO3JldHVybiByfSh0LHRoaXMuY29udHJvbGxlci5zaWduYWwpLG89ci5vblByb2dyZXNzLGw9XCJhcnJheWJ1ZmZlclwiPT09dC5yZXNwb25zZVR5cGUsdT1sP1wiYnl0ZUxlbmd0aFwiOlwibGVuZ3RoXCI7dGhpcy5jb250ZXh0PXQsdGhpcy5jb25maWc9ZSx0aGlzLmNhbGxiYWNrcz1yLHRoaXMucmVxdWVzdD10aGlzLmZldGNoU2V0dXAodCxzKSxzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KSx0aGlzLnJlcXVlc3RUaW1lb3V0PXNlbGYuc2V0VGltZW91dCgoZnVuY3Rpb24oKXtpLmFib3J0SW50ZXJuYWwoKSxyLm9uVGltZW91dChuLHQsaS5yZXNwb25zZSl9KSxlLnRpbWVvdXQpLHNlbGYuZmV0Y2godGhpcy5yZXF1ZXN0KS50aGVuKChmdW5jdGlvbihyKXtpZihpLnJlc3BvbnNlPWkubG9hZGVyPXIsIXIub2spe3ZhciBzPXIuc3RhdHVzLHU9ci5zdGF0dXNUZXh0O3Rocm93IG5ldyBFZSh1fHxcImZldGNoLCBiYWQgbmV0d29yayByZXNwb25zZVwiLHMscil9cmV0dXJuIG4ubG9hZGluZy5maXJzdD1NYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLG4ubG9hZGluZy5zdGFydCksbi50b3RhbD1wYXJzZUludChyLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIil8fFwiMFwiKSxvJiZPYmplY3QoYS5hKShlLmhpZ2hXYXRlck1hcmspP2kubG9hZFByb2dyZXNzaXZlbHkocixuLHQsZS5oaWdoV2F0ZXJNYXJrLG8pOmw/ci5hcnJheUJ1ZmZlcigpOnIudGV4dCgpfSkpLnRoZW4oKGZ1bmN0aW9uKHMpe3ZhciBsPWkucmVzcG9uc2U7c2VsZi5jbGVhclRpbWVvdXQoaS5yZXF1ZXN0VGltZW91dCksbi5sb2FkaW5nLmVuZD1NYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLG4ubG9hZGluZy5maXJzdCksbi5sb2FkZWQ9bi50b3RhbD1zW3VdO3ZhciBkPXt1cmw6bC51cmwsZGF0YTpzfTtvJiYhT2JqZWN0KGEuYSkoZS5oaWdoV2F0ZXJNYXJrKSYmbyhuLHQscyxsKSxyLm9uU3VjY2VzcyhkLG4sdCxsKX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7aWYoc2VsZi5jbGVhclRpbWVvdXQoaS5yZXF1ZXN0VGltZW91dCksIW4uYWJvcnRlZCl7dmFyIGE9ZS5jb2RlfHwwO3Iub25FcnJvcih7Y29kZTphLHRleHQ6ZS5tZXNzYWdlfSx0LGUuZGV0YWlscyl9fSkpfSxlLmdldENhY2hlQWdlPWZ1bmN0aW9uKCl7dmFyIHQ9bnVsbDtpZih0aGlzLnJlc3BvbnNlKXt2YXIgZT10aGlzLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiYWdlXCIpO3Q9ZT9wYXJzZUZsb2F0KGUpOm51bGx9cmV0dXJuIHR9LGUubG9hZFByb2dyZXNzaXZlbHk9ZnVuY3Rpb24odCxlLHIsaSxhKXt2b2lkIDA9PT1pJiYoaT0wKTt2YXIgbj1uZXcgaGUuYSxzPXQuYm9keS5nZXRSZWFkZXIoKTtyZXR1cm4gZnVuY3Rpb24gbygpe3JldHVybiBzLnJlYWQoKS50aGVuKChmdW5jdGlvbihzKXtpZihzLmRvbmUpcmV0dXJuIG4uZGF0YUxlbmd0aCYmYShlLHIsbi5mbHVzaCgpLHQpLFByb21pc2UucmVzb2x2ZShuZXcgQXJyYXlCdWZmZXIoMCkpO3ZhciBsPXMudmFsdWUsdT1sLmxlbmd0aDtyZXR1cm4gZS5sb2FkZWQrPXUsdTxpfHxuLmRhdGFMZW5ndGg/KG4ucHVzaChsKSxuLmRhdGFMZW5ndGg+PWkmJmEoZSxyLG4uZmx1c2goKSx0KSk6YShlLHIsbCx0KSxvKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVqZWN0KCl9KSl9KCl9LHR9KCk7ZnVuY3Rpb24gYmUodCxlKXtyZXR1cm4gbmV3IHNlbGYuUmVxdWVzdCh0LnVybCxlKX12YXIgVGUsRWU9ZnVuY3Rpb24odCl7dmFyIGUscjtmdW5jdGlvbiBpKGUscixpKXt2YXIgYTtyZXR1cm4oYT10LmNhbGwodGhpcyxlKXx8dGhpcykuY29kZT12b2lkIDAsYS5kZXRhaWxzPXZvaWQgMCxhLmNvZGU9cixhLmRldGFpbHM9aSxhfXJldHVybiByPXQsKGU9aSkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWUsZ2UoZSxyKSxpfShmZShFcnJvcikpLFNlPXllOyFmdW5jdGlvbih0KXt0LldJREVWSU5FPVwiY29tLndpZGV2aW5lLmFscGhhXCIsdC5QTEFZUkVBRFk9XCJjb20ubWljcm9zb2Z0LnBsYXlyZWFkeVwifShUZXx8KFRlPXt9KSk7dmFyIExlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmLm5hdmlnYXRvciYmc2VsZi5uYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzP3NlbGYubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcy5iaW5kKHNlbGYubmF2aWdhdG9yKTpudWxsO2Z1bmN0aW9uIEFlKCl7cmV0dXJuKEFlPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciByPWFyZ3VtZW50c1tlXTtmb3IodmFyIGkgaW4gcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixpKSYmKHRbaV09cltpXSl9cmV0dXJuIHR9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gUmUodCxlKXt2YXIgcj1PYmplY3Qua2V5cyh0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpO2UmJihpPWkuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGUpLmVudW1lcmFibGV9KSkpLHIucHVzaC5hcHBseShyLGkpfXJldHVybiByfWZ1bmN0aW9uIERlKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciByPW51bGwhPWFyZ3VtZW50c1tlXT9hcmd1bWVudHNbZV06e307ZSUyP1JlKE9iamVjdChyKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7X2UodCxlLHJbZV0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpOlJlKE9iamVjdChyKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSkpfSkpfXJldHVybiB0fWZ1bmN0aW9uIF9lKHQsZSxyKXtyZXR1cm4gZSBpbiB0P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPXIsdH12YXIga2U9RGUoRGUoe2F1dG9TdGFydExvYWQ6ITAsc3RhcnRQb3NpdGlvbjotMSxkZWZhdWx0QXVkaW9Db2RlYzp2b2lkIDAsZGVidWc6ITEsY2FwTGV2ZWxPbkZQU0Ryb3A6ITEsY2FwTGV2ZWxUb1BsYXllclNpemU6ITEsaW5pdGlhbExpdmVNYW5pZmVzdFNpemU6MSxtYXhCdWZmZXJMZW5ndGg6MzAsYmFja0J1ZmZlckxlbmd0aDoxLzAsbWF4QnVmZmVyU2l6ZTo2ZTcsbWF4QnVmZmVySG9sZTouMSxoaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2Q6MixudWRnZU9mZnNldDouMSxudWRnZU1heFJldHJ5OjMsbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTouMjUsbGl2ZVN5bmNEdXJhdGlvbkNvdW50OjMsbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OjEvMCxsaXZlU3luY0R1cmF0aW9uOnZvaWQgMCxsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOnZvaWQgMCxtYXhMaXZlU3luY1BsYXliYWNrUmF0ZToxLGxpdmVEdXJhdGlvbkluZmluaXR5OiExLGxpdmVCYWNrQnVmZmVyTGVuZ3RoOm51bGwsbWF4TWF4QnVmZmVyTGVuZ3RoOjYwMCxlbmFibGVXb3JrZXI6ITAsZW5hYmxlU29mdHdhcmVBRVM6ITAsbWFuaWZlc3RMb2FkaW5nVGltZU91dDoxZTQsbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6MSxtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5OjFlMyxtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6NjRlMyxzdGFydExldmVsOnZvaWQgMCxsZXZlbExvYWRpbmdUaW1lT3V0OjFlNCxsZXZlbExvYWRpbmdNYXhSZXRyeTo0LGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6MWUzLGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDo2NGUzLGZyYWdMb2FkaW5nVGltZU91dDoyZTQsZnJhZ0xvYWRpbmdNYXhSZXRyeTo2LGZyYWdMb2FkaW5nUmV0cnlEZWxheToxZTMsZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6NjRlMyxzdGFydEZyYWdQcmVmZXRjaDohMSxmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZDo1ZTMsZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6LjIsYXBwZW5kRXJyb3JNYXhSZXRyeTozLGxvYWRlcjpkZSxmTG9hZGVyOnZvaWQgMCxwTG9hZGVyOnZvaWQgMCx4aHJTZXR1cDp2b2lkIDAsbGljZW5zZVhoclNldHVwOnZvaWQgMCxsaWNlbnNlUmVzcG9uc2VDYWxsYmFjazp2b2lkIDAsYWJyQ29udHJvbGxlcjpadCxidWZmZXJDb250cm9sbGVyOmFlLGNhcExldmVsQ29udHJvbGxlcjpzZSxmcHNDb250cm9sbGVyOm9lLHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6ITEsbWF4QXVkaW9GcmFtZXNEcmlmdDoxLGZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHk6ITAsYWJyRXdtYUZhc3RMaXZlOjMsYWJyRXdtYVNsb3dMaXZlOjksYWJyRXdtYUZhc3RWb0Q6MyxhYnJFd21hU2xvd1ZvRDo5LGFickV3bWFEZWZhdWx0RXN0aW1hdGU6NWU1LGFickJhbmRXaWR0aEZhY3RvcjouOTUsYWJyQmFuZFdpZHRoVXBGYWN0b3I6LjcsYWJyTWF4V2l0aFJlYWxCaXRyYXRlOiExLG1heFN0YXJ2YXRpb25EZWxheTo0LG1heExvYWRpbmdEZWxheTo0LG1pbkF1dG9CaXRyYXRlOjAsZW1lRW5hYmxlZDohMSx3aWRldmluZUxpY2Vuc2VVcmw6dm9pZCAwLGRybVN5c3RlbU9wdGlvbnM6e30scmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYzpMZSx0ZXN0QmFuZHdpZHRoOiEwLHByb2dyZXNzaXZlOiExLGxvd0xhdGVuY3lNb2RlOiEwLGNtY2Q6dm9pZCAwfSx7Y3VlSGFuZGxlcjp0ZS5hLGVuYWJsZUNFQTcwOENhcHRpb25zOiExLGVuYWJsZVdlYlZUVDohMSxlbmFibGVJTVNDMTohMSxjYXB0aW9uc1RleHRUcmFjazFMYWJlbDpcIkVuZ2xpc2hcIixjYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGU6XCJlblwiLGNhcHRpb25zVGV4dFRyYWNrMkxhYmVsOlwiU3BhbmlzaFwiLGNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZTpcImVzXCIsY2FwdGlvbnNUZXh0VHJhY2szTGFiZWw6XCJVbmtub3duIENDXCIsY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlOlwiXCIsY2FwdGlvbnNUZXh0VHJhY2s0TGFiZWw6XCJVbmtub3duIENDXCIsY2FwdGlvbnNUZXh0VHJhY2s0TGFuZ3VhZ2VDb2RlOlwiXCIscmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5OiEwfSkse30se3N1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjp2b2lkIDAsc3VidGl0bGVUcmFja0NvbnRyb2xsZXI6dm9pZCAwLHRpbWVsaW5lQ29udHJvbGxlcjp2b2lkIDAsYXVkaW9TdHJlYW1Db250cm9sbGVyOnZvaWQgMCxhdWRpb1RyYWNrQ29udHJvbGxlcjp2b2lkIDAsZW1lQ29udHJvbGxlcjp2b2lkIDAsY21jZENvbnRyb2xsZXI6dm9pZCAwfSk7ZnVuY3Rpb24geGUodCl7dmFyIGU9dC5sb2FkZXI7ZSE9PVNlJiZlIT09ZGU/KG8uYi5sb2coXCJbY29uZmlnXTogQ3VzdG9tIGxvYWRlciBkZXRlY3RlZCwgY2Fubm90IGVuYWJsZSBwcm9ncmVzc2l2ZSBzdHJlYW1pbmdcIiksdC5wcm9ncmVzc2l2ZT0hMSk6ZnVuY3Rpb24oKXtpZihzZWxmLmZldGNoJiZzZWxmLkFib3J0Q29udHJvbGxlciYmc2VsZi5SZWFkYWJsZVN0cmVhbSYmc2VsZi5SZXF1ZXN0KXRyeXtyZXR1cm4gbmV3IHNlbGYuUmVhZGFibGVTdHJlYW0oe30pLCEwfWNhdGNoKHQpe31yZXR1cm4hMX0oKSYmKHQubG9hZGVyPVNlLHQucHJvZ3Jlc3NpdmU9ITAsdC5lbmFibGVTb2Z0d2FyZUFFUz0hMCxvLmIubG9nKFwiW2NvbmZpZ106IFByb2dyZXNzaXZlIHN0cmVhbWluZyBlbmFibGVkLCB1c2luZyBGZXRjaExvYWRlclwiKSl9ZnVuY3Rpb24gQ2UodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaS5rZXksaSl9fXZhciB3ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7dm9pZCAwPT09ZSYmKGU9e30pLHRoaXMuY29uZmlnPXZvaWQgMCx0aGlzLnVzZXJDb25maWc9dm9pZCAwLHRoaXMuY29yZUNvbXBvbmVudHM9dm9pZCAwLHRoaXMubmV0d29ya0NvbnRyb2xsZXJzPXZvaWQgMCx0aGlzLl9lbWl0dGVyPW5ldyBIdC5FdmVudEVtaXR0ZXIsdGhpcy5fYXV0b0xldmVsQ2FwcGluZz12b2lkIDAsdGhpcy5hYnJDb250cm9sbGVyPXZvaWQgMCx0aGlzLmJ1ZmZlckNvbnRyb2xsZXI9dm9pZCAwLHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyPXZvaWQgMCx0aGlzLmxhdGVuY3lDb250cm9sbGVyPXZvaWQgMCx0aGlzLmxldmVsQ29udHJvbGxlcj12b2lkIDAsdGhpcy5zdHJlYW1Db250cm9sbGVyPXZvaWQgMCx0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyPXZvaWQgMCx0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyPXZvaWQgMCx0aGlzLmVtZUNvbnRyb2xsZXI9dm9pZCAwLHRoaXMuY21jZENvbnRyb2xsZXI9dm9pZCAwLHRoaXMuX21lZGlhPW51bGwsdGhpcy51cmw9bnVsbDt2YXIgcj10aGlzLmNvbmZpZz1mdW5jdGlvbih0LGUpe2lmKChlLmxpdmVTeW5jRHVyYXRpb25Db3VudHx8ZS5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQpJiYoZS5saXZlU3luY0R1cmF0aW9ufHxlLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKXRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgaGxzLmpzIGNvbmZpZzogZG9uJ3QgbWl4IHVwIGxpdmVTeW5jRHVyYXRpb25Db3VudC9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgYW5kIGxpdmVTeW5jRHVyYXRpb24vbGl2ZU1heExhdGVuY3lEdXJhdGlvblwiKTtpZih2b2lkIDAhPT1lLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCYmKHZvaWQgMD09PWUubGl2ZVN5bmNEdXJhdGlvbkNvdW50fHxlLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudDw9ZS5saXZlU3luY0R1cmF0aW9uQ291bnQpKXRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudFwiIG11c3QgYmUgZ3JlYXRlciB0aGFuIFwibGl2ZVN5bmNEdXJhdGlvbkNvdW50XCInKTtpZih2b2lkIDAhPT1lLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24mJih2b2lkIDA9PT1lLmxpdmVTeW5jRHVyYXRpb258fGUubGl2ZU1heExhdGVuY3lEdXJhdGlvbjw9ZS5saXZlU3luY0R1cmF0aW9uKSl0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uXCInKTtyZXR1cm4gQWUoe30sdCxlKX0odC5EZWZhdWx0Q29uZmlnLGUpO3RoaXMudXNlckNvbmZpZz1lLE9iamVjdChvLmEpKHIuZGVidWcpLHRoaXMuX2F1dG9MZXZlbENhcHBpbmc9LTEsci5wcm9ncmVzc2l2ZSYmeGUocik7dmFyIGk9ci5hYnJDb250cm9sbGVyLGE9ci5idWZmZXJDb250cm9sbGVyLG49ci5jYXBMZXZlbENvbnRyb2xsZXIscz1yLmZwc0NvbnRyb2xsZXIsbD10aGlzLmFickNvbnRyb2xsZXI9bmV3IGkodGhpcyksdT10aGlzLmJ1ZmZlckNvbnRyb2xsZXI9bmV3IGEodGhpcyksZD10aGlzLmNhcExldmVsQ29udHJvbGxlcj1uZXcgbih0aGlzKSxoPW5ldyBzKHRoaXMpLGY9bmV3IHgodGhpcyksYz1uZXcgQyh0aGlzKSx2PW5ldyBQKHRoaXMpLGc9dGhpcy5sZXZlbENvbnRyb2xsZXI9bmV3IEoodGhpcykscD1uZXcgdHQodGhpcyksbT10aGlzLnN0cmVhbUNvbnRyb2xsZXI9bmV3IHF0KHRoaXMscCk7ZC5zZXRTdHJlYW1Db250cm9sbGVyKG0pLGguc2V0U3RyZWFtQ29udHJvbGxlcihtKTt2YXIgeT1bZyxtXTt0aGlzLm5ldHdvcmtDb250cm9sbGVycz15O3ZhciBiPVtmLGMsbCx1LGQsaCx2LHBdO3RoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI9dGhpcy5jcmVhdGVDb250cm9sbGVyKHIuYXVkaW9UcmFja0NvbnRyb2xsZXIsbnVsbCx5KSx0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoci5hdWRpb1N0cmVhbUNvbnRyb2xsZXIscCx5KSx0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyPXRoaXMuY3JlYXRlQ29udHJvbGxlcihyLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyLG51bGwseSksdGhpcy5jcmVhdGVDb250cm9sbGVyKHIuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyLHAseSksdGhpcy5jcmVhdGVDb250cm9sbGVyKHIudGltZWxpbmVDb250cm9sbGVyLG51bGwsYiksdGhpcy5lbWVDb250cm9sbGVyPXRoaXMuY3JlYXRlQ29udHJvbGxlcihyLmVtZUNvbnRyb2xsZXIsbnVsbCxiKSx0aGlzLmNtY2RDb250cm9sbGVyPXRoaXMuY3JlYXRlQ29udHJvbGxlcihyLmNtY2RDb250cm9sbGVyLG51bGwsYiksdGhpcy5sYXRlbmN5Q29udHJvbGxlcj10aGlzLmNyZWF0ZUNvbnRyb2xsZXIoTixudWxsLGIpLHRoaXMuY29yZUNvbXBvbmVudHM9Yn10LmlzU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQ9QnQoKTtpZighdClyZXR1cm4hMTt2YXIgZT1VdCgpLHI9dCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5pc1R5cGVTdXBwb3J0ZWQmJnQuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFLG1wNGEuNDAuMlwiJyksaT0hZXx8ZS5wcm90b3R5cGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJvdG90eXBlLmFwcGVuZEJ1ZmZlciYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5wcm90b3R5cGUucmVtb3ZlO3JldHVybiEhciYmISFpfSgpfTt2YXIgZSxyLGEsbD10LnByb3RvdHlwZTtyZXR1cm4gbC5jcmVhdGVDb250cm9sbGVyPWZ1bmN0aW9uKHQsZSxyKXtpZih0KXt2YXIgaT1lP25ldyB0KHRoaXMsZSk6bmV3IHQodGhpcyk7cmV0dXJuIHImJnIucHVzaChpKSxpfXJldHVybiBudWxsfSxsLm9uPWZ1bmN0aW9uKHQsZSxyKXt2b2lkIDA9PT1yJiYocj10aGlzKSx0aGlzLl9lbWl0dGVyLm9uKHQsZSxyKX0sbC5vbmNlPWZ1bmN0aW9uKHQsZSxyKXt2b2lkIDA9PT1yJiYocj10aGlzKSx0aGlzLl9lbWl0dGVyLm9uY2UodCxlLHIpfSxsLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbih0KXt0aGlzLl9lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyh0KX0sbC5vZmY9ZnVuY3Rpb24odCxlLHIsaSl7dm9pZCAwPT09ciYmKHI9dGhpcyksdGhpcy5fZW1pdHRlci5vZmYodCxlLHIsaSl9LGwubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9lbWl0dGVyLmxpc3RlbmVycyh0KX0sbC5lbWl0PWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdGhpcy5fZW1pdHRlci5lbWl0KHQsZSxyKX0sbC50cmlnZ2VyPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5jb25maWcuZGVidWcpcmV0dXJuIHRoaXMuZW1pdCh0LHQsZSk7dHJ5e3JldHVybiB0aGlzLmVtaXQodCx0LGUpfWNhdGNoKGUpe28uYi5lcnJvcihcIkFuIGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIGhhbmRsaW5nIGV2ZW50IFwiK3QrJy4gRXJyb3IgbWVzc2FnZTogXCInK2UubWVzc2FnZSsnXCIuIEhlcmUgaXMgYSBzdGFja3RyYWNlOicsZSksdGhpcy50cmlnZ2VyKG4uYS5FUlJPUix7dHlwZTpzLmIuT1RIRVJfRVJST1IsZGV0YWlsczpzLmEuSU5URVJOQUxfRVhDRVBUSU9OLGZhdGFsOiExLGV2ZW50OnQsZXJyb3I6ZX0pfXJldHVybiExfSxsLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJDb3VudCh0KX0sbC5kZXN0cm95PWZ1bmN0aW9uKCl7by5iLmxvZyhcImRlc3Ryb3lcIiksdGhpcy50cmlnZ2VyKG4uYS5ERVNUUk9ZSU5HLHZvaWQgMCksdGhpcy5kZXRhY2hNZWRpYSgpLHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCksdGhpcy5fYXV0b0xldmVsQ2FwcGluZz0tMSx0aGlzLnVybD1udWxsLHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRlc3Ryb3koKX0pKSx0aGlzLm5ldHdvcmtDb250cm9sbGVycy5sZW5ndGg9MCx0aGlzLmNvcmVDb21wb25lbnRzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRlc3Ryb3koKX0pKSx0aGlzLmNvcmVDb21wb25lbnRzLmxlbmd0aD0wfSxsLmF0dGFjaE1lZGlhPWZ1bmN0aW9uKHQpe28uYi5sb2coXCJhdHRhY2hNZWRpYVwiKSx0aGlzLl9tZWRpYT10LHRoaXMudHJpZ2dlcihuLmEuTUVESUFfQVRUQUNISU5HLHttZWRpYTp0fSl9LGwuZGV0YWNoTWVkaWE9ZnVuY3Rpb24oKXtvLmIubG9nKFwiZGV0YWNoTWVkaWFcIiksdGhpcy50cmlnZ2VyKG4uYS5NRURJQV9ERVRBQ0hJTkcsdm9pZCAwKSx0aGlzLl9tZWRpYT1udWxsfSxsLmxvYWRTb3VyY2U9ZnVuY3Rpb24odCl7dGhpcy5zdG9wTG9hZCgpO3ZhciBlPXRoaXMubWVkaWEscj10aGlzLnVybCxhPXRoaXMudXJsPWkuYnVpbGRBYnNvbHV0ZVVSTChzZWxmLmxvY2F0aW9uLmhyZWYsdCx7YWx3YXlzTm9ybWFsaXplOiEwfSk7by5iLmxvZyhcImxvYWRTb3VyY2U6XCIrYSksZSYmciYmciE9PWEmJnRoaXMuYnVmZmVyQ29udHJvbGxlci5oYXNTb3VyY2VUeXBlcygpJiYodGhpcy5kZXRhY2hNZWRpYSgpLHRoaXMuYXR0YWNoTWVkaWEoZSkpLHRoaXMudHJpZ2dlcihuLmEuTUFOSUZFU1RfTE9BRElORyx7dXJsOnR9KX0sbC5zdGFydExvYWQ9ZnVuY3Rpb24odCl7dm9pZCAwPT09dCYmKHQ9LTEpLG8uYi5sb2coXCJzdGFydExvYWQoXCIrdCtcIilcIiksdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5zdGFydExvYWQodCl9KSl9LGwuc3RvcExvYWQ9ZnVuY3Rpb24oKXtvLmIubG9nKFwic3RvcExvYWRcIiksdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5zdG9wTG9hZCgpfSkpfSxsLnN3YXBBdWRpb0NvZGVjPWZ1bmN0aW9uKCl7by5iLmxvZyhcInN3YXBBdWRpb0NvZGVjXCIpLHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpfSxsLnJlY292ZXJNZWRpYUVycm9yPWZ1bmN0aW9uKCl7by5iLmxvZyhcInJlY292ZXJNZWRpYUVycm9yXCIpO3ZhciB0PXRoaXMuX21lZGlhO3RoaXMuZGV0YWNoTWVkaWEoKSx0JiZ0aGlzLmF0dGFjaE1lZGlhKHQpfSxsLnJlbW92ZUxldmVsPWZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCksdGhpcy5sZXZlbENvbnRyb2xsZXIucmVtb3ZlTGV2ZWwodCxlKX0sZT10LGE9W3trZXk6XCJ2ZXJzaW9uXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCIxLjEuNVwifX0se2tleTpcIkV2ZW50c1wiLGdldDpmdW5jdGlvbigpe3JldHVybiBuLmF9fSx7a2V5OlwiRXJyb3JUeXBlc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLmJ9fSx7a2V5OlwiRXJyb3JEZXRhaWxzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuYX19LHtrZXk6XCJEZWZhdWx0Q29uZmlnXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdENvbmZpZz90LmRlZmF1bHRDb25maWc6a2V9LHNldDpmdW5jdGlvbihlKXt0LmRlZmF1bHRDb25maWc9ZX19XSwocj1be2tleTpcImxldmVsc1wiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVscztyZXR1cm4gdHx8W119fSx7a2V5OlwiY3VycmVudExldmVsXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50TGV2ZWx9LHNldDpmdW5jdGlvbih0KXtvLmIubG9nKFwic2V0IGN1cnJlbnRMZXZlbDpcIit0KSx0aGlzLmxvYWRMZXZlbD10LHRoaXMuYWJyQ29udHJvbGxlci5jbGVhclRpbWVyKCksdGhpcy5zdHJlYW1Db250cm9sbGVyLmltbWVkaWF0ZUxldmVsU3dpdGNoKCl9fSx7a2V5OlwibmV4dExldmVsXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWx9LHNldDpmdW5jdGlvbih0KXtvLmIubG9nKFwic2V0IG5leHRMZXZlbDpcIit0KSx0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbD10LHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKX19LHtrZXk6XCJsb2FkTGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWx9LHNldDpmdW5jdGlvbih0KXtvLmIubG9nKFwic2V0IGxvYWRMZXZlbDpcIit0KSx0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbD10fX0se2tleTpcIm5leHRMb2FkTGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWw9dH19LHtrZXk6XCJmaXJzdExldmVsXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgubWF4KHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwsdGhpcy5taW5BdXRvTGV2ZWwpfSxzZXQ6ZnVuY3Rpb24odCl7by5iLmxvZyhcInNldCBmaXJzdExldmVsOlwiK3QpLHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWw9dH19LHtrZXk6XCJzdGFydExldmVsXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWx9LHNldDpmdW5jdGlvbih0KXtvLmIubG9nKFwic2V0IHN0YXJ0TGV2ZWw6XCIrdCksLTEhPT10JiYodD1NYXRoLm1heCh0LHRoaXMubWluQXV0b0xldmVsKSksdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbD10fX0se2tleTpcImNhcExldmVsVG9QbGF5ZXJTaXplXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplfSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9ISF0O2UhPT10aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSYmKGU/dGhpcy5jYXBMZXZlbENvbnRyb2xsZXIuc3RhcnRDYXBwaW5nKCk6KHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyLnN0b3BDYXBwaW5nKCksdGhpcy5hdXRvTGV2ZWxDYXBwaW5nPS0xLHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKSksdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemU9ZSl9fSx7a2V5OlwiYXV0b0xldmVsQ2FwcGluZ1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fYXV0b0xldmVsQ2FwcGluZyE9PXQmJihvLmIubG9nKFwic2V0IGF1dG9MZXZlbENhcHBpbmc6XCIrdCksdGhpcy5fYXV0b0xldmVsQ2FwcGluZz10KX19LHtrZXk6XCJiYW5kd2lkdGhFc3RpbWF0ZVwiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuYWJyQ29udHJvbGxlci5id0VzdGltYXRvcjtyZXR1cm4gdD90LmdldEVzdGltYXRlKCk6TmFOfX0se2tleTpcImF1dG9MZXZlbEVuYWJsZWRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4tMT09PXRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsfX0se2tleTpcIm1hbnVhbExldmVsXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsfX0se2tleTpcIm1pbkF1dG9MZXZlbFwiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMubGV2ZWxzLGU9dGhpcy5jb25maWcubWluQXV0b0JpdHJhdGU7aWYoIXQpcmV0dXJuIDA7Zm9yKHZhciByPXQubGVuZ3RoLGk9MDtpPHI7aSsrKWlmKHRbaV0ubWF4Qml0cmF0ZT5lKXJldHVybiBpO3JldHVybiAwfX0se2tleTpcIm1heEF1dG9MZXZlbFwiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMubGV2ZWxzLGU9dGhpcy5hdXRvTGV2ZWxDYXBwaW5nO3JldHVybi0xPT09ZSYmdCYmdC5sZW5ndGg/dC5sZW5ndGgtMTplfX0se2tleTpcIm5leHRBdXRvTGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodGhpcy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwsdGhpcy5taW5BdXRvTGV2ZWwpLHRoaXMubWF4QXV0b0xldmVsKX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsPU1hdGgubWF4KHRoaXMubWluQXV0b0xldmVsLHQpfX0se2tleTpcImF1ZGlvVHJhY2tzXCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtyZXR1cm4gdD90LmF1ZGlvVHJhY2tzOltdfX0se2tleTpcImF1ZGlvVHJhY2tcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO3JldHVybiB0P3QuYXVkaW9UcmFjazotMX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7ZSYmKGUuYXVkaW9UcmFjaz10KX19LHtrZXk6XCJzdWJ0aXRsZVRyYWNrc1wiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7cmV0dXJuIHQ/dC5zdWJ0aXRsZVRyYWNrczpbXX19LHtrZXk6XCJzdWJ0aXRsZVRyYWNrXCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtyZXR1cm4gdD90LnN1YnRpdGxlVHJhY2s6LTF9LHNldDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO2UmJihlLnN1YnRpdGxlVHJhY2s9dCl9fSx7a2V5OlwibWVkaWFcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWVkaWF9fSx7a2V5Olwic3VidGl0bGVEaXNwbGF5XCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtyZXR1cm4hIXQmJnQuc3VidGl0bGVEaXNwbGF5fSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtlJiYoZS5zdWJ0aXRsZURpc3BsYXk9dCl9fSx7a2V5OlwibG93TGF0ZW5jeU1vZGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGV9LHNldDpmdW5jdGlvbih0KXt0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZT10fX0se2tleTpcImxpdmVTeW5jUG9zaXRpb25cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9ufX0se2tleTpcImxhdGVuY3lcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5sYXRlbmN5fX0se2tleTpcIm1heExhdGVuY3lcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5tYXhMYXRlbmN5fX0se2tleTpcInRhcmdldExhdGVuY3lcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci50YXJnZXRMYXRlbmN5fX0se2tleTpcImRyaWZ0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIuZHJpZnR9fSx7a2V5OlwiZm9yY2VTdGFydExvYWRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmZvcmNlU3RhcnRMb2FkfX1dKSYmQ2UoZS5wcm90b3R5cGUsciksYSYmQ2UoZSxhKSx0fSgpO3dlLmRlZmF1bHRDb25maWc9dm9pZCAwfV0pLmRlZmF1bHR9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obHMubGlnaHQubWluLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/hls.js/dist/hls.light.min.js\n");

/***/ })

}]);