"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_qr-scanner_src_qr-scanner_js"],{

/***/ "./node_modules/qr-scanner/src/qr-scanner.js":
/*!***************************************************!*\
  !*** ./node_modules/qr-scanner/src/qr-scanner.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ QrScanner)\n/* harmony export */ });\nclass QrScanner {\n  /* async */\n  static hasCamera() {\n    return QrScanner.listCameras(false).then(cameras => !!cameras.length).catch(() => false);\n  }\n  /* async */\n\n\n  static listCameras(requestLabels = false) {\n    if (!navigator.mediaDevices) return Promise.resolve([]); // Note that enumerateDevices can always be called and does not prompt the user for permission.\n    // However, enumerateDevices only includes device labels if served via https and an active media stream exists\n    // or permission to access the camera was given. Therefore, ask for camera permission by opening a stream, if\n    // labels were requested.\n\n    let openedStream = null;\n    return (requestLabels ? navigator.mediaDevices.getUserMedia({\n      audio: false,\n      video: true\n    }).then(stream => openedStream = stream) // Fail gracefully, especially if the device has no camera or on mobile when the camera is already in\n    // use and some browsers disallow a second stream.\n    .catch(() => {}) : Promise.resolve()).then(() => navigator.mediaDevices.enumerateDevices()).then(devices => devices.filter(device => device.kind === 'videoinput').map((device, i) => ({\n      id: device.deviceId,\n      label: device.label || (i === 0 ? 'Default Camera' : `Camera ${i + 1}`)\n    }))).finally(() => {\n      // close the stream we just opened for getting camera access for listing the device labels\n      if (!openedStream) return;\n\n      for (const track of openedStream.getTracks()) {\n        track.stop();\n        openedStream.removeTrack(track);\n      }\n    });\n  }\n\n  constructor(video, onDecode, canvasSizeOrOnDecodeError = this._onDecodeError, canvasSizeOrCalculateScanRegion = this._calculateScanRegion, preferredCamera = 'environment') {\n    this.$video = video;\n    this.$canvas = document.createElement('canvas');\n    this._onDecode = onDecode;\n    this._legacyCanvasSize = QrScanner.DEFAULT_CANVAS_SIZE;\n    this._preferredCamera = preferredCamera;\n    this._active = false;\n    this._paused = false;\n    this._flashOn = false;\n\n    if (typeof canvasSizeOrOnDecodeError === 'number') {\n      // legacy function signature where the third argument is the canvas size\n      this._legacyCanvasSize = canvasSizeOrOnDecodeError;\n      console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in ' + 'the future');\n    } else {\n      this._onDecodeError = canvasSizeOrOnDecodeError;\n    }\n\n    if (typeof canvasSizeOrCalculateScanRegion === 'number') {\n      // legacy function signature where the fourth argument is the canvas size\n      this._legacyCanvasSize = canvasSizeOrCalculateScanRegion;\n      console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in ' + 'the future');\n    } else {\n      this._calculateScanRegion = canvasSizeOrCalculateScanRegion;\n    }\n\n    this._scanRegion = this._calculateScanRegion(video);\n    this._onPlay = this._onPlay.bind(this);\n    this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n    this._onVisibilityChange = this._onVisibilityChange.bind(this);\n    video.disablePictureInPicture = true; // Allow inline playback on iPhone instead of requiring full screen playback,\n    // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n\n    video.playsInline = true; // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n    // includes no audio, but just to be safe.\n\n    video.muted = true; // Avoid Safari stopping the video stream on a hidden video.\n    // See https://github.com/cozmo/jsQR/issues/185\n\n    let shouldHideVideo = false;\n\n    if (video.hidden) {\n      video.hidden = false;\n      shouldHideVideo = true;\n    }\n\n    if (!document.body.contains(video)) {\n      document.body.appendChild(video);\n      shouldHideVideo = true;\n    }\n\n    requestAnimationFrame(() => {\n      // Checking in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle.\n      const computedStyle = window.getComputedStyle(video);\n\n      if (computedStyle.display === 'none') {\n        video.style.setProperty('display', 'block', 'important');\n        shouldHideVideo = true;\n      }\n\n      if (computedStyle.visibility !== 'visible') {\n        video.style.setProperty('visibility', 'visible', 'important');\n        shouldHideVideo = true;\n      }\n\n      if (shouldHideVideo) {\n        // Hide the video in a way that doesn't cause Safari to stop the playback.\n        console.warn('QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.');\n        video.style.opacity = 0;\n        video.style.width = 0;\n        video.style.height = 0;\n      }\n    });\n    video.addEventListener('play', this._onPlay);\n    video.addEventListener('loadedmetadata', this._onLoadedMetaData);\n    document.addEventListener('visibilitychange', this._onVisibilityChange);\n    this._qrEnginePromise = QrScanner.createQrEngine();\n  }\n  /* async */\n\n\n  hasFlash() {\n    let openedStream = null;\n    return (this.$video.srcObject ? Promise.resolve(this.$video.srcObject.getVideoTracks()[0]) : this._getCameraStream().then(({\n      stream\n    }) => {\n      console.warn('Call hasFlash after successfully starting the scanner to avoid creating ' + 'a temporary video stream');\n      openedStream = stream;\n      return stream.getVideoTracks()[0];\n    })).then(track => 'torch' in track.getSettings()).catch(() => false).finally(() => {\n      // close the stream we just opened for detecting whether it supports flash\n      if (!openedStream) return;\n\n      for (const track of openedStream.getTracks()) {\n        track.stop();\n        openedStream.removeTrack(track);\n      }\n    });\n  }\n\n  isFlashOn() {\n    return this._flashOn;\n  }\n  /* async */\n\n\n  toggleFlash() {\n    if (this._flashOn) {\n      return this.turnFlashOff();\n    } else {\n      return this.turnFlashOn();\n    }\n  }\n  /* async */\n\n\n  turnFlashOn() {\n    if (this._flashOn) return Promise.resolve();\n    this._flashOn = true;\n    if (!this._active || this._paused) return Promise.resolve(); // flash will be turned on later on .start()\n\n    return this.hasFlash().then(hasFlash => {\n      if (!hasFlash) return Promise.reject('No flash available'); // Note that the video track is guaranteed to exist at this point\n\n      return this.$video.srcObject.getVideoTracks()[0].applyConstraints({\n        advanced: [{\n          torch: true\n        }]\n      });\n    }).catch(() => {\n      this._flashOn = false;\n      throw e;\n    });\n  }\n  /* async */\n\n\n  turnFlashOff() {\n    if (!this._flashOn) return; // applyConstraints with torch: false does not work to turn the flashlight off, as a stream's torch stays\n    // continuously on, see https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#torch. Therefore,\n    // we have to stop the stream to turn the flashlight off.\n\n    this._flashOn = false;\n    return this._restartVideoStream();\n  }\n\n  destroy() {\n    this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData);\n    this.$video.removeEventListener('play', this._onPlay);\n    document.removeEventListener('visibilitychange', this._onVisibilityChange);\n    this.stop();\n\n    QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');\n  }\n  /* async */\n\n\n  start() {\n    if (this._active && !this._paused) {\n      return Promise.resolve();\n    }\n\n    if (window.location.protocol !== 'https:') {\n      // warn but try starting the camera anyways\n      console.warn('The camera stream is only accessible if the page is transferred via https.');\n    }\n\n    this._active = true;\n\n    if (document.hidden) {\n      // camera will be started as soon as tab is in foreground\n      return Promise.resolve();\n    }\n\n    this._paused = false;\n\n    if (this.$video.srcObject) {\n      // camera stream already/still set\n      this.$video.play();\n      return Promise.resolve();\n    }\n\n    return this._getCameraStream().then(({\n      stream,\n      facingMode\n    }) => {\n      this.$video.srcObject = stream;\n      this.$video.play();\n\n      this._setVideoMirror(facingMode); // Restart the flash if it was previously on\n\n\n      if (this._flashOn) {\n        this._flashOn = false; // force turnFlashOn to restart the flash\n\n        this.turnFlashOn().catch(() => {});\n      }\n    }).catch(e => {\n      this._active = false;\n      throw e;\n    });\n  }\n\n  stop() {\n    this.pause();\n    this._active = false;\n  }\n  /* async */\n\n\n  pause(stopStreamImmediately = false) {\n    this._paused = true;\n\n    if (!this._active) {\n      return Promise.resolve(true);\n    }\n\n    this.$video.pause();\n\n    const stopStream = () => {\n      const tracks = this.$video.srcObject ? this.$video.srcObject.getTracks() : [];\n\n      for (const track of tracks) {\n        track.stop(); //  note that this will also automatically turn the flashlight off\n\n        this.$video.srcObject.removeTrack(track);\n      }\n\n      this.$video.srcObject = null;\n    };\n\n    if (stopStreamImmediately) {\n      stopStream();\n      return Promise.resolve(true);\n    }\n\n    return new Promise(resolve => setTimeout(resolve, 300)).then(() => {\n      if (!this._paused) return false;\n      stopStream();\n      return true;\n    });\n  }\n  /* async */\n\n\n  setCamera(facingModeOrDeviceId) {\n    if (facingModeOrDeviceId === this._preferredCamera) return Promise.resolve();\n    this._preferredCamera = facingModeOrDeviceId; // Restart the scanner with the new camera which will also update the video mirror and the scan region.\n\n    return this._restartVideoStream();\n  }\n  /* async */\n\n\n  static scanImage(imageOrFileOrUrl, scanRegion = null, qrEngine = null, canvas = null, disallowCanvasResizing = false, alsoTryWithoutScanRegion = false) {\n    const gotExternalWorker = qrEngine instanceof Worker;\n    let promise = Promise.all([qrEngine || QrScanner.createQrEngine(), QrScanner._loadImage(imageOrFileOrUrl)]).then(([engine, image]) => {\n      qrEngine = engine;\n      let canvasContext;\n      [canvas, canvasContext] = this._drawToCanvas(image, scanRegion, canvas, disallowCanvasResizing);\n\n      if (qrEngine instanceof Worker) {\n        if (!gotExternalWorker) {\n          // Enable scanning of inverted color qr codes. Not using _postWorkerMessage as it's async\n          qrEngine.postMessage({\n            type: 'inversionMode',\n            data: 'both'\n          });\n        }\n\n        return new Promise((resolve, reject) => {\n          let timeout, onMessage, onError;\n\n          onMessage = event => {\n            if (event.data.type !== 'qrResult') {\n              return;\n            }\n\n            qrEngine.removeEventListener('message', onMessage);\n            qrEngine.removeEventListener('error', onError);\n            clearTimeout(timeout);\n\n            if (event.data.data !== null) {\n              resolve(event.data.data);\n            } else {\n              reject(QrScanner.NO_QR_CODE_FOUND);\n            }\n          };\n\n          onError = e => {\n            qrEngine.removeEventListener('message', onMessage);\n            qrEngine.removeEventListener('error', onError);\n            clearTimeout(timeout);\n            const errorMessage = !e ? 'Unknown Error' : e.message || e;\n            reject('Scanner error: ' + errorMessage);\n          };\n\n          qrEngine.addEventListener('message', onMessage);\n          qrEngine.addEventListener('error', onError);\n          timeout = setTimeout(() => onError('timeout'), 10000);\n          const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);\n          qrEngine.postMessage({\n            type: 'decode',\n            data: imageData\n          }, [imageData.data.buffer]);\n        });\n      } else {\n        return new Promise((resolve, reject) => {\n          const timeout = setTimeout(() => reject('Scanner error: timeout'), 10000);\n          qrEngine.detect(canvas).then(scanResults => {\n            if (!scanResults.length) {\n              reject(QrScanner.NO_QR_CODE_FOUND);\n            } else {\n              resolve(scanResults[0].rawValue);\n            }\n          }).catch(e => reject('Scanner error: ' + (e.message || e))).finally(() => clearTimeout(timeout));\n        });\n      }\n    });\n\n    if (scanRegion && alsoTryWithoutScanRegion) {\n      promise = promise.catch(() => QrScanner.scanImage(imageOrFileOrUrl, null, qrEngine, canvas, disallowCanvasResizing));\n    }\n\n    promise = promise.finally(() => {\n      if (gotExternalWorker) return;\n\n      QrScanner._postWorkerMessage(qrEngine, 'close');\n    });\n    return promise;\n  }\n\n  setGrayscaleWeights(red, green, blue, useIntegerApproximation = true) {\n    // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations work also\n    // well with colored qr codes.\n    QrScanner._postWorkerMessage(this._qrEnginePromise, 'grayscaleWeights', {\n      red,\n      green,\n      blue,\n      useIntegerApproximation\n    });\n  }\n\n  setInversionMode(inversionMode) {\n    // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations scan normal\n    // and inverted qr codes by default\n    QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);\n  }\n  /* async */\n\n\n  static createQrEngine(workerPath = QrScanner.WORKER_PATH) {\n    return ('BarcodeDetector' in window && BarcodeDetector.getSupportedFormats ? BarcodeDetector.getSupportedFormats() : Promise.resolve([])).then(supportedFormats => supportedFormats.indexOf('qr_code') !== -1 ? new BarcodeDetector({\n      formats: ['qr_code']\n    }) : new Worker(workerPath));\n  }\n\n  _onPlay() {\n    this._scanRegion = this._calculateScanRegion(this.$video);\n\n    this._scanFrame();\n  }\n\n  _onLoadedMetaData() {\n    this._scanRegion = this._calculateScanRegion(this.$video);\n  }\n\n  _onVisibilityChange() {\n    if (document.hidden) {\n      this.pause();\n    } else if (this._active) {\n      this.start();\n    }\n  }\n\n  _calculateScanRegion(video) {\n    // Default scan region calculation. Note that this can be overwritten in the constructor.\n    const smallestDimension = Math.min(video.videoWidth, video.videoHeight);\n    const scanRegionSize = Math.round(2 / 3 * smallestDimension);\n    return {\n      x: Math.round((video.videoWidth - scanRegionSize) / 2),\n      y: Math.round((video.videoHeight - scanRegionSize) / 2),\n      width: scanRegionSize,\n      height: scanRegionSize,\n      downScaledWidth: this._legacyCanvasSize,\n      downScaledHeight: this._legacyCanvasSize\n    };\n  }\n\n  _scanFrame() {\n    if (!this._active || this.$video.paused || this.$video.ended) return false; // using requestAnimationFrame to avoid scanning if tab is in background\n\n    requestAnimationFrame(() => {\n      if (this.$video.readyState <= 1) {\n        // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n        // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n        // This also avoids false positives for videos paused after a successful scan which remains visible on\n        // the canvas until the video is started again and ready.\n        this._scanFrame();\n\n        return;\n      }\n\n      this._qrEnginePromise.then(qrEngine => QrScanner.scanImage(this.$video, this._scanRegion, qrEngine, this.$canvas)).then(this._onDecode, error => {\n        if (!this._active) return;\n        const errorMessage = error.message || error;\n\n        if (errorMessage.indexOf('service unavailable') !== -1) {\n          // When the native BarcodeDetector crashed, create a new one\n          this._qrEnginePromise = QrScanner.createQrEngine();\n        }\n\n        this._onDecodeError(error);\n      }).then(() => this._scanFrame());\n    });\n  }\n\n  _onDecodeError(error) {\n    // default error handler; can be overwritten in the constructor\n    if (error === QrScanner.NO_QR_CODE_FOUND) return;\n    console.log(error);\n  }\n  /* async */\n\n\n  _getCameraStream() {\n    if (!navigator.mediaDevices) {\n      return Promise.reject('Camera not found.');\n    }\n\n    const preferenceType = this._preferredCamera === 'environment' || this._preferredCamera === 'user' ? 'facingMode' : 'deviceId';\n    const constraintsWithoutCamera = [{\n      width: {\n        min: 1024\n      }\n    }, {\n      width: {\n        min: 768\n      }\n    }, {}];\n    const constraintsWithCamera = constraintsWithoutCamera.map(constraint => Object.assign({}, constraint, {\n      [preferenceType]: {\n        exact: this._preferredCamera\n      }\n    })); // First try constraints with camera, then without camera. Using reduceRight as the Promise is build in a\n    // bottom up fashion.\n\n    return [...constraintsWithCamera, ...constraintsWithoutCamera].reduceRight((fallback, constraint) => () => navigator.mediaDevices.getUserMedia({\n      video: constraint,\n      audio: false\n    }).then(stream => ({\n      stream,\n      // Try to determine the facing mode from the stream, otherwise use a guess or 'environment' as\n      // default. Note that the guess is not always accurate as Safari returns cameras of different facing\n      // mode, even for exact facingMode constraints.\n      facingMode: this._getFacingMode(stream) || (constraint.facingMode ? this._preferredCamera // _preferredCamera is a facing mode and we are able to fulfill it\n      : this._preferredCamera === 'environment' ? 'user' // switch as _preferredCamera was environment but we are not able to fulfill it\n      : 'environment' // switch from unfulfilled user facingMode or default to environment\n      )\n    })).catch(fallback), () => Promise.reject('Camera not found.'))();\n  }\n  /* async */\n\n\n  _restartVideoStream() {\n    // Note that we always pause the stream and not only if !this._paused as even if this._paused === true, the\n    // stream might still be running, as it's by default only stopped after a delay of 300ms.\n    const wasPaused = this._paused;\n    return this.pause(true).then(paused => {\n      if (!paused || wasPaused || !this._active) return;\n      return this.start();\n    });\n  }\n\n  _setVideoMirror(facingMode) {\n    // in user facing mode mirror the video to make it easier for the user to position the QR code\n    const scaleFactor = facingMode === 'user' ? -1 : 1;\n    this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n  }\n\n  _getFacingMode(videoStream) {\n    const videoTrack = videoStream.getVideoTracks()[0];\n    if (!videoTrack) return null; // unknown\n    // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n\n    return /rear|back|environment/i.test(videoTrack.label) ? 'environment' : /front|user|face/i.test(videoTrack.label) ? 'user' : null; // unknown\n  }\n\n  static _drawToCanvas(image, scanRegion = null, canvas = null, disallowCanvasResizing = false) {\n    canvas = canvas || document.createElement('canvas');\n    const scanRegionX = scanRegion && scanRegion.x ? scanRegion.x : 0;\n    const scanRegionY = scanRegion && scanRegion.y ? scanRegion.y : 0;\n    const scanRegionWidth = scanRegion && scanRegion.width ? scanRegion.width : image.width || image.videoWidth;\n    const scanRegionHeight = scanRegion && scanRegion.height ? scanRegion.height : image.height || image.videoHeight;\n\n    if (!disallowCanvasResizing) {\n      const canvasWidth = scanRegion && scanRegion.downScaledWidth ? scanRegion.downScaledWidth : scanRegionWidth;\n      const canvasHeight = scanRegion && scanRegion.downScaledHeight ? scanRegion.downScaledHeight : scanRegionHeight; // Setting the canvas width or height clears the canvas, even if the values didn't change, therefore only\n      // set them if they actually changed.\n\n      if (canvas.width !== canvasWidth) {\n        canvas.width = canvasWidth;\n      }\n\n      if (canvas.height !== canvasHeight) {\n        canvas.height = canvasHeight;\n      }\n    }\n\n    const context = canvas.getContext('2d', {\n      alpha: false\n    });\n    context.imageSmoothingEnabled = false; // gives less blurry images\n\n    context.drawImage(image, scanRegionX, scanRegionY, scanRegionWidth, scanRegionHeight, 0, 0, canvas.width, canvas.height);\n    return [canvas, context];\n  }\n  /* async */\n\n\n  static _loadImage(imageOrFileOrBlobOrUrl) {\n    if (imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement || imageOrFileOrBlobOrUrl instanceof HTMLVideoElement || window.ImageBitmap && imageOrFileOrBlobOrUrl instanceof window.ImageBitmap || window.OffscreenCanvas && imageOrFileOrBlobOrUrl instanceof window.OffscreenCanvas) {\n      return Promise.resolve(imageOrFileOrBlobOrUrl);\n    } else if (imageOrFileOrBlobOrUrl instanceof Image) {\n      return QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl).then(() => imageOrFileOrBlobOrUrl);\n    } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob || imageOrFileOrBlobOrUrl instanceof URL || typeof imageOrFileOrBlobOrUrl === 'string') {\n      const image = new Image();\n\n      if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n        image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n      } else {\n        image.src = imageOrFileOrBlobOrUrl;\n      }\n\n      return QrScanner._awaitImageLoad(image).then(() => {\n        if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n          URL.revokeObjectURL(image.src);\n        }\n\n        return image;\n      });\n    } else {\n      return Promise.reject('Unsupported image type.');\n    }\n  }\n  /* async */\n\n\n  static _awaitImageLoad(image) {\n    return new Promise((resolve, reject) => {\n      if (image.complete && image.naturalWidth !== 0) {\n        // already loaded\n        resolve();\n      } else {\n        let onLoad, onError;\n\n        onLoad = () => {\n          image.removeEventListener('load', onLoad);\n          image.removeEventListener('error', onError);\n          resolve();\n        };\n\n        onError = () => {\n          image.removeEventListener('load', onLoad);\n          image.removeEventListener('error', onError);\n          reject('Image load error');\n        };\n\n        image.addEventListener('load', onLoad);\n        image.addEventListener('error', onError);\n      }\n    });\n  }\n  /* async */\n\n\n  static _postWorkerMessage(qrEngineOrQrEnginePromise, type, data) {\n    return Promise.resolve(qrEngineOrQrEnginePromise).then(qrEngine => {\n      if (!(qrEngine instanceof Worker)) return;\n      qrEngine.postMessage({\n        type,\n        data\n      });\n    });\n  }\n\n}\nQrScanner.DEFAULT_CANVAS_SIZE = 400;\nQrScanner.NO_QR_CODE_FOUND = 'No QR code found';\nQrScanner.WORKER_PATH = 'qr-scanner-worker.min.js';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcXItc2Nhbm5lci9zcmMvcXItc2Nhbm5lci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBOzs7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUhBO0FBU0E7QUFDQTtBQUZBO0FBS0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFDQTtBQUVBOztBQUNBO0FBR0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7OztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFFQTtBQUVBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUtBO0FBQUE7QUFHQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUFBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFLQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSEE7QUFMQTtBQWlCQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFLQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFqbUJBO0FBbW1CQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9xci1zY2FubmVyL3NyYy9xci1zY2FubmVyLmpzPzc5NTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXJTY2FubmVyIHtcbiAgICAvKiBhc3luYyAqL1xuICAgIHN0YXRpYyBoYXNDYW1lcmEoKSB7XG4gICAgICAgIHJldHVybiBRclNjYW5uZXIubGlzdENhbWVyYXMoZmFsc2UpXG4gICAgICAgICAgICAudGhlbihjYW1lcmFzID0+ICEhY2FtZXJhcy5sZW5ndGgpXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4gZmFsc2UpO1xuICAgIH1cblxuICAgIC8qIGFzeW5jICovXG4gICAgc3RhdGljIGxpc3RDYW1lcmFzKHJlcXVlc3RMYWJlbHMgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMpIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBlbnVtZXJhdGVEZXZpY2VzIGNhbiBhbHdheXMgYmUgY2FsbGVkIGFuZCBkb2VzIG5vdCBwcm9tcHQgdGhlIHVzZXIgZm9yIHBlcm1pc3Npb24uXG4gICAgICAgIC8vIEhvd2V2ZXIsIGVudW1lcmF0ZURldmljZXMgb25seSBpbmNsdWRlcyBkZXZpY2UgbGFiZWxzIGlmIHNlcnZlZCB2aWEgaHR0cHMgYW5kIGFuIGFjdGl2ZSBtZWRpYSBzdHJlYW0gZXhpc3RzXG4gICAgICAgIC8vIG9yIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoZSBjYW1lcmEgd2FzIGdpdmVuLiBUaGVyZWZvcmUsIGFzayBmb3IgY2FtZXJhIHBlcm1pc3Npb24gYnkgb3BlbmluZyBhIHN0cmVhbSwgaWZcbiAgICAgICAgLy8gbGFiZWxzIHdlcmUgcmVxdWVzdGVkLlxuICAgICAgICBsZXQgb3BlbmVkU3RyZWFtID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIChyZXF1ZXN0TGFiZWxzXG4gICAgICAgICAgICA/IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgYXVkaW86IGZhbHNlLCB2aWRlbzogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgIC50aGVuKHN0cmVhbSA9PiBvcGVuZWRTdHJlYW0gPSBzdHJlYW0pXG4gICAgICAgICAgICAgICAgLy8gRmFpbCBncmFjZWZ1bGx5LCBlc3BlY2lhbGx5IGlmIHRoZSBkZXZpY2UgaGFzIG5vIGNhbWVyYSBvciBvbiBtb2JpbGUgd2hlbiB0aGUgY2FtZXJhIGlzIGFscmVhZHkgaW5cbiAgICAgICAgICAgICAgICAvLyB1c2UgYW5kIHNvbWUgYnJvd3NlcnMgZGlzYWxsb3cgYSBzZWNvbmQgc3RyZWFtLlxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7fSlcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkpXG4gICAgICAgICAgICAudGhlbihkZXZpY2VzID0+IGRldmljZXMuZmlsdGVyKGRldmljZSA9PiBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKS5tYXAoKGRldmljZSwgaSkgPT4gKHtcbiAgICAgICAgICAgICAgICBpZDogZGV2aWNlLmRldmljZUlkLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBkZXZpY2UubGFiZWwgfHwgKGkgPT09IDAgPyAnRGVmYXVsdCBDYW1lcmEnIDogYENhbWVyYSAke2kgKyAxfWApLFxuICAgICAgICAgICAgfSkpKVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlIHRoZSBzdHJlYW0gd2UganVzdCBvcGVuZWQgZm9yIGdldHRpbmcgY2FtZXJhIGFjY2VzcyBmb3IgbGlzdGluZyB0aGUgZGV2aWNlIGxhYmVsc1xuICAgICAgICAgICAgICAgIGlmICghb3BlbmVkU3RyZWFtKSByZXR1cm47XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiBvcGVuZWRTdHJlYW0uZ2V0VHJhY2tzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICBvcGVuZWRTdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICB2aWRlbyxcbiAgICAgICAgb25EZWNvZGUsXG4gICAgICAgIGNhbnZhc1NpemVPck9uRGVjb2RlRXJyb3IgPSB0aGlzLl9vbkRlY29kZUVycm9yLFxuICAgICAgICBjYW52YXNTaXplT3JDYWxjdWxhdGVTY2FuUmVnaW9uID0gdGhpcy5fY2FsY3VsYXRlU2NhblJlZ2lvbixcbiAgICAgICAgcHJlZmVycmVkQ2FtZXJhID0gJ2Vudmlyb25tZW50J1xuICAgICkge1xuICAgICAgICB0aGlzLiR2aWRlbyA9IHZpZGVvO1xuICAgICAgICB0aGlzLiRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5fb25EZWNvZGUgPSBvbkRlY29kZTtcbiAgICAgICAgdGhpcy5fbGVnYWN5Q2FudmFzU2l6ZSA9IFFyU2Nhbm5lci5ERUZBVUxUX0NBTlZBU19TSVpFO1xuICAgICAgICB0aGlzLl9wcmVmZXJyZWRDYW1lcmEgPSBwcmVmZXJyZWRDYW1lcmE7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmxhc2hPbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2FudmFzU2l6ZU9yT25EZWNvZGVFcnJvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGxlZ2FjeSBmdW5jdGlvbiBzaWduYXR1cmUgd2hlcmUgdGhlIHRoaXJkIGFyZ3VtZW50IGlzIHRoZSBjYW52YXMgc2l6ZVxuICAgICAgICAgICAgdGhpcy5fbGVnYWN5Q2FudmFzU2l6ZSA9IGNhbnZhc1NpemVPck9uRGVjb2RlRXJyb3I7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1lvdVxcJ3JlIHVzaW5nIGEgZGVwcmVjYXRlZCB2ZXJzaW9uIG9mIHRoZSBRclNjYW5uZXIgY29uc3RydWN0b3Igd2hpY2ggd2lsbCBiZSByZW1vdmVkIGluICdcbiAgICAgICAgICAgICAgICArICd0aGUgZnV0dXJlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRlY29kZUVycm9yID0gY2FudmFzU2l6ZU9yT25EZWNvZGVFcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2FudmFzU2l6ZU9yQ2FsY3VsYXRlU2NhblJlZ2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGxlZ2FjeSBmdW5jdGlvbiBzaWduYXR1cmUgd2hlcmUgdGhlIGZvdXJ0aCBhcmd1bWVudCBpcyB0aGUgY2FudmFzIHNpemVcbiAgICAgICAgICAgIHRoaXMuX2xlZ2FjeUNhbnZhc1NpemUgPSBjYW52YXNTaXplT3JDYWxjdWxhdGVTY2FuUmVnaW9uO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdZb3VcXCdyZSB1c2luZyBhIGRlcHJlY2F0ZWQgdmVyc2lvbiBvZiB0aGUgUXJTY2FubmVyIGNvbnN0cnVjdG9yIHdoaWNoIHdpbGwgYmUgcmVtb3ZlZCBpbiAnXG4gICAgICAgICAgICAgICAgKyAndGhlIGZ1dHVyZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlU2NhblJlZ2lvbiA9IGNhbnZhc1NpemVPckNhbGN1bGF0ZVNjYW5SZWdpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zY2FuUmVnaW9uID0gdGhpcy5fY2FsY3VsYXRlU2NhblJlZ2lvbih2aWRlbyk7XG5cbiAgICAgICAgdGhpcy5fb25QbGF5ID0gdGhpcy5fb25QbGF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uTG9hZGVkTWV0YURhdGEgPSB0aGlzLl9vbkxvYWRlZE1ldGFEYXRhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZSA9IHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHZpZGVvLmRpc2FibGVQaWN0dXJlSW5QaWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgLy8gQWxsb3cgaW5saW5lIHBsYXliYWNrIG9uIGlQaG9uZSBpbnN0ZWFkIG9mIHJlcXVpcmluZyBmdWxsIHNjcmVlbiBwbGF5YmFjayxcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vd2Via2l0Lm9yZy9ibG9nLzY3ODQvbmV3LXZpZGVvLXBvbGljaWVzLWZvci1pb3MvXG4gICAgICAgIHZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgLy8gQWxsb3cgcGxheSgpIG9uIGlQaG9uZSB3aXRob3V0IHJlcXVpcmluZyBhIHVzZXIgZ2VzdHVyZS4gU2hvdWxkIG5vdCByZWFsbHkgYmUgbmVlZGVkIGFzIGNhbWVyYSBzdHJlYW1cbiAgICAgICAgLy8gaW5jbHVkZXMgbm8gYXVkaW8sIGJ1dCBqdXN0IHRvIGJlIHNhZmUuXG4gICAgICAgIHZpZGVvLm11dGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBBdm9pZCBTYWZhcmkgc3RvcHBpbmcgdGhlIHZpZGVvIHN0cmVhbSBvbiBhIGhpZGRlbiB2aWRlby5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jb3ptby9qc1FSL2lzc3Vlcy8xODVcbiAgICAgICAgbGV0IHNob3VsZEhpZGVWaWRlbyA9IGZhbHNlO1xuICAgICAgICBpZiAodmlkZW8uaGlkZGVuKSB7XG4gICAgICAgICAgICB2aWRlby5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHNob3VsZEhpZGVWaWRlbyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHZpZGVvKSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh2aWRlbyk7XG4gICAgICAgICAgICBzaG91bGRIaWRlVmlkZW8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBDaGVja2luZyBpbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2hpY2ggc2hvdWxkIGF2b2lkIGEgcG90ZW50aWFsIGFkZGl0aW9uYWwgcmUtZmxvdyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZS5cbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh2aWRlbyk7XG4gICAgICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICB2aWRlby5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdibG9jaycsICdpbXBvcnRhbnQnKTtcbiAgICAgICAgICAgICAgICBzaG91bGRIaWRlVmlkZW8gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGUudmlzaWJpbGl0eSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAgICAgdmlkZW8uc3R5bGUuc2V0UHJvcGVydHkoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScsICdpbXBvcnRhbnQnKTtcbiAgICAgICAgICAgICAgICBzaG91bGRIaWRlVmlkZW8gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZEhpZGVWaWRlbykge1xuICAgICAgICAgICAgICAgIC8vIEhpZGUgdGhlIHZpZGVvIGluIGEgd2F5IHRoYXQgZG9lc24ndCBjYXVzZSBTYWZhcmkgdG8gc3RvcCB0aGUgcGxheWJhY2suXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdRclNjYW5uZXIgaGFzIG92ZXJ3cml0dGVuIHRoZSB2aWRlbyBoaWRpbmcgc3R5bGUgdG8gYXZvaWQgU2FmYXJpIHN0b3BwaW5nIHRoZSBwbGF5YmFjay4nKTtcbiAgICAgICAgICAgICAgICB2aWRlby5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgICAgICB2aWRlby5zdHlsZS53aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgdmlkZW8uc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigncGxheScsIHRoaXMuX29uUGxheSk7XG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy5fb25Mb2FkZWRNZXRhRGF0YSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2UpO1xuXG4gICAgICAgIHRoaXMuX3FyRW5naW5lUHJvbWlzZSA9IFFyU2Nhbm5lci5jcmVhdGVRckVuZ2luZSgpO1xuICAgIH1cblxuICAgIC8qIGFzeW5jICovXG4gICAgaGFzRmxhc2goKSB7XG4gICAgICAgIGxldCBvcGVuZWRTdHJlYW0gPSBudWxsO1xuICAgICAgICByZXR1cm4gKHRoaXMuJHZpZGVvLnNyY09iamVjdFxuICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUodGhpcy4kdmlkZW8uc3JjT2JqZWN0LmdldFZpZGVvVHJhY2tzKClbMF0pXG4gICAgICAgICAgICA6IHRoaXMuX2dldENhbWVyYVN0cmVhbSgpLnRoZW4oKHsgc3RyZWFtIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NhbGwgaGFzRmxhc2ggYWZ0ZXIgc3VjY2Vzc2Z1bGx5IHN0YXJ0aW5nIHRoZSBzY2FubmVyIHRvIGF2b2lkIGNyZWF0aW5nICdcbiAgICAgICAgICAgICAgICAgICAgKyAnYSB0ZW1wb3JhcnkgdmlkZW8gc3RyZWFtJyk7XG4gICAgICAgICAgICAgICAgb3BlbmVkU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICAgICAgIC50aGVuKCh0cmFjaykgPT4gJ3RvcmNoJyBpbiB0cmFjay5nZXRTZXR0aW5ncygpKVxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IGZhbHNlKVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlIHRoZSBzdHJlYW0gd2UganVzdCBvcGVuZWQgZm9yIGRldGVjdGluZyB3aGV0aGVyIGl0IHN1cHBvcnRzIGZsYXNoXG4gICAgICAgICAgICAgICAgaWYgKCFvcGVuZWRTdHJlYW0pIHJldHVybjtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIG9wZW5lZFN0cmVhbS5nZXRUcmFja3MoKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lZFN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaXNGbGFzaE9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZsYXNoT247XG4gICAgfVxuXG4gICAgLyogYXN5bmMgKi9cbiAgICB0b2dnbGVGbGFzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZsYXNoT24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR1cm5GbGFzaE9mZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHVybkZsYXNoT24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIGFzeW5jICovXG4gICAgdHVybkZsYXNoT24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9mbGFzaE9uKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuX2ZsYXNoT24gPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZSB8fCB0aGlzLl9wYXVzZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsgLy8gZmxhc2ggd2lsbCBiZSB0dXJuZWQgb24gbGF0ZXIgb24gLnN0YXJ0KClcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzRmxhc2goKS50aGVuKChoYXNGbGFzaCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYXNGbGFzaCkgcmV0dXJuIFByb21pc2UucmVqZWN0KCdObyBmbGFzaCBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgdmlkZW8gdHJhY2sgaXMgZ3VhcmFudGVlZCB0byBleGlzdCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kdmlkZW8uc3JjT2JqZWN0LmdldFZpZGVvVHJhY2tzKClbMF0uYXBwbHlDb25zdHJhaW50cyh7XG4gICAgICAgICAgICAgICAgYWR2YW5jZWQ6IFt7IHRvcmNoOiB0cnVlIH1dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2ZsYXNoT24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIGFzeW5jICovXG4gICAgdHVybkZsYXNoT2ZmKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZsYXNoT24pIHJldHVybjtcbiAgICAgICAgLy8gYXBwbHlDb25zdHJhaW50cyB3aXRoIHRvcmNoOiBmYWxzZSBkb2VzIG5vdCB3b3JrIHRvIHR1cm4gdGhlIGZsYXNobGlnaHQgb2ZmLCBhcyBhIHN0cmVhbSdzIHRvcmNoIHN0YXlzXG4gICAgICAgIC8vIGNvbnRpbnVvdXNseSBvbiwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVRyYWNrQ29uc3RyYWludHMjdG9yY2guIFRoZXJlZm9yZSxcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBzdG9wIHRoZSBzdHJlYW0gdG8gdHVybiB0aGUgZmxhc2hsaWdodCBvZmYuXG4gICAgICAgIHRoaXMuX2ZsYXNoT24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3RhcnRWaWRlb1N0cmVhbSgpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJHZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy5fb25Mb2FkZWRNZXRhRGF0YSk7XG4gICAgICAgIHRoaXMuJHZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXknLCB0aGlzLl9vblBsYXkpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlKTtcblxuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgUXJTY2FubmVyLl9wb3N0V29ya2VyTWVzc2FnZSh0aGlzLl9xckVuZ2luZVByb21pc2UsICdjbG9zZScpO1xuICAgIH1cblxuICAgIC8qIGFzeW5jICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgIXRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgICAgICAgICAvLyB3YXJuIGJ1dCB0cnkgc3RhcnRpbmcgdGhlIGNhbWVyYSBhbnl3YXlzXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBjYW1lcmEgc3RyZWFtIGlzIG9ubHkgYWNjZXNzaWJsZSBpZiB0aGUgcGFnZSBpcyB0cmFuc2ZlcnJlZCB2aWEgaHR0cHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgLy8gY2FtZXJhIHdpbGwgYmUgc3RhcnRlZCBhcyBzb29uIGFzIHRhYiBpcyBpbiBmb3JlZ3JvdW5kXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLiR2aWRlby5zcmNPYmplY3QpIHtcbiAgICAgICAgICAgIC8vIGNhbWVyYSBzdHJlYW0gYWxyZWFkeS9zdGlsbCBzZXRcbiAgICAgICAgICAgIHRoaXMuJHZpZGVvLnBsYXkoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDYW1lcmFTdHJlYW0oKVxuICAgICAgICAgICAgLnRoZW4oKHsgc3RyZWFtLCBmYWNpbmdNb2RlIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiR2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgICAgICAgdGhpcy4kdmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZpZGVvTWlycm9yKGZhY2luZ01vZGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzdGFydCB0aGUgZmxhc2ggaWYgaXQgd2FzIHByZXZpb3VzbHkgb25cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmxhc2hPbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mbGFzaE9uID0gZmFsc2U7IC8vIGZvcmNlIHR1cm5GbGFzaE9uIHRvIHJlc3RhcnQgdGhlIGZsYXNoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHVybkZsYXNoT24oKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiBhc3luYyAqL1xuICAgIHBhdXNlKHN0b3BTdHJlYW1JbW1lZGlhdGVseSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHZpZGVvLnBhdXNlKCk7XG5cbiAgICAgICAgY29uc3Qgc3RvcFN0cmVhbSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMuJHZpZGVvLnNyY09iamVjdCA/IHRoaXMuJHZpZGVvLnNyY09iamVjdC5nZXRUcmFja3MoKSA6IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiB0cmFja3MpIHtcbiAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7IC8vICBub3RlIHRoYXQgdGhpcyB3aWxsIGFsc28gYXV0b21hdGljYWxseSB0dXJuIHRoZSBmbGFzaGxpZ2h0IG9mZlxuICAgICAgICAgICAgICAgIHRoaXMuJHZpZGVvLnNyY09iamVjdC5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiR2aWRlby5zcmNPYmplY3QgPSBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzdG9wU3RyZWFtSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgICAgIHN0b3BTdHJlYW0oKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0b3BTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIGFzeW5jICovXG4gICAgc2V0Q2FtZXJhKGZhY2luZ01vZGVPckRldmljZUlkKSB7XG4gICAgICAgIGlmIChmYWNpbmdNb2RlT3JEZXZpY2VJZCA9PT0gdGhpcy5fcHJlZmVycmVkQ2FtZXJhKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuX3ByZWZlcnJlZENhbWVyYSA9IGZhY2luZ01vZGVPckRldmljZUlkO1xuICAgICAgICAvLyBSZXN0YXJ0IHRoZSBzY2FubmVyIHdpdGggdGhlIG5ldyBjYW1lcmEgd2hpY2ggd2lsbCBhbHNvIHVwZGF0ZSB0aGUgdmlkZW8gbWlycm9yIGFuZCB0aGUgc2NhbiByZWdpb24uXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXN0YXJ0VmlkZW9TdHJlYW0oKTtcbiAgICB9XG5cbiAgICAvKiBhc3luYyAqL1xuICAgIHN0YXRpYyBzY2FuSW1hZ2UoaW1hZ2VPckZpbGVPclVybCwgc2NhblJlZ2lvbj1udWxsLCBxckVuZ2luZT1udWxsLCBjYW52YXM9bnVsbCwgZGlzYWxsb3dDYW52YXNSZXNpemluZz1mYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgIGFsc29UcnlXaXRob3V0U2NhblJlZ2lvbj1mYWxzZSkge1xuICAgICAgICBjb25zdCBnb3RFeHRlcm5hbFdvcmtlciA9IHFyRW5naW5lIGluc3RhbmNlb2YgV29ya2VyO1xuXG4gICAgICAgIGxldCBwcm9taXNlID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgcXJFbmdpbmUgfHwgUXJTY2FubmVyLmNyZWF0ZVFyRW5naW5lKCksXG4gICAgICAgICAgICBRclNjYW5uZXIuX2xvYWRJbWFnZShpbWFnZU9yRmlsZU9yVXJsKSxcbiAgICAgICAgXSkudGhlbigoW2VuZ2luZSwgaW1hZ2VdKSA9PiB7XG4gICAgICAgICAgICBxckVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgICAgIGxldCBjYW52YXNDb250ZXh0O1xuICAgICAgICAgICAgW2NhbnZhcywgY2FudmFzQ29udGV4dF0gPSB0aGlzLl9kcmF3VG9DYW52YXMoaW1hZ2UsIHNjYW5SZWdpb24sIGNhbnZhcywgZGlzYWxsb3dDYW52YXNSZXNpemluZyk7XG5cbiAgICAgICAgICAgIGlmIChxckVuZ2luZSBpbnN0YW5jZW9mIFdvcmtlcikge1xuICAgICAgICAgICAgICAgIGlmICghZ290RXh0ZXJuYWxXb3JrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5hYmxlIHNjYW5uaW5nIG9mIGludmVydGVkIGNvbG9yIHFyIGNvZGVzLiBOb3QgdXNpbmcgX3Bvc3RXb3JrZXJNZXNzYWdlIGFzIGl0J3MgYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgcXJFbmdpbmUucG9zdE1lc3NhZ2UoeyB0eXBlOiAnaW52ZXJzaW9uTW9kZScsIGRhdGE6ICdib3RoJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpbWVvdXQsIG9uTWVzc2FnZSwgb25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgb25NZXNzYWdlID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSAhPT0gJ3FyUmVzdWx0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHFyRW5naW5lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXJFbmdpbmUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGEuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChRclNjYW5uZXIuTk9fUVJfQ09ERV9GT1VORCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXJFbmdpbmUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBxckVuZ2luZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gIWUgPyAnVW5rbm93biBFcnJvcicgOiAoZS5tZXNzYWdlIHx8IGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCdTY2FubmVyIGVycm9yOiAnICsgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcXJFbmdpbmUuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHFyRW5naW5lLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IG9uRXJyb3IoJ3RpbWVvdXQnKSwgMTAwMDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjYW52YXNDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBxckVuZ2luZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGVjb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGltYWdlRGF0YVxuICAgICAgICAgICAgICAgICAgICB9LCBbaW1hZ2VEYXRhLmRhdGEuYnVmZmVyXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdCgnU2Nhbm5lciBlcnJvcjogdGltZW91dCcpLCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHFyRW5naW5lLmRldGVjdChjYW52YXMpLnRoZW4oc2NhblJlc3VsdHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2FuUmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoUXJTY2FubmVyLk5PX1FSX0NPREVfRk9VTkQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNjYW5SZXN1bHRzWzBdLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHJlamVjdCgnU2Nhbm5lciBlcnJvcjogJyArIChlLm1lc3NhZ2UgfHwgZSkpKS5maW5hbGx5KCgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzY2FuUmVnaW9uICYmIGFsc29UcnlXaXRob3V0U2NhblJlZ2lvbikge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UuY2F0Y2goKCkgPT5cbiAgICAgICAgICAgICAgICBRclNjYW5uZXIuc2NhbkltYWdlKGltYWdlT3JGaWxlT3JVcmwsIG51bGwsIHFyRW5naW5lLCBjYW52YXMsIGRpc2FsbG93Q2FudmFzUmVzaXppbmcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGdvdEV4dGVybmFsV29ya2VyKSByZXR1cm47XG4gICAgICAgICAgICBRclNjYW5uZXIuX3Bvc3RXb3JrZXJNZXNzYWdlKHFyRW5naW5lLCAnY2xvc2UnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgc2V0R3JheXNjYWxlV2VpZ2h0cyhyZWQsIGdyZWVuLCBibHVlLCB1c2VJbnRlZ2VyQXBwcm94aW1hdGlvbiA9IHRydWUpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IGZvciB0aGUgbmF0aXZlIEJhcmNvZGVEZWNvZGVyLCB0aGlzIGlzIGEgbm8tb3AuIEhvd2V2ZXIsIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIHdvcmsgYWxzb1xuICAgICAgICAvLyB3ZWxsIHdpdGggY29sb3JlZCBxciBjb2Rlcy5cbiAgICAgICAgUXJTY2FubmVyLl9wb3N0V29ya2VyTWVzc2FnZShcbiAgICAgICAgICAgIHRoaXMuX3FyRW5naW5lUHJvbWlzZSxcbiAgICAgICAgICAgICdncmF5c2NhbGVXZWlnaHRzJyxcbiAgICAgICAgICAgIHsgcmVkLCBncmVlbiwgYmx1ZSwgdXNlSW50ZWdlckFwcHJveGltYXRpb24gfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNldEludmVyc2lvbk1vZGUoaW52ZXJzaW9uTW9kZSkge1xuICAgICAgICAvLyBOb3RlIHRoYXQgZm9yIHRoZSBuYXRpdmUgQmFyY29kZURlY29kZXIsIHRoaXMgaXMgYSBuby1vcC4gSG93ZXZlciwgdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgc2NhbiBub3JtYWxcbiAgICAgICAgLy8gYW5kIGludmVydGVkIHFyIGNvZGVzIGJ5IGRlZmF1bHRcbiAgICAgICAgUXJTY2FubmVyLl9wb3N0V29ya2VyTWVzc2FnZSh0aGlzLl9xckVuZ2luZVByb21pc2UsICdpbnZlcnNpb25Nb2RlJywgaW52ZXJzaW9uTW9kZSk7XG4gICAgfVxuXG4gICAgLyogYXN5bmMgKi9cbiAgICBzdGF0aWMgY3JlYXRlUXJFbmdpbmUod29ya2VyUGF0aCA9IFFyU2Nhbm5lci5XT1JLRVJfUEFUSCkge1xuICAgICAgICByZXR1cm4gKCdCYXJjb2RlRGV0ZWN0b3InIGluIHdpbmRvdyAmJiBCYXJjb2RlRGV0ZWN0b3IuZ2V0U3VwcG9ydGVkRm9ybWF0c1xuICAgICAgICAgICAgPyBCYXJjb2RlRGV0ZWN0b3IuZ2V0U3VwcG9ydGVkRm9ybWF0cygpXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICAgICAgKVxuICAgICAgICAgICAgLnRoZW4oKHN1cHBvcnRlZEZvcm1hdHMpID0+IHN1cHBvcnRlZEZvcm1hdHMuaW5kZXhPZigncXJfY29kZScpICE9PSAtMVxuICAgICAgICAgICAgICAgID8gbmV3IEJhcmNvZGVEZXRlY3Rvcih7IGZvcm1hdHM6IFsncXJfY29kZSddIH0pXG4gICAgICAgICAgICAgICAgOiBuZXcgV29ya2VyKHdvcmtlclBhdGgpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIF9vblBsYXkoKSB7XG4gICAgICAgIHRoaXMuX3NjYW5SZWdpb24gPSB0aGlzLl9jYWxjdWxhdGVTY2FuUmVnaW9uKHRoaXMuJHZpZGVvKTtcbiAgICAgICAgdGhpcy5fc2NhbkZyYW1lKCk7XG4gICAgfVxuXG4gICAgX29uTG9hZGVkTWV0YURhdGEoKSB7XG4gICAgICAgIHRoaXMuX3NjYW5SZWdpb24gPSB0aGlzLl9jYWxjdWxhdGVTY2FuUmVnaW9uKHRoaXMuJHZpZGVvKTtcbiAgICB9XG5cbiAgICBfb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2FsY3VsYXRlU2NhblJlZ2lvbih2aWRlbykge1xuICAgICAgICAvLyBEZWZhdWx0IHNjYW4gcmVnaW9uIGNhbGN1bGF0aW9uLiBOb3RlIHRoYXQgdGhpcyBjYW4gYmUgb3ZlcndyaXR0ZW4gaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICBjb25zdCBzbWFsbGVzdERpbWVuc2lvbiA9IE1hdGgubWluKHZpZGVvLnZpZGVvV2lkdGgsIHZpZGVvLnZpZGVvSGVpZ2h0KTtcbiAgICAgICAgY29uc3Qgc2NhblJlZ2lvblNpemUgPSBNYXRoLnJvdW5kKDIgLyAzICogc21hbGxlc3REaW1lbnNpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogTWF0aC5yb3VuZCgodmlkZW8udmlkZW9XaWR0aCAtIHNjYW5SZWdpb25TaXplKSAvIDIpLFxuICAgICAgICAgICAgeTogTWF0aC5yb3VuZCgodmlkZW8udmlkZW9IZWlnaHQgLSBzY2FuUmVnaW9uU2l6ZSkgLyAyKSxcbiAgICAgICAgICAgIHdpZHRoOiBzY2FuUmVnaW9uU2l6ZSxcbiAgICAgICAgICAgIGhlaWdodDogc2NhblJlZ2lvblNpemUsXG4gICAgICAgICAgICBkb3duU2NhbGVkV2lkdGg6IHRoaXMuX2xlZ2FjeUNhbnZhc1NpemUsXG4gICAgICAgICAgICBkb3duU2NhbGVkSGVpZ2h0OiB0aGlzLl9sZWdhY3lDYW52YXNTaXplLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9zY2FuRnJhbWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYWN0aXZlIHx8IHRoaXMuJHZpZGVvLnBhdXNlZCB8fCB0aGlzLiR2aWRlby5lbmRlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyB1c2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdG8gYXZvaWQgc2Nhbm5pbmcgaWYgdGFiIGlzIGluIGJhY2tncm91bmRcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR2aWRlby5yZWFkeVN0YXRlIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHNjYW5zIHVudGlsIHRoZSB2aWRlbyBpcyByZWFkeSBhcyBkcmF3SW1hZ2UoKSBvbmx5IHdvcmtzIGNvcnJlY3RseSBvbiBhIHZpZGVvIHdpdGggcmVhZHlTdGF0ZVxuICAgICAgICAgICAgICAgIC8vID4gMSwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZHJhd0ltYWdlI05vdGVzLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxzbyBhdm9pZHMgZmFsc2UgcG9zaXRpdmVzIGZvciB2aWRlb3MgcGF1c2VkIGFmdGVyIGEgc3VjY2Vzc2Z1bCBzY2FuIHdoaWNoIHJlbWFpbnMgdmlzaWJsZSBvblxuICAgICAgICAgICAgICAgIC8vIHRoZSBjYW52YXMgdW50aWwgdGhlIHZpZGVvIGlzIHN0YXJ0ZWQgYWdhaW4gYW5kIHJlYWR5LlxuICAgICAgICAgICAgICAgIHRoaXMuX3NjYW5GcmFtZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3FyRW5naW5lUHJvbWlzZVxuICAgICAgICAgICAgICAgIC50aGVuKChxckVuZ2luZSkgPT4gUXJTY2FubmVyLnNjYW5JbWFnZSh0aGlzLiR2aWRlbywgdGhpcy5fc2NhblJlZ2lvbiwgcXJFbmdpbmUsIHRoaXMuJGNhbnZhcykpXG4gICAgICAgICAgICAgICAgLnRoZW4odGhpcy5fb25EZWNvZGUsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlLmluZGV4T2YoJ3NlcnZpY2UgdW5hdmFpbGFibGUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIG5hdGl2ZSBCYXJjb2RlRGV0ZWN0b3IgY3Jhc2hlZCwgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXJFbmdpbmVQcm9taXNlID0gUXJTY2FubmVyLmNyZWF0ZVFyRW5naW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25EZWNvZGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLl9zY2FuRnJhbWUoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9vbkRlY29kZUVycm9yKGVycm9yKSB7XG4gICAgICAgIC8vIGRlZmF1bHQgZXJyb3IgaGFuZGxlcjsgY2FuIGJlIG92ZXJ3cml0dGVuIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICBpZiAoZXJyb3IgPT09IFFyU2Nhbm5lci5OT19RUl9DT0RFX0ZPVU5EKSByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICB9XG5cbiAgICAvKiBhc3luYyAqL1xuICAgIF9nZXRDYW1lcmFTdHJlYW0oKSB7XG4gICAgICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW1lcmEgbm90IGZvdW5kLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJlZmVyZW5jZVR5cGUgPSB0aGlzLl9wcmVmZXJyZWRDYW1lcmEgPT09ICdlbnZpcm9ubWVudCcgfHwgdGhpcy5fcHJlZmVycmVkQ2FtZXJhID09PSAndXNlcidcbiAgICAgICAgICAgID8gJ2ZhY2luZ01vZGUnXG4gICAgICAgICAgICA6ICdkZXZpY2VJZCc7XG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzV2l0aG91dENhbWVyYSA9IFt7XG4gICAgICAgICAgICB3aWR0aDogeyBtaW46IDEwMjQgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB3aWR0aDogeyBtaW46IDc2OCB9XG4gICAgICAgIH0sIHt9XTtcbiAgICAgICAgY29uc3QgY29uc3RyYWludHNXaXRoQ2FtZXJhID0gY29uc3RyYWludHNXaXRob3V0Q2FtZXJhLm1hcCgoY29uc3RyYWludCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgY29uc3RyYWludCwge1xuICAgICAgICAgICAgW3ByZWZlcmVuY2VUeXBlXTogeyBleGFjdDogdGhpcy5fcHJlZmVycmVkQ2FtZXJhIH0sXG4gICAgICAgIH0pKTtcblxuICAgICAgICAvLyBGaXJzdCB0cnkgY29uc3RyYWludHMgd2l0aCBjYW1lcmEsIHRoZW4gd2l0aG91dCBjYW1lcmEuIFVzaW5nIHJlZHVjZVJpZ2h0IGFzIHRoZSBQcm9taXNlIGlzIGJ1aWxkIGluIGFcbiAgICAgICAgLy8gYm90dG9tIHVwIGZhc2hpb24uXG4gICAgICAgIHJldHVybiBbLi4uY29uc3RyYWludHNXaXRoQ2FtZXJhLCAuLi5jb25zdHJhaW50c1dpdGhvdXRDYW1lcmFdLnJlZHVjZVJpZ2h0KChmYWxsYmFjaywgY29uc3RyYWludCkgPT5cbiAgICAgICAgICAgICgpID0+IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgdmlkZW86IGNvbnN0cmFpbnQsIGF1ZGlvOiBmYWxzZSB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChzdHJlYW0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGRldGVybWluZSB0aGUgZmFjaW5nIG1vZGUgZnJvbSB0aGUgc3RyZWFtLCBvdGhlcndpc2UgdXNlIGEgZ3Vlc3Mgb3IgJ2Vudmlyb25tZW50JyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LiBOb3RlIHRoYXQgdGhlIGd1ZXNzIGlzIG5vdCBhbHdheXMgYWNjdXJhdGUgYXMgU2FmYXJpIHJldHVybnMgY2FtZXJhcyBvZiBkaWZmZXJlbnQgZmFjaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vZGUsIGV2ZW4gZm9yIGV4YWN0IGZhY2luZ01vZGUgY29uc3RyYWludHMuXG4gICAgICAgICAgICAgICAgICAgIGZhY2luZ01vZGU6IHRoaXMuX2dldEZhY2luZ01vZGUoc3RyZWFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGNvbnN0cmFpbnQuZmFjaW5nTW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5fcHJlZmVycmVkQ2FtZXJhIC8vIF9wcmVmZXJyZWRDYW1lcmEgaXMgYSBmYWNpbmcgbW9kZSBhbmQgd2UgYXJlIGFibGUgdG8gZnVsZmlsbCBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKHRoaXMuX3ByZWZlcnJlZENhbWVyYSA9PT0gJ2Vudmlyb25tZW50J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICd1c2VyJyAvLyBzd2l0Y2ggYXMgX3ByZWZlcnJlZENhbWVyYSB3YXMgZW52aXJvbm1lbnQgYnV0IHdlIGFyZSBub3QgYWJsZSB0byBmdWxmaWxsIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2Vudmlyb25tZW50JyAvLyBzd2l0Y2ggZnJvbSB1bmZ1bGZpbGxlZCB1c2VyIGZhY2luZ01vZGUgb3IgZGVmYXVsdCB0byBlbnZpcm9ubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZhbGxiYWNrKSxcbiAgICAgICAgICAgICgpID0+IFByb21pc2UucmVqZWN0KCdDYW1lcmEgbm90IGZvdW5kLicpXG4gICAgICAgICkoKTtcbiAgICB9XG5cbiAgICAvKiBhc3luYyAqL1xuICAgIF9yZXN0YXJ0VmlkZW9TdHJlYW0oKSB7XG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBhbHdheXMgcGF1c2UgdGhlIHN0cmVhbSBhbmQgbm90IG9ubHkgaWYgIXRoaXMuX3BhdXNlZCBhcyBldmVuIGlmIHRoaXMuX3BhdXNlZCA9PT0gdHJ1ZSwgdGhlXG4gICAgICAgIC8vIHN0cmVhbSBtaWdodCBzdGlsbCBiZSBydW5uaW5nLCBhcyBpdCdzIGJ5IGRlZmF1bHQgb25seSBzdG9wcGVkIGFmdGVyIGEgZGVsYXkgb2YgMzAwbXMuXG4gICAgICAgIGNvbnN0IHdhc1BhdXNlZCA9IHRoaXMuX3BhdXNlZDtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF1c2UodHJ1ZSkudGhlbigocGF1c2VkKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXBhdXNlZCB8fCB3YXNQYXVzZWQgfHwgIXRoaXMuX2FjdGl2ZSkgcmV0dXJuO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3NldFZpZGVvTWlycm9yKGZhY2luZ01vZGUpIHtcbiAgICAgICAgLy8gaW4gdXNlciBmYWNpbmcgbW9kZSBtaXJyb3IgdGhlIHZpZGVvIHRvIG1ha2UgaXQgZWFzaWVyIGZvciB0aGUgdXNlciB0byBwb3NpdGlvbiB0aGUgUVIgY29kZVxuICAgICAgICBjb25zdCBzY2FsZUZhY3RvciA9IGZhY2luZ01vZGU9PT0ndXNlcic/IC0xIDogMTtcbiAgICAgICAgdGhpcy4kdmlkZW8uc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlWCgnICsgc2NhbGVGYWN0b3IgKyAnKSc7XG4gICAgfVxuXG4gICAgX2dldEZhY2luZ01vZGUodmlkZW9TdHJlYW0pIHtcbiAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHZpZGVvU3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAgIGlmICghdmlkZW9UcmFjaykgcmV0dXJuIG51bGw7IC8vIHVua25vd25cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0pvZHVzTm9kdXMvcmVhY3QtcXItcmVhZGVyL2Jsb2IvbWFzdGVyL3NyYy9nZXREZXZpY2VJZC5qcyNMMTNcbiAgICAgICAgcmV0dXJuIC9yZWFyfGJhY2t8ZW52aXJvbm1lbnQvaS50ZXN0KHZpZGVvVHJhY2subGFiZWwpXG4gICAgICAgICAgICA/ICdlbnZpcm9ubWVudCdcbiAgICAgICAgICAgIDogL2Zyb250fHVzZXJ8ZmFjZS9pLnRlc3QodmlkZW9UcmFjay5sYWJlbClcbiAgICAgICAgICAgICAgICA/ICd1c2VyJ1xuICAgICAgICAgICAgICAgIDogbnVsbDsgLy8gdW5rbm93blxuICAgIH1cblxuICAgIHN0YXRpYyBfZHJhd1RvQ2FudmFzKGltYWdlLCBzY2FuUmVnaW9uPW51bGwsIGNhbnZhcz1udWxsLCBkaXNhbGxvd0NhbnZhc1Jlc2l6aW5nPWZhbHNlKSB7XG4gICAgICAgIGNhbnZhcyA9IGNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3Qgc2NhblJlZ2lvblggPSBzY2FuUmVnaW9uICYmIHNjYW5SZWdpb24ueD8gc2NhblJlZ2lvbi54IDogMDtcbiAgICAgICAgY29uc3Qgc2NhblJlZ2lvblkgPSBzY2FuUmVnaW9uICYmIHNjYW5SZWdpb24ueT8gc2NhblJlZ2lvbi55IDogMDtcbiAgICAgICAgY29uc3Qgc2NhblJlZ2lvbldpZHRoID0gc2NhblJlZ2lvbiAmJiBzY2FuUmVnaW9uLndpZHRoPyBzY2FuUmVnaW9uLndpZHRoIDogaW1hZ2Uud2lkdGggfHwgaW1hZ2UudmlkZW9XaWR0aDtcbiAgICAgICAgY29uc3Qgc2NhblJlZ2lvbkhlaWdodCA9IHNjYW5SZWdpb24gJiYgc2NhblJlZ2lvbi5oZWlnaHQ/IHNjYW5SZWdpb24uaGVpZ2h0IDogaW1hZ2UuaGVpZ2h0IHx8IGltYWdlLnZpZGVvSGVpZ2h0O1xuXG4gICAgICAgIGlmICghZGlzYWxsb3dDYW52YXNSZXNpemluZykge1xuICAgICAgICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBzY2FuUmVnaW9uICYmIHNjYW5SZWdpb24uZG93blNjYWxlZFdpZHRoXG4gICAgICAgICAgICAgICAgPyBzY2FuUmVnaW9uLmRvd25TY2FsZWRXaWR0aFxuICAgICAgICAgICAgICAgIDogc2NhblJlZ2lvbldpZHRoO1xuICAgICAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gc2NhblJlZ2lvbiAmJiBzY2FuUmVnaW9uLmRvd25TY2FsZWRIZWlnaHRcbiAgICAgICAgICAgICAgICA/IHNjYW5SZWdpb24uZG93blNjYWxlZEhlaWdodFxuICAgICAgICAgICAgICAgIDogc2NhblJlZ2lvbkhlaWdodDtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgdGhlIGNhbnZhcyB3aWR0aCBvciBoZWlnaHQgY2xlYXJzIHRoZSBjYW52YXMsIGV2ZW4gaWYgdGhlIHZhbHVlcyBkaWRuJ3QgY2hhbmdlLCB0aGVyZWZvcmUgb25seVxuICAgICAgICAgICAgLy8gc2V0IHRoZW0gaWYgdGhleSBhY3R1YWxseSBjaGFuZ2VkLlxuICAgICAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHsgYWxwaGE6IGZhbHNlIH0pO1xuICAgICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlOyAvLyBnaXZlcyBsZXNzIGJsdXJyeSBpbWFnZXNcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIHNjYW5SZWdpb25YLCBzY2FuUmVnaW9uWSwgc2NhblJlZ2lvbldpZHRoLCBzY2FuUmVnaW9uSGVpZ2h0LFxuICAgICAgICAgICAgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBbY2FudmFzLCBjb250ZXh0XTtcbiAgICB9XG5cbiAgICAvKiBhc3luYyAqL1xuICAgIHN0YXRpYyBfbG9hZEltYWdlKGltYWdlT3JGaWxlT3JCbG9iT3JVcmwpIHtcbiAgICAgICAgaWYgKGltYWdlT3JGaWxlT3JCbG9iT3JVcmwgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fCBpbWFnZU9yRmlsZU9yQmxvYk9yVXJsIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudFxuICAgICAgICAgICAgfHwgd2luZG93LkltYWdlQml0bWFwICYmIGltYWdlT3JGaWxlT3JCbG9iT3JVcmwgaW5zdGFuY2VvZiB3aW5kb3cuSW1hZ2VCaXRtYXBcbiAgICAgICAgICAgIHx8IHdpbmRvdy5PZmZzY3JlZW5DYW52YXMgJiYgaW1hZ2VPckZpbGVPckJsb2JPclVybCBpbnN0YW5jZW9mIHdpbmRvdy5PZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW1hZ2VPckZpbGVPckJsb2JPclVybCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW1hZ2VPckZpbGVPckJsb2JPclVybCBpbnN0YW5jZW9mIEltYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gUXJTY2FubmVyLl9hd2FpdEltYWdlTG9hZChpbWFnZU9yRmlsZU9yQmxvYk9yVXJsKS50aGVuKCgpID0+IGltYWdlT3JGaWxlT3JCbG9iT3JVcmwpO1xuICAgICAgICB9IGVsc2UgaWYgKGltYWdlT3JGaWxlT3JCbG9iT3JVcmwgaW5zdGFuY2VvZiBGaWxlIHx8IGltYWdlT3JGaWxlT3JCbG9iT3JVcmwgaW5zdGFuY2VvZiBCbG9iXG4gICAgICAgICAgICB8fCBpbWFnZU9yRmlsZU9yQmxvYk9yVXJsIGluc3RhbmNlb2YgVVJMIHx8IHR5cGVvZihpbWFnZU9yRmlsZU9yQmxvYk9yVXJsKT09PSdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaWYgKGltYWdlT3JGaWxlT3JCbG9iT3JVcmwgaW5zdGFuY2VvZiBGaWxlIHx8IGltYWdlT3JGaWxlT3JCbG9iT3JVcmwgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpbWFnZU9yRmlsZU9yQmxvYk9yVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2VPckZpbGVPckJsb2JPclVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBRclNjYW5uZXIuX2F3YWl0SW1hZ2VMb2FkKGltYWdlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VPckZpbGVPckJsb2JPclVybCBpbnN0YW5jZW9mIEZpbGUgfHwgaW1hZ2VPckZpbGVPckJsb2JPclVybCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChpbWFnZS5zcmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnVW5zdXBwb3J0ZWQgaW1hZ2UgdHlwZS4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIGFzeW5jICovXG4gICAgc3RhdGljIF9hd2FpdEltYWdlTG9hZChpbWFnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxXaWR0aCE9PTApIHtcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG9uTG9hZCwgb25FcnJvcjtcbiAgICAgICAgICAgICAgICBvbkxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvbkVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCdJbWFnZSBsb2FkIGVycm9yJyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICAgICAgICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiBhc3luYyAqL1xuICAgIHN0YXRpYyBfcG9zdFdvcmtlck1lc3NhZ2UocXJFbmdpbmVPclFyRW5naW5lUHJvbWlzZSwgdHlwZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHFyRW5naW5lT3JRckVuZ2luZVByb21pc2UpLnRoZW4oKHFyRW5naW5lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShxckVuZ2luZSBpbnN0YW5jZW9mIFdvcmtlcikpIHJldHVybjtcbiAgICAgICAgICAgIHFyRW5naW5lLnBvc3RNZXNzYWdlKHsgdHlwZSwgZGF0YSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuUXJTY2FubmVyLkRFRkFVTFRfQ0FOVkFTX1NJWkUgPSA0MDA7XG5RclNjYW5uZXIuTk9fUVJfQ09ERV9GT1VORCA9ICdObyBRUiBjb2RlIGZvdW5kJztcblFyU2Nhbm5lci5XT1JLRVJfUEFUSCA9ICdxci1zY2FubmVyLXdvcmtlci5taW4uanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/qr-scanner/src/qr-scanner.js\n");

/***/ })

}]);