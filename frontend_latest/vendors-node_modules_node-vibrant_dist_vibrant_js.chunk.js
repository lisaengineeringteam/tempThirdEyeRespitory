/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_node-vibrant_dist_vibrant_js"],{

/***/ "./node_modules/node-vibrant/dist/vibrant.js":
/*!***************************************************!*\
  !*** ./node_modules/node-vibrant/dist/vibrant.js ***!
  \***************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true) module.exports = factory();else {}\n})(window, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __nested_webpack_require_603__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_603__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __nested_webpack_require_603__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __nested_webpack_require_603__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __nested_webpack_require_603__.d = function (exports, name, getter) {\n        /******/\n        if (!__nested_webpack_require_603__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __nested_webpack_require_603__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __nested_webpack_require_603__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __nested_webpack_require_603__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __nested_webpack_require_603__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_603__.d(ns, key, function (key) {\n          return value[key];\n        }.bind(null, key));\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __nested_webpack_require_603__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __nested_webpack_require_603__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __nested_webpack_require_603__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __nested_webpack_require_603__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __nested_webpack_require_603__(__nested_webpack_require_603__.s = 10);\n      /******/\n    }([\n      /* 0 */\n\n      /***/\n\n      /* 1 */\n\n      /***/\n\n      /* 2 */\n\n      /***/\n\n      /* 3 */\n\n      /***/\n\n      /* 4 */\n\n      /***/\n\n      /* 5 */\n\n      /***/\n\n      /* 6 */\n\n      /***/\n\n      /* 7 */\n\n      /***/\n\n      /* 8 */\n\n      /***/\n\n      /* 9 */\n\n      /***/\n\n      /* 10 */\n\n      /***/\n\n      /* 11 */\n\n      /***/\n\n      /* 12 */\n\n      /***/\n\n      /* 13 */\n\n      /***/\n\n      /* 14 */\n\n      /***/\n\n      /* 15 */\n\n      /***/\n\n      /* 16 */\n\n      /***/\n\n      /* 17 */\n\n      /***/\n\n      /******/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.assignDeep = exports.mapValues = void 0;\n\n      function mapValues(o, mapper) {\n        var result = {};\n\n        for (var key in o) {\n          if (o.hasOwnProperty(key)) {\n            var v = o[key];\n            result[key] = mapper(v);\n          }\n        }\n\n        return result;\n      }\n\n      exports.mapValues = mapValues;\n      /**\n       * Overwrite values or properties on objects and lists recursively.\n       * A shallow copy will be created for each array value.\n       */\n\n      function assignDeep(target) {\n        var sources = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          sources[_i - 1] = arguments[_i];\n        }\n\n        sources.forEach(function (s) {\n          if (!s) return;\n\n          for (var key in s) {\n            if (s.hasOwnProperty(key)) {\n              var v = s[key];\n\n              if (Array.isArray(v)) {\n                // Shallow copy\n                target[key] = v.slice(0);\n              } else if (typeof v === 'object') {\n                if (!target[key]) target[key] = {};\n                assignDeep(target[key], v);\n              } else {\n                target[key] = v;\n              }\n            }\n          }\n        });\n        return target;\n      }\n\n      exports.assignDeep = assignDeep;\n      /***/\n    }, function (module, exports, __nested_webpack_require_7150__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var options_1 = __nested_webpack_require_7150__(7);\n\n      var builder_1 = __importDefault(__nested_webpack_require_7150__(8));\n\n      var utils_1 = __nested_webpack_require_7150__(0);\n\n      var Vibrant = function () {\n        function Vibrant(_src, opts) {\n          this._src = _src;\n          this.opts = utils_1.assignDeep({}, Vibrant.DefaultOpts, opts);\n        }\n\n        Vibrant.use = function (pipeline) {\n          this._pipeline = pipeline;\n        };\n\n        Vibrant.from = function (src) {\n          return new builder_1.default(src);\n        };\n\n        Object.defineProperty(Vibrant.prototype, \"result\", {\n          get: function () {\n            return this._result;\n          },\n          enumerable: false,\n          configurable: true\n        });\n\n        Vibrant.prototype._process = function (image, opts) {\n          var quantizer = this.opts.quantizer;\n          image.scaleDown(this.opts);\n          var processOpts = options_1.buildProcessOptions(this.opts, opts);\n          return Vibrant._pipeline.process(image.getImageData(), processOpts);\n        };\n\n        Vibrant.prototype.palette = function () {\n          return this.swatches();\n        };\n\n        Vibrant.prototype.swatches = function () {\n          throw new Error('Method deprecated. Use `Vibrant.result.palettes[name]` instead');\n        };\n\n        Vibrant.prototype.getPalette = function () {\n          var _this = this;\n\n          var arg0 = arguments[0];\n          var arg1 = arguments[1];\n          var name = typeof arg0 === 'string' ? arg0 : 'default';\n          var cb = typeof arg0 === 'string' ? arg1 : arg0;\n          var image = new this.opts.ImageClass();\n          return image.load(this._src).then(function (image) {\n            return _this._process(image, {\n              generators: [name]\n            });\n          }).then(function (result) {\n            _this._result = result;\n            return result.palettes[name];\n          }).then(function (res) {\n            image.remove();\n\n            if (cb) {\n              cb(undefined, res);\n            }\n\n            return res;\n          }).catch(function (err) {\n            image.remove();\n\n            if (cb) {\n              cb(err);\n            }\n\n            return Promise.reject(err);\n          });\n        };\n\n        Vibrant.prototype.getPalettes = function () {\n          var _this = this;\n\n          var arg0 = arguments[0];\n          var arg1 = arguments[1];\n          var names = Array.isArray(arg0) ? arg0 : ['*'];\n          var cb = Array.isArray(arg0) ? arg1 : arg0;\n          var image = new this.opts.ImageClass();\n          return image.load(this._src).then(function (image) {\n            return _this._process(image, {\n              generators: names\n            });\n          }).then(function (result) {\n            _this._result = result;\n            return result.palettes;\n          }).then(function (res) {\n            image.remove();\n\n            if (cb) {\n              cb(undefined, res);\n            }\n\n            return res;\n          }).catch(function (err) {\n            image.remove();\n\n            if (cb) {\n              cb(err);\n            }\n\n            return Promise.reject(err);\n          });\n        };\n\n        Vibrant.DefaultOpts = {\n          colorCount: 64,\n          quality: 5,\n          filters: []\n        };\n        return Vibrant;\n      }();\n\n      exports.default = Vibrant;\n      /***/\n    }, function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.applyFilters = exports.ImageBase = void 0;\n\n      var ImageBase = function () {\n        function ImageBase() {}\n\n        ImageBase.prototype.scaleDown = function (opts) {\n          var width = this.getWidth();\n          var height = this.getHeight();\n          var ratio = 1;\n\n          if (opts.maxDimension > 0) {\n            var maxSide = Math.max(width, height);\n            if (maxSide > opts.maxDimension) ratio = opts.maxDimension / maxSide;\n          } else {\n            ratio = 1 / opts.quality;\n          }\n\n          if (ratio < 1) this.resize(width * ratio, height * ratio, ratio);\n        };\n\n        return ImageBase;\n      }();\n\n      exports.ImageBase = ImageBase;\n\n      function applyFilters(imageData, filters) {\n        if (filters.length > 0) {\n          var pixels = imageData.data;\n          var n = pixels.length / 4;\n          var offset = void 0;\n          var r = void 0;\n          var g = void 0;\n          var b = void 0;\n          var a = void 0;\n\n          for (var i = 0; i < n; i++) {\n            offset = i * 4;\n            r = pixels[offset + 0];\n            g = pixels[offset + 1];\n            b = pixels[offset + 2];\n            a = pixels[offset + 3]; // Mark ignored color\n\n            for (var j = 0; j < filters.length; j++) {\n              if (!filters[j](r, g, b, a)) {\n                pixels[offset + 3] = 0;\n                break;\n              }\n            }\n          }\n        }\n\n        return imageData;\n      }\n\n      exports.applyFilters = applyFilters;\n      /***/\n    }, function (module, exports, __nested_webpack_require_12552__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.Swatch = void 0;\n\n      var converter_1 = __nested_webpack_require_12552__(4);\n\n      var Swatch = function () {\n        function Swatch(rgb, population) {\n          this._rgb = rgb;\n          this._population = population;\n        }\n\n        Swatch.applyFilters = function (colors, filters) {\n          return filters.length > 0 ? colors.filter(function (_a) {\n            var r = _a.r,\n                g = _a.g,\n                b = _a.b;\n\n            for (var j = 0; j < filters.length; j++) {\n              if (!filters[j](r, g, b, 255)) return false;\n            }\n\n            return true;\n          }) : colors;\n        };\n        /**\n         * Make a value copy of a swatch based on a previous one. Returns a new Swatch instance\n         * @param {Swatch} swatch\n         */\n\n\n        Swatch.clone = function (swatch) {\n          return new Swatch(swatch._rgb, swatch._population);\n        };\n\n        Object.defineProperty(Swatch.prototype, \"r\", {\n          /**\n           * The red value in the RGB value\n           */\n          get: function () {\n            return this._rgb[0];\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"g\", {\n          /**\n           * The green value in the RGB value\n           */\n          get: function () {\n            return this._rgb[1];\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"b\", {\n          /**\n           * The blue value in the RGB value\n           */\n          get: function () {\n            return this._rgb[2];\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"rgb\", {\n          /**\n           * The color value as a rgb value\n           */\n          get: function () {\n            return this._rgb;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"hsl\", {\n          /**\n           * The color value as a hsl value\n           */\n          get: function () {\n            if (!this._hsl) {\n              var _a = this._rgb,\n                  r = _a[0],\n                  g = _a[1],\n                  b = _a[2];\n              this._hsl = converter_1.rgbToHsl(r, g, b);\n            }\n\n            return this._hsl;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"hex\", {\n          /**\n           * The color value as a hex string\n           */\n          get: function () {\n            if (!this._hex) {\n              var _a = this._rgb,\n                  r = _a[0],\n                  g = _a[1],\n                  b = _a[2];\n              this._hex = converter_1.rgbToHex(r, g, b);\n            }\n\n            return this._hex;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"population\", {\n          get: function () {\n            return this._population;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        /**\n         * Get the JSON object for the swatch\n         */\n\n        Swatch.prototype.toJSON = function () {\n          return {\n            rgb: this.rgb,\n            population: this.population\n          };\n        };\n        /**\n         * Get the color value as a rgb value\n         * @deprecated Use property instead\n         */\n        // TODO: deprecate internally, use property instead\n\n\n        Swatch.prototype.getRgb = function () {\n          return this._rgb;\n        };\n        /**\n         * Get the color value as a hsl value\n         * @deprecated Use property instead\n         */\n        // TODO: deprecate internally, use property instead\n\n\n        Swatch.prototype.getHsl = function () {\n          return this.hsl;\n        };\n        /**\n         * @deprecated Use property instead\n         */\n        // TODO: deprecate internally, use property instead\n\n\n        Swatch.prototype.getPopulation = function () {\n          return this._population;\n        };\n        /**\n         * Get the color value as a hex string\n         * @deprecated Use property instead\n         */\n        // TODO: deprecate internally, use property instead\n\n\n        Swatch.prototype.getHex = function () {\n          return this.hex;\n        };\n\n        Swatch.prototype.getYiq = function () {\n          if (!this._yiq) {\n            var rgb = this._rgb;\n            this._yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n          }\n\n          return this._yiq;\n        };\n\n        Object.defineProperty(Swatch.prototype, \"titleTextColor\", {\n          get: function () {\n            if (this._titleTextColor) {\n              this._titleTextColor = this.getYiq() < 200 ? '#fff' : '#000';\n            }\n\n            return this._titleTextColor;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"bodyTextColor\", {\n          get: function () {\n            if (this._bodyTextColor) {\n              this._bodyTextColor = this.getYiq() < 150 ? '#fff' : '#000';\n            }\n\n            return this._bodyTextColor;\n          },\n          enumerable: false,\n          configurable: true\n        });\n\n        Swatch.prototype.getTitleTextColor = function () {\n          return this.titleTextColor;\n        };\n\n        Swatch.prototype.getBodyTextColor = function () {\n          return this.bodyTextColor;\n        };\n\n        return Swatch;\n      }();\n\n      exports.Swatch = Swatch;\n      /***/\n    }, function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.getColorDiffStatus = exports.hexDiff = exports.rgbDiff = exports.deltaE94 = exports.rgbToCIELab = exports.xyzToCIELab = exports.rgbToXyz = exports.hslToRgb = exports.rgbToHsl = exports.rgbToHex = exports.hexToRgb = exports.DELTAE94_DIFF_STATUS = void 0;\n      exports.DELTAE94_DIFF_STATUS = {\n        NA: 0,\n        PERFECT: 1,\n        CLOSE: 2,\n        GOOD: 10,\n        SIMILAR: 50\n      };\n      /**\n       * Converts hex string to RGB\n       * @param hex - The hex value you with to get the RGB value of\n       * @returns an array in the order of `red, green, blue` numerical values\n       */\n\n      function hexToRgb(hex) {\n        var m = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        if (!m) throw new RangeError(\"'\" + hex + \"' is not a valid hex color\");\n        return [m[1], m[2], m[3]].map(function (s) {\n          return parseInt(s, 16);\n        });\n      }\n\n      exports.hexToRgb = hexToRgb;\n      /**\n       * Given values for an RGB color convert to and return a valid HEX string\n       * @param r - Red value in RGB\n       * @param g - Green value in RGB\n       * @param b - Blue value in RGB\n       * @returns a valid hex string with pre-pending pound sign\n       */\n\n      function rgbToHex(r, g, b) {\n        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);\n      }\n\n      exports.rgbToHex = rgbToHex;\n      /**\n       * Given values for an RGB color convert to and return a valid HSL value\n       * @param r - Red value in RGB\n       * @param g - Green value in RGB\n       * @param b - Blue value in RGB\n       * @returns an array in the order of `hue, saturation, light` numerical values\n       */\n\n      function rgbToHsl(r, g, b) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var h = 0;\n        var s = 0;\n        var l = (max + min) / 2;\n\n        if (max !== min) {\n          var d = max - min;\n          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n          switch (max) {\n            case r:\n              h = (g - b) / d + (g < b ? 6 : 0);\n              break;\n\n            case g:\n              h = (b - r) / d + 2;\n              break;\n\n            case b:\n              h = (r - g) / d + 4;\n              break;\n          }\n\n          h /= 6;\n        }\n\n        return [h, s, l];\n      }\n\n      exports.rgbToHsl = rgbToHsl;\n\n      function hslToRgb(h, s, l) {\n        var r;\n        var g;\n        var b;\n\n        function hue2rgb(p, q, t) {\n          if (t < 0) t += 1;\n          if (t > 1) t -= 1;\n          if (t < 1 / 6) return p + (q - p) * 6 * t;\n          if (t < 1 / 2) return q;\n          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n          return p;\n        }\n\n        if (s === 0) {\n          r = g = b = l;\n        } else {\n          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n          var p = 2 * l - q;\n          r = hue2rgb(p, q, h + 1 / 3);\n          g = hue2rgb(p, q, h);\n          b = hue2rgb(p, q, h - 1 / 3);\n        }\n\n        return [r * 255, g * 255, b * 255];\n      }\n\n      exports.hslToRgb = hslToRgb;\n\n      function rgbToXyz(r, g, b) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        r = r > 0.04045 ? Math.pow((r + 0.005) / 1.055, 2.4) : r / 12.92;\n        g = g > 0.04045 ? Math.pow((g + 0.005) / 1.055, 2.4) : g / 12.92;\n        b = b > 0.04045 ? Math.pow((b + 0.005) / 1.055, 2.4) : b / 12.92;\n        r *= 100;\n        g *= 100;\n        b *= 100;\n        var x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n        var y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n        var z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n        return [x, y, z];\n      }\n\n      exports.rgbToXyz = rgbToXyz;\n\n      function xyzToCIELab(x, y, z) {\n        var REF_X = 95.047;\n        var REF_Y = 100;\n        var REF_Z = 108.883;\n        x /= REF_X;\n        y /= REF_Y;\n        z /= REF_Z;\n        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n        var L = 116 * y - 16;\n        var a = 500 * (x - y);\n        var b = 200 * (y - z);\n        return [L, a, b];\n      }\n\n      exports.xyzToCIELab = xyzToCIELab;\n\n      function rgbToCIELab(r, g, b) {\n        var _a = rgbToXyz(r, g, b),\n            x = _a[0],\n            y = _a[1],\n            z = _a[2];\n\n        return xyzToCIELab(x, y, z);\n      }\n\n      exports.rgbToCIELab = rgbToCIELab;\n\n      function deltaE94(lab1, lab2) {\n        var WEIGHT_L = 1;\n        var WEIGHT_C = 1;\n        var WEIGHT_H = 1;\n        var L1 = lab1[0],\n            a1 = lab1[1],\n            b1 = lab1[2];\n        var L2 = lab2[0],\n            a2 = lab2[1],\n            b2 = lab2[2];\n        var dL = L1 - L2;\n        var da = a1 - a2;\n        var db = b1 - b2;\n        var xC1 = Math.sqrt(a1 * a1 + b1 * b1);\n        var xC2 = Math.sqrt(a2 * a2 + b2 * b2);\n        var xDL = L2 - L1;\n        var xDC = xC2 - xC1;\n        var xDE = Math.sqrt(dL * dL + da * da + db * db);\n        var xDH = Math.sqrt(xDE) > Math.sqrt(Math.abs(xDL)) + Math.sqrt(Math.abs(xDC)) ? Math.sqrt(xDE * xDE - xDL * xDL - xDC * xDC) : 0;\n        var xSC = 1 + 0.045 * xC1;\n        var xSH = 1 + 0.015 * xC1;\n        xDL /= WEIGHT_L;\n        xDC /= WEIGHT_C * xSC;\n        xDH /= WEIGHT_H * xSH;\n        return Math.sqrt(xDL * xDL + xDC * xDC + xDH * xDH);\n      }\n\n      exports.deltaE94 = deltaE94;\n\n      function rgbDiff(rgb1, rgb2) {\n        var lab1 = rgbToCIELab.apply(undefined, rgb1);\n        var lab2 = rgbToCIELab.apply(undefined, rgb2);\n        return deltaE94(lab1, lab2);\n      }\n\n      exports.rgbDiff = rgbDiff;\n\n      function hexDiff(hex1, hex2) {\n        var rgb1 = hexToRgb(hex1);\n        var rgb2 = hexToRgb(hex2);\n        return rgbDiff(rgb1, rgb2);\n      }\n\n      exports.hexDiff = hexDiff;\n\n      function getColorDiffStatus(d) {\n        if (d < exports.DELTAE94_DIFF_STATUS.NA) {\n          return 'N/A';\n        } // Not perceptible by human eyes\n\n\n        if (d <= exports.DELTAE94_DIFF_STATUS.PERFECT) {\n          return 'Perfect';\n        } // Perceptible through close observation\n\n\n        if (d <= exports.DELTAE94_DIFF_STATUS.CLOSE) {\n          return 'Close';\n        } // Perceptible at a glance\n\n\n        if (d <= exports.DELTAE94_DIFF_STATUS.GOOD) {\n          return 'Good';\n        } // Colors are more similar than opposite\n\n\n        if (d < exports.DELTAE94_DIFF_STATUS.SIMILAR) {\n          return 'Similar';\n        }\n\n        return 'Wrong';\n      }\n\n      exports.getColorDiffStatus = getColorDiffStatus;\n      /***/\n    }, function (module, exports, __nested_webpack_require_25198__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n\n      var config_1 = __importDefault(__nested_webpack_require_25198__(6));\n\n      var image_browser_1 = __importDefault(__nested_webpack_require_25198__(9));\n\n      config_1.default.DefaultOpts.ImageClass = image_browser_1.default;\n      module.exports = config_1.default;\n      /***/\n    }, function (module, exports, __nested_webpack_require_25705__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var core_1 = __importDefault(__nested_webpack_require_25705__(1));\n\n      core_1.default.DefaultOpts.quantizer = 'mmcq';\n      core_1.default.DefaultOpts.generators = ['default'];\n      core_1.default.DefaultOpts.filters = ['default'];\n      exports.default = core_1.default;\n      /***/\n    }, function (module, exports, __nested_webpack_require_26318__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.buildProcessOptions = void 0;\n\n      var utils_1 = __nested_webpack_require_26318__(0);\n\n      function buildProcessOptions(opts, override) {\n        var colorCount = opts.colorCount,\n            quantizer = opts.quantizer,\n            generators = opts.generators,\n            filters = opts.filters; // Merge with common quantizer options\n\n        var commonQuantizerOpts = {\n          colorCount: colorCount\n        };\n        var q = typeof quantizer === 'string' ? {\n          name: quantizer,\n          options: {}\n        } : quantizer;\n        q.options = utils_1.assignDeep({}, commonQuantizerOpts, q.options);\n        return utils_1.assignDeep({}, {\n          quantizer: q,\n          generators: generators,\n          filters: filters\n        }, override);\n      }\n\n      exports.buildProcessOptions = buildProcessOptions;\n      /***/\n    }, function (module, exports, __nested_webpack_require_27325__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _1 = __importDefault(__nested_webpack_require_27325__(1));\n\n      var utils_1 = __nested_webpack_require_27325__(0);\n\n      var Builder = function () {\n        function Builder(src, opts) {\n          if (opts === void 0) {\n            opts = {};\n          }\n\n          this._src = src;\n          this._opts = utils_1.assignDeep({}, _1.default.DefaultOpts, opts);\n        }\n\n        Builder.prototype.maxColorCount = function (n) {\n          this._opts.colorCount = n;\n          return this;\n        };\n\n        Builder.prototype.maxDimension = function (d) {\n          this._opts.maxDimension = d;\n          return this;\n        };\n\n        Builder.prototype.addFilter = function (name) {\n          if (!this._opts.filters) {\n            this._opts.filters = [name];\n          } else {\n            this._opts.filters.push(name);\n          }\n\n          return this;\n        };\n\n        Builder.prototype.removeFilter = function (name) {\n          if (this._opts.filters) {\n            var i = this._opts.filters.indexOf(name);\n\n            if (i > 0) this._opts.filters.splice(i);\n          }\n\n          return this;\n        };\n\n        Builder.prototype.clearFilters = function () {\n          this._opts.filters = [];\n          return this;\n        };\n\n        Builder.prototype.quality = function (q) {\n          this._opts.quality = q;\n          return this;\n        };\n\n        Builder.prototype.useImageClass = function (imageClass) {\n          this._opts.ImageClass = imageClass;\n          return this;\n        };\n\n        Builder.prototype.useGenerator = function (generator, options) {\n          if (!this._opts.generators) this._opts.generators = [];\n\n          this._opts.generators.push(options ? {\n            name: generator,\n            options: options\n          } : generator);\n\n          return this;\n        };\n\n        Builder.prototype.useQuantizer = function (quantizer, options) {\n          this._opts.quantizer = options ? {\n            name: quantizer,\n            options: options\n          } : quantizer;\n          return this;\n        };\n\n        Builder.prototype.build = function () {\n          return new _1.default(this._src, this._opts);\n        };\n\n        Builder.prototype.getPalette = function (cb) {\n          return this.build().getPalette(cb);\n        };\n\n        Builder.prototype.getSwatches = function (cb) {\n          return this.build().getPalette(cb);\n        };\n\n        return Builder;\n      }();\n\n      exports.default = Builder;\n      /***/\n    }, function (module, exports, __nested_webpack_require_30130__) {\n      \"use strict\";\n\n      var __extends = this && this.__extends || function () {\n        var extendStatics = function (d, b) {\n          extendStatics = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (d, b) {\n            d.__proto__ = b;\n          } || function (d, b) {\n            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n          };\n\n          return extendStatics(d, b);\n        };\n\n        return function (d, b) {\n          extendStatics(d, b);\n\n          function __() {\n            this.constructor = d;\n          }\n\n          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n      }();\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var image_1 = __nested_webpack_require_30130__(2);\n\n      function isRelativeUrl(url) {\n        var u = new URL(url, location.href);\n        return u.protocol === location.protocol && u.host === location.host && u.port === location.port;\n      }\n\n      function isSameOrigin(a, b) {\n        var ua = new URL(a);\n        var ub = new URL(b); // https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\n\n        return ua.protocol === ub.protocol && ua.hostname === ub.hostname && ua.port === ub.port;\n      }\n\n      var BrowserImage = function (_super) {\n        __extends(BrowserImage, _super);\n\n        function BrowserImage() {\n          return _super !== null && _super.apply(this, arguments) || this;\n        }\n\n        BrowserImage.prototype._initCanvas = function () {\n          var img = this.image;\n          var canvas = this._canvas = document.createElement('canvas');\n          var context = canvas.getContext('2d');\n          if (!context) throw new ReferenceError('Failed to create canvas context');\n          this._context = context;\n          canvas.className = '@vibrant/canvas';\n          canvas.style.display = 'none';\n          this._width = canvas.width = img.width;\n          this._height = canvas.height = img.height;\n          context.drawImage(img, 0, 0);\n          document.body.appendChild(canvas);\n        };\n\n        BrowserImage.prototype.load = function (image) {\n          var _this = this;\n\n          var img;\n          var src;\n\n          if (typeof image === 'string') {\n            img = document.createElement('img');\n            src = image;\n\n            if (!isRelativeUrl(src) && !isSameOrigin(window.location.href, src)) {\n              img.crossOrigin = 'anonymous';\n            }\n\n            img.src = src;\n          } else if (image instanceof HTMLImageElement) {\n            img = image;\n            src = image.src;\n          } else {\n            return Promise.reject(new Error(\"Cannot load buffer as an image in browser\"));\n          }\n\n          this.image = img;\n          return new Promise(function (resolve, reject) {\n            var onImageLoad = function () {\n              _this._initCanvas();\n\n              resolve(_this);\n            };\n\n            if (img.complete) {\n              // Already loaded\n              onImageLoad();\n            } else {\n              img.onload = onImageLoad;\n\n              img.onerror = function (e) {\n                return reject(new Error(\"Fail to load image: \" + src));\n              };\n            }\n          });\n        };\n\n        BrowserImage.prototype.clear = function () {\n          this._context.clearRect(0, 0, this._width, this._height);\n        };\n\n        BrowserImage.prototype.update = function (imageData) {\n          this._context.putImageData(imageData, 0, 0);\n        };\n\n        BrowserImage.prototype.getWidth = function () {\n          return this._width;\n        };\n\n        BrowserImage.prototype.getHeight = function () {\n          return this._height;\n        };\n\n        BrowserImage.prototype.resize = function (targetWidth, targetHeight, ratio) {\n          var _a = this,\n              canvas = _a._canvas,\n              context = _a._context,\n              img = _a.image;\n\n          this._width = canvas.width = targetWidth;\n          this._height = canvas.height = targetHeight;\n          context.scale(ratio, ratio);\n          context.drawImage(img, 0, 0);\n        };\n\n        BrowserImage.prototype.getPixelCount = function () {\n          return this._width * this._height;\n        };\n\n        BrowserImage.prototype.getImageData = function () {\n          return this._context.getImageData(0, 0, this._width, this._height);\n        };\n\n        BrowserImage.prototype.remove = function () {\n          if (this._canvas && this._canvas.parentNode) {\n            this._canvas.parentNode.removeChild(this._canvas);\n          }\n        };\n\n        return BrowserImage;\n      }(image_1.ImageBase);\n\n      exports.default = BrowserImage;\n      /***/\n    }, function (module, exports, __nested_webpack_require_34959__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n\n      var Vibrant = __nested_webpack_require_34959__(5);\n\n      var pipeline_1 = __importDefault(__nested_webpack_require_34959__(11));\n\n      Vibrant.use(pipeline_1.default);\n      module.exports = Vibrant;\n      /***/\n    }, function (module, exports, __nested_webpack_require_35401__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var quantizer_mmcq_1 = __importDefault(__nested_webpack_require_35401__(12));\n\n      var generator_default_1 = __importDefault(__nested_webpack_require_35401__(16));\n\n      var pipeline_1 = __nested_webpack_require_35401__(17);\n\n      var pipeline = new pipeline_1.BasicPipeline().filter.register('default', function (r, g, b, a) {\n        return a >= 125 && !(r > 250 && g > 250 && b > 250);\n      }).quantizer.register('mmcq', quantizer_mmcq_1.default).generator.register('default', generator_default_1.default);\n      exports.default = pipeline;\n      /***/\n    }, function (module, exports, __nested_webpack_require_36261__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var color_1 = __nested_webpack_require_36261__(3);\n\n      var vbox_1 = __importDefault(__nested_webpack_require_36261__(13));\n\n      var pqueue_1 = __importDefault(__nested_webpack_require_36261__(15));\n\n      var fractByPopulations = 0.75;\n\n      function _splitBoxes(pq, target) {\n        var lastSize = pq.size();\n\n        while (pq.size() < target) {\n          var vbox = pq.pop();\n\n          if (vbox && vbox.count() > 0) {\n            var _a = vbox.split(),\n                vbox1 = _a[0],\n                vbox2 = _a[1];\n\n            pq.push(vbox1);\n            if (vbox2 && vbox2.count() > 0) pq.push(vbox2); // No more new boxes, converged\n\n            if (pq.size() === lastSize) {\n              break;\n            } else {\n              lastSize = pq.size();\n            }\n          } else {\n            break;\n          }\n        }\n      }\n\n      var MMCQ = function (pixels, opts) {\n        if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n          throw new Error('Wrong MMCQ parameters');\n        }\n\n        var vbox = vbox_1.default.build(pixels);\n        var colorCount = vbox.histogram.colorCount;\n        var pq = new pqueue_1.default(function (a, b) {\n          return a.count() - b.count();\n        });\n        pq.push(vbox); // first set of colors, sorted by population\n\n        _splitBoxes(pq, fractByPopulations * opts.colorCount); // Re-order\n\n\n        var pq2 = new pqueue_1.default(function (a, b) {\n          return a.count() * a.volume() - b.count() * b.volume();\n        });\n        pq2.contents = pq.contents; // next set - generate the median cuts using the (npix * vol) sorting.\n\n        _splitBoxes(pq2, opts.colorCount - pq2.size()); // calculate the actual colors\n\n\n        return generateSwatches(pq2);\n      };\n\n      function generateSwatches(pq) {\n        var swatches = [];\n\n        while (pq.size()) {\n          var v = pq.pop();\n          var color = v.avg();\n          var r = color[0],\n              g = color[1],\n              b = color[2];\n          swatches.push(new color_1.Swatch(color, v.count()));\n        }\n\n        return swatches;\n      }\n\n      exports.default = MMCQ;\n      /***/\n    }, function (module, exports, __nested_webpack_require_38722__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var histogram_1 = __importDefault(__nested_webpack_require_38722__(14));\n\n      var SIGBITS = 5;\n      var RSHIFT = 8 - SIGBITS;\n\n      var VBox = function () {\n        function VBox(r1, r2, g1, g2, b1, b2, histogram) {\n          this.histogram = histogram;\n          this._volume = -1;\n          this._count = -1; // NOTE: dimension will be mutated by split operation.\n          //       It must be specified explicitly, not from histogram\n\n          this.dimension = {\n            r1: r1,\n            r2: r2,\n            g1: g1,\n            g2: g2,\n            b1: b1,\n            b2: b2\n          };\n        }\n\n        VBox.build = function (pixels) {\n          var h = new histogram_1.default(pixels, {\n            sigBits: SIGBITS\n          });\n          var rmin = h.rmin,\n              rmax = h.rmax,\n              gmin = h.gmin,\n              gmax = h.gmax,\n              bmin = h.bmin,\n              bmax = h.bmax;\n          return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, h);\n        };\n\n        VBox.prototype.invalidate = function () {\n          this._volume = this._count = -1;\n          this._avg = null;\n        };\n\n        VBox.prototype.volume = function () {\n          if (this._volume < 0) {\n            var _a = this.dimension,\n                r1 = _a.r1,\n                r2 = _a.r2,\n                g1 = _a.g1,\n                g2 = _a.g2,\n                b1 = _a.b1,\n                b2 = _a.b2;\n            this._volume = (r2 - r1 + 1) * (g2 - g1 + 1) * (b2 - b1 + 1);\n          }\n\n          return this._volume;\n        };\n\n        VBox.prototype.count = function () {\n          if (this._count < 0) {\n            var _a = this.histogram,\n                hist = _a.hist,\n                getColorIndex = _a.getColorIndex;\n            var _b = this.dimension,\n                r1 = _b.r1,\n                r2 = _b.r2,\n                g1 = _b.g1,\n                g2 = _b.g2,\n                b1 = _b.b1,\n                b2 = _b.b2;\n            var c = 0;\n\n            for (var r = r1; r <= r2; r++) {\n              for (var g = g1; g <= g2; g++) {\n                for (var b = b1; b <= b2; b++) {\n                  var index = getColorIndex(r, g, b);\n                  c += hist[index];\n                }\n              }\n            }\n\n            this._count = c;\n          }\n\n          return this._count;\n        };\n\n        VBox.prototype.clone = function () {\n          var histogram = this.histogram;\n          var _a = this.dimension,\n              r1 = _a.r1,\n              r2 = _a.r2,\n              g1 = _a.g1,\n              g2 = _a.g2,\n              b1 = _a.b1,\n              b2 = _a.b2;\n          return new VBox(r1, r2, g1, g2, b1, b2, histogram);\n        };\n\n        VBox.prototype.avg = function () {\n          if (!this._avg) {\n            var _a = this.histogram,\n                hist = _a.hist,\n                getColorIndex = _a.getColorIndex;\n            var _b = this.dimension,\n                r1 = _b.r1,\n                r2 = _b.r2,\n                g1 = _b.g1,\n                g2 = _b.g2,\n                b1 = _b.b1,\n                b2 = _b.b2;\n            var ntot = 0;\n            var mult = 1 << 8 - SIGBITS;\n            var rsum = void 0;\n            var gsum = void 0;\n            var bsum = void 0;\n            rsum = gsum = bsum = 0;\n\n            for (var r = r1; r <= r2; r++) {\n              for (var g = g1; g <= g2; g++) {\n                for (var b = b1; b <= b2; b++) {\n                  var index = getColorIndex(r, g, b);\n                  var h = hist[index];\n                  ntot += h;\n                  rsum += h * (r + 0.5) * mult;\n                  gsum += h * (g + 0.5) * mult;\n                  bsum += h * (b + 0.5) * mult;\n                }\n              }\n            }\n\n            if (ntot) {\n              this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n            } else {\n              this._avg = [~~(mult * (r1 + r2 + 1) / 2), ~~(mult * (g1 + g2 + 1) / 2), ~~(mult * (b1 + b2 + 1) / 2)];\n            }\n          }\n\n          return this._avg;\n        };\n\n        VBox.prototype.contains = function (rgb) {\n          var r = rgb[0],\n              g = rgb[1],\n              b = rgb[2];\n          var _a = this.dimension,\n              r1 = _a.r1,\n              r2 = _a.r2,\n              g1 = _a.g1,\n              g2 = _a.g2,\n              b1 = _a.b1,\n              b2 = _a.b2;\n          r >>= RSHIFT;\n          g >>= RSHIFT;\n          b >>= RSHIFT;\n          return r >= r1 && r <= r2 && g >= g1 && g <= g2 && b >= b1 && b <= b2;\n        };\n\n        VBox.prototype.split = function () {\n          var _a = this.histogram,\n              hist = _a.hist,\n              getColorIndex = _a.getColorIndex;\n          var _b = this.dimension,\n              r1 = _b.r1,\n              r2 = _b.r2,\n              g1 = _b.g1,\n              g2 = _b.g2,\n              b1 = _b.b1,\n              b2 = _b.b2;\n          var count = this.count();\n          if (!count) return [];\n          if (count === 1) return [this.clone()];\n          var rw = r2 - r1 + 1;\n          var gw = g2 - g1 + 1;\n          var bw = b2 - b1 + 1;\n          var maxw = Math.max(rw, gw, bw);\n          var accSum = null;\n          var sum;\n          var total;\n          sum = total = 0;\n          var maxd = null;\n\n          if (maxw === rw) {\n            maxd = 'r';\n            accSum = new Uint32Array(r2 + 1);\n\n            for (var r = r1; r <= r2; r++) {\n              sum = 0;\n\n              for (var g = g1; g <= g2; g++) {\n                for (var b = b1; b <= b2; b++) {\n                  var index = getColorIndex(r, g, b);\n                  sum += hist[index];\n                }\n              }\n\n              total += sum;\n              accSum[r] = total;\n            }\n          } else if (maxw === gw) {\n            maxd = 'g';\n            accSum = new Uint32Array(g2 + 1);\n\n            for (var g = g1; g <= g2; g++) {\n              sum = 0;\n\n              for (var r = r1; r <= r2; r++) {\n                for (var b = b1; b <= b2; b++) {\n                  var index = getColorIndex(r, g, b);\n                  sum += hist[index];\n                }\n              }\n\n              total += sum;\n              accSum[g] = total;\n            }\n          } else {\n            maxd = 'b';\n            accSum = new Uint32Array(b2 + 1);\n\n            for (var b = b1; b <= b2; b++) {\n              sum = 0;\n\n              for (var r = r1; r <= r2; r++) {\n                for (var g = g1; g <= g2; g++) {\n                  var index = getColorIndex(r, g, b);\n                  sum += hist[index];\n                }\n              }\n\n              total += sum;\n              accSum[b] = total;\n            }\n          }\n\n          var splitPoint = -1;\n          var reverseSum = new Uint32Array(accSum.length);\n\n          for (var i = 0; i < accSum.length; i++) {\n            var d = accSum[i];\n            if (splitPoint < 0 && d > total / 2) splitPoint = i;\n            reverseSum[i] = total - d;\n          }\n\n          var vbox = this;\n\n          function doCut(d) {\n            var dim1 = d + '1';\n            var dim2 = d + '2';\n            var d1 = vbox.dimension[dim1];\n            var d2 = vbox.dimension[dim2];\n            var vbox1 = vbox.clone();\n            var vbox2 = vbox.clone();\n            var left = splitPoint - d1;\n            var right = d2 - splitPoint;\n\n            if (left <= right) {\n              d2 = Math.min(d2 - 1, ~~(splitPoint + right / 2));\n              d2 = Math.max(0, d2);\n            } else {\n              d2 = Math.max(d1, ~~(splitPoint - 1 - left / 2));\n              d2 = Math.min(vbox.dimension[dim2], d2);\n            }\n\n            while (!accSum[d2]) d2++;\n\n            var c2 = reverseSum[d2];\n\n            while (!c2 && accSum[d2 - 1]) c2 = reverseSum[--d2];\n\n            vbox1.dimension[dim2] = d2;\n            vbox2.dimension[dim1] = d2 + 1;\n            return [vbox1, vbox2];\n          }\n\n          return doCut(maxd);\n        };\n\n        return VBox;\n      }();\n\n      exports.default = VBox;\n      /***/\n    }, function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var Histogram = function () {\n        function Histogram(pixels, opts) {\n          this.pixels = pixels;\n          this.opts = opts;\n          var sigBits = opts.sigBits;\n\n          var getColorIndex = function (r, g, b) {\n            return (r << 2 * sigBits) + (g << sigBits) + b;\n          };\n\n          this.getColorIndex = getColorIndex;\n          var rshift = 8 - sigBits;\n          var hn = 1 << 3 * sigBits;\n          var hist = new Uint32Array(hn);\n          var rmax;\n          var rmin;\n          var gmax;\n          var gmin;\n          var bmax;\n          var bmin;\n          var r;\n          var g;\n          var b;\n          var a;\n          rmax = gmax = bmax = 0;\n          rmin = gmin = bmin = Number.MAX_VALUE;\n          var n = pixels.length / 4;\n          var i = 0;\n\n          while (i < n) {\n            var offset = i * 4;\n            i++;\n            r = pixels[offset + 0];\n            g = pixels[offset + 1];\n            b = pixels[offset + 2];\n            a = pixels[offset + 3]; // Ignored pixels' alpha is marked as 0 in filtering stage\n\n            if (a === 0) continue;\n            r = r >> rshift;\n            g = g >> rshift;\n            b = b >> rshift;\n            var index = getColorIndex(r, g, b);\n            hist[index] += 1;\n            if (r > rmax) rmax = r;\n            if (r < rmin) rmin = r;\n            if (g > gmax) gmax = g;\n            if (g < gmin) gmin = g;\n            if (b > bmax) bmax = b;\n            if (b < bmin) bmin = b;\n          }\n\n          this._colorCount = hist.reduce(function (total, c) {\n            return c > 0 ? total + 1 : total;\n          }, 0);\n          this.hist = hist;\n          this.rmax = rmax;\n          this.rmin = rmin;\n          this.gmax = gmax;\n          this.gmin = gmin;\n          this.bmax = bmax;\n          this.bmin = bmin;\n        }\n\n        Object.defineProperty(Histogram.prototype, \"colorCount\", {\n          get: function () {\n            return this._colorCount;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        return Histogram;\n      }();\n\n      exports.default = Histogram;\n      /***/\n    }, function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var PQueue = function () {\n        function PQueue(comparator) {\n          this._comparator = comparator;\n          this.contents = [];\n          this._sorted = false;\n        }\n\n        PQueue.prototype._sort = function () {\n          if (!this._sorted) {\n            this.contents.sort(this._comparator);\n            this._sorted = true;\n          }\n        };\n\n        PQueue.prototype.push = function (item) {\n          this.contents.push(item);\n          this._sorted = false;\n        };\n\n        PQueue.prototype.peek = function (index) {\n          this._sort();\n\n          index = typeof index === 'number' ? index : this.contents.length - 1;\n          return this.contents[index];\n        };\n\n        PQueue.prototype.pop = function () {\n          this._sort();\n\n          return this.contents.pop();\n        };\n\n        PQueue.prototype.size = function () {\n          return this.contents.length;\n        };\n\n        PQueue.prototype.map = function (mapper) {\n          this._sort();\n\n          return this.contents.map(mapper);\n        };\n\n        return PQueue;\n      }();\n\n      exports.default = PQueue;\n      /***/\n    }, function (module, exports, __nested_webpack_require_50656__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var color_1 = __nested_webpack_require_50656__(3);\n\n      var converter_1 = __nested_webpack_require_50656__(4);\n\n      var DefaultOpts = {\n        targetDarkLuma: 0.26,\n        maxDarkLuma: 0.45,\n        minLightLuma: 0.55,\n        targetLightLuma: 0.74,\n        minNormalLuma: 0.3,\n        targetNormalLuma: 0.5,\n        maxNormalLuma: 0.7,\n        targetMutesSaturation: 0.3,\n        maxMutesSaturation: 0.4,\n        targetVibrantSaturation: 1.0,\n        minVibrantSaturation: 0.35,\n        weightSaturation: 3,\n        weightLuma: 6.5,\n        weightPopulation: 0.5\n      };\n\n      function _findMaxPopulation(swatches) {\n        var p = 0;\n        swatches.forEach(function (s) {\n          p = Math.max(p, s.population);\n        });\n        return p;\n      }\n\n      function _isAlreadySelected(palette, s) {\n        return palette.Vibrant === s || palette.DarkVibrant === s || palette.LightVibrant === s || palette.Muted === s || palette.DarkMuted === s || palette.LightMuted === s;\n      }\n\n      function _createComparisonValue(saturation, targetSaturation, luma, targetLuma, population, maxPopulation, opts) {\n        function weightedMean() {\n          var values = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            values[_i] = arguments[_i];\n          }\n\n          var sum = 0;\n          var weightSum = 0;\n\n          for (var i = 0; i < values.length; i += 2) {\n            var value = values[i];\n            var weight = values[i + 1];\n            sum += value * weight;\n            weightSum += weight;\n          }\n\n          return sum / weightSum;\n        }\n\n        function invertDiff(value, targetValue) {\n          return 1 - Math.abs(value - targetValue);\n        }\n\n        return weightedMean(invertDiff(saturation, targetSaturation), opts.weightSaturation, invertDiff(luma, targetLuma), opts.weightLuma, population / maxPopulation, opts.weightPopulation);\n      }\n\n      function _findColorVariation(palette, swatches, maxPopulation, targetLuma, minLuma, maxLuma, targetSaturation, minSaturation, maxSaturation, opts) {\n        var max = null;\n        var maxValue = 0;\n        swatches.forEach(function (swatch) {\n          var _a = swatch.hsl,\n              s = _a[1],\n              l = _a[2];\n\n          if (s >= minSaturation && s <= maxSaturation && l >= minLuma && l <= maxLuma && !_isAlreadySelected(palette, swatch)) {\n            var value = _createComparisonValue(s, targetSaturation, l, targetLuma, swatch.population, maxPopulation, opts);\n\n            if (max === null || value > maxValue) {\n              max = swatch;\n              maxValue = value;\n            }\n          }\n        });\n        return max;\n      }\n\n      function _generateVariationColors(swatches, maxPopulation, opts) {\n        var palette = {\n          Vibrant: null,\n          DarkVibrant: null,\n          LightVibrant: null,\n          Muted: null,\n          DarkMuted: null,\n          LightMuted: null\n        }; // mVibrantSwatch = findColor(TARGET_NORMAL_LUMA, MIN_NORMAL_LUMA, MAX_NORMAL_LUMA,\n        //     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n\n        palette.Vibrant = _findColorVariation(palette, swatches, maxPopulation, opts.targetNormalLuma, opts.minNormalLuma, opts.maxNormalLuma, opts.targetVibrantSaturation, opts.minVibrantSaturation, 1, opts); // mLightVibrantSwatch = findColor(TARGET_LIGHT_LUMA, MIN_LIGHT_LUMA, 1f,\n        //     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n\n        palette.LightVibrant = _findColorVariation(palette, swatches, maxPopulation, opts.targetLightLuma, opts.minLightLuma, 1, opts.targetVibrantSaturation, opts.minVibrantSaturation, 1, opts); // mDarkVibrantSwatch = findColor(TARGET_DARK_LUMA, 0f, MAX_DARK_LUMA,\n        //     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n\n        palette.DarkVibrant = _findColorVariation(palette, swatches, maxPopulation, opts.targetDarkLuma, 0, opts.maxDarkLuma, opts.targetVibrantSaturation, opts.minVibrantSaturation, 1, opts); // mMutedSwatch = findColor(TARGET_NORMAL_LUMA, MIN_NORMAL_LUMA, MAX_NORMAL_LUMA,\n        //     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n\n        palette.Muted = _findColorVariation(palette, swatches, maxPopulation, opts.targetNormalLuma, opts.minNormalLuma, opts.maxNormalLuma, opts.targetMutesSaturation, 0, opts.maxMutesSaturation, opts); // mLightMutedColor = findColor(TARGET_LIGHT_LUMA, MIN_LIGHT_LUMA, 1f,\n        //     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n\n        palette.LightMuted = _findColorVariation(palette, swatches, maxPopulation, opts.targetLightLuma, opts.minLightLuma, 1, opts.targetMutesSaturation, 0, opts.maxMutesSaturation, opts); // mDarkMutedSwatch = findColor(TARGET_DARK_LUMA, 0f, MAX_DARK_LUMA,\n        //     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n\n        palette.DarkMuted = _findColorVariation(palette, swatches, maxPopulation, opts.targetDarkLuma, 0, opts.maxDarkLuma, opts.targetMutesSaturation, 0, opts.maxMutesSaturation, opts);\n        return palette;\n      }\n\n      function _generateEmptySwatches(palette, maxPopulation, opts) {\n        if (!palette.Vibrant && !palette.DarkVibrant && !palette.LightVibrant) {\n          if (!palette.DarkVibrant && palette.DarkMuted) {\n            var _a = palette.DarkMuted.hsl,\n                h = _a[0],\n                s = _a[1],\n                l = _a[2];\n            l = opts.targetDarkLuma;\n            palette.DarkVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n          }\n\n          if (!palette.LightVibrant && palette.LightMuted) {\n            var _b = palette.LightMuted.hsl,\n                h = _b[0],\n                s = _b[1],\n                l = _b[2];\n            l = opts.targetDarkLuma;\n            palette.DarkVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n          }\n        }\n\n        if (!palette.Vibrant && palette.DarkVibrant) {\n          var _c = palette.DarkVibrant.hsl,\n              h = _c[0],\n              s = _c[1],\n              l = _c[2];\n          l = opts.targetNormalLuma;\n          palette.Vibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        } else if (!palette.Vibrant && palette.LightVibrant) {\n          var _d = palette.LightVibrant.hsl,\n              h = _d[0],\n              s = _d[1],\n              l = _d[2];\n          l = opts.targetNormalLuma;\n          palette.Vibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n\n        if (!palette.DarkVibrant && palette.Vibrant) {\n          var _e = palette.Vibrant.hsl,\n              h = _e[0],\n              s = _e[1],\n              l = _e[2];\n          l = opts.targetDarkLuma;\n          palette.DarkVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n\n        if (!palette.LightVibrant && palette.Vibrant) {\n          var _f = palette.Vibrant.hsl,\n              h = _f[0],\n              s = _f[1],\n              l = _f[2];\n          l = opts.targetLightLuma;\n          palette.LightVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n\n        if (!palette.Muted && palette.Vibrant) {\n          var _g = palette.Vibrant.hsl,\n              h = _g[0],\n              s = _g[1],\n              l = _g[2];\n          l = opts.targetMutesSaturation;\n          palette.Muted = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n\n        if (!palette.DarkMuted && palette.DarkVibrant) {\n          var _h = palette.DarkVibrant.hsl,\n              h = _h[0],\n              s = _h[1],\n              l = _h[2];\n          l = opts.targetMutesSaturation;\n          palette.DarkMuted = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n\n        if (!palette.LightMuted && palette.LightVibrant) {\n          var _j = palette.LightVibrant.hsl,\n              h = _j[0],\n              s = _j[1],\n              l = _j[2];\n          l = opts.targetMutesSaturation;\n          palette.LightMuted = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n      }\n\n      var DefaultGenerator = function (swatches, opts) {\n        opts = Object.assign({}, DefaultOpts, opts);\n\n        var maxPopulation = _findMaxPopulation(swatches);\n\n        var palette = _generateVariationColors(swatches, maxPopulation, opts);\n\n        _generateEmptySwatches(palette, maxPopulation, opts);\n\n        return palette;\n      };\n\n      exports.default = DefaultGenerator;\n      /***/\n    }, function (module, exports, __nested_webpack_require_59182__) {\n      \"use strict\";\n\n      var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function (resolve) {\n            resolve(value);\n          });\n        }\n\n        return new (P || (P = Promise))(function (resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n\n      var __generator = this && this.__generator || function (thisArg, body) {\n        var _ = {\n          label: 0,\n          sent: function () {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n          },\n          trys: [],\n          ops: []\n        },\n            f,\n            y,\n            t,\n            g;\n        return g = {\n          next: verb(0),\n          \"throw\": verb(1),\n          \"return\": verb(2)\n        }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n          return this;\n        }), g;\n\n        function verb(n) {\n          return function (v) {\n            return step([n, v]);\n          };\n        }\n\n        function step(op) {\n          if (f) throw new TypeError(\"Generator is already executing.\");\n\n          while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n\n              case 4:\n                _.label++;\n                return {\n                  value: op[1],\n                  done: false\n                };\n\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n\n              case 7:\n                op = _.ops.pop();\n\n                _.trys.pop();\n\n                continue;\n\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n\n                  _.ops.push(op);\n\n                  break;\n                }\n\n                if (t[2]) _.ops.pop();\n\n                _.trys.pop();\n\n                continue;\n            }\n\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n\n          if (op[0] & 5) throw op[1];\n          return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n          };\n        }\n      };\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.BasicPipeline = exports.Stage = void 0;\n\n      var image_1 = __nested_webpack_require_59182__(2);\n\n      var Stage = function () {\n        function Stage(pipeline) {\n          this.pipeline = pipeline;\n          this._map = {};\n        }\n\n        Stage.prototype.names = function () {\n          return Object.keys(this._map);\n        };\n\n        Stage.prototype.has = function (name) {\n          return !!this._map[name];\n        };\n\n        Stage.prototype.get = function (name) {\n          return this._map[name];\n        };\n\n        Stage.prototype.register = function (name, stageFn) {\n          this._map[name] = stageFn;\n          return this.pipeline;\n        };\n\n        return Stage;\n      }();\n\n      exports.Stage = Stage;\n\n      var BasicPipeline = function () {\n        function BasicPipeline() {\n          this.filter = new Stage(this);\n          this.quantizer = new Stage(this);\n          this.generator = new Stage(this);\n        }\n\n        BasicPipeline.prototype._buildProcessTasks = function (_a) {\n          var _this = this;\n\n          var filters = _a.filters,\n              quantizer = _a.quantizer,\n              generators = _a.generators; // Support wildcard for generators\n\n          if (generators.length === 1 && generators[0] === '*') {\n            generators = this.generator.names();\n          }\n\n          return {\n            filters: filters.map(function (f) {\n              return createTask(_this.filter, f);\n            }),\n            quantizer: createTask(this.quantizer, quantizer),\n            generators: generators.map(function (g) {\n              return createTask(_this.generator, g);\n            })\n          };\n\n          function createTask(stage, o) {\n            var name;\n            var options;\n\n            if (typeof o === 'string') {\n              name = o;\n            } else {\n              name = o.name;\n              options = o.options;\n            }\n\n            return {\n              name: name,\n              fn: stage.get(name),\n              options: options\n            };\n          }\n        };\n\n        BasicPipeline.prototype.process = function (imageData, opts) {\n          return __awaiter(this, void 0, void 0, function () {\n            var _a, filters, quantizer, generators, imageFilterData, colors, palettes;\n\n            return __generator(this, function (_b) {\n              switch (_b.label) {\n                case 0:\n                  _a = this._buildProcessTasks(opts), filters = _a.filters, quantizer = _a.quantizer, generators = _a.generators;\n                  return [4\n                  /*yield*/\n                  , this._filterColors(filters, imageData)];\n\n                case 1:\n                  imageFilterData = _b.sent();\n                  return [4\n                  /*yield*/\n                  , this._generateColors(quantizer, imageFilterData)];\n\n                case 2:\n                  colors = _b.sent();\n                  return [4\n                  /*yield*/\n                  , this._generatePalettes(generators, colors)];\n\n                case 3:\n                  palettes = _b.sent();\n                  return [2\n                  /*return*/\n                  , {\n                    colors: colors,\n                    palettes: palettes\n                  }];\n              }\n            });\n          });\n        };\n\n        BasicPipeline.prototype._filterColors = function (filters, imageData) {\n          return Promise.resolve(image_1.applyFilters(imageData, filters.map(function (_a) {\n            var fn = _a.fn;\n            return fn;\n          })));\n        };\n\n        BasicPipeline.prototype._generateColors = function (quantizer, imageData) {\n          return Promise.resolve(quantizer.fn(imageData.data, quantizer.options));\n        };\n\n        BasicPipeline.prototype._generatePalettes = function (generators, colors) {\n          return __awaiter(this, void 0, void 0, function () {\n            var promiseArr;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4\n                  /*yield*/\n                  , Promise.all(generators.map(function (_a) {\n                    var fn = _a.fn,\n                        options = _a.options;\n                    return Promise.resolve(fn(colors, options));\n                  })) // Map the values to the expected name\n                  ];\n\n                case 1:\n                  promiseArr = _a.sent(); // Map the values to the expected name\n\n                  return [2\n                  /*return*/\n                  , Promise.resolve(promiseArr.reduce(function (promises, promiseVal, i) {\n                    promises[generators[i].name] = promiseVal;\n                    return promises;\n                  }, {}))];\n              }\n            });\n          });\n        };\n\n        return BasicPipeline;\n      }();\n\n      exports.BasicPipeline = BasicPipeline;\n      /***/\n    }])\n  );\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm9kZS12aWJyYW50L2Rpc3QvdmlicmFudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBUUE7QUFDQTs7Ozs7QUNWQTtBQUFBOztBQUNBO0FBQUE7OztBQUVBO0FBQUE7O0FBQ0E7O0FBQUE7OztBQUVBO0FBQUE7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7QUFDQTs7O0FBQUE7QUFDQTtBQUFBOztBQUNBO0FBQUE7O0FBQ0E7QUFBQTtBQUNBOztBQUpBOzs7QUFNQTtBQUFBOztBQUNBOztBQUFBOzs7QUFFQTtBQUFBOztBQUNBOztBQUFBOzs7QUFFQTtBQUFBOztBQUNBOztBQUFBO0FBQ0E7QUFBQTs7Ozs7QUFHQTtBQUFBOztBQUNBOzs7QUFBQTs7O0FBRUE7QUFBQTs7QUFDQTs7QUFBQTs7O0FBRUE7QUFBQTs7QUFDQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOztBQUFBOzs7QUFFQTtBQUFBOztBQUNBOzs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7O0FBRUE7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQUNBOzs7QUFBQTtBQUNBO0FBQUE7QUFDQTs7QUFBQTtBQUNBOztBQUFBO0FBQ0E7O0FBQUE7QUFDQTs7QUFBQTtBQUNBOzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUFBO0FBQ0E7QUFBQTs7O0FBRUE7QUFBQTs7QUFDQTs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7QUFBQTs7O0FBRUE7QUFBQTs7QUFDQTs7O0FBQUE7QUFBQTtBQUFBOzs7QUFFQTtBQUFBOztBQUNBOzs7QUFBQTs7Ozs7QUFHQTtBQUFBOztBQUNBOztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFYQTtBQWFBOzs7QUFHQTs7QUFDQTtBQUFBOztBQUFBO0FBQUE7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbkJBOzs7Ozs7Ozs7Ozs7Ozs7QUNqQkE7O0FBTUE7O0FBRUE7O0FBTUE7QUFxQkE7QUFBQTtBQUNBO0FBQ0E7O0FBcEJBO0FBQ0E7QUFDQTs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7QUFBQTs7QUFRQTtBQUlBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7QUFJQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQU1BO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBekdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUEwR0E7QUFBQTs7QUFoSEE7Ozs7Ozs7Ozs7QUNzQkE7QUFBQTs7QUFXQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBOztBQTFCQTs7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBMUJBOzs7Ozs7Ozs7O0FDaEVBOztBQXlCQTtBQW1KQTtBQUNBO0FBQ0E7QUFDQTs7QUFySkE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7OztBQUdBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBVUE7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUFBO0FBTUE7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUFBO0FBTUE7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUFBO0FBTUE7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUFBO0FBTUE7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQU5BOztBQUFBO0FBV0E7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQU5BOztBQUFBO0FBT0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7QUFBQTtBQUlBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBOzs7QUFHQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBS0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBTEE7O0FBQUE7QUFNQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFMQTs7QUFBQTs7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQU1BO0FBQUE7O0FBdkpBOzs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTs7OztBQUlBOztBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUNBOztBQU5BO0FBUUE7Ozs7OztBQU1BOztBQUNBO0FBQ0E7QUFDQTs7QUFGQTtBQUlBOzs7Ozs7QUFNQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFUQTs7QUFZQTtBQUNBOztBQUNBO0FBQ0E7O0FBM0JBOztBQTZCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUtBOztBQTVCQTs7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQWpCQTs7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQWxCQTs7QUFvQkE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUhBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBOUJBOztBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUpBOztBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBTEE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBOztBQXRCQTs7Ozs7Ozs7Ozs7QUM3TEE7O0FBQ0E7O0FBRUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDTEE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUNEQTs7QUFVQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBZEE7Ozs7Ozs7Ozs7Ozs7OztBQ0FBOztBQUNBOztBQUVBO0FBR0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekZBOztBQVFBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUtBOztBQUVBO0FBQUE7O0FBQUE7O0FBOEZBOztBQXhGQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUN6SEE7O0FBQ0E7O0FBRUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDTEE7O0FBQ0E7O0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBS0E7Ozs7Ozs7Ozs7Ozs7OztBQ1RBOztBQUNBOztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTs7QUFHQTs7O0FBR0E7QUFBQTtBQUFBO0FBQ0E7O0FBR0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ25FQTs7QUFXQTtBQUNBOztBQUVBO0FBYUE7QUFJQTtBQVJBO0FBRUE7QUFTQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBckJBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBRUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBOzs7Ozs7Ozs7OztBQ3BPQTtBQVdBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE3REE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQThEQTtBQUFBOzs7Ozs7Ozs7OztBQ3pFQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7Ozs7Ozs7Ozs7O0FDN0NBOztBQUVBOztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTs7QUFpQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQU1BOztBQUVBO0FBS0E7QUFBQTs7QUFBQTtBQUFBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQU1BOztBQUVBO0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTs7QUFDQTtBQVVBOztBQUNBO0FBVUE7O0FBQ0E7QUFVQTs7QUFDQTtBQVVBOztBQUNBO0FBVUE7O0FBQ0E7QUFTQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaFFBOztBQUtBO0FBRUE7QUFBQTtBQURBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUFoQkE7O0FBb0RBO0FBQUE7QUFtQ0E7QUFDQTtBQUNBO0FBNENBOztBQWhGQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUhBOztBQUtBO0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7O0FBSUE7Ozs7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTs7O0FBQUE7QUFDQTtBQUFBO0FBQUE7OztBQUFBO0FBQ0E7QUFBQTtBQUFBOzs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7OztBQUlBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTs7QUFDQTtBQUlBO0FBQ0E7O0FBQ0E7Ozs7OztBQUtBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBREE7OztBQUFBOztBQUlBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUNBO0FBQUE7O0FBakZBOzs7QW5CL0NBO0FBVkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbj8zYWRiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvd2VicGFjay9ib290c3RyYXA/ZmExNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtY29yZS9zcmMvdXRpbHMudHM/ZWE1ZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtY29yZS9zcmMvaW5kZXgudHM/ZWNlYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtaW1hZ2Uvc3JjL2luZGV4LnRzP2Q2OTMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWNvbG9yL3NyYy9pbmRleC50cz8wYjEwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1jb2xvci9zcmMvY29udmVydGVyLnRzPzYyNGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC9zcmMvYnJvd3Nlci50cz9kYmQ4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvc3JjL2NvbmZpZy50cz9hN2E5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1jb3JlL3NyYy9vcHRpb25zLnRzPzQzOTUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWNvcmUvc3JjL2J1aWxkZXIudHM/ZjU4ZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtaW1hZ2UtYnJvd3Nlci9zcmMvaW5kZXgudHM/NDEzMCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3NyYy9idW5kbGUudHM/NDUzOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3NyYy9waXBlbGluZS9pbmRleC50cz82ODIxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1xdWFudGl6ZXItbW1jcS9zcmMvaW5kZXgudHM/ZjNiYiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtcXVhbnRpemVyLW1tY3Evc3JjL3Zib3gudHM/MTBiYiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtaW1hZ2Uvc3JjL2hpc3RvZ3JhbS50cz9iMWJkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1xdWFudGl6ZXItbW1jcS9zcmMvcHF1ZXVlLnRzP2FkYzYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWdlbmVyYXRvci1kZWZhdWx0L3NyYy9pbmRleC50cz81MjgyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1jb3JlL3NyYy9waXBlbGluZS9pbmRleC50cz8wY2Y1Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlZpYnJhbnRcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiVmlicmFudFwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEwKTtcbiIsImV4cG9ydCBmdW5jdGlvbiBtYXBWYWx1ZXM8VCwgUj4gKG86IHsgW2tleTogc3RyaW5nXTogVCB9LCBtYXBwZXI6ICh2OiBUKSA9PiBSKTogeyBba2V5OiBzdHJpbmddOiBSIH0ge1xuICBsZXQgcmVzdWx0OiB7IFtrZXk6IHN0cmluZ106IFIgfSA9IHt9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnN0IHYgPSBvW2tleV1cbiAgICAgIHJlc3VsdFtrZXldID0gbWFwcGVyKHYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIE92ZXJ3cml0ZSB2YWx1ZXMgb3IgcHJvcGVydGllcyBvbiBvYmplY3RzIGFuZCBsaXN0cyByZWN1cnNpdmVseS5cbiAqIEEgc2hhbGxvdyBjb3B5IHdpbGwgYmUgY3JlYXRlZCBmb3IgZWFjaCBhcnJheSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkRlZXA8VD4gKHRhcmdldDogUGFydGlhbDxUPiwgLi4uc291cmNlczogKFBhcnRpYWw8VD4gfCB1bmRlZmluZWQpW10pOiBUIHtcbiAgc291cmNlcy5mb3JFYWNoKHMgPT4ge1xuICAgIGlmICghcykgcmV0dXJuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcykge1xuICAgICAgaWYgKHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjb25zdCB2ID0gc1trZXldIGFzIGFueVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgIC8vIFNoYWxsb3cgY29weVxuICAgICAgICAgIHRhcmdldFtrZXldID0gdi5zbGljZSgwKSBhcyBhbnlcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAoIXRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHt9IGFzIGFueVxuICAgICAgICAgIGFzc2lnbkRlZXA8YW55Pih0YXJnZXRba2V5XSBhcyBhbnksIHYpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiB0YXJnZXQgYXMgVFxufVxuIiwiaW1wb3J0IHsgT3B0aW9ucywgYnVpbGRQcm9jZXNzT3B0aW9ucyB9IGZyb20gJy4vb3B0aW9ucydcbmltcG9ydCB7IENhbGxiYWNrIH0gZnJvbSAnQHZpYnJhbnQvdHlwZXMnXG5pbXBvcnQgeyBJbWFnZSwgSW1hZ2VTb3VyY2UgfSBmcm9tICdAdmlicmFudC9pbWFnZSdcblxuaW1wb3J0IHsgRmlsdGVyLCBQYWxldHRlLCBTd2F0Y2ggfSBmcm9tICdAdmlicmFudC9jb2xvcidcblxuaW1wb3J0IEJ1aWxkZXIgZnJvbSAnLi9idWlsZGVyJ1xuaW1wb3J0IHsgUGlwZWxpbmUsIFByb2Nlc3NPcHRpb25zLCBQcm9jZXNzUmVzdWx0IH0gZnJvbSAnLi9waXBlbGluZSdcbmltcG9ydCB7IGFzc2lnbkRlZXAgfSBmcm9tICcuL3V0aWxzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFZpYnJhbnRTdGF0aWMge1xuICBmcm9tIChzcmM6IEltYWdlU291cmNlKTogQnVpbGRlclxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWJyYW50IHtcbiAgcHJpdmF0ZSBfcmVzdWx0OiBQcm9jZXNzUmVzdWx0XG4gIHByaXZhdGUgc3RhdGljIF9waXBlbGluZTogUGlwZWxpbmVcbiAgc3RhdGljIHVzZSAocGlwZWxpbmU6IFBpcGVsaW5lKSB7XG4gICAgdGhpcy5fcGlwZWxpbmUgPSBwaXBlbGluZVxuICB9XG4gIHN0YXRpYyBEZWZhdWx0T3B0czogUGFydGlhbDxPcHRpb25zPiA9IHtcbiAgICBjb2xvckNvdW50OiA2NCxcbiAgICBxdWFsaXR5OiA1LFxuICAgIGZpbHRlcnM6IFtdXG4gIH1cblxuICBzdGF0aWMgZnJvbSAoc3JjOiBJbWFnZVNvdXJjZSk6IEJ1aWxkZXIge1xuICAgIHJldHVybiBuZXcgQnVpbGRlcihzcmMpXG4gIH1cblxuICBnZXQgcmVzdWx0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzdWx0XG4gIH1cblxuICBvcHRzOiBPcHRpb25zXG4gIGNvbnN0cnVjdG9yIChwcml2YXRlIF9zcmM6IEltYWdlU291cmNlLCBvcHRzPzogUGFydGlhbDxPcHRpb25zPikge1xuICAgIHRoaXMub3B0cyA9IGFzc2lnbkRlZXAoe30sIFZpYnJhbnQuRGVmYXVsdE9wdHMsIG9wdHMpXG4gIH1cbiAgcHJpdmF0ZSBfcHJvY2VzcyAoXG4gICAgaW1hZ2U6IEltYWdlLFxuICAgIG9wdHM/OiBQYXJ0aWFsPFByb2Nlc3NPcHRpb25zPlxuICApOiBQcm9taXNlPFByb2Nlc3NSZXN1bHQ+IHtcbiAgICBsZXQgeyBxdWFudGl6ZXIgfSA9IHRoaXMub3B0c1xuXG4gICAgaW1hZ2Uuc2NhbGVEb3duKHRoaXMub3B0cylcblxuICAgIGxldCBwcm9jZXNzT3B0cyA9IGJ1aWxkUHJvY2Vzc09wdGlvbnModGhpcy5vcHRzLCBvcHRzKVxuXG4gICAgcmV0dXJuIFZpYnJhbnQuX3BpcGVsaW5lLnByb2Nlc3MoaW1hZ2UuZ2V0SW1hZ2VEYXRhKCksIHByb2Nlc3NPcHRzKVxuICB9XG4gIHBhbGV0dGUgKCk6IFBhbGV0dGUge1xuICAgIHJldHVybiB0aGlzLnN3YXRjaGVzKClcbiAgfVxuICBzd2F0Y2hlcyAoKTogUGFsZXR0ZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ01ldGhvZCBkZXByZWNhdGVkLiBVc2UgYFZpYnJhbnQucmVzdWx0LnBhbGV0dGVzW25hbWVdYCBpbnN0ZWFkJ1xuICAgIClcbiAgfVxuXG4gIGdldFBhbGV0dGUgKG5hbWU6IHN0cmluZywgY2I/OiBDYWxsYmFjazxQYWxldHRlPik6IFByb21pc2U8UGFsZXR0ZT5cbiAgZ2V0UGFsZXR0ZSAoY2I/OiBDYWxsYmFjazxQYWxldHRlPik6IFByb21pc2U8UGFsZXR0ZT5cbiAgZ2V0UGFsZXR0ZSAoKTogUHJvbWlzZTxQYWxldHRlPiB7XG4gICAgY29uc3QgYXJnMCA9IGFyZ3VtZW50c1swXVxuICAgIGNvbnN0IGFyZzEgPSBhcmd1bWVudHNbMV1cbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnID8gYXJnMCA6ICdkZWZhdWx0J1xuICAgIGNvbnN0IGNiID0gdHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnID8gYXJnMSA6IGFyZzBcbiAgICBsZXQgaW1hZ2UgPSBuZXcgdGhpcy5vcHRzLkltYWdlQ2xhc3MoKVxuICAgIHJldHVybiBpbWFnZVxuICAgICAgLmxvYWQodGhpcy5fc3JjKVxuICAgICAgLnRoZW4oaW1hZ2UgPT4gdGhpcy5fcHJvY2VzcyhpbWFnZSwgeyBnZW5lcmF0b3JzOiBbbmFtZV0gfSkpXG4gICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICB0aGlzLl9yZXN1bHQgPSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5wYWxldHRlc1tuYW1lXVxuICAgICAgfSlcbiAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIGltYWdlLnJlbW92ZSgpXG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKHVuZGVmaW5lZCwgcmVzKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaW1hZ2UucmVtb3ZlKClcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gICAgICB9KVxuICB9XG4gIGdldFBhbGV0dGVzIChcbiAgICBuYW1lczogc3RyaW5nW10sXG4gICAgY2I/OiBDYWxsYmFjazxQYWxldHRlPlxuICApOiBQcm9taXNlPHsgW25hbWU6IHN0cmluZ106IFBhbGV0dGUgfT5cbiAgZ2V0UGFsZXR0ZXMgKGNiPzogQ2FsbGJhY2s8UGFsZXR0ZT4pOiBQcm9taXNlPHsgW25hbWU6IHN0cmluZ106IFBhbGV0dGUgfT5cbiAgZ2V0UGFsZXR0ZXMgKCk6IFByb21pc2U8eyBbbmFtZTogc3RyaW5nXTogUGFsZXR0ZSB9PiB7XG4gICAgY29uc3QgYXJnMCA9IGFyZ3VtZW50c1swXVxuICAgIGNvbnN0IGFyZzEgPSBhcmd1bWVudHNbMV1cbiAgICBjb25zdCBuYW1lcyA9IEFycmF5LmlzQXJyYXkoYXJnMCkgPyBhcmcwIDogWycqJ11cbiAgICBjb25zdCBjYiA9IEFycmF5LmlzQXJyYXkoYXJnMCkgPyBhcmcxIDogYXJnMFxuICAgIGxldCBpbWFnZSA9IG5ldyB0aGlzLm9wdHMuSW1hZ2VDbGFzcygpXG4gICAgcmV0dXJuIGltYWdlXG4gICAgICAubG9hZCh0aGlzLl9zcmMpXG4gICAgICAudGhlbihpbWFnZSA9PlxuICAgICAgICB0aGlzLl9wcm9jZXNzKGltYWdlLCB7XG4gICAgICAgICAgZ2VuZXJhdG9yczogbmFtZXNcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdCA9IHJlc3VsdFxuICAgICAgICByZXR1cm4gcmVzdWx0LnBhbGV0dGVzXG4gICAgICB9KVxuICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgaW1hZ2UucmVtb3ZlKClcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IodW5kZWZpbmVkLCByZXMpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpbWFnZS5yZW1vdmUoKVxuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycilcbiAgICAgIH0pXG4gIH1cbn1cbiIsImltcG9ydCB7IENhbGxiYWNrIH0gZnJvbSAnQHZpYnJhbnQvdHlwZXMnXG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICdAdmlicmFudC9jb2xvcidcblxuZXhwb3J0IHR5cGUgSW1hZ2VDYWxsYmFjayA9IENhbGxiYWNrPEltYWdlPlxuXG5leHBvcnQgdHlwZSBJbWFnZVNvdXJjZSA9IHN0cmluZyB8IEhUTUxJbWFnZUVsZW1lbnQgfCBCdWZmZXJcblxuZXhwb3J0IHR5cGUgUGl4ZWxzID0gVWludDhDbGFtcGVkQXJyYXkgfCBCdWZmZXJcbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VEYXRhIHtcbiAgZGF0YTogUGl4ZWxzLFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlT3B0aW9ucyB7XG4gIHF1YWxpdHk6IG51bWJlclxuICBtYXhEaW1lbnNpb246IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlIHtcbiAgbG9hZCAoaW1hZ2U6IEltYWdlU291cmNlKTogUHJvbWlzZTxJbWFnZT5cbiAgY2xlYXIgKCk6IHZvaWRcbiAgdXBkYXRlIChpbWFnZURhdGE6IEltYWdlRGF0YSk6IHZvaWRcbiAgZ2V0V2lkdGggKCk6IG51bWJlclxuICBnZXRIZWlnaHQgKCk6IG51bWJlclxuICByZXNpemUgKHRhcmdldFdpZHRoOiBudW1iZXIsIHRhcmdldEhlaWdodDogbnVtYmVyLCByYXRpbzogbnVtYmVyKTogdm9pZFxuICBnZXRQaXhlbENvdW50ICgpOiBudW1iZXJcbiAgZ2V0SW1hZ2VEYXRhICgpOiBJbWFnZURhdGFcbiAgcmVtb3ZlICgpOiB2b2lkXG4gIHNjYWxlRG93biAob3B0czogSW1hZ2VPcHRpb25zKTogdm9pZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlQ2xhc3Mge1xuICBuZXcoKTogSW1hZ2Vcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEltYWdlQmFzZSBpbXBsZW1lbnRzIEltYWdlIHtcbiAgYWJzdHJhY3QgbG9hZCAoaW1hZ2U6IEltYWdlU291cmNlKTogUHJvbWlzZTxJbWFnZUJhc2U+XG4gIGFic3RyYWN0IGNsZWFyICgpOiB2b2lkXG4gIGFic3RyYWN0IHVwZGF0ZSAoaW1hZ2VEYXRhOiBJbWFnZURhdGEpOiB2b2lkXG4gIGFic3RyYWN0IGdldFdpZHRoICgpOiBudW1iZXJcbiAgYWJzdHJhY3QgZ2V0SGVpZ2h0ICgpOiBudW1iZXJcbiAgYWJzdHJhY3QgcmVzaXplICh0YXJnZXRXaWR0aDogbnVtYmVyLCB0YXJnZXRIZWlnaHQ6IG51bWJlciwgcmF0aW86IG51bWJlcik6IHZvaWRcbiAgYWJzdHJhY3QgZ2V0UGl4ZWxDb3VudCAoKTogbnVtYmVyXG4gIGFic3RyYWN0IGdldEltYWdlRGF0YSAoKTogSW1hZ2VEYXRhXG4gIGFic3RyYWN0IHJlbW92ZSAoKTogdm9pZFxuXG4gIHNjYWxlRG93biAob3B0czogSW1hZ2VPcHRpb25zKTogdm9pZCB7XG4gICAgbGV0IHdpZHRoOiBudW1iZXIgPSB0aGlzLmdldFdpZHRoKClcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXIgPSB0aGlzLmdldEhlaWdodCgpXG5cbiAgICBsZXQgcmF0aW86IG51bWJlciA9IDFcblxuICAgIGlmIChvcHRzLm1heERpbWVuc2lvbiA+IDApIHtcbiAgICAgIGxldCBtYXhTaWRlOiBudW1iZXIgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KVxuICAgICAgaWYgKG1heFNpZGUgPiBvcHRzLm1heERpbWVuc2lvbikgcmF0aW8gPSBvcHRzLm1heERpbWVuc2lvbiAvIG1heFNpZGVcbiAgICB9IGVsc2Uge1xuICAgICAgcmF0aW8gPSAxIC8gb3B0cy5xdWFsaXR5XG4gICAgfVxuXG4gICAgaWYgKHJhdGlvIDwgMSkgdGhpcy5yZXNpemUod2lkdGggKiByYXRpbywgaGVpZ2h0ICogcmF0aW8sIHJhdGlvKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUZpbHRlcnMgKGltYWdlRGF0YTogSW1hZ2VEYXRhLCBmaWx0ZXJzOiBGaWx0ZXJbXSkge1xuICBpZiAoZmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgbGV0IHBpeGVscyA9IGltYWdlRGF0YS5kYXRhXG4gICAgbGV0IG4gPSBwaXhlbHMubGVuZ3RoIC8gNFxuICAgIGxldCBvZmZzZXRcbiAgICBsZXQgclxuICAgIGxldCBnXG4gICAgbGV0IGJcbiAgICBsZXQgYVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBvZmZzZXQgPSBpICogNFxuICAgICAgciA9IHBpeGVsc1tvZmZzZXQgKyAwXVxuICAgICAgZyA9IHBpeGVsc1tvZmZzZXQgKyAxXVxuICAgICAgYiA9IHBpeGVsc1tvZmZzZXQgKyAyXVxuICAgICAgYSA9IHBpeGVsc1tvZmZzZXQgKyAzXVxuICAgICAgLy8gTWFyayBpZ25vcmVkIGNvbG9yXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpbHRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFmaWx0ZXJzW2pdKHIsIGcsIGIsIGEpKSB7XG4gICAgICAgICAgcGl4ZWxzW29mZnNldCArIDNdID0gMFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW1hZ2VEYXRhXG59XG4iLCJpbXBvcnQgeyByZ2JUb0hzbCwgcmdiVG9IZXggfSBmcm9tICcuL2NvbnZlcnRlcidcblxuZXhwb3J0IGludGVyZmFjZSBGaWx0ZXIge1xuICAocmVkOiBudW1iZXIsIGdyZWVuOiBudW1iZXIsIGJsdWU6IG51bWJlciwgYWxwaGE6IG51bWJlcik6IGJvb2xlYW5cbn1cblxuLyoqXG4gKiAzZCBmbG9hdGluZyBwb2ludGVyIHZlY3RvclxuICovXG5leHBvcnQgdHlwZSBWZWMzID0gW251bWJlciwgbnVtYmVyLCBudW1iZXJdXG5cbi8qKlxuICogVGhlIGxheW91dCBmb3IgYSBub2RlLXZpYnJhbnQgUGFsZXR0ZS4gQWxsb3dzIHlvdSB0byBrZWVwIHRyYWNrIG9mXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFsZXR0ZSB7XG4gIFZpYnJhbnQ6IFN3YXRjaCB8IG51bGxcbiAgTXV0ZWQ6IFN3YXRjaCB8IG51bGxcbiAgRGFya1ZpYnJhbnQ6IFN3YXRjaCB8IG51bGxcbiAgRGFya011dGVkOiBTd2F0Y2ggfCBudWxsXG4gIExpZ2h0VmlicmFudDogU3dhdGNoIHwgbnVsbFxuICBMaWdodE11dGVkOiBTd2F0Y2ggfCBudWxsXG4gIC8vID9cbiAgW25hbWU6IHN0cmluZ106IFN3YXRjaCB8IG51bGxcbn1cblxuZXhwb3J0IGNsYXNzIFN3YXRjaCB7XG4gIHN0YXRpYyBhcHBseUZpbHRlcnMgKGNvbG9yczogU3dhdGNoW10sIGZpbHRlcnM6IEZpbHRlcltdKTogU3dhdGNoW10ge1xuICAgIHJldHVybiBmaWx0ZXJzLmxlbmd0aCA+IDBcbiAgICAgID8gY29sb3JzLmZpbHRlcigoeyByLCBnLCBiIH0pID0+IHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaWx0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKCFmaWx0ZXJzW2pdKHIsIGcsIGIsIDI1NSkpIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgICAgOiBjb2xvcnNcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgdmFsdWUgY29weSBvZiBhIHN3YXRjaCBiYXNlZCBvbiBhIHByZXZpb3VzIG9uZS4gUmV0dXJucyBhIG5ldyBTd2F0Y2ggaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2F0Y2h9IHN3YXRjaFxuICAgKi9cbiAgc3RhdGljIGNsb25lIChzd2F0Y2g6IFN3YXRjaCkge1xuICAgIHJldHVybiBuZXcgU3dhdGNoKHN3YXRjaC5fcmdiLCBzd2F0Y2guX3BvcHVsYXRpb24pXG4gIH1cbiAgcHJpdmF0ZSBfaHNsOiBWZWMzXG4gIHByaXZhdGUgX3JnYjogVmVjM1xuICBwcml2YXRlIF95aXE6IG51bWJlclxuICBwcml2YXRlIF9wb3B1bGF0aW9uOiBudW1iZXJcbiAgcHJpdmF0ZSBfaGV4OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHJlZCB2YWx1ZSBpbiB0aGUgUkdCIHZhbHVlXG4gICAqL1xuICBnZXQgciAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcmdiWzBdXG4gIH1cbiAgLyoqXG4gICAqIFRoZSBncmVlbiB2YWx1ZSBpbiB0aGUgUkdCIHZhbHVlXG4gICAqL1xuICBnZXQgZyAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcmdiWzFdXG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVlIHZhbHVlIGluIHRoZSBSR0IgdmFsdWVcbiAgICovXG4gIGdldCBiICgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9yZ2JbMl1cbiAgfVxuICAvKipcbiAgICogVGhlIGNvbG9yIHZhbHVlIGFzIGEgcmdiIHZhbHVlXG4gICAqL1xuICBnZXQgcmdiICgpOiBWZWMzIHtcbiAgICByZXR1cm4gdGhpcy5fcmdiXG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjb2xvciB2YWx1ZSBhcyBhIGhzbCB2YWx1ZVxuICAgKi9cbiAgZ2V0IGhzbCAoKTogVmVjMyB7XG4gICAgaWYgKCF0aGlzLl9oc2wpIHtcbiAgICAgIGxldCBbciwgZywgYl0gPSB0aGlzLl9yZ2JcbiAgICAgIHRoaXMuX2hzbCA9IHJnYlRvSHNsKHIsIGcsIGIpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9oc2xcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3IgdmFsdWUgYXMgYSBoZXggc3RyaW5nXG4gICAqL1xuICBnZXQgaGV4ICgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5faGV4KSB7XG4gICAgICBsZXQgW3IsIGcsIGJdID0gdGhpcy5fcmdiXG4gICAgICB0aGlzLl9oZXggPSByZ2JUb0hleChyLCBnLCBiKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faGV4XG4gIH1cbiAgZ2V0IHBvcHVsYXRpb24gKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcHVsYXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIEpTT04gb2JqZWN0IGZvciB0aGUgc3dhdGNoXG4gICAqL1xuICB0b0pTT04gKCk6IHtyZ2I6IFZlYzMsIHBvcHVsYXRpb246IG51bWJlcn0ge1xuICAgIHJldHVybiB7XG4gICAgICByZ2I6IHRoaXMucmdiLFxuICAgICAgcG9wdWxhdGlvbjogdGhpcy5wb3B1bGF0aW9uXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29sb3IgdmFsdWUgYXMgYSByZ2IgdmFsdWVcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByb3BlcnR5IGluc3RlYWRcbiAgICovXG4gIC8vIFRPRE86IGRlcHJlY2F0ZSBpbnRlcm5hbGx5LCB1c2UgcHJvcGVydHkgaW5zdGVhZFxuICBnZXRSZ2IgKCk6IFZlYzMge1xuICAgIHJldHVybiB0aGlzLl9yZ2JcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjb2xvciB2YWx1ZSBhcyBhIGhzbCB2YWx1ZVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJvcGVydHkgaW5zdGVhZFxuICAgKi9cbiAgLy8gVE9ETzogZGVwcmVjYXRlIGludGVybmFsbHksIHVzZSBwcm9wZXJ0eSBpbnN0ZWFkXG4gIGdldEhzbCAoKTogVmVjMyB7XG4gICAgcmV0dXJuIHRoaXMuaHNsXG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcm9wZXJ0eSBpbnN0ZWFkXG4gICAqL1xuICAvLyBUT0RPOiBkZXByZWNhdGUgaW50ZXJuYWxseSwgdXNlIHByb3BlcnR5IGluc3RlYWRcbiAgZ2V0UG9wdWxhdGlvbiAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcG9wdWxhdGlvblxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbG9yIHZhbHVlIGFzIGEgaGV4IHN0cmluZ1xuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJvcGVydHkgaW5zdGVhZFxuICAgKi9cbiAgLy8gVE9ETzogZGVwcmVjYXRlIGludGVybmFsbHksIHVzZSBwcm9wZXJ0eSBpbnN0ZWFkXG4gIGdldEhleCAoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5oZXhcbiAgfVxuXG4gIHByaXZhdGUgZ2V0WWlxICgpOiBudW1iZXIge1xuICAgIGlmICghdGhpcy5feWlxKSB7XG4gICAgICBsZXQgcmdiID0gdGhpcy5fcmdiXG4gICAgICB0aGlzLl95aXEgPSAocmdiWzBdICogMjk5ICsgcmdiWzFdICogNTg3ICsgcmdiWzJdICogMTE0KSAvIDEwMDBcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3lpcVxuICB9XG5cbiAgcHJpdmF0ZSBfdGl0bGVUZXh0Q29sb3I6IHN0cmluZ1xuICBwcml2YXRlIF9ib2R5VGV4dENvbG9yOiBzdHJpbmdcblxuICBnZXQgdGl0bGVUZXh0Q29sb3IgKCkge1xuICAgIGlmICh0aGlzLl90aXRsZVRleHRDb2xvcikge1xuICAgICAgdGhpcy5fdGl0bGVUZXh0Q29sb3IgPSB0aGlzLmdldFlpcSgpIDwgMjAwID8gJyNmZmYnIDogJyMwMDAnXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90aXRsZVRleHRDb2xvclxuICB9XG4gIGdldCBib2R5VGV4dENvbG9yICgpIHtcbiAgICBpZiAodGhpcy5fYm9keVRleHRDb2xvcikge1xuICAgICAgdGhpcy5fYm9keVRleHRDb2xvciA9IHRoaXMuZ2V0WWlxKCkgPCAxNTAgPyAnI2ZmZicgOiAnIzAwMCdcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2JvZHlUZXh0Q29sb3JcbiAgfVxuICBnZXRUaXRsZVRleHRDb2xvciAoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50aXRsZVRleHRDb2xvclxuICB9XG5cbiAgZ2V0Qm9keVRleHRDb2xvciAoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5ib2R5VGV4dENvbG9yXG4gIH1cblxuICBjb25zdHJ1Y3RvciAocmdiOiBWZWMzLCBwb3B1bGF0aW9uOiBudW1iZXIpIHtcbiAgICB0aGlzLl9yZ2IgPSByZ2JcbiAgICB0aGlzLl9wb3B1bGF0aW9uID0gcG9wdWxhdGlvblxuICB9XG59XG4iLCJpbXBvcnQgeyBWZWMzIH0gZnJvbSAnLi8nXG5cbmV4cG9ydCBjb25zdCBERUxUQUU5NF9ESUZGX1NUQVRVUyA9IHtcbiAgTkE6IDAsXG4gIFBFUkZFQ1Q6IDEsXG4gIENMT1NFOiAyLFxuICBHT09EOiAxMCxcbiAgU0lNSUxBUjogNTBcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBoZXggc3RyaW5nIHRvIFJHQlxuICogQHBhcmFtIGhleCAtIFRoZSBoZXggdmFsdWUgeW91IHdpdGggdG8gZ2V0IHRoZSBSR0IgdmFsdWUgb2ZcbiAqIEByZXR1cm5zIGFuIGFycmF5IGluIHRoZSBvcmRlciBvZiBgcmVkLCBncmVlbiwgYmx1ZWAgbnVtZXJpY2FsIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9SZ2IgKGhleDogc3RyaW5nKTogVmVjMyB7XG4gIGxldCBtID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleClcblxuICBpZiAoIW0pIHRocm93IG5ldyBSYW5nZUVycm9yKGAnJHtoZXh9JyBpcyBub3QgYSB2YWxpZCBoZXggY29sb3JgKVxuXG4gIHJldHVybiBbbVsxXSwgbVsyXSwgbVszXV0ubWFwKChzKSA9PiBwYXJzZUludChzLCAxNikpIGFzIFZlYzNcbn1cblxuLyoqXG4gKiBHaXZlbiB2YWx1ZXMgZm9yIGFuIFJHQiBjb2xvciBjb252ZXJ0IHRvIGFuZCByZXR1cm4gYSB2YWxpZCBIRVggc3RyaW5nXG4gKiBAcGFyYW0gciAtIFJlZCB2YWx1ZSBpbiBSR0JcbiAqIEBwYXJhbSBnIC0gR3JlZW4gdmFsdWUgaW4gUkdCXG4gKiBAcGFyYW0gYiAtIEJsdWUgdmFsdWUgaW4gUkdCXG4gKiBAcmV0dXJucyBhIHZhbGlkIGhleCBzdHJpbmcgd2l0aCBwcmUtcGVuZGluZyBwb3VuZCBzaWduXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZ2JUb0hleCAocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcik6IHN0cmluZyB7XG4gIHJldHVybiAnIycgKyAoKDEgPDwgMjQpICsgKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiKS50b1N0cmluZygxNikuc2xpY2UoMSwgNylcbn1cblxuLyoqXG4gKiBHaXZlbiB2YWx1ZXMgZm9yIGFuIFJHQiBjb2xvciBjb252ZXJ0IHRvIGFuZCByZXR1cm4gYSB2YWxpZCBIU0wgdmFsdWVcbiAqIEBwYXJhbSByIC0gUmVkIHZhbHVlIGluIFJHQlxuICogQHBhcmFtIGcgLSBHcmVlbiB2YWx1ZSBpbiBSR0JcbiAqIEBwYXJhbSBiIC0gQmx1ZSB2YWx1ZSBpbiBSR0JcbiAqIEByZXR1cm5zIGFuIGFycmF5IGluIHRoZSBvcmRlciBvZiBgaHVlLCBzYXR1cmF0aW9uLCBsaWdodGAgbnVtZXJpY2FsIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmdiVG9Ic2wgKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpOiBWZWMzIHtcbiAgciAvPSAyNTVcbiAgZyAvPSAyNTVcbiAgYiAvPSAyNTVcbiAgbGV0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpXG4gIGxldCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKVxuICBsZXQgaDogbnVtYmVyID0gMFxuICBsZXQgczogbnVtYmVyID0gMFxuICBsZXQgbCA9IChtYXggKyBtaW4pIC8gMlxuICBpZiAobWF4ICE9PSBtaW4pIHtcbiAgICBsZXQgZCA9IG1heCAtIG1pblxuICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKVxuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIHI6XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBnOlxuICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGI6XG4gICAgICAgIGggPSAociAtIGcpIC8gZCArIDRcbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBoIC89IDZcbiAgfVxuICByZXR1cm4gW2gsIHMsIGxdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc2xUb1JnYiAoaDogbnVtYmVyLCBzOiBudW1iZXIsIGw6IG51bWJlcik6IFZlYzMge1xuICBsZXQgcjogbnVtYmVyXG4gIGxldCBnOiBudW1iZXJcbiAgbGV0IGI6IG51bWJlclxuXG4gIGZ1bmN0aW9uIGh1ZTJyZ2IgKHA6IG51bWJlciwgcTogbnVtYmVyLCB0OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmICh0IDwgMCkgdCArPSAxXG4gICAgaWYgKHQgPiAxKSB0IC09IDFcbiAgICBpZiAodCA8IDEgLyA2KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdFxuICAgIGlmICh0IDwgMSAvIDIpIHJldHVybiBxXG4gICAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2XG4gICAgcmV0dXJuIHBcbiAgfVxuXG4gIGlmIChzID09PSAwKSB7XG4gICAgciA9IGcgPSBiID0gbFxuICB9IGVsc2Uge1xuICAgIGxldCBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSAobCAqIHMpXG4gICAgbGV0IHAgPSAyICogbCAtIHFcbiAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpXG4gICAgZyA9IGh1ZTJyZ2IocCwgcSwgaClcbiAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gKDEgLyAzKSlcbiAgfVxuICByZXR1cm4gW1xuICAgIHIgKiAyNTUsXG4gICAgZyAqIDI1NSxcbiAgICBiICogMjU1XG4gIF1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYlRvWHl6IChyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyKTogVmVjMyB7XG4gIHIgLz0gMjU1XG4gIGcgLz0gMjU1XG4gIGIgLz0gMjU1XG4gIHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KChyICsgMC4wMDUpIC8gMS4wNTUsIDIuNCkgOiByIC8gMTIuOTJcbiAgZyA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKGcgKyAwLjAwNSkgLyAxLjA1NSwgMi40KSA6IGcgLyAxMi45MlxuICBiID0gYiA+IDAuMDQwNDUgPyBNYXRoLnBvdygoYiArIDAuMDA1KSAvIDEuMDU1LCAyLjQpIDogYiAvIDEyLjkyXG5cbiAgciAqPSAxMDBcbiAgZyAqPSAxMDBcbiAgYiAqPSAxMDBcblxuICBsZXQgeCA9IHIgKiAwLjQxMjQgKyBnICogMC4zNTc2ICsgYiAqIDAuMTgwNVxuICBsZXQgeSA9IHIgKiAwLjIxMjYgKyBnICogMC43MTUyICsgYiAqIDAuMDcyMlxuICBsZXQgeiA9IHIgKiAwLjAxOTMgKyBnICogMC4xMTkyICsgYiAqIDAuOTUwNVxuXG4gIHJldHVybiBbeCwgeSwgel1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHh5elRvQ0lFTGFiICh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogVmVjMyB7XG4gIGxldCBSRUZfWCA9IDk1LjA0N1xuICBsZXQgUkVGX1kgPSAxMDBcbiAgbGV0IFJFRl9aID0gMTA4Ljg4M1xuXG4gIHggLz0gUkVGX1hcbiAgeSAvPSBSRUZfWVxuICB6IC89IFJFRl9aXG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6IDcuNzg3ICogeCArIDE2IC8gMTE2XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiA3Ljc4NyAqIHkgKyAxNiAvIDExNlxuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMSAvIDMpIDogNy43ODcgKiB6ICsgMTYgLyAxMTZcblxuICBsZXQgTCA9IDExNiAqIHkgLSAxNlxuICBsZXQgYSA9IDUwMCAqICh4IC0geSlcbiAgbGV0IGIgPSAyMDAgKiAoeSAtIHopXG5cbiAgcmV0dXJuIFtMLCBhLCBiXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiVG9DSUVMYWIgKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpOiBWZWMzIHtcbiAgbGV0IFt4LCB5LCB6XSA9IHJnYlRvWHl6KHIsIGcsIGIpXG4gIHJldHVybiB4eXpUb0NJRUxhYih4LCB5LCB6KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsdGFFOTQgKGxhYjE6IFZlYzMsIGxhYjI6IFZlYzMpOiBudW1iZXIge1xuICBsZXQgV0VJR0hUX0wgPSAxXG4gIGxldCBXRUlHSFRfQyA9IDFcbiAgbGV0IFdFSUdIVF9IID0gMVxuXG4gIGxldCBbTDEsIGExLCBiMV0gPSBsYWIxXG4gIGxldCBbTDIsIGEyLCBiMl0gPSBsYWIyXG4gIGxldCBkTCA9IEwxIC0gTDJcbiAgbGV0IGRhID0gYTEgLSBhMlxuICBsZXQgZGIgPSBiMSAtIGIyXG5cbiAgbGV0IHhDMSA9IE1hdGguc3FydChhMSAqIGExICsgYjEgKiBiMSlcbiAgbGV0IHhDMiA9IE1hdGguc3FydChhMiAqIGEyICsgYjIgKiBiMilcblxuICBsZXQgeERMID0gTDIgLSBMMVxuICBsZXQgeERDID0geEMyIC0geEMxXG4gIGxldCB4REUgPSBNYXRoLnNxcnQoZEwgKiBkTCArIGRhICogZGEgKyBkYiAqIGRiKVxuXG4gIGxldCB4REggPSAoTWF0aC5zcXJ0KHhERSkgPiBNYXRoLnNxcnQoTWF0aC5hYnMoeERMKSkgKyBNYXRoLnNxcnQoTWF0aC5hYnMoeERDKSkpXG4gICAgPyBNYXRoLnNxcnQoeERFICogeERFIC0geERMICogeERMIC0geERDICogeERDKVxuICAgIDogMFxuXG4gIGxldCB4U0MgPSAxICsgMC4wNDUgKiB4QzFcbiAgbGV0IHhTSCA9IDEgKyAwLjAxNSAqIHhDMVxuXG4gIHhETCAvPSBXRUlHSFRfTFxuICB4REMgLz0gV0VJR0hUX0MgKiB4U0NcbiAgeERIIC89IFdFSUdIVF9IICogeFNIXG5cbiAgcmV0dXJuIE1hdGguc3FydCh4REwgKiB4REwgKyB4REMgKiB4REMgKyB4REggKiB4REgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JEaWZmIChyZ2IxOiBWZWMzLCByZ2IyOiBWZWMzKTogbnVtYmVyIHtcbiAgbGV0IGxhYjEgPSByZ2JUb0NJRUxhYi5hcHBseSh1bmRlZmluZWQsIHJnYjEpXG4gIGxldCBsYWIyID0gcmdiVG9DSUVMYWIuYXBwbHkodW5kZWZpbmVkLCByZ2IyKVxuICByZXR1cm4gZGVsdGFFOTQobGFiMSwgbGFiMilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhleERpZmYgKGhleDE6IHN0cmluZywgaGV4Mjogc3RyaW5nKTogbnVtYmVyIHtcbiAgbGV0IHJnYjEgPSBoZXhUb1JnYihoZXgxKVxuICBsZXQgcmdiMiA9IGhleFRvUmdiKGhleDIpXG5cbiAgcmV0dXJuIHJnYkRpZmYocmdiMSwgcmdiMilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbG9yRGlmZlN0YXR1cyAoZDogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKGQgPCBERUxUQUU5NF9ESUZGX1NUQVRVUy5OQSkge1xuICAgIHJldHVybiAnTi9BJ1xuICB9XG4gIC8vIE5vdCBwZXJjZXB0aWJsZSBieSBodW1hbiBleWVzXG4gIGlmIChkIDw9IERFTFRBRTk0X0RJRkZfU1RBVFVTLlBFUkZFQ1QpIHtcbiAgICByZXR1cm4gJ1BlcmZlY3QnXG4gIH1cbiAgLy8gUGVyY2VwdGlibGUgdGhyb3VnaCBjbG9zZSBvYnNlcnZhdGlvblxuICBpZiAoZCA8PSBERUxUQUU5NF9ESUZGX1NUQVRVUy5DTE9TRSkge1xuICAgIHJldHVybiAnQ2xvc2UnXG4gIH1cbiAgLy8gUGVyY2VwdGlibGUgYXQgYSBnbGFuY2VcbiAgaWYgKGQgPD0gREVMVEFFOTRfRElGRl9TVEFUVVMuR09PRCkge1xuICAgIHJldHVybiAnR29vZCdcbiAgfVxuICAvLyBDb2xvcnMgYXJlIG1vcmUgc2ltaWxhciB0aGFuIG9wcG9zaXRlXG4gIGlmIChkIDwgREVMVEFFOTRfRElGRl9TVEFUVVMuU0lNSUxBUikge1xuICAgIHJldHVybiAnU2ltaWxhcidcbiAgfVxuICByZXR1cm4gJ1dyb25nJ1xuXG59XG4iLCJpbXBvcnQgVmlicmFudCBmcm9tICcuL2NvbmZpZydcbmltcG9ydCBCcm93c2VySW1hZ2UgZnJvbSAnQHZpYnJhbnQvaW1hZ2UtYnJvd3NlcidcblxuVmlicmFudC5EZWZhdWx0T3B0cy5JbWFnZUNsYXNzID0gQnJvd3NlckltYWdlXG5cbmV4cG9ydCA9IFZpYnJhbnRcbiIsImltcG9ydCBWaWJyYW50IGZyb20gJ0B2aWJyYW50L2NvcmUnXG5cblZpYnJhbnQuRGVmYXVsdE9wdHMucXVhbnRpemVyID0gJ21tY3EnXG5WaWJyYW50LkRlZmF1bHRPcHRzLmdlbmVyYXRvcnMgPSBbJ2RlZmF1bHQnXVxuVmlicmFudC5EZWZhdWx0T3B0cy5maWx0ZXJzID0gWydkZWZhdWx0J11cblxuZXhwb3J0IGRlZmF1bHQgVmlicmFudFxuIiwiaW1wb3J0IHsgUGFsZXR0ZSwgU3dhdGNoLCBGaWx0ZXIgfSBmcm9tICdAdmlicmFudC9jb2xvcidcbmltcG9ydCB7IEltYWdlLCBJbWFnZUNsYXNzLCBJbWFnZVNvdXJjZSwgSW1hZ2VPcHRpb25zIH0gZnJvbSAnQHZpYnJhbnQvaW1hZ2UnXG5pbXBvcnQgeyBRdWFudGl6ZXIsIFF1YW50aXplck9wdGlvbnMgfSBmcm9tICdAdmlicmFudC9xdWFudGl6ZXInXG5pbXBvcnQgeyBHZW5lcmF0b3IgfSBmcm9tICdAdmlicmFudC9nZW5lcmF0b3InXG5pbXBvcnQgeyBTdGFnZU9wdGlvbnMsIFByb2Nlc3NPcHRpb25zIH0gZnJvbSAnLi9waXBlbGluZSdcbmltcG9ydCB7IGFzc2lnbkRlZXAgfSBmcm9tICcuL3V0aWxzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnMgZXh0ZW5kcyBJbWFnZU9wdGlvbnMsIFF1YW50aXplck9wdGlvbnMge1xuICB1c2VXb3JrZXI6IGJvb2xlYW5cbiAgSW1hZ2VDbGFzczogSW1hZ2VDbGFzc1xuICBxdWFudGl6ZXI6IHN0cmluZyB8IFN0YWdlT3B0aW9uc1xuICBnZW5lcmF0b3JzOiAoc3RyaW5nIHwgU3RhZ2VPcHRpb25zKVtdXG4gIGZpbHRlcnM6IHN0cmluZ1tdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFByb2Nlc3NPcHRpb25zIChvcHRzOiBPcHRpb25zLCBvdmVycmlkZT86IFBhcnRpYWw8UHJvY2Vzc09wdGlvbnM+KTogUHJvY2Vzc09wdGlvbnMge1xuICBsZXQgeyBjb2xvckNvdW50LCBxdWFudGl6ZXIsIGdlbmVyYXRvcnMsIGZpbHRlcnMgfSA9IG9wdHNcbiAgLy8gTWVyZ2Ugd2l0aCBjb21tb24gcXVhbnRpemVyIG9wdGlvbnNcbiAgbGV0IGNvbW1vblF1YW50aXplck9wdHMgPSB7IGNvbG9yQ291bnQgfVxuICBsZXQgcSA9IHR5cGVvZiBxdWFudGl6ZXIgPT09ICdzdHJpbmcnXG4gICAgPyB7IG5hbWU6IHF1YW50aXplciwgb3B0aW9uczoge30gfVxuICAgIDogcXVhbnRpemVyXG4gIHEub3B0aW9ucyA9IGFzc2lnbkRlZXAoe30sIGNvbW1vblF1YW50aXplck9wdHMsIHEub3B0aW9ucylcblxuICByZXR1cm4gYXNzaWduRGVlcCh7fSwge1xuICAgIHF1YW50aXplcjogcSxcbiAgICBnZW5lcmF0b3JzLFxuICAgIGZpbHRlcnNcbiAgfSwgb3ZlcnJpZGUpXG59XG4iLCJpbXBvcnQge1xuICBPcHRpb25zXG59IGZyb20gJy4vb3B0aW9ucydcbmltcG9ydCB7XG4gIENhbGxiYWNrXG59IGZyb20gJ0B2aWJyYW50L3R5cGVzJ1xuaW1wb3J0IHtcbiAgSW1hZ2VDbGFzcyxcbiAgSW1hZ2VTb3VyY2Vcbn0gZnJvbSAnQHZpYnJhbnQvaW1hZ2UnXG5cbmltcG9ydCB7XG4gIEZpbHRlcixcbiAgUGFsZXR0ZVxufSBmcm9tICdAdmlicmFudC9jb2xvcidcbmltcG9ydCBWaWJyYW50IGZyb20gJy4vJ1xuaW1wb3J0IHsgYXNzaWduRGVlcCB9IGZyb20gJy4vdXRpbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1aWxkZXIge1xuICBwcml2YXRlIF9zcmM6IEltYWdlU291cmNlXG4gIHByaXZhdGUgX29wdHM6IFBhcnRpYWw8T3B0aW9ucz5cbiAgY29uc3RydWN0b3IgKHNyYzogSW1hZ2VTb3VyY2UsIG9wdHM6IFBhcnRpYWw8T3B0aW9ucz4gPSB7fSkge1xuICAgIHRoaXMuX3NyYyA9IHNyY1xuICAgIHRoaXMuX29wdHMgPSBhc3NpZ25EZWVwKHt9LCBWaWJyYW50LkRlZmF1bHRPcHRzLCBvcHRzKVxuICB9XG5cbiAgbWF4Q29sb3JDb3VudCAobjogbnVtYmVyKTogQnVpbGRlciB7XG4gICAgdGhpcy5fb3B0cy5jb2xvckNvdW50ID0gblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBtYXhEaW1lbnNpb24gKGQ6IG51bWJlcik6IEJ1aWxkZXIge1xuICAgIHRoaXMuX29wdHMubWF4RGltZW5zaW9uID0gZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBhZGRGaWx0ZXIgKG5hbWU6IHN0cmluZyk6IEJ1aWxkZXIge1xuICAgIGlmICghdGhpcy5fb3B0cy5maWx0ZXJzKSB7XG4gICAgICB0aGlzLl9vcHRzLmZpbHRlcnMgPSBbbmFtZV1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3B0cy5maWx0ZXJzLnB1c2gobmFtZSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlbW92ZUZpbHRlciAobmFtZTogc3RyaW5nKTogQnVpbGRlciB7XG4gICAgaWYgKHRoaXMuX29wdHMuZmlsdGVycykge1xuICAgICAgbGV0IGkgPSB0aGlzLl9vcHRzLmZpbHRlcnMuaW5kZXhPZihuYW1lKVxuICAgICAgaWYgKGkgPiAwKSB0aGlzLl9vcHRzLmZpbHRlcnMuc3BsaWNlKGkpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjbGVhckZpbHRlcnMgKCk6IEJ1aWxkZXIge1xuICAgIHRoaXMuX29wdHMuZmlsdGVycyA9IFtdXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHF1YWxpdHkgKHE6IG51bWJlcik6IEJ1aWxkZXIge1xuICAgIHRoaXMuX29wdHMucXVhbGl0eSA9IHFcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdXNlSW1hZ2VDbGFzcyAoaW1hZ2VDbGFzczogSW1hZ2VDbGFzcyk6IEJ1aWxkZXIge1xuICAgIHRoaXMuX29wdHMuSW1hZ2VDbGFzcyA9IGltYWdlQ2xhc3NcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdXNlR2VuZXJhdG9yIChnZW5lcmF0b3I6IHN0cmluZywgb3B0aW9ucz86IGFueSk6IEJ1aWxkZXIge1xuICAgIGlmICghdGhpcy5fb3B0cy5nZW5lcmF0b3JzKSB0aGlzLl9vcHRzLmdlbmVyYXRvcnMgPSBbXVxuICAgIHRoaXMuX29wdHMuZ2VuZXJhdG9ycy5wdXNoKG9wdGlvbnMgPyB7IG5hbWU6IGdlbmVyYXRvciwgb3B0aW9ucyB9IDogZ2VuZXJhdG9yKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB1c2VRdWFudGl6ZXIgKHF1YW50aXplcjogc3RyaW5nLCBvcHRpb25zPzogYW55KTogQnVpbGRlciB7XG4gICAgdGhpcy5fb3B0cy5xdWFudGl6ZXIgPSBvcHRpb25zID8geyBuYW1lOiBxdWFudGl6ZXIsIG9wdGlvbnMgfSA6IHF1YW50aXplclxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBidWlsZCAoKTogVmlicmFudCB7XG4gICAgcmV0dXJuIG5ldyBWaWJyYW50KHRoaXMuX3NyYywgdGhpcy5fb3B0cylcbiAgfVxuXG4gIGdldFBhbGV0dGUgKGNiPzogQ2FsbGJhY2s8UGFsZXR0ZT4pOiBQcm9taXNlPFBhbGV0dGU+IHtcbiAgICByZXR1cm4gdGhpcy5idWlsZCgpLmdldFBhbGV0dGUoY2IpXG4gIH1cbiAgZ2V0U3dhdGNoZXMgKGNiPzogQ2FsbGJhY2s8UGFsZXR0ZT4pOiBQcm9taXNlPFBhbGV0dGU+IHtcbiAgICByZXR1cm4gdGhpcy5idWlsZCgpLmdldFBhbGV0dGUoY2IpXG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEltYWdlT3B0aW9ucyxcbiAgSW1hZ2VEYXRhIGFzIFZpYnJhbnRJbWFnZURhdGEsXG4gIEltYWdlU291cmNlLFxuICBJbWFnZUNhbGxiYWNrLFxuICBJbWFnZUJhc2Vcbn0gZnJvbSAnQHZpYnJhbnQvaW1hZ2UnXG5cbmZ1bmN0aW9uIGlzUmVsYXRpdmVVcmwgKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGxldCB1ID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpXG4gIHJldHVybiB1LnByb3RvY29sID09PSBsb2NhdGlvbi5wcm90b2NvbCAmJlxuICAgIHUuaG9zdCA9PT0gbG9jYXRpb24uaG9zdCAmJlxuICAgIHUucG9ydCA9PT0gbG9jYXRpb24ucG9ydFxufVxuXG5mdW5jdGlvbiBpc1NhbWVPcmlnaW4gKGE6IHN0cmluZywgYjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGxldCB1YSA9IG5ldyBVUkwoYSlcbiAgbGV0IHViID0gbmV3IFVSTChiKVxuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NlY3VyaXR5L1NhbWUtb3JpZ2luX3BvbGljeVxuICByZXR1cm4gKFxuICAgIHVhLnByb3RvY29sID09PSB1Yi5wcm90b2NvbCAmJlxuICAgIHVhLmhvc3RuYW1lID09PSB1Yi5ob3N0bmFtZSAmJlxuICAgIHVhLnBvcnQgPT09IHViLnBvcnRcbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcm93c2VySW1hZ2UgZXh0ZW5kcyBJbWFnZUJhc2Uge1xuICBpbWFnZTogSFRNTEltYWdlRWxlbWVudFxuICBwcml2YXRlIF9jYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4gIHByaXZhdGUgX2NvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuICBwcml2YXRlIF93aWR0aDogbnVtYmVyXG4gIHByaXZhdGUgX2hlaWdodDogbnVtYmVyXG4gIHByaXZhdGUgX2luaXRDYW52YXMgKCk6IHZvaWQge1xuICAgIGNvbnN0IGltZyA9IHRoaXMuaW1hZ2VcbiAgICBjb25zdCBjYW52YXMgPSAodGhpcy5fY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpXG4gICAgY29uc3QgY29udGV4dCA9IChjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSlcblxuICAgIGlmICghY29udGV4dCkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGNhbnZhcyBjb250ZXh0JylcblxuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0XG5cbiAgICBjYW52YXMuY2xhc3NOYW1lID0gJ0B2aWJyYW50L2NhbnZhcydcbiAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuXG4gICAgdGhpcy5fd2lkdGggPSBjYW52YXMud2lkdGggPSBpbWcud2lkdGhcbiAgICB0aGlzLl9oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodFxuXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKVxuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpXG4gIH1cbiAgbG9hZCAoaW1hZ2U6IEltYWdlU291cmNlKTogUHJvbWlzZTxJbWFnZUJhc2U+IHtcbiAgICBsZXQgaW1nOiBIVE1MSW1hZ2VFbGVtZW50XG4gICAgbGV0IHNyYzogc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG4gICAgICBzcmMgPSBpbWFnZVxuXG4gICAgICBpZiAoIWlzUmVsYXRpdmVVcmwoc3JjKSAmJiAhaXNTYW1lT3JpZ2luKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBzcmMpKSB7XG4gICAgICAgIGltZy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnXG4gICAgICB9XG5cbiAgICAgIGltZy5zcmMgPSBzcmNcbiAgICB9IGVsc2UgaWYgKGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgaW1nID0gaW1hZ2VcbiAgICAgIHNyYyA9IGltYWdlLnNyY1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBFcnJvcihgQ2Fubm90IGxvYWQgYnVmZmVyIGFzIGFuIGltYWdlIGluIGJyb3dzZXJgKVxuICAgICAgKVxuICAgIH1cbiAgICB0aGlzLmltYWdlID0gaW1nXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2U8SW1hZ2VCYXNlPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgb25JbWFnZUxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2luaXRDYW52YXMoKVxuICAgICAgICByZXNvbHZlKHRoaXMpXG4gICAgICB9XG5cbiAgICAgIGlmIChpbWcuY29tcGxldGUpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBsb2FkZWRcbiAgICAgICAgb25JbWFnZUxvYWQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1nLm9ubG9hZCA9IG9uSW1hZ2VMb2FkXG4gICAgICAgIGltZy5vbmVycm9yID0gZSA9PiByZWplY3QobmV3IEVycm9yKGBGYWlsIHRvIGxvYWQgaW1hZ2U6ICR7c3JjfWApKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgY2xlYXIgKCk6IHZvaWQge1xuICAgIHRoaXMuX2NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpXG4gIH1cbiAgdXBkYXRlIChpbWFnZURhdGE6IFZpYnJhbnRJbWFnZURhdGEpOiB2b2lkIHtcbiAgICB0aGlzLl9jb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEgYXMgSW1hZ2VEYXRhLCAwLCAwKVxuICB9XG4gIGdldFdpZHRoICgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl93aWR0aFxuICB9XG4gIGdldEhlaWdodCAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0XG4gIH1cbiAgcmVzaXplICh0YXJnZXRXaWR0aDogbnVtYmVyLCB0YXJnZXRIZWlnaHQ6IG51bWJlciwgcmF0aW86IG51bWJlcik6IHZvaWQge1xuICAgIGxldCB7IF9jYW52YXM6IGNhbnZhcywgX2NvbnRleHQ6IGNvbnRleHQsIGltYWdlOiBpbWcgfSA9IHRoaXNcblxuICAgIHRoaXMuX3dpZHRoID0gY2FudmFzLndpZHRoID0gdGFyZ2V0V2lkdGhcbiAgICB0aGlzLl9oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gdGFyZ2V0SGVpZ2h0XG5cbiAgICBjb250ZXh0LnNjYWxlKHJhdGlvLCByYXRpbylcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDApXG4gIH1cbiAgZ2V0UGl4ZWxDb3VudCAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGggKiB0aGlzLl9oZWlnaHRcbiAgfVxuICBnZXRJbWFnZURhdGEgKCk6IEltYWdlRGF0YSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpXG4gIH1cbiAgcmVtb3ZlICgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fY2FudmFzICYmIHRoaXMuX2NhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLl9jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jYW52YXMpXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgVmlicmFudCA9IHJlcXVpcmUoJy4vYnJvd3NlcicpXG5pbXBvcnQgcGlwZWxpbmUgZnJvbSAnLi9waXBlbGluZSdcblxuVmlicmFudC51c2UocGlwZWxpbmUpXG5cbmV4cG9ydCA9IFZpYnJhbnRcbiIsImltcG9ydCBNTUNRIGZyb20gJ0B2aWJyYW50L3F1YW50aXplci1tbWNxJ1xuaW1wb3J0IERlZmF1bHRHZW5lcmF0b3IgZnJvbSAnQHZpYnJhbnQvZ2VuZXJhdG9yLWRlZmF1bHQnXG5cbmltcG9ydCB7IEJhc2ljUGlwZWxpbmUgfSBmcm9tICdAdmlicmFudC9jb3JlL2xpYi9waXBlbGluZSdcblxuY29uc3QgcGlwZWxpbmUgPSBuZXcgQmFzaWNQaXBlbGluZSgpXG4gIC5maWx0ZXIucmVnaXN0ZXIoJ2RlZmF1bHQnLCAocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlciwgYTogbnVtYmVyKSA9PlxuICAgIGEgPj0gMTI1XG4gICAgJiYgIShyID4gMjUwICYmIGcgPiAyNTAgJiYgYiA+IDI1MClcbiAgKVxuICAucXVhbnRpemVyLnJlZ2lzdGVyKCdtbWNxJywgTU1DUSlcbiAgLmdlbmVyYXRvci5yZWdpc3RlcignZGVmYXVsdCcsIERlZmF1bHRHZW5lcmF0b3IpXG5cbmV4cG9ydCBkZWZhdWx0IHBpcGVsaW5lXG4iLCJpbXBvcnQgeyBRdWFudGl6ZXIsIFF1YW50aXplck9wdGlvbnMgfSBmcm9tICdAdmlicmFudC9xdWFudGl6ZXInXG5pbXBvcnQge1xuICBQaXhlbHNcbn0gZnJvbSAnQHZpYnJhbnQvaW1hZ2UnXG5pbXBvcnQgeyBGaWx0ZXIsIFN3YXRjaCB9IGZyb20gJ0B2aWJyYW50L2NvbG9yJ1xuaW1wb3J0IFZCb3ggZnJvbSAnLi92Ym94J1xuaW1wb3J0IFBRdWV1ZSBmcm9tICcuL3BxdWV1ZSdcblxuY29uc3QgZnJhY3RCeVBvcHVsYXRpb25zID0gMC43NVxuXG5mdW5jdGlvbiBfc3BsaXRCb3hlcyAocHE6IFBRdWV1ZTxWQm94PiwgdGFyZ2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgbGV0IGxhc3RTaXplID0gcHEuc2l6ZSgpXG4gIHdoaWxlIChwcS5zaXplKCkgPCB0YXJnZXQpIHtcbiAgICBsZXQgdmJveCA9IHBxLnBvcCgpXG5cbiAgICBpZiAodmJveCAmJiB2Ym94LmNvdW50KCkgPiAwKSB7XG4gICAgICBsZXQgW3Zib3gxLCB2Ym94Ml0gPSB2Ym94LnNwbGl0KClcblxuICAgICAgcHEucHVzaCh2Ym94MSlcbiAgICAgIGlmICh2Ym94MiAmJiB2Ym94Mi5jb3VudCgpID4gMCkgcHEucHVzaCh2Ym94MilcblxuICAgICAgLy8gTm8gbW9yZSBuZXcgYm94ZXMsIGNvbnZlcmdlZFxuICAgICAgaWYgKHBxLnNpemUoKSA9PT0gbGFzdFNpemUpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RTaXplID0gcHEuc2l6ZSgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IE1NQ1EgPSAocGl4ZWxzOiBQaXhlbHMsIG9wdHM6IFF1YW50aXplck9wdGlvbnMpOiBBcnJheTxTd2F0Y2g+ID0+IHtcbiAgaWYgKHBpeGVscy5sZW5ndGggPT09IDAgfHwgb3B0cy5jb2xvckNvdW50IDwgMiB8fCBvcHRzLmNvbG9yQ291bnQgPiAyNTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIE1NQ1EgcGFyYW1ldGVycycpXG4gIH1cblxuICBsZXQgdmJveCA9IFZCb3guYnVpbGQocGl4ZWxzKVxuICBsZXQgY29sb3JDb3VudCA9IHZib3guaGlzdG9ncmFtLmNvbG9yQ291bnRcbiAgbGV0IHBxID0gbmV3IFBRdWV1ZTxWQm94PigoYSwgYikgPT4gYS5jb3VudCgpIC0gYi5jb3VudCgpKVxuXG4gIHBxLnB1c2godmJveClcblxuICAvLyBmaXJzdCBzZXQgb2YgY29sb3JzLCBzb3J0ZWQgYnkgcG9wdWxhdGlvblxuICBfc3BsaXRCb3hlcyhwcSwgZnJhY3RCeVBvcHVsYXRpb25zICogb3B0cy5jb2xvckNvdW50KVxuXG4gIC8vIFJlLW9yZGVyXG4gIGxldCBwcTIgPSBuZXcgUFF1ZXVlPFZCb3g+KChhLCBiKSA9PiBhLmNvdW50KCkgKiBhLnZvbHVtZSgpIC0gYi5jb3VudCgpICogYi52b2x1bWUoKSlcbiAgcHEyLmNvbnRlbnRzID0gcHEuY29udGVudHNcblxuICAvLyBuZXh0IHNldCAtIGdlbmVyYXRlIHRoZSBtZWRpYW4gY3V0cyB1c2luZyB0aGUgKG5waXggKiB2b2wpIHNvcnRpbmcuXG4gIF9zcGxpdEJveGVzKHBxMiwgb3B0cy5jb2xvckNvdW50IC0gcHEyLnNpemUoKSlcblxuICAvLyBjYWxjdWxhdGUgdGhlIGFjdHVhbCBjb2xvcnNcbiAgcmV0dXJuIGdlbmVyYXRlU3dhdGNoZXMocHEyKVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVN3YXRjaGVzIChwcTogUFF1ZXVlPFZCb3g+KSB7XG4gIGxldCBzd2F0Y2hlczogU3dhdGNoW10gPSBbXVxuICB3aGlsZSAocHEuc2l6ZSgpKSB7XG4gICAgbGV0IHYgPSBwcS5wb3AoKSFcbiAgICBsZXQgY29sb3IgPSB2LmF2ZygpXG4gICAgbGV0IFtyLCBnLCBiXSA9IGNvbG9yXG4gICAgc3dhdGNoZXMucHVzaChuZXcgU3dhdGNoKGNvbG9yLCB2LmNvdW50KCkpKVxuICB9XG4gIHJldHVybiBzd2F0Y2hlc1xufVxuXG5leHBvcnQgZGVmYXVsdCBNTUNRXG4iLCJpbXBvcnQgeyBWZWMzLCBGaWx0ZXIgfSBmcm9tICdAdmlicmFudC9jb2xvcidcbmltcG9ydCB7IFBpeGVscyB9IGZyb20gJ0B2aWJyYW50L2ltYWdlJ1xuaW1wb3J0IEhpc3RvZ3JhbSBmcm9tICdAdmlicmFudC9pbWFnZS9saWIvaGlzdG9ncmFtJ1xuZXhwb3J0IGludGVyZmFjZSBEaW1lbnNpb24ge1xuICByMTogbnVtYmVyXG4gIHIyOiBudW1iZXJcbiAgZzE6IG51bWJlclxuICBnMjogbnVtYmVyXG4gIGIxOiBudW1iZXJcbiAgYjI6IG51bWJlclxuICBbZDogc3RyaW5nXTogbnVtYmVyXG59XG5cbmNvbnN0IFNJR0JJVFMgPSA1XG5jb25zdCBSU0hJRlQgPSA4IC0gU0lHQklUU1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWQm94IHtcbiAgc3RhdGljIGJ1aWxkIChwaXhlbHM6IFBpeGVscyk6IFZCb3gge1xuICAgIGxldCBoID0gbmV3IEhpc3RvZ3JhbShwaXhlbHMsIHsgc2lnQml0czogU0lHQklUUyB9KVxuICAgIGxldCB7IHJtaW4sIHJtYXgsIGdtaW4sIGdtYXgsIGJtaW4sIGJtYXggfSA9IGhcbiAgICByZXR1cm4gbmV3IFZCb3gocm1pbiwgcm1heCwgZ21pbiwgZ21heCwgYm1pbiwgYm1heCwgaClcbiAgfVxuXG4gIGRpbWVuc2lvbjogRGltZW5zaW9uXG5cbiAgcHJpdmF0ZSBfdm9sdW1lID0gLTFcbiAgcHJpdmF0ZSBfYXZnOiBWZWMzIHwgbnVsbFxuICBwcml2YXRlIF9jb3VudCA9IC0xXG5cbiAgY29uc3RydWN0b3IgKFxuICAgIHIxOiBudW1iZXIsIHIyOiBudW1iZXIsXG4gICAgZzE6IG51bWJlciwgZzI6IG51bWJlcixcbiAgICBiMTogbnVtYmVyLCBiMjogbnVtYmVyLFxuICAgIHB1YmxpYyBoaXN0b2dyYW06IEhpc3RvZ3JhbVxuICApIHtcbiAgICAvLyBOT1RFOiBkaW1lbnNpb24gd2lsbCBiZSBtdXRhdGVkIGJ5IHNwbGl0IG9wZXJhdGlvbi5cbiAgICAvLyAgICAgICBJdCBtdXN0IGJlIHNwZWNpZmllZCBleHBsaWNpdGx5LCBub3QgZnJvbSBoaXN0b2dyYW1cbiAgICB0aGlzLmRpbWVuc2lvbiA9IHsgcjEsIHIyLCBnMSwgZzIsIGIxLCBiMiB9XG4gIH1cblxuICBpbnZhbGlkYXRlICgpOiB2b2lkIHtcbiAgICB0aGlzLl92b2x1bWUgPSB0aGlzLl9jb3VudCA9IC0xXG4gICAgdGhpcy5fYXZnID0gbnVsbFxuICB9XG5cbiAgdm9sdW1lICgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLl92b2x1bWUgPCAwKSB7XG4gICAgICBsZXQgeyByMSwgcjIsIGcxLCBnMiwgYjEsIGIyIH0gPSB0aGlzLmRpbWVuc2lvblxuICAgICAgdGhpcy5fdm9sdW1lID0gKHIyIC0gcjEgKyAxKSAqIChnMiAtIGcxICsgMSkgKiAoYjIgLSBiMSArIDEpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92b2x1bWVcbiAgfVxuXG4gIGNvdW50ICgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLl9jb3VudCA8IDApIHtcbiAgICAgIGxldCB7IGhpc3QsIGdldENvbG9ySW5kZXggfSA9IHRoaXMuaGlzdG9ncmFtXG4gICAgICBsZXQgeyByMSwgcjIsIGcxLCBnMiwgYjEsIGIyIH0gPSB0aGlzLmRpbWVuc2lvblxuICAgICAgbGV0IGMgPSAwXG5cbiAgICAgIGZvciAobGV0IHIgPSByMTsgciA8PSByMjsgcisrKSB7XG4gICAgICAgIGZvciAobGV0IGcgPSBnMTsgZyA8PSBnMjsgZysrKSB7XG4gICAgICAgICAgZm9yIChsZXQgYiA9IGIxOyBiIDw9IGIyOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGdldENvbG9ySW5kZXgociwgZywgYilcbiAgICAgICAgICAgIGMgKz0gaGlzdFtpbmRleF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvdW50ID0gY1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY291bnRcbiAgfVxuXG4gIGNsb25lICgpOiBWQm94IHtcbiAgICBsZXQgeyBoaXN0b2dyYW0gfSA9IHRoaXNcbiAgICBsZXQgeyByMSwgcjIsIGcxLCBnMiwgYjEsIGIyIH0gPSB0aGlzLmRpbWVuc2lvblxuICAgIHJldHVybiBuZXcgVkJveChyMSwgcjIsIGcxLCBnMiwgYjEsIGIyLCBoaXN0b2dyYW0pXG4gIH1cblxuICBhdmcgKCk6IFZlYzMge1xuICAgIGlmICghdGhpcy5fYXZnKSB7XG4gICAgICBsZXQgeyBoaXN0LCBnZXRDb2xvckluZGV4IH0gPSB0aGlzLmhpc3RvZ3JhbVxuICAgICAgbGV0IHsgcjEsIHIyLCBnMSwgZzIsIGIxLCBiMiB9ID0gdGhpcy5kaW1lbnNpb25cbiAgICAgIGxldCBudG90ID0gMFxuICAgICAgbGV0IG11bHQgPSAxIDw8ICg4IC0gU0lHQklUUylcbiAgICAgIGxldCByc3VtOiBudW1iZXJcbiAgICAgIGxldCBnc3VtOiBudW1iZXJcbiAgICAgIGxldCBic3VtOiBudW1iZXJcbiAgICAgIHJzdW0gPSBnc3VtID0gYnN1bSA9IDBcblxuICAgICAgZm9yIChsZXQgciA9IHIxOyByIDw9IHIyOyByKyspIHtcbiAgICAgICAgZm9yIChsZXQgZyA9IGcxOyBnIDw9IGcyOyBnKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBiID0gYjE7IGIgPD0gYjI7IGIrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gZ2V0Q29sb3JJbmRleChyLCBnLCBiKVxuICAgICAgICAgICAgbGV0IGggPSBoaXN0W2luZGV4XVxuICAgICAgICAgICAgbnRvdCArPSBoXG4gICAgICAgICAgICByc3VtICs9IChoICogKHIgKyAwLjUpICogbXVsdClcbiAgICAgICAgICAgIGdzdW0gKz0gKGggKiAoZyArIDAuNSkgKiBtdWx0KVxuICAgICAgICAgICAgYnN1bSArPSAoaCAqIChiICsgMC41KSAqIG11bHQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobnRvdCkge1xuICAgICAgICB0aGlzLl9hdmcgPSBbXG4gICAgICAgICAgfn4ocnN1bSAvIG50b3QpLFxuICAgICAgICAgIH5+KGdzdW0gLyBudG90KSxcbiAgICAgICAgICB+fihic3VtIC8gbnRvdClcbiAgICAgICAgXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYXZnID0gW1xuICAgICAgICAgIH5+KG11bHQgKiAocjEgKyByMiArIDEpIC8gMiksXG4gICAgICAgICAgfn4obXVsdCAqIChnMSArIGcyICsgMSkgLyAyKSxcbiAgICAgICAgICB+fihtdWx0ICogKGIxICsgYjIgKyAxKSAvIDIpXG4gICAgICAgIF1cbiAgICAgIH1cblxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXZnXG4gIH1cblxuICBjb250YWlucyAocmdiOiBWZWMzKTogYm9vbGVhbiB7XG4gICAgbGV0IFtyLCBnLCBiXSA9IHJnYlxuICAgIGxldCB7IHIxLCByMiwgZzEsIGcyLCBiMSwgYjIgfSA9IHRoaXMuZGltZW5zaW9uXG4gICAgciA+Pj0gUlNISUZUXG4gICAgZyA+Pj0gUlNISUZUXG4gICAgYiA+Pj0gUlNISUZUXG5cbiAgICByZXR1cm4gciA+PSByMSAmJiByIDw9IHIyXG4gICAgICAmJiBnID49IGcxICYmIGcgPD0gZzJcbiAgICAgICYmIGIgPj0gYjEgJiYgYiA8PSBiMlxuICB9XG5cbiAgc3BsaXQgKCk6IFZCb3hbXSB7XG4gICAgbGV0IHsgaGlzdCwgZ2V0Q29sb3JJbmRleCB9ID0gdGhpcy5oaXN0b2dyYW1cbiAgICBsZXQgeyByMSwgcjIsIGcxLCBnMiwgYjEsIGIyIH0gPSB0aGlzLmRpbWVuc2lvblxuICAgIGxldCBjb3VudCA9IHRoaXMuY291bnQoKVxuICAgIGlmICghY291bnQpIHJldHVybiBbXVxuICAgIGlmIChjb3VudCA9PT0gMSkgcmV0dXJuIFt0aGlzLmNsb25lKCldXG4gICAgbGV0IHJ3ID0gcjIgLSByMSArIDFcbiAgICBsZXQgZ3cgPSBnMiAtIGcxICsgMVxuICAgIGxldCBidyA9IGIyIC0gYjEgKyAxXG5cbiAgICBsZXQgbWF4dyA9IE1hdGgubWF4KHJ3LCBndywgYncpXG4gICAgbGV0IGFjY1N1bTogVWludDMyQXJyYXkgfCBudWxsID0gbnVsbFxuICAgIGxldCBzdW06IG51bWJlclxuICAgIGxldCB0b3RhbDogbnVtYmVyXG4gICAgc3VtID0gdG90YWwgPSAwXG5cbiAgICBsZXQgbWF4ZDogJ3InIHwgJ2cnIHwgJ2InIHwgbnVsbCA9IG51bGxcblxuICAgIGlmIChtYXh3ID09PSBydykge1xuICAgICAgbWF4ZCA9ICdyJ1xuICAgICAgYWNjU3VtID0gbmV3IFVpbnQzMkFycmF5KHIyICsgMSlcbiAgICAgIGZvciAobGV0IHIgPSByMTsgciA8PSByMjsgcisrKSB7XG4gICAgICAgIHN1bSA9IDBcbiAgICAgICAgZm9yIChsZXQgZyA9IGcxOyBnIDw9IGcyOyBnKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBiID0gYjE7IGIgPD0gYjI7IGIrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gZ2V0Q29sb3JJbmRleChyLCBnLCBiKVxuICAgICAgICAgICAgc3VtICs9IGhpc3RbaW5kZXhdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvdGFsICs9IHN1bVxuICAgICAgICBhY2NTdW1bcl0gPSB0b3RhbFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWF4dyA9PT0gZ3cpIHtcbiAgICAgIG1heGQgPSAnZydcbiAgICAgIGFjY1N1bSA9IG5ldyBVaW50MzJBcnJheShnMiArIDEpXG4gICAgICBmb3IgKGxldCBnID0gZzE7IGcgPD0gZzI7IGcrKykge1xuICAgICAgICBzdW0gPSAwXG4gICAgICAgIGZvciAobGV0IHIgPSByMTsgciA8PSByMjsgcisrKSB7XG4gICAgICAgICAgZm9yIChsZXQgYiA9IGIxOyBiIDw9IGIyOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGdldENvbG9ySW5kZXgociwgZywgYilcbiAgICAgICAgICAgIHN1bSArPSBoaXN0W2luZGV4XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b3RhbCArPSBzdW1cbiAgICAgICAgYWNjU3VtW2ddID0gdG90YWxcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4ZCA9ICdiJ1xuICAgICAgYWNjU3VtID0gbmV3IFVpbnQzMkFycmF5KGIyICsgMSlcbiAgICAgIGZvciAobGV0IGIgPSBiMTsgYiA8PSBiMjsgYisrKSB7XG4gICAgICAgIHN1bSA9IDBcbiAgICAgICAgZm9yIChsZXQgciA9IHIxOyByIDw9IHIyOyByKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBnID0gZzE7IGcgPD0gZzI7IGcrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gZ2V0Q29sb3JJbmRleChyLCBnLCBiKVxuICAgICAgICAgICAgc3VtICs9IGhpc3RbaW5kZXhdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvdGFsICs9IHN1bVxuICAgICAgICBhY2NTdW1bYl0gPSB0b3RhbFxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzcGxpdFBvaW50ID0gLTFcbiAgICBsZXQgcmV2ZXJzZVN1bSA9IG5ldyBVaW50MzJBcnJheShhY2NTdW0ubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjU3VtLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZCA9IGFjY1N1bVtpXVxuICAgICAgaWYgKHNwbGl0UG9pbnQgPCAwICYmIGQgPiB0b3RhbCAvIDIpIHNwbGl0UG9pbnQgPSBpXG4gICAgICByZXZlcnNlU3VtW2ldID0gdG90YWwgLSBkXG4gICAgfVxuXG4gICAgbGV0IHZib3ggPSB0aGlzXG5cbiAgICBmdW5jdGlvbiBkb0N1dCAoZDogc3RyaW5nKTogVkJveFtdIHtcbiAgICAgIGxldCBkaW0xID0gZCArICcxJ1xuICAgICAgbGV0IGRpbTIgPSBkICsgJzInXG4gICAgICBsZXQgZDEgPSB2Ym94LmRpbWVuc2lvbltkaW0xXVxuICAgICAgbGV0IGQyID0gdmJveC5kaW1lbnNpb25bZGltMl1cbiAgICAgIGxldCB2Ym94MSA9IHZib3guY2xvbmUoKVxuICAgICAgbGV0IHZib3gyID0gdmJveC5jbG9uZSgpXG4gICAgICBsZXQgbGVmdCA9IHNwbGl0UG9pbnQgLSBkMVxuICAgICAgbGV0IHJpZ2h0ID0gZDIgLSBzcGxpdFBvaW50XG4gICAgICBpZiAobGVmdCA8PSByaWdodCkge1xuICAgICAgICBkMiA9IE1hdGgubWluKGQyIC0gMSwgfn4oc3BsaXRQb2ludCArIHJpZ2h0IC8gMikpXG4gICAgICAgIGQyID0gTWF0aC5tYXgoMCwgZDIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkMiA9IE1hdGgubWF4KGQxLCB+fihzcGxpdFBvaW50IC0gMSAtIGxlZnQgLyAyKSlcbiAgICAgICAgZDIgPSBNYXRoLm1pbih2Ym94LmRpbWVuc2lvbltkaW0yXSwgZDIpXG4gICAgICB9XG5cbiAgICAgIHdoaWxlICghYWNjU3VtIVtkMl0pIGQyKytcblxuICAgICAgbGV0IGMyID0gcmV2ZXJzZVN1bVtkMl1cbiAgICAgIHdoaWxlICghYzIgJiYgYWNjU3VtIVtkMiAtIDFdKSBjMiA9IHJldmVyc2VTdW1bLS1kMl1cblxuICAgICAgdmJveDEuZGltZW5zaW9uW2RpbTJdID0gZDJcbiAgICAgIHZib3gyLmRpbWVuc2lvbltkaW0xXSA9IGQyICsgMVxuXG4gICAgICByZXR1cm4gW3Zib3gxLCB2Ym94Ml1cbiAgICB9XG5cbiAgICByZXR1cm4gZG9DdXQobWF4ZClcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBQaXhlbHMgfSBmcm9tICcuL2luZGV4J1xuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvZ3JhbU9wdGlvbnMge1xuICBzaWdCaXRzOiBudW1iZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGlzdG9ncmFtIHtcbiAgYm1pbjogbnVtYmVyXG4gIGJtYXg6IG51bWJlclxuICBnbWluOiBudW1iZXJcbiAgZ21heDogbnVtYmVyXG4gIHJtaW46IG51bWJlclxuICBybWF4OiBudW1iZXJcbiAgaGlzdDogVWludDMyQXJyYXlcbiAgcHJpdmF0ZSBfY29sb3JDb3VudDogbnVtYmVyXG4gIGdldCBjb2xvckNvdW50ICgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yQ291bnQgfVxuICBnZXRDb2xvckluZGV4OiAocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcikgPT4gbnVtYmVyXG4gIGNvbnN0cnVjdG9yIChwdWJsaWMgcGl4ZWxzOiBQaXhlbHMsIHB1YmxpYyBvcHRzOiBIaXN0b2dyYW1PcHRpb25zKSB7XG4gICAgY29uc3QgeyBzaWdCaXRzIH0gPSBvcHRzXG4gICAgY29uc3QgZ2V0Q29sb3JJbmRleCA9IChyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyKSA9PlxuICAgICAgKHIgPDwgKDIgKiBzaWdCaXRzKSkgKyAoZyA8PCBzaWdCaXRzKSArIGJcblxuICAgIHRoaXMuZ2V0Q29sb3JJbmRleCA9IGdldENvbG9ySW5kZXhcblxuICAgIGNvbnN0IHJzaGlmdCA9IDggLSBzaWdCaXRzXG4gICAgY29uc3QgaG4gPSAxIDw8ICgzICogc2lnQml0cylcbiAgICBsZXQgaGlzdCA9IG5ldyBVaW50MzJBcnJheShobilcbiAgICBsZXQgcm1heDogbnVtYmVyXG4gICAgbGV0IHJtaW46IG51bWJlclxuICAgIGxldCBnbWF4OiBudW1iZXJcbiAgICBsZXQgZ21pbjogbnVtYmVyXG4gICAgbGV0IGJtYXg6IG51bWJlclxuICAgIGxldCBibWluOiBudW1iZXJcbiAgICBsZXQgcjogbnVtYmVyXG4gICAgbGV0IGc6IG51bWJlclxuICAgIGxldCBiOiBudW1iZXJcbiAgICBsZXQgYTogbnVtYmVyXG4gICAgcm1heCA9IGdtYXggPSBibWF4ID0gMFxuICAgIHJtaW4gPSBnbWluID0gYm1pbiA9IE51bWJlci5NQVhfVkFMVUVcbiAgICBsZXQgbiA9IHBpeGVscy5sZW5ndGggLyA0XG4gICAgbGV0IGkgPSAwXG5cbiAgICB3aGlsZSAoaSA8IG4pIHtcblxuICAgICAgbGV0IG9mZnNldCA9IGkgKiA0XG4gICAgICBpKytcbiAgICAgIHIgPSBwaXhlbHNbb2Zmc2V0ICsgMF1cbiAgICAgIGcgPSBwaXhlbHNbb2Zmc2V0ICsgMV1cbiAgICAgIGIgPSBwaXhlbHNbb2Zmc2V0ICsgMl1cbiAgICAgIGEgPSBwaXhlbHNbb2Zmc2V0ICsgM11cblxuICAgICAgLy8gSWdub3JlZCBwaXhlbHMnIGFscGhhIGlzIG1hcmtlZCBhcyAwIGluIGZpbHRlcmluZyBzdGFnZVxuICAgICAgaWYgKGEgPT09IDApIGNvbnRpbnVlXG5cbiAgICAgIHIgPSByID4+IHJzaGlmdFxuICAgICAgZyA9IGcgPj4gcnNoaWZ0XG4gICAgICBiID0gYiA+PiByc2hpZnRcblxuICAgICAgbGV0IGluZGV4ID0gZ2V0Q29sb3JJbmRleChyLCBnLCBiKVxuICAgICAgaGlzdFtpbmRleF0gKz0gMVxuXG4gICAgICBpZiAociA+IHJtYXgpIHJtYXggPSByXG4gICAgICBpZiAociA8IHJtaW4pIHJtaW4gPSByXG4gICAgICBpZiAoZyA+IGdtYXgpIGdtYXggPSBnXG4gICAgICBpZiAoZyA8IGdtaW4pIGdtaW4gPSBnXG4gICAgICBpZiAoYiA+IGJtYXgpIGJtYXggPSBiXG4gICAgICBpZiAoYiA8IGJtaW4pIGJtaW4gPSBiXG4gICAgfVxuICAgIHRoaXMuX2NvbG9yQ291bnQgPSBoaXN0LnJlZHVjZSgodG90YWwsIGMpID0+IGMgPiAwID8gdG90YWwgKyAxIDogdG90YWwsIDApXG4gICAgdGhpcy5oaXN0ID0gaGlzdFxuICAgIHRoaXMucm1heCA9IHJtYXhcbiAgICB0aGlzLnJtaW4gPSBybWluXG4gICAgdGhpcy5nbWF4ID0gZ21heFxuICAgIHRoaXMuZ21pbiA9IGdtaW5cbiAgICB0aGlzLmJtYXggPSBibWF4XG4gICAgdGhpcy5ibWluID0gYm1pblxuICB9XG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIFBRdWV1ZUNvbXBhcmF0b3I8VD4ge1xuICAoYTogVCwgYjogVCk6IG51bWJlclxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQUXVldWU8VD4ge1xuICBjb250ZW50czogVFtdXG4gIHByaXZhdGUgX3NvcnRlZDogYm9vbGVhblxuICBwcml2YXRlIF9jb21wYXJhdG9yOiBQUXVldWVDb21wYXJhdG9yPFQ+XG4gIHByaXZhdGUgX3NvcnQgKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgICB0aGlzLmNvbnRlbnRzLnNvcnQodGhpcy5fY29tcGFyYXRvcilcbiAgICAgIHRoaXMuX3NvcnRlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvciAoY29tcGFyYXRvcjogUFF1ZXVlQ29tcGFyYXRvcjxUPikge1xuICAgIHRoaXMuX2NvbXBhcmF0b3IgPSBjb21wYXJhdG9yXG4gICAgdGhpcy5jb250ZW50cyA9IFtdXG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2VcbiAgfVxuXG4gIHB1c2ggKGl0ZW06IFQpOiB2b2lkIHtcbiAgICB0aGlzLmNvbnRlbnRzLnB1c2goaXRlbSlcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZVxuICB9XG5cbiAgcGVlayAoaW5kZXg/OiBudW1iZXIpOiBUIHtcbiAgICB0aGlzLl9zb3J0KClcbiAgICBpbmRleCA9IHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicgPyBpbmRleCA6IHRoaXMuY29udGVudHMubGVuZ3RoIC0gMVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzW2luZGV4XVxuICB9XG5cbiAgcG9wICgpIHtcbiAgICB0aGlzLl9zb3J0KClcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cy5wb3AoKVxuICB9XG5cbiAgc2l6ZSAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGhcbiAgfVxuXG4gIG1hcDxVPiAobWFwcGVyOiAoaXRlbTogVCwgaW5kZXg6IG51bWJlcikgPT4gYW55KTogVVtdIHtcbiAgICB0aGlzLl9zb3J0KClcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cy5tYXAobWFwcGVyKVxuICB9XG59XG4iLCJpbXBvcnQgeyBTd2F0Y2gsIFBhbGV0dGUgfSBmcm9tICdAdmlicmFudC9jb2xvcidcbmltcG9ydCB7IEdlbmVyYXRvciB9IGZyb20gJ0B2aWJyYW50L2dlbmVyYXRvcidcbmltcG9ydCB7IGhzbFRvUmdiIH0gZnJvbSAnQHZpYnJhbnQvY29sb3IvbGliL2NvbnZlcnRlcidcblxuaW50ZXJmYWNlIERlZmF1bHRHZW5lcmF0b3JPcHRpb25zIHtcbiAgdGFyZ2V0RGFya0x1bWE6IG51bWJlcixcbiAgbWF4RGFya0x1bWE6IG51bWJlcixcbiAgbWluTGlnaHRMdW1hOiBudW1iZXIsXG4gIHRhcmdldExpZ2h0THVtYTogbnVtYmVyLFxuICBtaW5Ob3JtYWxMdW1hOiBudW1iZXIsXG4gIHRhcmdldE5vcm1hbEx1bWE6IG51bWJlcixcbiAgbWF4Tm9ybWFsTHVtYTogbnVtYmVyLFxuICB0YXJnZXRNdXRlc1NhdHVyYXRpb246IG51bWJlcixcbiAgbWF4TXV0ZXNTYXR1cmF0aW9uOiBudW1iZXIsXG4gIHRhcmdldFZpYnJhbnRTYXR1cmF0aW9uOiBudW1iZXIsXG4gIG1pblZpYnJhbnRTYXR1cmF0aW9uOiBudW1iZXIsXG4gIHdlaWdodFNhdHVyYXRpb246IG51bWJlcixcbiAgd2VpZ2h0THVtYTogbnVtYmVyLFxuICB3ZWlnaHRQb3B1bGF0aW9uOiBudW1iZXJcbn1cblxuY29uc3QgRGVmYXVsdE9wdHM6IERlZmF1bHRHZW5lcmF0b3JPcHRpb25zID0ge1xuICB0YXJnZXREYXJrTHVtYTogMC4yNixcbiAgbWF4RGFya0x1bWE6IDAuNDUsXG4gIG1pbkxpZ2h0THVtYTogMC41NSxcbiAgdGFyZ2V0TGlnaHRMdW1hOiAwLjc0LFxuICBtaW5Ob3JtYWxMdW1hOiAwLjMsXG4gIHRhcmdldE5vcm1hbEx1bWE6IDAuNSxcbiAgbWF4Tm9ybWFsTHVtYTogMC43LFxuICB0YXJnZXRNdXRlc1NhdHVyYXRpb246IDAuMyxcbiAgbWF4TXV0ZXNTYXR1cmF0aW9uOiAwLjQsXG4gIHRhcmdldFZpYnJhbnRTYXR1cmF0aW9uOiAxLjAsXG4gIG1pblZpYnJhbnRTYXR1cmF0aW9uOiAwLjM1LFxuICB3ZWlnaHRTYXR1cmF0aW9uOiAzLFxuICB3ZWlnaHRMdW1hOiA2LjUsXG4gIHdlaWdodFBvcHVsYXRpb246IDAuNVxufVxuXG5mdW5jdGlvbiBfZmluZE1heFBvcHVsYXRpb24gKHN3YXRjaGVzOiBBcnJheTxTd2F0Y2g+KTogbnVtYmVyIHtcbiAgbGV0IHAgPSAwXG5cbiAgc3dhdGNoZXMuZm9yRWFjaCgocykgPT4ge1xuICAgIHAgPSBNYXRoLm1heChwLCBzLnBvcHVsYXRpb24pXG4gIH0pXG5cbiAgcmV0dXJuIHBcbn1cblxuZnVuY3Rpb24gX2lzQWxyZWFkeVNlbGVjdGVkIChwYWxldHRlOiBQYWxldHRlLCBzOiBTd2F0Y2gpOiBib29sZWFuIHtcbiAgcmV0dXJuIHBhbGV0dGUuVmlicmFudCA9PT0gc1xuICAgIHx8IHBhbGV0dGUuRGFya1ZpYnJhbnQgPT09IHNcbiAgICB8fCBwYWxldHRlLkxpZ2h0VmlicmFudCA9PT0gc1xuICAgIHx8IHBhbGV0dGUuTXV0ZWQgPT09IHNcbiAgICB8fCBwYWxldHRlLkRhcmtNdXRlZCA9PT0gc1xuICAgIHx8IHBhbGV0dGUuTGlnaHRNdXRlZCA9PT0gc1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ29tcGFyaXNvblZhbHVlIChcbiAgc2F0dXJhdGlvbjogbnVtYmVyLCB0YXJnZXRTYXR1cmF0aW9uOiBudW1iZXIsXG4gIGx1bWE6IG51bWJlciwgdGFyZ2V0THVtYTogbnVtYmVyLFxuICBwb3B1bGF0aW9uOiBudW1iZXIsIG1heFBvcHVsYXRpb246IG51bWJlciwgb3B0czogRGVmYXVsdEdlbmVyYXRvck9wdGlvbnMpOiBudW1iZXIge1xuXG4gIGZ1bmN0aW9uIHdlaWdodGVkTWVhbiAoLi4udmFsdWVzOiBudW1iZXJbXSkge1xuICAgIGxldCBzdW0gPSAwXG4gICAgbGV0IHdlaWdodFN1bSA9IDBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2ldXG4gICAgICBsZXQgd2VpZ2h0ID0gdmFsdWVzW2kgKyAxXVxuICAgICAgc3VtICs9IHZhbHVlICogd2VpZ2h0XG4gICAgICB3ZWlnaHRTdW0gKz0gd2VpZ2h0XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bSAvIHdlaWdodFN1bVxuICB9XG5cbiAgZnVuY3Rpb24gaW52ZXJ0RGlmZiAodmFsdWU6IG51bWJlciwgdGFyZ2V0VmFsdWU6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmFicyh2YWx1ZSAtIHRhcmdldFZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIHdlaWdodGVkTWVhbihcbiAgICBpbnZlcnREaWZmKHNhdHVyYXRpb24sIHRhcmdldFNhdHVyYXRpb24pLCBvcHRzLndlaWdodFNhdHVyYXRpb24sXG4gICAgaW52ZXJ0RGlmZihsdW1hLCB0YXJnZXRMdW1hKSwgb3B0cy53ZWlnaHRMdW1hLFxuICAgIHBvcHVsYXRpb24gLyBtYXhQb3B1bGF0aW9uLCBvcHRzLndlaWdodFBvcHVsYXRpb25cbiAgKVxuXG59XG5cbmZ1bmN0aW9uIF9maW5kQ29sb3JWYXJpYXRpb24gKHBhbGV0dGU6IFBhbGV0dGUsIHN3YXRjaGVzOiBBcnJheTxTd2F0Y2g+LCBtYXhQb3B1bGF0aW9uOiBudW1iZXIsXG4gIHRhcmdldEx1bWE6IG51bWJlcixcbiAgbWluTHVtYTogbnVtYmVyLFxuICBtYXhMdW1hOiBudW1iZXIsXG4gIHRhcmdldFNhdHVyYXRpb246IG51bWJlcixcbiAgbWluU2F0dXJhdGlvbjogbnVtYmVyLFxuICBtYXhTYXR1cmF0aW9uOiBudW1iZXIsXG4gIG9wdHM6IERlZmF1bHRHZW5lcmF0b3JPcHRpb25zKTogU3dhdGNoIHwgbnVsbCB7XG5cbiAgbGV0IG1heDogU3dhdGNoIHwgbnVsbCA9IG51bGxcbiAgbGV0IG1heFZhbHVlID0gMFxuXG4gIHN3YXRjaGVzLmZvckVhY2goKHN3YXRjaCkgPT4ge1xuICAgIGxldCBbLCBzLCBsXSA9IHN3YXRjaC5oc2xcblxuICAgIGlmIChzID49IG1pblNhdHVyYXRpb24gJiYgcyA8PSBtYXhTYXR1cmF0aW9uXG4gICAgICAmJiBsID49IG1pbkx1bWEgJiYgbCA8PSBtYXhMdW1hXG4gICAgICAmJiAhX2lzQWxyZWFkeVNlbGVjdGVkKHBhbGV0dGUsIHN3YXRjaClcbiAgICApIHtcbiAgICAgIGxldCB2YWx1ZSA9IF9jcmVhdGVDb21wYXJpc29uVmFsdWUocywgdGFyZ2V0U2F0dXJhdGlvbiwgbCwgdGFyZ2V0THVtYSwgc3dhdGNoLnBvcHVsYXRpb24sIG1heFBvcHVsYXRpb24sIG9wdHMpXG5cbiAgICAgIGlmIChtYXggPT09IG51bGwgfHwgdmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICBtYXggPSBzd2F0Y2hcbiAgICAgICAgbWF4VmFsdWUgPSB2YWx1ZVxuICAgICAgfVxuXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBtYXhcbn1cblxuZnVuY3Rpb24gX2dlbmVyYXRlVmFyaWF0aW9uQ29sb3JzIChzd2F0Y2hlczogQXJyYXk8U3dhdGNoPiwgbWF4UG9wdWxhdGlvbjogbnVtYmVyLCBvcHRzOiBEZWZhdWx0R2VuZXJhdG9yT3B0aW9ucyk6IFBhbGV0dGUge1xuICBsZXQgcGFsZXR0ZTogUGFsZXR0ZSA9IHtcbiAgICBWaWJyYW50OiBudWxsLFxuICAgIERhcmtWaWJyYW50OiBudWxsLFxuICAgIExpZ2h0VmlicmFudDogbnVsbCxcbiAgICBNdXRlZDogbnVsbCxcbiAgICBEYXJrTXV0ZWQ6IG51bGwsXG4gICAgTGlnaHRNdXRlZDogbnVsbFxuICB9XG4gIC8vIG1WaWJyYW50U3dhdGNoID0gZmluZENvbG9yKFRBUkdFVF9OT1JNQUxfTFVNQSwgTUlOX05PUk1BTF9MVU1BLCBNQVhfTk9STUFMX0xVTUEsXG4gIC8vICAgICBUQVJHRVRfVklCUkFOVF9TQVRVUkFUSU9OLCBNSU5fVklCUkFOVF9TQVRVUkFUSU9OLCAxZilcbiAgcGFsZXR0ZS5WaWJyYW50ID0gX2ZpbmRDb2xvclZhcmlhdGlvbihwYWxldHRlLCBzd2F0Y2hlcywgbWF4UG9wdWxhdGlvbixcbiAgICBvcHRzLnRhcmdldE5vcm1hbEx1bWEsXG4gICAgb3B0cy5taW5Ob3JtYWxMdW1hLFxuICAgIG9wdHMubWF4Tm9ybWFsTHVtYSxcbiAgICBvcHRzLnRhcmdldFZpYnJhbnRTYXR1cmF0aW9uLFxuICAgIG9wdHMubWluVmlicmFudFNhdHVyYXRpb24sXG4gICAgMSxcbiAgICBvcHRzXG4gIClcbiAgLy8gbUxpZ2h0VmlicmFudFN3YXRjaCA9IGZpbmRDb2xvcihUQVJHRVRfTElHSFRfTFVNQSwgTUlOX0xJR0hUX0xVTUEsIDFmLFxuICAvLyAgICAgVEFSR0VUX1ZJQlJBTlRfU0FUVVJBVElPTiwgTUlOX1ZJQlJBTlRfU0FUVVJBVElPTiwgMWYpXG4gIHBhbGV0dGUuTGlnaHRWaWJyYW50ID0gX2ZpbmRDb2xvclZhcmlhdGlvbihwYWxldHRlLCBzd2F0Y2hlcywgbWF4UG9wdWxhdGlvbixcbiAgICBvcHRzLnRhcmdldExpZ2h0THVtYSxcbiAgICBvcHRzLm1pbkxpZ2h0THVtYSxcbiAgICAxLFxuICAgIG9wdHMudGFyZ2V0VmlicmFudFNhdHVyYXRpb24sXG4gICAgb3B0cy5taW5WaWJyYW50U2F0dXJhdGlvbixcbiAgICAxLFxuICAgIG9wdHNcbiAgKVxuICAvLyBtRGFya1ZpYnJhbnRTd2F0Y2ggPSBmaW5kQ29sb3IoVEFSR0VUX0RBUktfTFVNQSwgMGYsIE1BWF9EQVJLX0xVTUEsXG4gIC8vICAgICBUQVJHRVRfVklCUkFOVF9TQVRVUkFUSU9OLCBNSU5fVklCUkFOVF9TQVRVUkFUSU9OLCAxZilcbiAgcGFsZXR0ZS5EYXJrVmlicmFudCA9IF9maW5kQ29sb3JWYXJpYXRpb24ocGFsZXR0ZSwgc3dhdGNoZXMsIG1heFBvcHVsYXRpb24sXG4gICAgb3B0cy50YXJnZXREYXJrTHVtYSxcbiAgICAwLFxuICAgIG9wdHMubWF4RGFya0x1bWEsXG4gICAgb3B0cy50YXJnZXRWaWJyYW50U2F0dXJhdGlvbixcbiAgICBvcHRzLm1pblZpYnJhbnRTYXR1cmF0aW9uLFxuICAgIDEsXG4gICAgb3B0c1xuICApXG4gIC8vIG1NdXRlZFN3YXRjaCA9IGZpbmRDb2xvcihUQVJHRVRfTk9STUFMX0xVTUEsIE1JTl9OT1JNQUxfTFVNQSwgTUFYX05PUk1BTF9MVU1BLFxuICAvLyAgICAgVEFSR0VUX01VVEVEX1NBVFVSQVRJT04sIDBmLCBNQVhfTVVURURfU0FUVVJBVElPTilcbiAgcGFsZXR0ZS5NdXRlZCA9IF9maW5kQ29sb3JWYXJpYXRpb24ocGFsZXR0ZSwgc3dhdGNoZXMsIG1heFBvcHVsYXRpb24sXG4gICAgb3B0cy50YXJnZXROb3JtYWxMdW1hLFxuICAgIG9wdHMubWluTm9ybWFsTHVtYSxcbiAgICBvcHRzLm1heE5vcm1hbEx1bWEsXG4gICAgb3B0cy50YXJnZXRNdXRlc1NhdHVyYXRpb24sXG4gICAgMCxcbiAgICBvcHRzLm1heE11dGVzU2F0dXJhdGlvbixcbiAgICBvcHRzXG4gIClcbiAgLy8gbUxpZ2h0TXV0ZWRDb2xvciA9IGZpbmRDb2xvcihUQVJHRVRfTElHSFRfTFVNQSwgTUlOX0xJR0hUX0xVTUEsIDFmLFxuICAvLyAgICAgVEFSR0VUX01VVEVEX1NBVFVSQVRJT04sIDBmLCBNQVhfTVVURURfU0FUVVJBVElPTilcbiAgcGFsZXR0ZS5MaWdodE11dGVkID0gX2ZpbmRDb2xvclZhcmlhdGlvbihwYWxldHRlLCBzd2F0Y2hlcywgbWF4UG9wdWxhdGlvbixcbiAgICBvcHRzLnRhcmdldExpZ2h0THVtYSxcbiAgICBvcHRzLm1pbkxpZ2h0THVtYSxcbiAgICAxLFxuICAgIG9wdHMudGFyZ2V0TXV0ZXNTYXR1cmF0aW9uLFxuICAgIDAsXG4gICAgb3B0cy5tYXhNdXRlc1NhdHVyYXRpb24sXG4gICAgb3B0c1xuICApXG4gIC8vIG1EYXJrTXV0ZWRTd2F0Y2ggPSBmaW5kQ29sb3IoVEFSR0VUX0RBUktfTFVNQSwgMGYsIE1BWF9EQVJLX0xVTUEsXG4gIC8vICAgICBUQVJHRVRfTVVURURfU0FUVVJBVElPTiwgMGYsIE1BWF9NVVRFRF9TQVRVUkFUSU9OKVxuICBwYWxldHRlLkRhcmtNdXRlZCA9IF9maW5kQ29sb3JWYXJpYXRpb24ocGFsZXR0ZSwgc3dhdGNoZXMsIG1heFBvcHVsYXRpb24sXG4gICAgb3B0cy50YXJnZXREYXJrTHVtYSxcbiAgICAwLFxuICAgIG9wdHMubWF4RGFya0x1bWEsXG4gICAgb3B0cy50YXJnZXRNdXRlc1NhdHVyYXRpb24sXG4gICAgMCxcbiAgICBvcHRzLm1heE11dGVzU2F0dXJhdGlvbixcbiAgICBvcHRzXG4gIClcbiAgcmV0dXJuIHBhbGV0dGVcbn1cblxuZnVuY3Rpb24gX2dlbmVyYXRlRW1wdHlTd2F0Y2hlcyAocGFsZXR0ZTogUGFsZXR0ZSwgbWF4UG9wdWxhdGlvbjogbnVtYmVyLCBvcHRzOiBEZWZhdWx0R2VuZXJhdG9yT3B0aW9ucyk6IHZvaWQge1xuICBpZiAoIXBhbGV0dGUuVmlicmFudCAmJiAhcGFsZXR0ZS5EYXJrVmlicmFudCAmJiAhcGFsZXR0ZS5MaWdodFZpYnJhbnQpIHtcbiAgICBpZiAoIXBhbGV0dGUuRGFya1ZpYnJhbnQgJiYgcGFsZXR0ZS5EYXJrTXV0ZWQpIHtcbiAgICAgIGxldCBbaCwgcywgbF0gPSBwYWxldHRlLkRhcmtNdXRlZC5oc2xcbiAgICAgIGwgPSBvcHRzLnRhcmdldERhcmtMdW1hXG4gICAgICBwYWxldHRlLkRhcmtWaWJyYW50ID0gbmV3IFN3YXRjaChoc2xUb1JnYihoLCBzLCBsKSwgMClcbiAgICB9XG4gICAgaWYgKCFwYWxldHRlLkxpZ2h0VmlicmFudCAmJiBwYWxldHRlLkxpZ2h0TXV0ZWQpIHtcbiAgICAgIGxldCBbaCwgcywgbF0gPSBwYWxldHRlLkxpZ2h0TXV0ZWQuaHNsXG4gICAgICBsID0gb3B0cy50YXJnZXREYXJrTHVtYVxuICAgICAgcGFsZXR0ZS5EYXJrVmlicmFudCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gICAgfVxuICB9XG4gIGlmICghcGFsZXR0ZS5WaWJyYW50ICYmIHBhbGV0dGUuRGFya1ZpYnJhbnQpIHtcbiAgICBsZXQgW2gsIHMsIGxdID0gcGFsZXR0ZS5EYXJrVmlicmFudC5oc2xcbiAgICBsID0gb3B0cy50YXJnZXROb3JtYWxMdW1hXG4gICAgcGFsZXR0ZS5WaWJyYW50ID0gbmV3IFN3YXRjaChoc2xUb1JnYihoLCBzLCBsKSwgMClcbiAgfSBlbHNlIGlmICghcGFsZXR0ZS5WaWJyYW50ICYmIHBhbGV0dGUuTGlnaHRWaWJyYW50KSB7XG4gICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuTGlnaHRWaWJyYW50LmhzbFxuICAgIGwgPSBvcHRzLnRhcmdldE5vcm1hbEx1bWFcbiAgICBwYWxldHRlLlZpYnJhbnQgPSBuZXcgU3dhdGNoKGhzbFRvUmdiKGgsIHMsIGwpLCAwKVxuICB9XG4gIGlmICghcGFsZXR0ZS5EYXJrVmlicmFudCAmJiBwYWxldHRlLlZpYnJhbnQpIHtcbiAgICBsZXQgW2gsIHMsIGxdID0gcGFsZXR0ZS5WaWJyYW50LmhzbFxuICAgIGwgPSBvcHRzLnRhcmdldERhcmtMdW1hXG4gICAgcGFsZXR0ZS5EYXJrVmlicmFudCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gIH1cbiAgaWYgKCFwYWxldHRlLkxpZ2h0VmlicmFudCAmJiBwYWxldHRlLlZpYnJhbnQpIHtcbiAgICBsZXQgW2gsIHMsIGxdID0gcGFsZXR0ZS5WaWJyYW50LmhzbFxuICAgIGwgPSBvcHRzLnRhcmdldExpZ2h0THVtYVxuICAgIHBhbGV0dGUuTGlnaHRWaWJyYW50ID0gbmV3IFN3YXRjaChoc2xUb1JnYihoLCBzLCBsKSwgMClcbiAgfVxuICBpZiAoIXBhbGV0dGUuTXV0ZWQgJiYgcGFsZXR0ZS5WaWJyYW50KSB7XG4gICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuVmlicmFudC5oc2xcbiAgICBsID0gb3B0cy50YXJnZXRNdXRlc1NhdHVyYXRpb25cbiAgICBwYWxldHRlLk11dGVkID0gbmV3IFN3YXRjaChoc2xUb1JnYihoLCBzLCBsKSwgMClcbiAgfVxuICBpZiAoIXBhbGV0dGUuRGFya011dGVkICYmIHBhbGV0dGUuRGFya1ZpYnJhbnQpIHtcbiAgICBsZXQgW2gsIHMsIGxdID0gcGFsZXR0ZS5EYXJrVmlicmFudC5oc2xcbiAgICBsID0gb3B0cy50YXJnZXRNdXRlc1NhdHVyYXRpb25cbiAgICBwYWxldHRlLkRhcmtNdXRlZCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gIH1cbiAgaWYgKCFwYWxldHRlLkxpZ2h0TXV0ZWQgJiYgcGFsZXR0ZS5MaWdodFZpYnJhbnQpIHtcbiAgICBsZXQgW2gsIHMsIGxdID0gcGFsZXR0ZS5MaWdodFZpYnJhbnQuaHNsXG4gICAgbCA9IG9wdHMudGFyZ2V0TXV0ZXNTYXR1cmF0aW9uXG4gICAgcGFsZXR0ZS5MaWdodE11dGVkID0gbmV3IFN3YXRjaChoc2xUb1JnYihoLCBzLCBsKSwgMClcbiAgfVxufVxuXG5jb25zdCBEZWZhdWx0R2VuZXJhdG9yOiBHZW5lcmF0b3IgPSAoc3dhdGNoZXM6IEFycmF5PFN3YXRjaD4sIG9wdHM/OiBEZWZhdWx0R2VuZXJhdG9yT3B0aW9ucyk6IFBhbGV0dGUgPT4ge1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgRGVmYXVsdE9wdHMsIG9wdHMpXG4gIGxldCBtYXhQb3B1bGF0aW9uID0gX2ZpbmRNYXhQb3B1bGF0aW9uKHN3YXRjaGVzKVxuXG4gIGxldCBwYWxldHRlID0gX2dlbmVyYXRlVmFyaWF0aW9uQ29sb3JzKHN3YXRjaGVzLCBtYXhQb3B1bGF0aW9uLCBvcHRzKVxuICBfZ2VuZXJhdGVFbXB0eVN3YXRjaGVzKHBhbGV0dGUsIG1heFBvcHVsYXRpb24sIG9wdHMpXG5cbiAgcmV0dXJuIHBhbGV0dGVcbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdEdlbmVyYXRvclxuIiwiaW1wb3J0IHsgSW1hZ2VEYXRhLCBhcHBseUZpbHRlcnMgfSBmcm9tICdAdmlicmFudC9pbWFnZSdcbmltcG9ydCB7IFF1YW50aXplciB9IGZyb20gJ0B2aWJyYW50L3F1YW50aXplcidcbmltcG9ydCB7IEdlbmVyYXRvciB9IGZyb20gJ0B2aWJyYW50L2dlbmVyYXRvcidcbmltcG9ydCB7IFBhbGV0dGUsIFN3YXRjaCwgRmlsdGVyIH0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5cbmV4cG9ydCBjbGFzcyBTdGFnZTxUPiB7XG4gIHByaXZhdGUgX21hcDogeyBbbmFtZTogc3RyaW5nXTogVCB9ID0ge31cbiAgY29uc3RydWN0b3IgKHByb3RlY3RlZCBwaXBlbGluZTogQmFzaWNQaXBlbGluZSkgeyB9XG4gIG5hbWVzICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fbWFwKVxuICB9XG4gIGhhcyAobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fbWFwW25hbWVdXG4gIH1cbiAgZ2V0IChuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwW25hbWVdXG4gIH1cbiAgcmVnaXN0ZXIgKG5hbWU6IHN0cmluZywgc3RhZ2VGbjogVCkge1xuICAgIHRoaXMuX21hcFtuYW1lXSA9IHN0YWdlRm5cbiAgICByZXR1cm4gdGhpcy5waXBlbGluZVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc1Jlc3VsdCB7XG4gIGNvbG9yczogU3dhdGNoW11cbiAgcGFsZXR0ZXM6IHsgW25hbWU6IHN0cmluZ106IFBhbGV0dGUgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YWdlT3B0aW9ucyB7XG4gIG5hbWU6IHN0cmluZ1xuICBvcHRpb25zPzogYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc09wdGlvbnMge1xuICBmaWx0ZXJzOiBzdHJpbmdbXVxuICBxdWFudGl6ZXI6IHN0cmluZyB8IFN0YWdlT3B0aW9uc1xuICBnZW5lcmF0b3JzOiAoc3RyaW5nIHwgU3RhZ2VPcHRpb25zKVtdXG59XG5cbmludGVyZmFjZSBTdGFnZVRhc2s8UT4ge1xuICBuYW1lOiBzdHJpbmdcbiAgZm46IFFcbiAgb3B0aW9ucz86IGFueVxufVxuXG5pbnRlcmZhY2UgUHJvY2Vzc1Rhc2tzIHtcbiAgZmlsdGVyczogU3RhZ2VUYXNrPEZpbHRlcj5bXVxuICBxdWFudGl6ZXI6IFN0YWdlVGFzazxRdWFudGl6ZXI+XG4gIGdlbmVyYXRvcnM6IFN0YWdlVGFzazxHZW5lcmF0b3I+W11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQaXBlbGluZSB7XG4gIC8vIHF1YW50aXplcjogU3RhZ2U8UXVhbnRpemVyPlxuICAvLyBnZW5lcmF0b3I6IFN0YWdlPEdlbmVyYXRvcj5cbiAgcHJvY2VzcyAoaW1hZ2VEYXRhOiBJbWFnZURhdGEsIG9wdHM6IFByb2Nlc3NPcHRpb25zKTogUHJvbWlzZTxQcm9jZXNzUmVzdWx0PlxufVxuXG5leHBvcnQgY2xhc3MgQmFzaWNQaXBlbGluZSBpbXBsZW1lbnRzIFBpcGVsaW5lIHtcbiAgcHJpdmF0ZSBfYnVpbGRQcm9jZXNzVGFza3MgKHtcbiAgICBmaWx0ZXJzLFxuICAgIHF1YW50aXplcixcbiAgICBnZW5lcmF0b3JzXG4gIH06IFByb2Nlc3NPcHRpb25zKTogUHJvY2Vzc1Rhc2tzIHtcbiAgICAvLyBTdXBwb3J0IHdpbGRjYXJkIGZvciBnZW5lcmF0b3JzXG4gICAgaWYgKGdlbmVyYXRvcnMubGVuZ3RoID09PSAxICYmIGdlbmVyYXRvcnNbMF0gPT09ICcqJykge1xuICAgICAgZ2VuZXJhdG9ycyA9IHRoaXMuZ2VuZXJhdG9yLm5hbWVzKClcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbHRlcnM6IGZpbHRlcnMubWFwKGYgPT4gY3JlYXRlVGFzayh0aGlzLmZpbHRlciwgZikpLFxuICAgICAgcXVhbnRpemVyOiBjcmVhdGVUYXNrKHRoaXMucXVhbnRpemVyLCBxdWFudGl6ZXIpLFxuICAgICAgZ2VuZXJhdG9yczogZ2VuZXJhdG9ycy5tYXAoZyA9PiBjcmVhdGVUYXNrKHRoaXMuZ2VuZXJhdG9yLCBnKSlcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVGFzazxRPiAoXG4gICAgICBzdGFnZTogU3RhZ2U8UT4sXG4gICAgICBvOiBzdHJpbmcgfCBTdGFnZU9wdGlvbnNcbiAgICApOiBTdGFnZVRhc2s8UT4ge1xuICAgICAgbGV0IG5hbWU6IHN0cmluZ1xuICAgICAgbGV0IG9wdGlvbnM6IGFueVxuICAgICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gb1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IG8ubmFtZVxuICAgICAgICBvcHRpb25zID0gby5vcHRpb25zXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGZuOiBzdGFnZS5nZXQobmFtZSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmlsdGVyOiBTdGFnZTxGaWx0ZXI+ID0gbmV3IFN0YWdlKHRoaXMpXG4gIHF1YW50aXplcjogU3RhZ2U8UXVhbnRpemVyPiA9IG5ldyBTdGFnZSh0aGlzKVxuICBnZW5lcmF0b3I6IFN0YWdlPEdlbmVyYXRvcj4gPSBuZXcgU3RhZ2UodGhpcylcbiAgYXN5bmMgcHJvY2VzcyAoXG4gICAgaW1hZ2VEYXRhOiBJbWFnZURhdGEsXG4gICAgb3B0czogUHJvY2Vzc09wdGlvbnNcbiAgKTogUHJvbWlzZTxQcm9jZXNzUmVzdWx0PiB7XG4gICAgbGV0IHsgZmlsdGVycywgcXVhbnRpemVyLCBnZW5lcmF0b3JzIH0gPSB0aGlzLl9idWlsZFByb2Nlc3NUYXNrcyhvcHRzKVxuICAgIGNvbnN0IGltYWdlRmlsdGVyRGF0YSA9IGF3YWl0IHRoaXMuX2ZpbHRlckNvbG9ycyhmaWx0ZXJzLCBpbWFnZURhdGEpXG4gICAgY29uc3QgY29sb3JzID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGVDb2xvcnMocXVhbnRpemVyLCBpbWFnZUZpbHRlckRhdGEpXG4gICAgY29uc3QgcGFsZXR0ZXMgPSBhd2FpdCB0aGlzLl9nZW5lcmF0ZVBhbGV0dGVzKGdlbmVyYXRvcnMsIGNvbG9ycylcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3JzLFxuICAgICAgcGFsZXR0ZXNcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfZmlsdGVyQ29sb3JzIChmaWx0ZXJzOiBTdGFnZVRhc2s8RmlsdGVyPltdLCBpbWFnZURhdGE6IEltYWdlRGF0YSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICBhcHBseUZpbHRlcnMoaW1hZ2VEYXRhLCBmaWx0ZXJzLm1hcCgoeyBmbiB9KSA9PiBmbikpXG4gICAgKVxuICB9XG4gIHByaXZhdGUgX2dlbmVyYXRlQ29sb3JzIChcbiAgICBxdWFudGl6ZXI6IFN0YWdlVGFzazxRdWFudGl6ZXI+LFxuICAgIGltYWdlRGF0YTogSW1hZ2VEYXRhXG4gICkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocXVhbnRpemVyLmZuKGltYWdlRGF0YS5kYXRhLCBxdWFudGl6ZXIub3B0aW9ucykpXG4gIH1cbiAgcHJpdmF0ZSBhc3luYyBfZ2VuZXJhdGVQYWxldHRlcyAoXG4gICAgZ2VuZXJhdG9yczogU3RhZ2VUYXNrPEdlbmVyYXRvcj5bXSxcbiAgICBjb2xvcnM6IFN3YXRjaFtdXG4gICkge1xuICAgIC8vIE1ha2UgYSBwcm9taXNlIG1hcCB0aGF0IHdpbGwgcnVuIHRoZW0gXCJjb25jdXJyZW50bHlcIiAoYnV0IHJldHVybiBpbiBleHBlY3RlZCByZXN1bHQpXG4gICAgY29uc3QgcHJvbWlzZUFyciA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgZ2VuZXJhdG9ycy5tYXAoKHsgZm4sIG9wdGlvbnMgfSkgPT4gUHJvbWlzZS5yZXNvbHZlKGZuKGNvbG9ycywgb3B0aW9ucykpKVxuICAgIClcbiAgICAvLyBNYXAgdGhlIHZhbHVlcyB0byB0aGUgZXhwZWN0ZWQgbmFtZVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICBwcm9taXNlQXJyLnJlZHVjZShcbiAgICAgICAgKHByb21pc2VzLCBwcm9taXNlVmFsLCBpKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZXNbZ2VuZXJhdG9yc1tpXS5uYW1lXSA9IHByb21pc2VWYWxcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZXNcbiAgICAgICAgfSxcbiAgICAgICAge30gYXMgeyBbbmFtZTogc3RyaW5nXTogUGFsZXR0ZSB9XG4gICAgICApXG4gICAgKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/node-vibrant/dist/vibrant.js\n");

/***/ })

}]);