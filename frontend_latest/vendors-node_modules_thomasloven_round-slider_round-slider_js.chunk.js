"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_thomasloven_round-slider_round-slider_js"],{

/***/ "./node_modules/@thomasloven/round-slider/round-slider.js":
/*!****************************************************************!*\
  !*** ./node_modules/@thomasloven/round-slider/round-slider.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RoundSlider\": () => (/* binding */ RoundSlider)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/decorators.js */ \"./node_modules/lit/decorators.js\");\n\n\n\nclass RoundSlider extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {\n  constructor() {\n    super();\n    this.min = 0;\n    this.max = 100;\n    this.step = 1;\n    this.startAngle = 135;\n    this.arcLength = 270;\n    this.handleSize = 6;\n    this.handleZoom = 1.5;\n    this.readonly = false;\n    this.disabled = false;\n    this.dragging = false;\n    this.rtl = false;\n    this._scale = 1;\n    this.dragEnd = this.dragEnd.bind(this);\n    this.drag = this.drag.bind(this);\n    this._keyStep = this._keyStep.bind(this);\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    document.addEventListener(\"mouseup\", this.dragEnd);\n    document.addEventListener(\"touchend\", this.dragEnd, {\n      passive: false\n    });\n    document.addEventListener(\"mousemove\", this.drag);\n    document.addEventListener(\"touchmove\", this.drag, {\n      passive: false\n    });\n    document.addEventListener(\"keydown\", this._keyStep);\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    document.removeEventListener(\"mouseup\", this.dragEnd);\n    document.removeEventListener(\"touchend\", this.dragEnd);\n    document.removeEventListener(\"mousemove\", this.drag);\n    document.removeEventListener(\"touchmove\", this.drag);\n    document.removeEventListener(\"keydown\", this._keyStep);\n  }\n\n  get _start() {\n    return this.startAngle * Math.PI / 180;\n  }\n\n  get _len() {\n    // Things get weird if length is more than a complete turn\n    return Math.min(this.arcLength * Math.PI / 180, 2 * Math.PI - 0.01);\n  }\n\n  get _end() {\n    return this._start + this._len;\n  }\n\n  get _showHandle() {\n    // If handle is shown\n    if (this.readonly) return false;\n    if (this.value == null && (this.high == null || this.low == null)) return false;\n    return true;\n  }\n\n  _angleInside(angle) {\n    // Check if an angle is on the arc\n    let a = (this.startAngle + this.arcLength / 2 - angle + 180 + 360) % 360 - 180;\n    return a < this.arcLength / 2 && a > -this.arcLength / 2;\n  }\n\n  _angle2xy(angle) {\n    if (this.rtl) return {\n      x: -Math.cos(angle),\n      y: Math.sin(angle)\n    };\n    return {\n      x: Math.cos(angle),\n      y: Math.sin(angle)\n    };\n  }\n\n  _xy2angle(x, y) {\n    if (this.rtl) x = -x;\n    return (Math.atan2(y, x) - this._start + 2 * Math.PI) % (2 * Math.PI);\n  }\n\n  _value2angle(value) {\n    value = Math.min(this.max, Math.max(this.min, value));\n    const fraction = (value - this.min) / (this.max - this.min);\n    return this._start + fraction * this._len;\n  }\n\n  _angle2value(angle) {\n    return Math.round((angle / this._len * (this.max - this.min) + this.min) / this.step) * this.step;\n  }\n\n  get _boundaries() {\n    // Get the maximum extents of the bar arc\n    const start = this._angle2xy(this._start);\n\n    const end = this._angle2xy(this._end);\n\n    let up = 1;\n    if (!this._angleInside(270)) up = Math.max(-start.y, -end.y);\n    let down = 1;\n    if (!this._angleInside(90)) down = Math.max(start.y, end.y);\n    let left = 1;\n    if (!this._angleInside(180)) left = Math.max(-start.x, -end.x);\n    let right = 1;\n    if (!this._angleInside(0)) right = Math.max(start.x, end.x);\n    return {\n      up,\n      down,\n      left,\n      right,\n      height: up + down,\n      width: left + right\n    };\n  }\n\n  _mouse2value(ev) {\n    const mouseX = ev.type.startsWith(\"touch\") ? ev.touches[0].clientX : ev.clientX;\n    const mouseY = ev.type.startsWith(\"touch\") ? ev.touches[0].clientY : ev.clientY;\n    const rect = this.shadowRoot.querySelector(\"svg\").getBoundingClientRect();\n    const boundaries = this._boundaries;\n    const x = mouseX - (rect.left + boundaries.left * rect.width / boundaries.width);\n    const y = mouseY - (rect.top + boundaries.up * rect.height / boundaries.height);\n\n    const angle = this._xy2angle(x, y);\n\n    const pos = this._angle2value(angle);\n\n    return pos;\n  }\n\n  dragStart(ev) {\n    if (!this._showHandle || this.disabled) return;\n    let handle = ev.target;\n    let cooldown = undefined; // Avoid double events mouseDown->focus\n\n    if (this._rotation && this._rotation.type !== \"focus\") return; // If the bar was touched, find the nearest handle and drag from that\n\n    if (handle.classList.contains(\"shadowpath\")) {\n      if (ev.type === \"touchstart\") cooldown = window.setTimeout(() => {\n        if (this._rotation) this._rotation.cooldown = undefined;\n      }, 200);\n\n      if (this.low == null) {\n        handle = this.shadowRoot.querySelector(\"#value\");\n      } else {\n        const mouse = this._mouse2value(ev);\n\n        if (Math.abs(mouse - this.low) < Math.abs(mouse - this.high)) {\n          handle = this.shadowRoot.querySelector(\"#low\");\n        } else {\n          handle = this.shadowRoot.querySelector(\"#high\");\n        }\n      }\n    } // If an invisible handle was clicked, switch to the visible counterpart\n\n\n    if (handle.classList.contains(\"overflow\")) handle = handle.nextElementSibling;\n    if (!handle.classList.contains(\"handle\")) return;\n    handle.setAttribute(\"stroke-width\", String(2 * this.handleSize * this.handleZoom * this._scale));\n    const min = handle.id === \"high\" ? this.low : this.min;\n    const max = handle.id === \"low\" ? this.high : this.max;\n    this._rotation = {\n      handle,\n      min,\n      max,\n      start: this[handle.id],\n      type: ev.type,\n      cooldown\n    };\n    this.dragging = true;\n  }\n\n  _cleanupRotation() {\n    const handle = this._rotation.handle;\n    handle.setAttribute(\"stroke-width\", String(2 * this.handleSize * this._scale));\n    this._rotation = undefined;\n    this.dragging = false;\n    handle.blur();\n  }\n\n  dragEnd(_ev) {\n    if (!this._showHandle || this.disabled) return;\n    if (!this._rotation) return;\n    const handle = this._rotation.handle;\n\n    this._cleanupRotation();\n\n    let event = new CustomEvent(\"value-changed\", {\n      detail: {\n        [handle.id]: this[handle.id]\n      },\n      bubbles: true,\n      composed: true\n    });\n    this.dispatchEvent(event); // This makes the low handle render over the high handle if they both are\n    // close to the top end.  Otherwise if would be unclickable, and the high\n    // handle locked by the low.  Calcualtion is done in the dragEnd handler to\n    // avoid \"z fighting\" while dragging.\n\n    if (this.low && this.low >= 0.99 * this.max) this._reverseOrder = true;else this._reverseOrder = false;\n  }\n\n  drag(ev) {\n    if (!this._showHandle || this.disabled) return;\n    if (!this._rotation) return;\n\n    if (this._rotation.cooldown) {\n      window.clearTimeout(this._rotation.cooldown);\n\n      this._cleanupRotation();\n\n      return;\n    }\n\n    if (this._rotation.type === \"focus\") return;\n    ev.preventDefault();\n\n    const pos = this._mouse2value(ev);\n\n    this._dragpos(pos);\n  }\n\n  _dragpos(pos) {\n    if (pos < this._rotation.min || pos > this._rotation.max) return;\n    const handle = this._rotation.handle;\n    this[handle.id] = pos;\n    let event = new CustomEvent(\"value-changing\", {\n      detail: {\n        [handle.id]: pos\n      },\n      bubbles: true,\n      composed: true\n    });\n    this.dispatchEvent(event);\n  }\n\n  _keyStep(ev) {\n    if (!this._showHandle || this.disabled) return;\n    if (!this._rotation) return;\n    const handle = this._rotation.handle;\n\n    if (ev.key === \"ArrowLeft\" || ev.key === \"ArrowDown\") {\n      ev.preventDefault();\n      if (this.rtl) this._dragpos(this[handle.id] + this.step);else this._dragpos(this[handle.id] - this.step);\n    }\n\n    if (ev.key === \"ArrowRight\" || ev.key === \"ArrowUp\") {\n      ev.preventDefault();\n      if (this.rtl) this._dragpos(this[handle.id] - this.step);else this._dragpos(this[handle.id] + this.step);\n    }\n\n    if (ev.key === \"Home\") {\n      ev.preventDefault();\n\n      this._dragpos(this.min);\n    }\n\n    if (ev.key === \"End\") {\n      ev.preventDefault();\n\n      this._dragpos(this.max);\n    }\n  }\n\n  updated(changedProperties) {\n    // Adjust margin in the bar slider stroke width is greater than the handle size\n    if (this.shadowRoot.querySelector(\".slider\")) {\n      const styles = window.getComputedStyle(this.shadowRoot.querySelector(\".slider\"));\n\n      if (styles && styles[\"strokeWidth\"]) {\n        const stroke = parseFloat(styles[\"strokeWidth\"]);\n\n        if (stroke > this.handleSize * this.handleZoom) {\n          const view = this._boundaries;\n          const margin = `\n          ${stroke / 2 * Math.abs(view.up)}px\n          ${stroke / 2 * Math.abs(view.right)}px\n          ${stroke / 2 * Math.abs(view.down)}px\n          ${stroke / 2 * Math.abs(view.left)}px`;\n          this.shadowRoot.querySelector(\"svg\").style.margin = margin;\n        }\n      }\n    } // Workaround for vector-effect not working in IE and pre-Chromium Edge\n    // That's also why the _scale property exists\n\n\n    if (this.shadowRoot.querySelector(\"svg\") && // @ts-expect-error\n    this.shadowRoot.querySelector(\"svg\").style.vectorEffect === undefined) {\n      if (changedProperties.has(\"_scale\") && this._scale != 1) {\n        this.shadowRoot.querySelector(\"svg\").querySelectorAll(\"path\").forEach(e => {\n          if (e.getAttribute(\"stroke-width\")) return;\n          const orig = parseFloat(getComputedStyle(e).getPropertyValue(\"stroke-width\"));\n          e.style.strokeWidth = `${orig * this._scale}px`;\n        });\n      }\n\n      const rect = this.shadowRoot.querySelector(\"svg\").getBoundingClientRect();\n      const scale = Math.max(rect.width, rect.height);\n      this._scale = 2 / scale;\n    }\n  }\n\n  _renderArc(start, end) {\n    const diff = end - start;\n\n    const startXY = this._angle2xy(start);\n\n    const endXY = this._angle2xy(end + 0.001); // Safari doesn't like arcs with no length\n\n\n    return `\n      M ${startXY.x} ${startXY.y}\n      A 1 1,\n        0,\n        ${diff > Math.PI ? \"1\" : \"0\"} ${this.rtl ? \"0\" : \"1\"},\n        ${endXY.x} ${endXY.y}\n    `;\n  }\n\n  _renderHandle(id) {\n    const theta = this._value2angle(this[id]);\n\n    const pos = this._angle2xy(theta);\n\n    const label = {\n      value: this.valueLabel,\n      low: this.lowLabel,\n      high: this.highLabel\n    }[id] || \"\"; // Two handles are drawn. One visible, and one invisible that's twice as\n    // big. Makes it easier to click.\n\n    return lit__WEBPACK_IMPORTED_MODULE_0__.svg`\n      <g class=\"${id} handle\">\n        <path\n          id=${id}\n          class=\"overflow\"\n          d=\"\n          M ${pos.x} ${pos.y}\n          L ${pos.x + 0.001} ${pos.y + 0.001}\n          \"\n          vector-effect=\"non-scaling-stroke\"\n          stroke=\"rgba(0,0,0,0)\"\n          stroke-width=\"${4 * this.handleSize * this._scale}\"\n          />\n        <path\n          id=${id}\n          class=\"handle\"\n          d=\"\n          M ${pos.x} ${pos.y}\n          L ${pos.x + 0.001} ${pos.y + 0.001}\n          \"\n          vector-effect=\"non-scaling-stroke\"\n          stroke-width=\"${2 * this.handleSize * this._scale}\"\n          tabindex=\"0\"\n          @focus=${this.dragStart}\n          @blur=${this.dragEnd}\n          role=\"slider\"\n          aria-valuemin=${this.min}\n          aria-valuemax=${this.max}\n          aria-valuenow=${this[id]}\n          aria-disabled=${this.disabled}\n          aria-label=${label || \"\"}\n          />\n        </g>\n      `;\n  }\n\n  render() {\n    const view = this._boundaries;\n    return lit__WEBPACK_IMPORTED_MODULE_0__.html`\n      <svg\n        @mousedown=${this.dragStart}\n        @touchstart=${this.dragStart}\n        xmln=\"http://www.w3.org/2000/svg\"\n        viewBox=\"${-view.left} ${-view.up} ${view.width} ${view.height}\"\n        style=\"margin: ${this.handleSize * this.handleZoom}px;\"\n        ?disabled=${this.disabled}\n        focusable=\"false\"\n      >\n        <g class=\"slider\">\n          <path\n            class=\"path\"\n            d=${this._renderArc(this._start, this._end)}\n            vector-effect=\"non-scaling-stroke\"\n          />\n          <path\n            class=\"bar\"\n            vector-effect=\"non-scaling-stroke\"\n            d=${this._renderArc(this._value2angle(this.low != null ? this.low : this.min), this._value2angle(this.high != null ? this.high : this.value))}\n          />\n          <path\n            class=\"shadowpath\"\n            d=${this._renderArc(this._start, this._end)}\n            vector-effect=\"non-scaling-stroke\"\n            stroke=\"rgba(0,0,0,0)\"\n            stroke-width=\"${3 * this.handleSize * this._scale}\"\n            stroke-linecap=\"butt\"\n          />\n        </g>\n\n        <g class=\"handles\">\n          ${this._showHandle ? this.low != null ? this._reverseOrder ? lit__WEBPACK_IMPORTED_MODULE_0__.svg`${this._renderHandle(\"high\")} ${this._renderHandle(\"low\")}` : lit__WEBPACK_IMPORTED_MODULE_0__.svg`${this._renderHandle(\"low\")} ${this._renderHandle(\"high\")}` : lit__WEBPACK_IMPORTED_MODULE_0__.svg`${this._renderHandle(\"value\")}` : ``}\n        </g>\n      </svg>\n    `;\n  }\n\n  static get styles() {\n    return lit__WEBPACK_IMPORTED_MODULE_0__.css`\n      :host {\n        display: inline-block;\n        width: 100%;\n      }\n      svg {\n        overflow: visible;\n        display: block;\n      }\n      path {\n        transition: stroke 1s ease-out, stroke-width 200ms ease-out;\n      }\n      .slider {\n        fill: none;\n        stroke-width: var(--round-slider-path-width, 3);\n        stroke-linecap: var(--round-slider-linecap, round);\n      }\n      .path {\n        stroke: var(--round-slider-path-color, lightgray);\n      }\n      .bar {\n        stroke: var(--round-slider-bar-color, deepskyblue);\n      }\n      svg[disabled] .bar {\n        stroke: var(--round-slider-disabled-bar-color, darkgray);\n      }\n      g.handles {\n        stroke: var(\n          --round-slider-handle-color,\n          var(--round-slider-bar-color, deepskyblue)\n        );\n        stroke-linecap: round;\n        cursor: var(--round-slider-handle-cursor, pointer);\n      }\n      g.low.handle {\n        stroke: var(--round-slider-low-handle-color);\n      }\n      g.high.handle {\n        stroke: var(--round-slider-high-handle-color);\n      }\n      svg[disabled] g.handles {\n        stroke: var(--round-slider-disabled-bar-color, darkgray);\n      }\n      .handle:focus {\n        outline: unset;\n      }\n    `;\n  }\n\n}\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"value\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"high\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"low\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"min\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"max\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"step\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"startAngle\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"arcLength\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"handleSize\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"handleZoom\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Boolean\n})], RoundSlider.prototype, \"readonly\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Boolean\n})], RoundSlider.prototype, \"disabled\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Boolean,\n  reflect: true\n})], RoundSlider.prototype, \"dragging\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Boolean\n})], RoundSlider.prototype, \"rtl\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)()], RoundSlider.prototype, \"valueLabel\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)()], RoundSlider.prototype, \"lowLabel\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)()], RoundSlider.prototype, \"highLabel\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.state)()], RoundSlider.prototype, \"_scale\", void 0);\n\ncustomElements.define(\"round-slider\", RoundSlider);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRob21hc2xvdmVuL3JvdW5kLXNsaWRlci9yb3VuZC1zbGlkZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7O0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTs7QUFHQTtBQUNBO0FBRUE7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUVBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUxBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFJQTs7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUxBO0FBT0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBNWJBOztBQThiQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQUE7O0FBRUE7O0FBR0E7O0FBR0E7O0FBR0E7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGhvbWFzbG92ZW4vcm91bmQtc2xpZGVyL3JvdW5kLXNsaWRlci5qcz9lOGI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IExpdEVsZW1lbnQsIGh0bWwsIGNzcywgc3ZnLCB9IGZyb20gXCJsaXRcIjtcbmltcG9ydCB7IHByb3BlcnR5LCBzdGF0ZSB9IGZyb20gXCJsaXQvZGVjb3JhdG9ycy5qc1wiO1xuZXhwb3J0IGNsYXNzIFJvdW5kU2xpZGVyIGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWluID0gMDtcbiAgICAgICAgdGhpcy5tYXggPSAxMDA7XG4gICAgICAgIHRoaXMuc3RlcCA9IDE7XG4gICAgICAgIHRoaXMuc3RhcnRBbmdsZSA9IDEzNTtcbiAgICAgICAgdGhpcy5hcmNMZW5ndGggPSAyNzA7XG4gICAgICAgIHRoaXMuaGFuZGxlU2l6ZSA9IDY7XG4gICAgICAgIHRoaXMuaGFuZGxlWm9vbSA9IDEuNTtcbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ydGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2NhbGUgPSAxO1xuICAgICAgICB0aGlzLmRyYWdFbmQgPSB0aGlzLmRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kcmFnID0gdGhpcy5kcmFnLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2tleVN0ZXAgPSB0aGlzLl9rZXlTdGVwLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmRyYWdFbmQpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5kcmFnRW5kLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5kcmFnKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLmRyYWcsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5U3RlcCk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmRyYWdFbmQpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5kcmFnRW5kKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLmRyYWcpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuZHJhZyk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleVN0ZXApO1xuICAgIH1cbiAgICBnZXQgX3N0YXJ0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnRBbmdsZSAqIE1hdGguUEkpIC8gMTgwO1xuICAgIH1cbiAgICBnZXQgX2xlbigpIHtcbiAgICAgICAgLy8gVGhpbmdzIGdldCB3ZWlyZCBpZiBsZW5ndGggaXMgbW9yZSB0aGFuIGEgY29tcGxldGUgdHVyblxuICAgICAgICByZXR1cm4gTWF0aC5taW4oKHRoaXMuYXJjTGVuZ3RoICogTWF0aC5QSSkgLyAxODAsIDIgKiBNYXRoLlBJIC0gMC4wMSk7XG4gICAgfVxuICAgIGdldCBfZW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnQgKyB0aGlzLl9sZW47XG4gICAgfVxuICAgIGdldCBfc2hvd0hhbmRsZSgpIHtcbiAgICAgICAgLy8gSWYgaGFuZGxlIGlzIHNob3duXG4gICAgICAgIGlmICh0aGlzLnJlYWRvbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PSBudWxsICYmICh0aGlzLmhpZ2ggPT0gbnVsbCB8fCB0aGlzLmxvdyA9PSBudWxsKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9hbmdsZUluc2lkZShhbmdsZSkge1xuICAgICAgICAvLyBDaGVjayBpZiBhbiBhbmdsZSBpcyBvbiB0aGUgYXJjXG4gICAgICAgIGxldCBhID0gKCh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmFyY0xlbmd0aCAvIDIgLSBhbmdsZSArIDE4MCArIDM2MCkgJSAzNjApIC0gMTgwO1xuICAgICAgICByZXR1cm4gYSA8IHRoaXMuYXJjTGVuZ3RoIC8gMiAmJiBhID4gLXRoaXMuYXJjTGVuZ3RoIC8gMjtcbiAgICB9XG4gICAgX2FuZ2xlMnh5KGFuZ2xlKSB7XG4gICAgICAgIGlmICh0aGlzLnJ0bClcbiAgICAgICAgICAgIHJldHVybiB7IHg6IC1NYXRoLmNvcyhhbmdsZSksIHk6IE1hdGguc2luKGFuZ2xlKSB9O1xuICAgICAgICByZXR1cm4geyB4OiBNYXRoLmNvcyhhbmdsZSksIHk6IE1hdGguc2luKGFuZ2xlKSB9O1xuICAgIH1cbiAgICBfeHkyYW5nbGUoeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5ydGwpXG4gICAgICAgICAgICB4ID0gLXg7XG4gICAgICAgIHJldHVybiAoTWF0aC5hdGFuMih5LCB4KSAtIHRoaXMuX3N0YXJ0ICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKTtcbiAgICB9XG4gICAgX3ZhbHVlMmFuZ2xlKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4odGhpcy5tYXgsIE1hdGgubWF4KHRoaXMubWluLCB2YWx1ZSkpO1xuICAgICAgICBjb25zdCBmcmFjdGlvbiA9ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgZnJhY3Rpb24gKiB0aGlzLl9sZW47XG4gICAgfVxuICAgIF9hbmdsZTJ2YWx1ZShhbmdsZSkge1xuICAgICAgICByZXR1cm4gKE1hdGgucm91bmQoKChhbmdsZSAvIHRoaXMuX2xlbikgKiAodGhpcy5tYXggLSB0aGlzLm1pbikgKyB0aGlzLm1pbikgLyB0aGlzLnN0ZXApICogdGhpcy5zdGVwKTtcbiAgICB9XG4gICAgZ2V0IF9ib3VuZGFyaWVzKCkge1xuICAgICAgICAvLyBHZXQgdGhlIG1heGltdW0gZXh0ZW50cyBvZiB0aGUgYmFyIGFyY1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2FuZ2xlMnh5KHRoaXMuX3N0YXJ0KTtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fYW5nbGUyeHkodGhpcy5fZW5kKTtcbiAgICAgICAgbGV0IHVwID0gMTtcbiAgICAgICAgaWYgKCF0aGlzLl9hbmdsZUluc2lkZSgyNzApKVxuICAgICAgICAgICAgdXAgPSBNYXRoLm1heCgtc3RhcnQueSwgLWVuZC55KTtcbiAgICAgICAgbGV0IGRvd24gPSAxO1xuICAgICAgICBpZiAoIXRoaXMuX2FuZ2xlSW5zaWRlKDkwKSlcbiAgICAgICAgICAgIGRvd24gPSBNYXRoLm1heChzdGFydC55LCBlbmQueSk7XG4gICAgICAgIGxldCBsZWZ0ID0gMTtcbiAgICAgICAgaWYgKCF0aGlzLl9hbmdsZUluc2lkZSgxODApKVxuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KC1zdGFydC54LCAtZW5kLngpO1xuICAgICAgICBsZXQgcmlnaHQgPSAxO1xuICAgICAgICBpZiAoIXRoaXMuX2FuZ2xlSW5zaWRlKDApKVxuICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChzdGFydC54LCBlbmQueCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cCxcbiAgICAgICAgICAgIGRvd24sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IHVwICsgZG93bixcbiAgICAgICAgICAgIHdpZHRoOiBsZWZ0ICsgcmlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9tb3VzZTJ2YWx1ZShldikge1xuICAgICAgICBjb25zdCBtb3VzZVggPSBldi50eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKVxuICAgICAgICAgICAgPyBldi50b3VjaGVzWzBdLmNsaWVudFhcbiAgICAgICAgICAgIDogZXYuY2xpZW50WDtcbiAgICAgICAgY29uc3QgbW91c2VZID0gZXYudHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIilcbiAgICAgICAgICAgID8gZXYudG91Y2hlc1swXS5jbGllbnRZXG4gICAgICAgICAgICA6IGV2LmNsaWVudFk7XG4gICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInN2Z1wiKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgYm91bmRhcmllcyA9IHRoaXMuX2JvdW5kYXJpZXM7XG4gICAgICAgIGNvbnN0IHggPSBtb3VzZVggLSAocmVjdC5sZWZ0ICsgKGJvdW5kYXJpZXMubGVmdCAqIHJlY3Qud2lkdGgpIC8gYm91bmRhcmllcy53aWR0aCk7XG4gICAgICAgIGNvbnN0IHkgPSBtb3VzZVkgLSAocmVjdC50b3AgKyAoYm91bmRhcmllcy51cCAqIHJlY3QuaGVpZ2h0KSAvIGJvdW5kYXJpZXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLl94eTJhbmdsZSh4LCB5KTtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fYW5nbGUydmFsdWUoYW5nbGUpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBkcmFnU3RhcnQoZXYpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93SGFuZGxlIHx8IHRoaXMuZGlzYWJsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBoYW5kbGUgPSBldi50YXJnZXQ7XG4gICAgICAgIGxldCBjb29sZG93biA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQXZvaWQgZG91YmxlIGV2ZW50cyBtb3VzZURvd24tPmZvY3VzXG4gICAgICAgIGlmICh0aGlzLl9yb3RhdGlvbiAmJiB0aGlzLl9yb3RhdGlvbi50eXBlICE9PSBcImZvY3VzXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIElmIHRoZSBiYXIgd2FzIHRvdWNoZWQsIGZpbmQgdGhlIG5lYXJlc3QgaGFuZGxlIGFuZCBkcmFnIGZyb20gdGhhdFxuICAgICAgICBpZiAoaGFuZGxlLmNsYXNzTGlzdC5jb250YWlucyhcInNoYWRvd3BhdGhcIikpIHtcbiAgICAgICAgICAgIGlmIChldi50eXBlID09PSBcInRvdWNoc3RhcnRcIilcbiAgICAgICAgICAgICAgICBjb29sZG93biA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JvdGF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm90YXRpb24uY29vbGRvd24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvdyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIjdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZSA9IHRoaXMuX21vdXNlMnZhbHVlKGV2KTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobW91c2UgLSB0aGlzLmxvdykgPCBNYXRoLmFicyhtb3VzZSAtIHRoaXMuaGlnaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIjbG93XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIjaGlnaFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYW4gaW52aXNpYmxlIGhhbmRsZSB3YXMgY2xpY2tlZCwgc3dpdGNoIHRvIHRoZSB2aXNpYmxlIGNvdW50ZXJwYXJ0XG4gICAgICAgIGlmIChoYW5kbGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwib3ZlcmZsb3dcIikpXG4gICAgICAgICAgICBoYW5kbGUgPSBoYW5kbGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBpZiAoIWhhbmRsZS5jbGFzc0xpc3QuY29udGFpbnMoXCJoYW5kbGVcIikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgU3RyaW5nKDIgKiB0aGlzLmhhbmRsZVNpemUgKiB0aGlzLmhhbmRsZVpvb20gKiB0aGlzLl9zY2FsZSkpO1xuICAgICAgICBjb25zdCBtaW4gPSBoYW5kbGUuaWQgPT09IFwiaGlnaFwiID8gdGhpcy5sb3cgOiB0aGlzLm1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gaGFuZGxlLmlkID09PSBcImxvd1wiID8gdGhpcy5oaWdoIDogdGhpcy5tYXg7XG4gICAgICAgIHRoaXMuX3JvdGF0aW9uID0ge1xuICAgICAgICAgICAgaGFuZGxlLFxuICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXNbaGFuZGxlLmlkXSxcbiAgICAgICAgICAgIHR5cGU6IGV2LnR5cGUsXG4gICAgICAgICAgICBjb29sZG93bixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgfVxuICAgIF9jbGVhbnVwUm90YXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuX3JvdGF0aW9uLmhhbmRsZTtcbiAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBTdHJpbmcoMiAqIHRoaXMuaGFuZGxlU2l6ZSAqIHRoaXMuX3NjYWxlKSk7XG4gICAgICAgIHRoaXMuX3JvdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIGhhbmRsZS5ibHVyKCk7XG4gICAgfVxuICAgIGRyYWdFbmQoX2V2KSB7XG4gICAgICAgIGlmICghdGhpcy5fc2hvd0hhbmRsZSB8fCB0aGlzLmRpc2FibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuX3JvdGF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBoYW5kbGUgPSB0aGlzLl9yb3RhdGlvbi5oYW5kbGU7XG4gICAgICAgIHRoaXMuX2NsZWFudXBSb3RhdGlvbigpO1xuICAgICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJ2YWx1ZS1jaGFuZ2VkXCIsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIFtoYW5kbGUuaWRdOiB0aGlzW2hhbmRsZS5pZF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgLy8gVGhpcyBtYWtlcyB0aGUgbG93IGhhbmRsZSByZW5kZXIgb3ZlciB0aGUgaGlnaCBoYW5kbGUgaWYgdGhleSBib3RoIGFyZVxuICAgICAgICAvLyBjbG9zZSB0byB0aGUgdG9wIGVuZC4gIE90aGVyd2lzZSBpZiB3b3VsZCBiZSB1bmNsaWNrYWJsZSwgYW5kIHRoZSBoaWdoXG4gICAgICAgIC8vIGhhbmRsZSBsb2NrZWQgYnkgdGhlIGxvdy4gIENhbGN1YWx0aW9uIGlzIGRvbmUgaW4gdGhlIGRyYWdFbmQgaGFuZGxlciB0b1xuICAgICAgICAvLyBhdm9pZCBcInogZmlnaHRpbmdcIiB3aGlsZSBkcmFnZ2luZy5cbiAgICAgICAgaWYgKHRoaXMubG93ICYmIHRoaXMubG93ID49IDAuOTkgKiB0aGlzLm1heClcbiAgICAgICAgICAgIHRoaXMuX3JldmVyc2VPcmRlciA9IHRydWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX3JldmVyc2VPcmRlciA9IGZhbHNlO1xuICAgIH1cbiAgICBkcmFnKGV2KSB7XG4gICAgICAgIGlmICghdGhpcy5fc2hvd0hhbmRsZSB8fCB0aGlzLmRpc2FibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuX3JvdGF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fcm90YXRpb24uY29vbGRvd24pIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fcm90YXRpb24uY29vbGRvd24pO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW51cFJvdGF0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JvdGF0aW9uLnR5cGUgPT09IFwiZm9jdXNcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fbW91c2UydmFsdWUoZXYpO1xuICAgICAgICB0aGlzLl9kcmFncG9zKHBvcyk7XG4gICAgfVxuICAgIF9kcmFncG9zKHBvcykge1xuICAgICAgICBpZiAocG9zIDwgdGhpcy5fcm90YXRpb24ubWluIHx8IHBvcyA+IHRoaXMuX3JvdGF0aW9uLm1heClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gdGhpcy5fcm90YXRpb24uaGFuZGxlO1xuICAgICAgICB0aGlzW2hhbmRsZS5pZF0gPSBwb3M7XG4gICAgICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudChcInZhbHVlLWNoYW5naW5nXCIsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIFtoYW5kbGUuaWRdOiBwb3MsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgX2tleVN0ZXAoZXYpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93SGFuZGxlIHx8IHRoaXMuZGlzYWJsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5fcm90YXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuX3JvdGF0aW9uLmhhbmRsZTtcbiAgICAgICAgaWYgKGV2LmtleSA9PT0gXCJBcnJvd0xlZnRcIiB8fCBldi5rZXkgPT09IFwiQXJyb3dEb3duXCIpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ydGwpXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ3Bvcyh0aGlzW2hhbmRsZS5pZF0gKyB0aGlzLnN0ZXApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdwb3ModGhpc1toYW5kbGUuaWRdIC0gdGhpcy5zdGVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXYua2V5ID09PSBcIkFycm93UmlnaHRcIiB8fCBldi5rZXkgPT09IFwiQXJyb3dVcFwiKSB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucnRsKVxuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdwb3ModGhpc1toYW5kbGUuaWRdIC0gdGhpcy5zdGVwKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFncG9zKHRoaXNbaGFuZGxlLmlkXSArIHRoaXMuc3RlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2LmtleSA9PT0gXCJIb21lXCIpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLl9kcmFncG9zKHRoaXMubWluKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXYua2V5ID09PSBcIkVuZFwiKSB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ3Bvcyh0aGlzLm1heCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcykge1xuICAgICAgICAvLyBBZGp1c3QgbWFyZ2luIGluIHRoZSBiYXIgc2xpZGVyIHN0cm9rZSB3aWR0aCBpcyBncmVhdGVyIHRoYW4gdGhlIGhhbmRsZSBzaXplXG4gICAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIi5zbGlkZXJcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiLnNsaWRlclwiKSk7XG4gICAgICAgICAgICBpZiAoc3R5bGVzICYmIHN0eWxlc1tcInN0cm9rZVdpZHRoXCJdKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlID0gcGFyc2VGbG9hdChzdHlsZXNbXCJzdHJva2VXaWR0aFwiXSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cm9rZSA+IHRoaXMuaGFuZGxlU2l6ZSAqIHRoaXMuaGFuZGxlWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5fYm91bmRhcmllcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFyZ2luID0gYFxuICAgICAgICAgICR7KHN0cm9rZSAvIDIpICogTWF0aC5hYnModmlldy51cCl9cHhcbiAgICAgICAgICAkeyhzdHJva2UgLyAyKSAqIE1hdGguYWJzKHZpZXcucmlnaHQpfXB4XG4gICAgICAgICAgJHsoc3Ryb2tlIC8gMikgKiBNYXRoLmFicyh2aWV3LmRvd24pfXB4XG4gICAgICAgICAgJHsoc3Ryb2tlIC8gMikgKiBNYXRoLmFicyh2aWV3LmxlZnQpfXB4YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIikuc3R5bGUubWFyZ2luID0gbWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciB2ZWN0b3ItZWZmZWN0IG5vdCB3b3JraW5nIGluIElFIGFuZCBwcmUtQ2hyb21pdW0gRWRnZVxuICAgICAgICAvLyBUaGF0J3MgYWxzbyB3aHkgdGhlIF9zY2FsZSBwcm9wZXJ0eSBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpICYmXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInN2Z1wiKS5zdHlsZS52ZWN0b3JFZmZlY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmhhcyhcIl9zY2FsZVwiKSAmJiB0aGlzLl9zY2FsZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290XG4gICAgICAgICAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpXG4gICAgICAgICAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5nZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWcgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZSkuZ2V0UHJvcGVydHlWYWx1ZShcInN0cm9rZS13aWR0aFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc3Ryb2tlV2lkdGggPSBgJHtvcmlnICogdGhpcy5fc2NhbGV9cHhgO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1heChyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLl9zY2FsZSA9IDIgLyBzY2FsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVuZGVyQXJjKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc3QgZGlmZiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICBjb25zdCBzdGFydFhZID0gdGhpcy5fYW5nbGUyeHkoc3RhcnQpO1xuICAgICAgICBjb25zdCBlbmRYWSA9IHRoaXMuX2FuZ2xlMnh5KGVuZCArIDAuMDAxKTsgLy8gU2FmYXJpIGRvZXNuJ3QgbGlrZSBhcmNzIHdpdGggbm8gbGVuZ3RoXG4gICAgICAgIHJldHVybiBgXG4gICAgICBNICR7c3RhcnRYWS54fSAke3N0YXJ0WFkueX1cbiAgICAgIEEgMSAxLFxuICAgICAgICAwLFxuICAgICAgICAke2RpZmYgPiBNYXRoLlBJID8gXCIxXCIgOiBcIjBcIn0gJHt0aGlzLnJ0bCA/IFwiMFwiIDogXCIxXCJ9LFxuICAgICAgICAke2VuZFhZLnh9ICR7ZW5kWFkueX1cbiAgICBgO1xuICAgIH1cbiAgICBfcmVuZGVySGFuZGxlKGlkKSB7XG4gICAgICAgIGNvbnN0IHRoZXRhID0gdGhpcy5fdmFsdWUyYW5nbGUodGhpc1tpZF0pO1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9hbmdsZTJ4eSh0aGV0YSk7XG4gICAgICAgIGNvbnN0IGxhYmVsID0ge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVMYWJlbCxcbiAgICAgICAgICAgIGxvdzogdGhpcy5sb3dMYWJlbCxcbiAgICAgICAgICAgIGhpZ2g6IHRoaXMuaGlnaExhYmVsLFxuICAgICAgICB9W2lkXSB8fCBcIlwiO1xuICAgICAgICAvLyBUd28gaGFuZGxlcyBhcmUgZHJhd24uIE9uZSB2aXNpYmxlLCBhbmQgb25lIGludmlzaWJsZSB0aGF0J3MgdHdpY2UgYXNcbiAgICAgICAgLy8gYmlnLiBNYWtlcyBpdCBlYXNpZXIgdG8gY2xpY2suXG4gICAgICAgIHJldHVybiBzdmcgYFxuICAgICAgPGcgY2xhc3M9XCIke2lkfSBoYW5kbGVcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBpZD0ke2lkfVxuICAgICAgICAgIGNsYXNzPVwib3ZlcmZsb3dcIlxuICAgICAgICAgIGQ9XCJcbiAgICAgICAgICBNICR7cG9zLnh9ICR7cG9zLnl9XG4gICAgICAgICAgTCAke3Bvcy54ICsgMC4wMDF9ICR7cG9zLnkgKyAwLjAwMX1cbiAgICAgICAgICBcIlxuICAgICAgICAgIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxuICAgICAgICAgIHN0cm9rZT1cInJnYmEoMCwwLDAsMClcIlxuICAgICAgICAgIHN0cm9rZS13aWR0aD1cIiR7NCAqIHRoaXMuaGFuZGxlU2l6ZSAqIHRoaXMuX3NjYWxlfVwiXG4gICAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBpZD0ke2lkfVxuICAgICAgICAgIGNsYXNzPVwiaGFuZGxlXCJcbiAgICAgICAgICBkPVwiXG4gICAgICAgICAgTSAke3Bvcy54fSAke3Bvcy55fVxuICAgICAgICAgIEwgJHtwb3MueCArIDAuMDAxfSAke3Bvcy55ICsgMC4wMDF9XG4gICAgICAgICAgXCJcbiAgICAgICAgICB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCJcbiAgICAgICAgICBzdHJva2Utd2lkdGg9XCIkezIgKiB0aGlzLmhhbmRsZVNpemUgKiB0aGlzLl9zY2FsZX1cIlxuICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgQGZvY3VzPSR7dGhpcy5kcmFnU3RhcnR9XG4gICAgICAgICAgQGJsdXI9JHt0aGlzLmRyYWdFbmR9XG4gICAgICAgICAgcm9sZT1cInNsaWRlclwiXG4gICAgICAgICAgYXJpYS12YWx1ZW1pbj0ke3RoaXMubWlufVxuICAgICAgICAgIGFyaWEtdmFsdWVtYXg9JHt0aGlzLm1heH1cbiAgICAgICAgICBhcmlhLXZhbHVlbm93PSR7dGhpc1tpZF19XG4gICAgICAgICAgYXJpYS1kaXNhYmxlZD0ke3RoaXMuZGlzYWJsZWR9XG4gICAgICAgICAgYXJpYS1sYWJlbD0ke2xhYmVsIHx8IFwiXCJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9nPlxuICAgICAgYDtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5fYm91bmRhcmllcztcbiAgICAgICAgcmV0dXJuIGh0bWwgYFxuICAgICAgPHN2Z1xuICAgICAgICBAbW91c2Vkb3duPSR7dGhpcy5kcmFnU3RhcnR9XG4gICAgICAgIEB0b3VjaHN0YXJ0PSR7dGhpcy5kcmFnU3RhcnR9XG4gICAgICAgIHhtbG49XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgIHZpZXdCb3g9XCIkey12aWV3LmxlZnR9ICR7LXZpZXcudXB9ICR7dmlldy53aWR0aH0gJHt2aWV3LmhlaWdodH1cIlxuICAgICAgICBzdHlsZT1cIm1hcmdpbjogJHt0aGlzLmhhbmRsZVNpemUgKiB0aGlzLmhhbmRsZVpvb219cHg7XCJcbiAgICAgICAgP2Rpc2FibGVkPSR7dGhpcy5kaXNhYmxlZH1cbiAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgPlxuICAgICAgICA8ZyBjbGFzcz1cInNsaWRlclwiPlxuICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICBjbGFzcz1cInBhdGhcIlxuICAgICAgICAgICAgZD0ke3RoaXMuX3JlbmRlckFyYyh0aGlzLl9zdGFydCwgdGhpcy5fZW5kKX1cbiAgICAgICAgICAgIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGNsYXNzPVwiYmFyXCJcbiAgICAgICAgICAgIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxuICAgICAgICAgICAgZD0ke3RoaXMuX3JlbmRlckFyYyh0aGlzLl92YWx1ZTJhbmdsZSh0aGlzLmxvdyAhPSBudWxsID8gdGhpcy5sb3cgOiB0aGlzLm1pbiksIHRoaXMuX3ZhbHVlMmFuZ2xlKHRoaXMuaGlnaCAhPSBudWxsID8gdGhpcy5oaWdoIDogdGhpcy52YWx1ZSkpfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGNsYXNzPVwic2hhZG93cGF0aFwiXG4gICAgICAgICAgICBkPSR7dGhpcy5fcmVuZGVyQXJjKHRoaXMuX3N0YXJ0LCB0aGlzLl9lbmQpfVxuICAgICAgICAgICAgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiXG4gICAgICAgICAgICBzdHJva2U9XCJyZ2JhKDAsMCwwLDApXCJcbiAgICAgICAgICAgIHN0cm9rZS13aWR0aD1cIiR7MyAqIHRoaXMuaGFuZGxlU2l6ZSAqIHRoaXMuX3NjYWxlfVwiXG4gICAgICAgICAgICBzdHJva2UtbGluZWNhcD1cImJ1dHRcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZz5cblxuICAgICAgICA8ZyBjbGFzcz1cImhhbmRsZXNcIj5cbiAgICAgICAgICAke3RoaXMuX3Nob3dIYW5kbGVcbiAgICAgICAgICAgID8gdGhpcy5sb3cgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gdGhpcy5fcmV2ZXJzZU9yZGVyXG4gICAgICAgICAgICAgICAgICAgID8gc3ZnIGAke3RoaXMuX3JlbmRlckhhbmRsZShcImhpZ2hcIil9ICR7dGhpcy5fcmVuZGVySGFuZGxlKFwibG93XCIpfWBcbiAgICAgICAgICAgICAgICAgICAgOiBzdmcgYCR7dGhpcy5fcmVuZGVySGFuZGxlKFwibG93XCIpfSAke3RoaXMuX3JlbmRlckhhbmRsZShcImhpZ2hcIil9YFxuICAgICAgICAgICAgICAgIDogc3ZnIGAke3RoaXMuX3JlbmRlckhhbmRsZShcInZhbHVlXCIpfWBcbiAgICAgICAgICAgIDogYGB9XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIGA7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgc3R5bGVzKCkge1xuICAgICAgICByZXR1cm4gY3NzIGBcbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgIH1cbiAgICAgIHN2ZyB7XG4gICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cbiAgICAgIHBhdGgge1xuICAgICAgICB0cmFuc2l0aW9uOiBzdHJva2UgMXMgZWFzZS1vdXQsIHN0cm9rZS13aWR0aCAyMDBtcyBlYXNlLW91dDtcbiAgICAgIH1cbiAgICAgIC5zbGlkZXIge1xuICAgICAgICBmaWxsOiBub25lO1xuICAgICAgICBzdHJva2Utd2lkdGg6IHZhcigtLXJvdW5kLXNsaWRlci1wYXRoLXdpZHRoLCAzKTtcbiAgICAgICAgc3Ryb2tlLWxpbmVjYXA6IHZhcigtLXJvdW5kLXNsaWRlci1saW5lY2FwLCByb3VuZCk7XG4gICAgICB9XG4gICAgICAucGF0aCB7XG4gICAgICAgIHN0cm9rZTogdmFyKC0tcm91bmQtc2xpZGVyLXBhdGgtY29sb3IsIGxpZ2h0Z3JheSk7XG4gICAgICB9XG4gICAgICAuYmFyIHtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1yb3VuZC1zbGlkZXItYmFyLWNvbG9yLCBkZWVwc2t5Ymx1ZSk7XG4gICAgICB9XG4gICAgICBzdmdbZGlzYWJsZWRdIC5iYXIge1xuICAgICAgICBzdHJva2U6IHZhcigtLXJvdW5kLXNsaWRlci1kaXNhYmxlZC1iYXItY29sb3IsIGRhcmtncmF5KTtcbiAgICAgIH1cbiAgICAgIGcuaGFuZGxlcyB7XG4gICAgICAgIHN0cm9rZTogdmFyKFxuICAgICAgICAgIC0tcm91bmQtc2xpZGVyLWhhbmRsZS1jb2xvcixcbiAgICAgICAgICB2YXIoLS1yb3VuZC1zbGlkZXItYmFyLWNvbG9yLCBkZWVwc2t5Ymx1ZSlcbiAgICAgICAgKTtcbiAgICAgICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xuICAgICAgICBjdXJzb3I6IHZhcigtLXJvdW5kLXNsaWRlci1oYW5kbGUtY3Vyc29yLCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICAgIGcubG93LmhhbmRsZSB7XG4gICAgICAgIHN0cm9rZTogdmFyKC0tcm91bmQtc2xpZGVyLWxvdy1oYW5kbGUtY29sb3IpO1xuICAgICAgfVxuICAgICAgZy5oaWdoLmhhbmRsZSB7XG4gICAgICAgIHN0cm9rZTogdmFyKC0tcm91bmQtc2xpZGVyLWhpZ2gtaGFuZGxlLWNvbG9yKTtcbiAgICAgIH1cbiAgICAgIHN2Z1tkaXNhYmxlZF0gZy5oYW5kbGVzIHtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1yb3VuZC1zbGlkZXItZGlzYWJsZWQtYmFyLWNvbG9yLCBkYXJrZ3JheSk7XG4gICAgICB9XG4gICAgICAuaGFuZGxlOmZvY3VzIHtcbiAgICAgICAgb3V0bGluZTogdW5zZXQ7XG4gICAgICB9XG4gICAgYDtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IE51bWJlciB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IE51bWJlciB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcImhpZ2hcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHByb3BlcnR5KHsgdHlwZTogTnVtYmVyIH0pXG5dLCBSb3VuZFNsaWRlci5wcm90b3R5cGUsIFwibG93XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IE51bWJlciB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoeyB0eXBlOiBOdW1iZXIgfSlcbl0sIFJvdW5kU2xpZGVyLnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHByb3BlcnR5KHsgdHlwZTogTnVtYmVyIH0pXG5dLCBSb3VuZFNsaWRlci5wcm90b3R5cGUsIFwic3RlcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoeyB0eXBlOiBOdW1iZXIgfSlcbl0sIFJvdW5kU2xpZGVyLnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IE51bWJlciB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcImFyY0xlbmd0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoeyB0eXBlOiBOdW1iZXIgfSlcbl0sIFJvdW5kU2xpZGVyLnByb3RvdHlwZSwgXCJoYW5kbGVTaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IE51bWJlciB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcImhhbmRsZVpvb21cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHByb3BlcnR5KHsgdHlwZTogQm9vbGVhbiB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IEJvb2xlYW4gfSlcbl0sIFJvdW5kU2xpZGVyLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoeyB0eXBlOiBCb29sZWFuLCByZWZsZWN0OiB0cnVlIH0pXG5dLCBSb3VuZFNsaWRlci5wcm90b3R5cGUsIFwiZHJhZ2dpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHByb3BlcnR5KHsgdHlwZTogQm9vbGVhbiB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcInJ0bFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoKVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcInZhbHVlTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHByb3BlcnR5KClcbl0sIFJvdW5kU2xpZGVyLnByb3RvdHlwZSwgXCJsb3dMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoKVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcImhpZ2hMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgc3RhdGUoKVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcIl9zY2FsZVwiLCB2b2lkIDApO1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwicm91bmQtc2xpZGVyXCIsIFJvdW5kU2xpZGVyKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@thomasloven/round-slider/round-slider.js\n");

/***/ })

}]);